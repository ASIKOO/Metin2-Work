; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?piecewise_construct@std@@3Upiecewise_construct_t@1@B	ORG $+1 ; std::piecewise_construct
	ORG $+3
?c_IndexCC@eterpack@@3KB DD 0444b5045H			; eterpack::c_IndexCC
?c_Version@eterpack@@3KB DD 02H				; eterpack::c_Version
CONST	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	_printf
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
PUBLIC	?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
PUBLIC	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?_Swap_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_data
PUBLIC	?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::swap
PUBLIC	?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??8std@@YA_NABVerror_condition@0@0@Z		; std::operator==
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category2@std@@UBEPBDXZ	; std::_Iostream_error_category2::name
PUBLIC	?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category2::message
PUBLIC	??_G_Iostream_error_category2@std@@UAEPAXI@Z	; std::_Iostream_error_category2::`scalar deleting destructor'
PUBLIC	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
PUBLIC	??$hash_value@K@boost@@YAIK@Z			; boost::hash_value<unsigned long>
PUBLIC	?next_prime@detail@unordered@boost@@YAII@Z	; boost::unordered::detail::next_prime
PUBLIC	?InsertItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z ; CEterFileDict::InsertItem
PUBLIC	?UpdateItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z ; CEterFileDict::UpdateItem
PUBLIC	?GetItem@CEterFileDict@@QAEPAUItem@1@KPBD@Z	; CEterFileDict::GetItem
PUBLIC	??1?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::~functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >
PUBLIC	?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::key_eq
PUBLIC	?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
PUBLIC	?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
PUBLIC	?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
PUBLIC	?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load
PUBLIC	?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
PUBLIC	?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
PUBLIC	?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node
PUBLIC	?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets
PUBLIC	?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@IABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
PUBLIC	?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@ABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
PUBLIC	?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert
PUBLIC	?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
PUBLIC	?add_node_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAU5234@I0@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_equiv
PUBLIC	?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_equiv
PUBLIC	?find@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::find
PUBLIC	?equal_range@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@U1234@@std@@ABK@Z ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::equal_range
PUBLIC	??0CEterPack@@QAE@XZ				; CEterPack::CEterPack
PUBLIC	??1CEterPack@@UAE@XZ				; CEterPack::~CEterPack
PUBLIC	?Destroy@CEterPack@@QAEXXZ			; CEterPack::Destroy
PUBLIC	?Create@CEterPack@@QAE_NAAVCEterFileDict@@PBD1_NPBE@Z ; CEterPack::Create
PUBLIC	?DecryptIV@CEterPack@@QAE_NK@Z			; CEterPack::DecryptIV
PUBLIC	?GetPathName@CEterPack@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CEterPack::GetPathName
PUBLIC	?GetDBName@CEterPack@@QAEPBDXZ			; CEterPack::GetDBName
PUBLIC	?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z	; CEterPack::Get
PUBLIC	?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z ; CEterPack::Get2
PUBLIC	?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CEterPack::Put
PUBLIC	?Put@CEterPack@@QAE_NPBDPBXJE@Z			; CEterPack::Put
PUBLIC	?Delete@CEterPack@@QAE_NPBD@Z			; CEterPack::Delete
PUBLIC	?Extract@CEterPack@@QAE_NXZ			; CEterPack::Extract
PUBLIC	?GetFragmentSize@CEterPack@@QAEJXZ		; CEterPack::GetFragmentSize
PUBLIC	?IsExist@CEterPack@@QAE_NPBD@Z			; CEterPack::IsExist
PUBLIC	?GetIndexMap@CEterPack@@QAEAAV?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@XZ ; CEterPack::GetIndexMap
PUBLIC	?EncryptIndexFile@CEterPack@@QAE_NXZ		; CEterPack::EncryptIndexFile
PUBLIC	?DecryptIndexFile@CEterPack@@QAE_NXZ		; CEterPack::DecryptIndexFile
PUBLIC	?DeleteUnreferencedData@CEterPack@@QAEKXZ	; CEterPack::DeleteUnreferencedData
PUBLIC	?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ; CEterPack::GetNames
PUBLIC	?GetPackPolicy_HybridCrypt@CEterPack@@QBEPAVEterPackPolicy_CSHybridCrypt@@XZ ; CEterPack::GetPackPolicy_HybridCrypt
PUBLIC	?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z ; CEterPack::__BuildIndex
PUBLIC	?CreateIndexFile@CEterPack@@AAE_NXZ		; CEterPack::CreateIndexFile
PUBLIC	?FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z ; CEterPack::FindIndex
PUBLIC	?GetNewIndexPosition@CEterPack@@AAEJAAVCFileBase@@@Z ; CEterPack::GetNewIndexPosition
PUBLIC	?NewIndex@CEterPack@@AAEPAUSEterPackIndex@@AAVCFileBase@@PBDJ@Z ; CEterPack::NewIndex
PUBLIC	?WriteIndex@CEterPack@@AAEXAAVCFileBase@@PAUSEterPackIndex@@@Z ; CEterPack::WriteIndex
PUBLIC	?GetFreeBlockIndex@CEterPack@@AAEHJ@Z		; CEterPack::GetFreeBlockIndex
PUBLIC	?PushFreeIndex@CEterPack@@AAEXPAUSEterPackIndex@@@Z ; CEterPack::PushFreeIndex
PUBLIC	?CreateDataFile@CEterPack@@AAE_NXZ		; CEterPack::CreateDataFile
PUBLIC	?GetNewDataPosition@CEterPack@@AAEJAAVCFileBase@@@Z ; CEterPack::GetNewDataPosition
PUBLIC	?ReadData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PAXJ@Z ; CEterPack::ReadData
PUBLIC	?WriteData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z ; CEterPack::WriteData
PUBLIC	?WriteNewData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z ; CEterPack::WriteNewData
PUBLIC	?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z	; CEterPack::Delete
PUBLIC	?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
PUBLIC	?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
PUBLIC	?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
PUBLIC	?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load
PUBLIC	?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
PUBLIC	??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >
PUBLIC	?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
PUBLIC	?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node
PUBLIC	?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
PUBLIC	?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets
PUBLIC	?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert
PUBLIC	?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
PUBLIC	?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_unique
PUBLIC	?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::resize_and_add_node_unique
PUBLIC	??0?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >
PUBLIC	??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::~unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >
PUBLIC	??A?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAEAAKABK@Z ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
PUBLIC	?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
PUBLIC	?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
PUBLIC	?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@XZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
PUBLIC	?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
PUBLIC	?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load
PUBLIC	?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
PUBLIC	??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >
PUBLIC	?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
PUBLIC	?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node
PUBLIC	?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
PUBLIC	?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets
PUBLIC	?fix_bucket@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEIIPAUptr_bucket@234@PAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::fix_bucket
PUBLIC	?clear_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::clear_impl
PUBLIC	?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@ABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
PUBLIC	?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert
PUBLIC	?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
PUBLIC	?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_unique
PUBLIC	?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::resize_and_add_node_unique
PUBLIC	?erase_nodes_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@0@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::erase_nodes_unique
PUBLIC	??0?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >
PUBLIC	??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::~unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >
PUBLIC	?erase@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@U4523@@Z ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::erase
PUBLIC	?find@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::find
PUBLIC	??0?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >
PUBLIC	??1?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::~list<SEterPackIndex *,std::allocator<SEterPackIndex *> >
PUBLIC	?begin@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@XZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::begin
PUBLIC	?erase@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@@Z ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::erase
PUBLIC	?clear@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEXXZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::clear
PUBLIC	?_Tidy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Alloc_sentinel_and_proxy
PUBLIC	?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z ; CEterPack::__CreateFileNameKey_Panama
PUBLIC	?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z ; CEterPack::__Decrypt_Panama
PUBLIC	?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z ; CEterPack::__Encrypt_Panama
PUBLIC	??_GCEterPack@@UAEPAXI@Z			; CEterPack::`scalar deleting destructor'
PUBLIC	?GetSingleton@CMakePackLog@@SAAAV1@XZ		; CMakePackLog::GetSingleton
PUBLIC	??0CMakePackLog@@QAE@XZ				; CMakePackLog::CMakePackLog
PUBLIC	??1CMakePackLog@@QAE@XZ				; CMakePackLog::~CMakePackLog
PUBLIC	?SetFileName@CMakePackLog@@QAEXPBD@Z		; CMakePackLog::SetFileName
PUBLIC	?Writef@CMakePackLog@@QAAXPBDZZ			; CMakePackLog::Writef
PUBLIC	?Writenf@CMakePackLog@@QAAXPBDZZ		; CMakePackLog::Writenf
PUBLIC	?Write@CMakePackLog@@QAEXPBD@Z			; CMakePackLog::Write
PUBLIC	?WriteErrorf@CMakePackLog@@QAAXPBDZZ		; CMakePackLog::WriteErrorf
PUBLIC	?WriteErrornf@CMakePackLog@@QAAXPBDZZ		; CMakePackLog::WriteErrornf
PUBLIC	?WriteError@CMakePackLog@@QAEXPBD@Z		; CMakePackLog::WriteError
PUBLIC	?FlushError@CMakePackLog@@QAEXXZ		; CMakePackLog::FlushError
PUBLIC	?__Write@CMakePackLog@@AAEXPBDH@Z		; CMakePackLog::__Write
PUBLIC	?__WriteError@CMakePackLog@@AAEXPBDH@Z		; CMakePackLog::__WriteError
PUBLIC	?__IsLogMode@CMakePackLog@@AAE_NXZ		; CMakePackLog::__IsLogMode
PUBLIC	?inlinePathCreate@@YAXPBD@Z			; inlinePathCreate
PUBLIC	?inlineConvertPackFilename@@YAXPAD@Z		; inlineConvertPackFilename
PUBLIC	??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::Exception::Exception
PUBLIC	??1Exception@CryptoPP@@UAE@XZ			; CryptoPP::Exception::~Exception
PUBLIC	?what@Exception@CryptoPP@@UBEPBDXZ		; CryptoPP::Exception::what
PUBLIC	??0Exception@CryptoPP@@QAE@ABV01@@Z		; CryptoPP::Exception::Exception
PUBLIC	??_GException@CryptoPP@@UAEPAXI@Z		; CryptoPP::Exception::`scalar deleting destructor'
PUBLIC	??0InvalidArgument@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::InvalidArgument::InvalidArgument
PUBLIC	??1InvalidArgument@CryptoPP@@UAE@XZ		; CryptoPP::InvalidArgument::~InvalidArgument
PUBLIC	??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z	; CryptoPP::InvalidArgument::InvalidArgument
PUBLIC	??_GInvalidArgument@CryptoPP@@UAEPAXI@Z		; CryptoPP::InvalidArgument::`scalar deleting destructor'
PUBLIC	??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::NotImplemented::NotImplemented
PUBLIC	??1NotImplemented@CryptoPP@@UAE@XZ		; CryptoPP::NotImplemented::~NotImplemented
PUBLIC	??0NotImplemented@CryptoPP@@QAE@ABV01@@Z	; CryptoPP::NotImplemented::NotImplemented
PUBLIC	??_GNotImplemented@CryptoPP@@UAEPAXI@Z		; CryptoPP::NotImplemented::`scalar deleting destructor'
PUBLIC	??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z ; CryptoPP::NameValuePairs::ValueTypeMismatch::ValueTypeMismatch
PUBLIC	??1ValueTypeMismatch@NameValuePairs@CryptoPP@@UAE@XZ ; CryptoPP::NameValuePairs::ValueTypeMismatch::~ValueTypeMismatch
PUBLIC	??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z ; CryptoPP::NameValuePairs::ValueTypeMismatch::ValueTypeMismatch
PUBLIC	??_GValueTypeMismatch@NameValuePairs@CryptoPP@@UAEPAXI@Z ; CryptoPP::NameValuePairs::ValueTypeMismatch::`scalar deleting destructor'
PUBLIC	?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z ; CryptoPP::NameValuePairs::ThrowIfTypeMismatch
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?Clone@Clonable@CryptoPP@@UBEPAV12@XZ		; CryptoPP::Clonable::Clone
PUBLIC	?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CryptoPP::Algorithm::AlgorithmName
PUBLIC	??1SimpleKeyingInterface@CryptoPP@@UAE@XZ	; CryptoPP::SimpleKeyingInterface::~SimpleKeyingInterface
PUBLIC	?IsValidKeyLength@SimpleKeyingInterface@CryptoPP@@UBE_NI@Z ; CryptoPP::SimpleKeyingInterface::IsValidKeyLength
PUBLIC	?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ	; CryptoPP::SimpleKeyingInterface::IVSize
PUBLIC	?MinIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ ; CryptoPP::SimpleKeyingInterface::MinIVLength
PUBLIC	?MaxIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ ; CryptoPP::SimpleKeyingInterface::MaxIVLength
PUBLIC	?MandatoryBlockSize@StreamTransformation@CryptoPP@@UBEIXZ ; CryptoPP::StreamTransformation::MandatoryBlockSize
PUBLIC	?GetOptimalBlockSizeUsed@StreamTransformation@CryptoPP@@UBEIXZ ; CryptoPP::StreamTransformation::GetOptimalBlockSizeUsed
PUBLIC	?MinLastBlockSize@StreamTransformation@CryptoPP@@UBEIXZ ; CryptoPP::StreamTransformation::MinLastBlockSize
PUBLIC	?Final@HashTransformation@CryptoPP@@UAEXPAE@Z	; CryptoPP::HashTransformation::Final
PUBLIC	?CalculateDigest@HashTransformation@CryptoPP@@UAEXPAEPBEI@Z ; CryptoPP::HashTransformation::CalculateDigest
PUBLIC	?Verify@HashTransformation@CryptoPP@@UAE_NPBE@Z	; CryptoPP::HashTransformation::Verify
PUBLIC	?VerifyDigest@HashTransformation@CryptoPP@@UAE_NPBE0I@Z ; CryptoPP::HashTransformation::VerifyDigest
PUBLIC	?CalculateTruncatedDigest@HashTransformation@CryptoPP@@UAEXPAEIPBEI@Z ; CryptoPP::HashTransformation::CalculateTruncatedDigest
PUBLIC	?VerifyTruncatedDigest@HashTransformation@CryptoPP@@UAE_NPBEI0I@Z ; CryptoPP::HashTransformation::VerifyTruncatedDigest
PUBLIC	?GetAlgorithm@SymmetricCipher@CryptoPP@@MBEABVAlgorithm@2@XZ ; CryptoPP::SymmetricCipher::GetAlgorithm
PUBLIC	?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z ; CryptoPP::RandomNumberGenerator::IncorporateEntropy
PUBLIC	?CanIncorporateEntropy@RandomNumberGenerator@CryptoPP@@UBE_NXZ ; CryptoPP::RandomNumberGenerator::CanIncorporateEntropy
PUBLIC	??1RandomNumberGenerator@CryptoPP@@UAE@XZ	; CryptoPP::RandomNumberGenerator::~RandomNumberGenerator
PUBLIC	??0BufferedTransformation@CryptoPP@@QAE@XZ	; CryptoPP::BufferedTransformation::BufferedTransformation
PUBLIC	?CreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEAAI@Z ; CryptoPP::BufferedTransformation::CreatePutSpace
PUBLIC	?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ ; CryptoPP::BufferedTransformation::CanModifyInput
PUBLIC	?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z ; CryptoPP::BufferedTransformation::PutModifiable2
PUBLIC	?IsolatedMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_N_N@Z ; CryptoPP::BufferedTransformation::IsolatedMessageSeriesEnd
PUBLIC	?SetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UAEXH@Z ; CryptoPP::BufferedTransformation::SetAutoSignalPropagation
PUBLIC	?GetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UBEHXZ ; CryptoPP::BufferedTransformation::GetAutoSignalPropagation
PUBLIC	?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ ; CryptoPP::BufferedTransformation::GetNextMessageSeries
PUBLIC	?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ ; CryptoPP::BufferedTransformation::NumberOfMessagesInThisSeries
PUBLIC	?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ ; CryptoPP::BufferedTransformation::NumberOfMessageSeries
PUBLIC	?Attachable@BufferedTransformation@CryptoPP@@UAE_NXZ ; CryptoPP::BufferedTransformation::Attachable
PUBLIC	?AttachedTransformation@BufferedTransformation@CryptoPP@@UAEPAV12@XZ ; CryptoPP::BufferedTransformation::AttachedTransformation
PUBLIC	?AttachedTransformation@BufferedTransformation@CryptoPP@@UBEPBV12@XZ ; CryptoPP::BufferedTransformation::AttachedTransformation
PUBLIC	?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z ; CryptoPP::BufferedTransformation::Detach
PUBLIC	??1BufferedTransformation@CryptoPP@@UAE@XZ	; CryptoPP::BufferedTransformation::~BufferedTransformation
PUBLIC	?IsAlignedOn@CryptoPP@@YA_NPBXI@Z		; CryptoPP::IsAlignedOn
PUBLIC	?Put2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::Put2
PUBLIC	?IsolatedFlush@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N0@Z ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::IsolatedFlush
PUBLIC	?IsolatedMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N@Z ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::IsolatedMessageSeriesEnd
PUBLIC	?ChannelPut2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::ChannelPut2
PUBLIC	?ChannelMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::ChannelMessageSeriesEnd
PUBLIC	?SetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UAEXH@Z ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::SetAutoSignalPropagation
PUBLIC	?GetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UBEHXZ ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::GetAutoSignalPropagation
PUBLIC	?IsolatedInitialize@Store@CryptoPP@@UAEXABVNameValuePairs@2@@Z ; CryptoPP::Store::IsolatedInitialize
PUBLIC	?NumberOfMessages@Store@CryptoPP@@UBEIXZ	; CryptoPP::Store::NumberOfMessages
PUBLIC	??1Store@CryptoPP@@UAE@XZ			; CryptoPP::Store::~Store
PUBLIC	?TransferTo2@Sink@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CryptoPP::Sink::TransferTo2
PUBLIC	?CopyRangeTo2@Sink@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CryptoPP::Sink::CopyRangeTo2
PUBLIC	?IsolatedFlush@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@UAE_N_N0@Z ; CryptoPP::Bufferless<CryptoPP::Sink>::IsolatedFlush
PUBLIC	?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z	; CryptoPP::AllocatorBase<unsigned char>::CheckSize
PUBLIC	??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >
PUBLIC	?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node
PUBLIC	?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
PUBLIC	?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets
PUBLIC	??0?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >
PUBLIC	??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >::~unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >
PUBLIC	??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> >,unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> >,unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long> > >
PUBLIC	??0?$unordered_map@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> > >::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> > >
PUBLIC	??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z ; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter
PUBLIC	?Assign@ConstByteArrayParameter@CryptoPP@@QAEXPBEI_N@Z ; CryptoPP::ConstByteArrayParameter::Assign
PUBLIC	??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
PUBLIC	??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
PUBLIC	??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
PUBLIC	?Assign@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXABV12@@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::Assign
PUBLIC	?New@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXI@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::New
PUBLIC	??1ConstByteArrayParameter@CryptoPP@@QAE@XZ	; CryptoPP::ConstByteArrayParameter::~ConstByteArrayParameter
PUBLIC	??0ConstByteArrayParameter@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter
PUBLIC	??4ConstByteArrayParameter@CryptoPP@@QAEAAV01@ABV01@@Z ; CryptoPP::ConstByteArrayParameter::operator=
PUBLIC	??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::ParameterNotUsed
PUBLIC	??1ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAE@XZ ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::~ParameterNotUsed
PUBLIC	??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::ParameterNotUsed
PUBLIC	??_GParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAEPAXI@Z ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`scalar deleting destructor'
PUBLIC	??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::AlgorithmParametersBase::AlgorithmParametersBase
PUBLIC	??1AlgorithmParametersBase@CryptoPP@@UAE@XZ	; CryptoPP::AlgorithmParametersBase::~AlgorithmParametersBase
PUBLIC	??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
PUBLIC	?reset@?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAEXPAVAlgorithmParametersBase@2@@Z ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::reset
PUBLIC	??_GAlgorithmParametersBase@CryptoPP@@UAEPAXI@Z	; CryptoPP::AlgorithmParametersBase::`scalar deleting destructor'
PUBLIC	?AssignValue@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPBDABVtype_info@@PAX@Z ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::AssignValue
PUBLIC	?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::MoveInto
PUBLIC	??_G?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UAEPAXI@Z ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`scalar deleting destructor'
PUBLIC	??1AlgorithmParameters@CryptoPP@@UAE@XZ		; CryptoPP::AlgorithmParameters::~AlgorithmParameters
PUBLIC	?Attachable@Filter@CryptoPP@@UAE_NXZ		; CryptoPP::Filter::Attachable
PUBLIC	?ShouldPropagateMessageEnd@Filter@CryptoPP@@MBE_NXZ ; CryptoPP::Filter::ShouldPropagateMessageEnd
PUBLIC	?ShouldPropagateMessageSeriesEnd@Filter@CryptoPP@@MBE_NXZ ; CryptoPP::Filter::ShouldPropagateMessageSeriesEnd
PUBLIC	??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
PUBLIC	?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::IsolatedInitialize
PUBLIC	?Put2@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEIPBEIH_N@Z ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::Put2
PUBLIC	??_G?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEPAXI@Z ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
PUBLIC	??_GArraySink@CryptoPP@@UAEPAXI@Z		; CryptoPP::ArraySink::`scalar deleting destructor'
PUBLIC	??0StringStore@CryptoPP@@QAE@PBD@Z		; CryptoPP::StringStore::StringStore
PUBLIC	??_GStringStore@CryptoPP@@UAEPAXI@Z		; CryptoPP::StringStore::`scalar deleting destructor'
PUBLIC	??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z ; CryptoPP::MakeParameters<CryptoPP::ConstByteArrayParameter>
PUBLIC	?Put2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z ; CryptoPP::InputRejecting<CryptoPP::Filter>::Put2
PUBLIC	?IsolatedFlush@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N0@Z ; CryptoPP::InputRejecting<CryptoPP::Filter>::IsolatedFlush
PUBLIC	?IsolatedMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N@Z ; CryptoPP::InputRejecting<CryptoPP::Filter>::IsolatedMessageSeriesEnd
PUBLIC	?ChannelPut2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z ; CryptoPP::InputRejecting<CryptoPP::Filter>::ChannelPut2
PUBLIC	?ChannelMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z ; CryptoPP::InputRejecting<CryptoPP::Filter>::ChannelMessageSeriesEnd
PUBLIC	??1?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::InputRejecting<CryptoPP::Filter>::~InputRejecting<CryptoPP::Filter>
PUBLIC	??1Source@CryptoPP@@UAE@XZ			; CryptoPP::Source::~Source
PUBLIC	??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SourceTemplate<CryptoPP::StringStore>
PUBLIC	?IsolatedInitialize@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::IsolatedInitialize
PUBLIC	?Pump2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAA_K_N@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::Pump2
PUBLIC	?PumpMessages2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAAI_N@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::PumpMessages2
PUBLIC	?PumpAll2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEI_N@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::PumpAll2
PUBLIC	?SourceExhausted@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBE_NXZ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SourceExhausted
PUBLIC	?SetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXH@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SetAutoSignalPropagation
PUBLIC	?GetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBEHXZ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::GetAutoSignalPropagation
PUBLIC	??1?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::~SourceTemplate<CryptoPP::StringStore>
PUBLIC	??_G?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEPAXI@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`scalar deleting destructor'
PUBLIC	??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z ; CryptoPP::StringSource::StringSource
PUBLIC	??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z ; CryptoPP::StringSource::StringSource
PUBLIC	??_GStringSource@CryptoPP@@UAEPAXI@Z		; CryptoPP::StringSource::`scalar deleting destructor'
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?GetOptimalBlockSize@AdditiveCipherAbstractPolicy@CryptoPP@@UBEIXZ ; CryptoPP::AdditiveCipherAbstractPolicy::GetOptimalBlockSize
PUBLIC	?WriteKeystream@AdditiveCipherAbstractPolicy@CryptoPP@@UAEXPAEI@Z ; CryptoPP::AdditiveCipherAbstractPolicy::WriteKeystream
PUBLIC	?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z ; CryptoPP::AdditiveCipherAbstractPolicy::SeekToIteration
PUBLIC	??1?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@UAE@XZ ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::~AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>
PUBLIC	?OptimalBlockSize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::OptimalBlockSize
PUBLIC	?OptimalDataAlignment@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::OptimalDataAlignment
PUBLIC	?IsSelfInverting@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsSelfInverting
PUBLIC	?IsForwardTransformation@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsForwardTransformation
PUBLIC	?IsRandomAccess@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsRandomAccess
PUBLIC	??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >
PUBLIC	??1?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::~AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >
PUBLIC	?OptimalBlockSize@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::OptimalBlockSize
PUBLIC	?OptimalDataAlignment@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::OptimalDataAlignment
PUBLIC	??1?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::~IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>
PUBLIC	?OptimalBlockSize@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::OptimalBlockSize
PUBLIC	?OptimalDataAlignment@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::OptimalDataAlignment
PUBLIC	??1?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::~IteratedHashBase<unsigned int,CryptoPP::HashTransformation>
PUBLIC	?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::BlockSize
PUBLIC	?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::GetByteOrder
PUBLIC	?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::DataBuf
PUBLIC	?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0>::deallocate
PUBLIC	??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
PUBLIC	??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
PUBLIC	??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
PUBLIC	??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
PUBLIC	??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
PUBLIC	?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::AlgorithmName
PUBLIC	?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::Clone
PUBLIC	??1?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UAE@XZ ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::~ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >
PUBLIC	?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::DigestSize
PUBLIC	??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>
PUBLIC	?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::HashEndianCorrectedBlock
PUBLIC	?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::Init
PUBLIC	?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::StateBuf
PUBLIC	??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ ; CryptoPP::FixedSizeAlignedSecBlock<unsigned __int64,8,0>::~FixedSizeAlignedSecBlock<unsigned __int64,8,0>
PUBLIC	??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::~IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>
PUBLIC	??_GTiger@CryptoPP@@UAEPAXI@Z			; CryptoPP::Tiger::`scalar deleting destructor'
PUBLIC	?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::BlockSize
PUBLIC	?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::GetByteOrder
PUBLIC	?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::DataBuf
PUBLIC	?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
PUBLIC	??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
PUBLIC	??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
PUBLIC	??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
PUBLIC	??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
PUBLIC	??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
PUBLIC	?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::AlgorithmName
PUBLIC	?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::Clone
PUBLIC	??1?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UAE@XZ ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::~ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >
PUBLIC	?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::DigestSize
PUBLIC	??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>
PUBLIC	?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::HashEndianCorrectedBlock
PUBLIC	?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::Init
PUBLIC	?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEPAIXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::StateBuf
PUBLIC	??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ ; CryptoPP::FixedSizeAlignedSecBlock<unsigned int,16,0>::~FixedSizeAlignedSecBlock<unsigned int,16,0>
PUBLIC	??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::~IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>
PUBLIC	??_GSHA1@CryptoPP@@UAEPAXI@Z			; CryptoPP::SHA1::`scalar deleting destructor'
PUBLIC	?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::BlockSize
PUBLIC	?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::GetByteOrder
PUBLIC	?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::DataBuf
PUBLIC	??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
PUBLIC	??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
PUBLIC	??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
PUBLIC	?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::AlgorithmName
PUBLIC	?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::Clone
PUBLIC	??1?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UAE@XZ ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::~ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >
PUBLIC	?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::DigestSize
PUBLIC	??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>
PUBLIC	?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::HashEndianCorrectedBlock
PUBLIC	?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::Init
PUBLIC	?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEPAIXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::StateBuf
PUBLIC	??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::~IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>
PUBLIC	??_GRIPEMD128@CryptoPP@@UAEPAXI@Z		; CryptoPP::RIPEMD128::`scalar deleting destructor'
PUBLIC	?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::BlockSize
PUBLIC	?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::GetByteOrder
PUBLIC	?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::DataBuf
PUBLIC	??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
PUBLIC	??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
PUBLIC	??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
PUBLIC	?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::AlgorithmName
PUBLIC	?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::Clone
PUBLIC	??1?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UAE@XZ ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::~ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >
PUBLIC	?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UBEIXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::DigestSize
PUBLIC	??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>
PUBLIC	?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::HashEndianCorrectedBlock
PUBLIC	?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::Init
PUBLIC	?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::StateBuf
PUBLIC	??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::~IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>
PUBLIC	??_GWhirlpool@CryptoPP@@UAEPAXI@Z		; CryptoPP::Whirlpool::`scalar deleting destructor'
PUBLIC	?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1>::deallocate
PUBLIC	??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >
PUBLIC	??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >
PUBLIC	?GetBytesPerIteration@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::GetBytesPerIteration
PUBLIC	?GetIterationsToBuffer@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::GetIterationsToBuffer
PUBLIC	?CanOperateKeystream@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBE_NXZ ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::CanOperateKeystream
PUBLIC	??1?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::~AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>
PUBLIC	?deallocate@?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
PUBLIC	??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >
PUBLIC	??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	?do_always_noconv@codecvt_base@std@@MBE_NXZ	; std::codecvt_base::do_always_noconv
PUBLIC	?do_max_length@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_max_length
PUBLIC	?do_encoding@codecvt_base@std@@MBEHXZ		; std::codecvt_base::do_encoding
PUBLIC	??_Gcodecvt_base@std@@UAEPAXI@Z			; std::codecvt_base::`scalar deleting destructor'
PUBLIC	?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<wchar_t,char,_Mbstatet>::_Getcat
PUBLIC	?do_in@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPA_W3AAPA_W@Z ; std::codecvt<wchar_t,char,_Mbstatet>::do_in
PUBLIC	?do_out@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PB_W1AAPB_WPAD3AAPAD@Z ; std::codecvt<wchar_t,char,_Mbstatet>::do_out
PUBLIC	?do_unshift@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z ; std::codecvt<wchar_t,char,_Mbstatet>::do_unshift
PUBLIC	?do_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z ; std::codecvt<wchar_t,char,_Mbstatet>::do_length
PUBLIC	?do_always_noconv@?$codecvt@_WDU_Mbstatet@@@std@@MBE_NXZ ; std::codecvt<wchar_t,char,_Mbstatet>::do_always_noconv
PUBLIC	?do_max_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ ; std::codecvt<wchar_t,char,_Mbstatet>::do_max_length
PUBLIC	?do_encoding@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ ; std::codecvt<wchar_t,char,_Mbstatet>::do_encoding
PUBLIC	??_G?$codecvt@_WDU_Mbstatet@@@std@@MAEPAXI@Z	; std::codecvt<wchar_t,char,_Mbstatet>::`scalar deleting destructor'
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<wchar_t>::_Getcat
PUBLIC	??1?$ctype@_W@std@@MAE@XZ			; std::ctype<wchar_t>::~ctype<wchar_t>
PUBLIC	?do_is@?$ctype@_W@std@@MBE_NF_W@Z		; std::ctype<wchar_t>::do_is
PUBLIC	?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z	; std::ctype<wchar_t>::do_is
PUBLIC	?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_is
PUBLIC	?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z	; std::ctype<wchar_t>::do_scan_not
PUBLIC	?do_tolower@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_tolower
PUBLIC	?do_toupper@?$ctype@_W@std@@MBE_W_W@Z		; std::ctype<wchar_t>::do_toupper
PUBLIC	?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z	; std::ctype<wchar_t>::do_toupper
PUBLIC	?_Dowiden@?$ctype@_W@std@@IBE_WD@Z		; std::ctype<wchar_t>::_Dowiden
PUBLIC	?do_widen@?$ctype@_W@std@@MBE_WD@Z		; std::ctype<wchar_t>::do_widen
PUBLIC	?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z	; std::ctype<wchar_t>::do_widen
PUBLIC	?_Donarrow@?$ctype@_W@std@@IBED_WD@Z		; std::ctype<wchar_t>::_Donarrow
PUBLIC	?do_narrow@?$ctype@_W@std@@MBED_WD@Z		; std::ctype<wchar_t>::do_narrow
PUBLIC	?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z	; std::ctype<wchar_t>::do_narrow
PUBLIC	??_G?$ctype@_W@std@@MAEPAXI@Z			; std::ctype<wchar_t>::`scalar deleting destructor'
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?_Init@ios_base@std@@IAEXXZ			; std::ios_base::_Init
PUBLIC	??_Gios_base@std@@UAEPAXI@Z			; std::ios_base::`scalar deleting destructor'
PUBLIC	??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen
PUBLIC	?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
PUBLIC	??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Ipfx
PUBLIC	??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
PUBLIC	??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::basic_ifstream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?getloc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::getloc
PUBLIC	?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sbumpc
PUBLIC	?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sgetc
PUBLIC	?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::snextc
PUBLIC	?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
PUBLIC	?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
PUBLIC	?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
PUBLIC	?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc
PUBLIC	?_Gnpreinc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnpreinc
PUBLIC	?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
PUBLIC	?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init
PUBLIC	?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
PUBLIC	?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
PUBLIC	?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow
PUBLIC	?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
PUBLIC	?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
PUBLIC	?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
PUBLIC	?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos
PUBLIC	?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
PUBLIC	?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
PUBLIC	?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
PUBLIC	??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::open
PUBLIC	?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close
PUBLIC	?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::underflow
PUBLIC	?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::setbuf
PUBLIC	?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::sync
PUBLIC	?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::imbue
PUBLIC	?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXABV?$codecvt@_WDU_Mbstatet@@@2@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Set_back
PUBLIC	??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
PUBLIC	?_Getval@?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@AAEXXZ ; std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>::_Getval
PUBLIC	??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ ; std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>::~istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>
PUBLIC	?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
PUBLIC	??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABEII@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@II@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Change_array
PUBLIC	?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z ; std::copy<std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>,std::back_insert_iterator<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
PUBLIC	??4?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@std@@QAEAAV01@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::ostream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t> >::operator=
PUBLIC	?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
PUBLIC	?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
PUBLIC	??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
PUBLIC	??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@V?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@2@@std@@YA?AV?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::ostream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t> > >
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
PUBLIC	?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
PUBLIC	??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::~Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >
PUBLIC	?CipherIsRandomAccess@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBE_NXZ ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::CipherIsRandomAccess
PUBLIC	??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >
PUBLIC	??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::~PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >
PUBLIC	??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >
PUBLIC	??_G?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAEPAXI@Z ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`scalar deleting destructor'
PUBLIC	?GetPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MBEABUAdditiveCipherAbstractPolicy@2@XZ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::GetPolicy
PUBLIC	?AccessPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MAEAAUAdditiveCipherAbstractPolicy@2@XZ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::AccessPolicy
PUBLIC	??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>
PUBLIC	??1?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAE@XZ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::~ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>
PUBLIC	??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>
PUBLIC	??_G?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`scalar deleting destructor'
PUBLIC	?MinKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::MinKeyLength
PUBLIC	?MaxKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::MaxKeyLength
PUBLIC	?DefaultKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::DefaultKeyLength
PUBLIC	?GetValidKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEII@Z ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::GetValidKeyLength
PUBLIC	?IVRequirement@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AW4IV_Requirement@SimpleKeyingInterface@2@XZ ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::IVRequirement
PUBLIC	?IVSize@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::IVSize
PUBLIC	?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::AlgorithmName
PUBLIC	??0?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@QAE@XZ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >
PUBLIC	?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::Clone
PUBLIC	??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::~SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >
PUBLIC	??_G?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`scalar deleting destructor'
PUBLIC	??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >
PUBLIC	??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected
PUBLIC	??1InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::~InputRejected
PUBLIC	??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected
PUBLIC	??_GInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEPAXI@Z ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`scalar deleting destructor'
PUBLIC	??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected
PUBLIC	??1InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE@XZ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::~InputRejected
PUBLIC	??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected
PUBLIC	??_GInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEPAXI@Z ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`scalar deleting destructor'
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ; std::_List_node<SEterPackIndex *,void *>::_Free_non_head<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
PUBLIC	??$_Emplace@ABQAUSEterPackIndex@@@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@1@QAU21@ABQAUSEterPackIndex@@@Z ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Emplace<SEterPackIndex * const &>
PUBLIC	??$emplace@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@12@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@std@@@Z ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::emplace<std::pair<unsigned long const ,CEterFileDict::Item> >
PUBLIC	??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$SecureWipeArray@I@CryptoPP@@YAXPAII@Z	; CryptoPP::SecureWipeArray<unsigned int>
PUBLIC	??$SecureWipeArray@_K@CryptoPP@@YAXPA_KI@Z	; CryptoPP::SecureWipeArray<unsigned __int64>
PUBLIC	??$SecureWipeArray@E@CryptoPP@@YAXPAEI@Z	; CryptoPP::SecureWipeArray<unsigned char>
PUBLIC	??$StandardReallocate@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@YAPAEAAV?$AllocatorWithCleanup@E$0A@@0@PAEII_N@Z ; CryptoPP::StandardReallocate<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ; std::_List_node<SEterPackIndex *,void *>::_Freenode0<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
PUBLIC	??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
PUBLIC	??$lower_bound@PBIIU?$less@X@std@@@std@@YAPBIPBIQBIABIU?$less@X@0@@Z ; std::lower_bound<unsigned int const *,unsigned int,std::less<void> >
PUBLIC	??$try_emplace_unique@ABK@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::try_emplace_unique<unsigned long const &>
PUBLIC	??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z ; CryptoPP::AlgorithmParameters::operator()<CryptoPP::ConstByteArrayParameter>
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z ; std::_Copy_unchecked<std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>,std::back_insert_iterator<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_Transfer_before
PUBLIC	??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > ><SEterPackIndex * const &>
PUBLIC	??$emplace_unique@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK$$QAU?$pair@$$CBKPAUSEterPackIndex@@@5@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_unique<std::pair<unsigned long const ,SEterPackIndex *> >
PUBLIC	??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z ; boost::unordered::detail::func::construct_node_from_args<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > >,std::pair<unsigned long const ,CEterFileDict::Item> >
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<SEterPackIndex *,void *> *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * const &>
PUBLIC	??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@IABKABU?$equal_to@K@std@@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >
PUBLIC	??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
PUBLIC	??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@IABKABU?$equal_to@K@std@@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >
PUBLIC	??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z ; boost::unordered::detail::func::construct_node_pair<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > >,unsigned long const &>
PUBLIC	??$?9V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z ; std::operator!=<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>
PUBLIC	??$_Sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0HU?$less@X@0@@Z ; std::_Sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
PUBLIC	??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z ; boost::unordered::detail::func::construct_node_from_args<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > >,std::pair<unsigned long const ,SEterPackIndex *> >
PUBLIC	??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
PUBLIC	?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::create_node
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
PUBLIC	??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
PUBLIC	??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@IABKABU?$equal_to@K@std@@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >
PUBLIC	??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
PUBLIC	??$emplace_back@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back_with_unused_capacity<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
PUBLIC	??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
PUBLIC	??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
PUBLIC	??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
PUBLIC	?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::create_node
PUBLIC	??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@std@@SAXAAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@1@QAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
PUBLIC	??$?8V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z ; std::operator==<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>
PUBLIC	??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z ; std::_Insertion_sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
PUBLIC	??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ; std::_Make_heap_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
PUBLIC	??$_Partition_by_median_guess_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
PUBLIC	??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
PUBLIC	?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::create_node
PUBLIC	??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
PUBLIC	??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Move_backward_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00@Z ; std::_Move_backward_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
PUBLIC	??$_Pop_heap_hole_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >
PUBLIC	??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ; std::_Pop_heap_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
PUBLIC	??$_Guess_median_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ; std::_Guess_median_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
PUBLIC	??$_Emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ; std::_Pocma<std::allocator<wchar_t> >
PUBLIC	??$_Push_heap_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z ; std::_Push_heap_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >
PUBLIC	??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ; std::_Med3_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
PUBLIC	??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z ; std::_Traits_compare<std::char_traits<wchar_t> >
PUBLIC	??$_Pocs@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ; std::_Pocs<std::allocator<wchar_t> >
PUBLIC	??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
PUBLIC	??_E?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@W3AEPAXI@Z ; [thunk]:CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vector deleting destructor'
PUBLIC	??_EArraySink@CryptoPP@@W3AEPAXI@Z		; [thunk]:CryptoPP::ArraySink::`vector deleting destructor'
PUBLIC	??_EStringStore@CryptoPP@@W3AEPAXI@Z		; [thunk]:CryptoPP::StringStore::`vector deleting destructor'
PUBLIC	??_EStringSource@CryptoPP@@W3AEPAXI@Z		; [thunk]:CryptoPP::StringSource::`vector deleting destructor'
PUBLIC	??_E?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@W3AEPAXI@Z ; [thunk]:CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vector deleting destructor'
PUBLIC	??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W3AEPAXI@Z ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor'
PUBLIC	??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W7AEPAXI@Z ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor'
PUBLIC	??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@WCA@AEPAXI@Z ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor'
PUBLIC	??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3AEPAXI@Z ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor'
PUBLIC	??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W7AEPAXI@Z ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor'
PUBLIC	?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BEPAVClonable@2@XZ ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::Clone`adjustor{4}'
PUBLIC	?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; [thunk]:CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::AlgorithmName`adjustor{4}'
PUBLIC	??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@WCA@AEPAXI@Z ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_7_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
PUBLIC	?value@?$prime_list_template@I@detail@unordered@boost@@2QBIB ; boost::unordered::detail::prime_list_template<unsigned int>::value
PUBLIC	?length@?$prime_list_template@I@detail@unordered@boost@@2HB ; boost::unordered::detail::prime_list_template<unsigned int>::length
PUBLIC	?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A	; CSingleton<CLZO>::ms_singleton
PUBLIC	??_7CEterPack@@6B@				; CEterPack::`vftable'
PUBLIC	??_7Exception@CryptoPP@@6B@			; CryptoPP::Exception::`vftable'
PUBLIC	??_7InvalidArgument@CryptoPP@@6B@		; CryptoPP::InvalidArgument::`vftable'
PUBLIC	??_7NotImplemented@CryptoPP@@6B@		; CryptoPP::NotImplemented::`vftable'
PUBLIC	??_7ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@ ; CryptoPP::NameValuePairs::ValueTypeMismatch::`vftable'
PUBLIC	??_C@_01GEODFPGF@?8@				; `string'
PUBLIC	??_C@_0BI@CPJAGCKP@?8?0?5trying?5to?5retrieve?5?8@ ; `string'
PUBLIC	??_C@_0M@PGGGIJHH@?8?0?5stored?5?8@		; `string'
PUBLIC	??_C@_0CE@LNMKHLKF@NameValuePairs?3?5type?5mismatch?5f@ ; `string'
PUBLIC	__TI4?AVValueTypeMismatch@NameValuePairs@CryptoPP@@
PUBLIC	__CTA4?AVValueTypeMismatch@NameValuePairs@CryptoPP@@
PUBLIC	??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8 ; CryptoPP::NameValuePairs::ValueTypeMismatch `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z48
PUBLIC	??_R0?AVInvalidArgument@CryptoPP@@@8		; CryptoPP::InvalidArgument `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVInvalidArgument@CryptoPP@@@8??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z40
PUBLIC	??_R0?AVException@CryptoPP@@@8			; CryptoPP::Exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40
PUBLIC	__TI3?AVInvalidArgument@CryptoPP@@
PUBLIC	__CTA3?AVInvalidArgument@CryptoPP@@
PUBLIC	__TI3?AVNotImplemented@CryptoPP@@
PUBLIC	__CTA3?AVNotImplemented@CryptoPP@@
PUBLIC	??_R0?AVNotImplemented@CryptoPP@@@8		; CryptoPP::NotImplemented `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVNotImplemented@CryptoPP@@@8??0NotImplemented@CryptoPP@@QAE@ABV01@@Z40
PUBLIC	??_C@_0CA@CCPAJEEJ@Clone?$CI?$CJ?5is?5not?5implemented?5yet?4@ ; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown@			; `string'
PUBLIC	??_C@_0DA@CJIHPKKH@?3?5this?5object?5doesn?8t?5support?5r@ ; `string'
PUBLIC	??_C@_0EA@BPAJPOGP@StreamTransformation?3?5this?5obje@ ; `string'
PUBLIC	??_C@_0DK@CFJCNMFC@RandomNumberGenerator?3?5Incorpor@ ; `string'
PUBLIC	??_C@_0DG@FIHMKEGL@BufferedTransformation?3?5this?5ob@ ; `string'
PUBLIC	??_7ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@ ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable'
PUBLIC	??_7AlgorithmParametersBase@CryptoPP@@6B@	; CryptoPP::AlgorithmParametersBase::`vftable'
PUBLIC	??_C@_0L@IAABKFFP@?$CC?5not?5used@		; `string'
PUBLIC	??_C@_0CF@BLINCPFB@AlgorithmParametersBase?3?5parame@ ; `string'
PUBLIC	__TI3?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@
PUBLIC	__CTA3?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@
PUBLIC	??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8 ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z40
PUBLIC	??_7?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable'
PUBLIC	??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vftable'
PUBLIC	??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@ ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vftable'
PUBLIC	??_7ArraySink@CryptoPP@@6BAlgorithm@1@@		; CryptoPP::ArraySink::`vftable'
PUBLIC	??_7ArraySink@CryptoPP@@6BWaitable@1@@		; CryptoPP::ArraySink::`vftable'
PUBLIC	??_7StringStore@CryptoPP@@6BAlgorithm@1@@	; CryptoPP::StringStore::`vftable'
PUBLIC	??_7StringStore@CryptoPP@@6BWaitable@1@@	; CryptoPP::StringStore::`vftable'
PUBLIC	??_C@_0M@JMHEFFAI@InputBuffer@			; `string'
PUBLIC	??_7?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable'
PUBLIC	??_7?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BWaitable@1@@ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable'
PUBLIC	??_7StringSource@CryptoPP@@6BAlgorithm@1@@	; CryptoPP::StringSource::`vftable'
PUBLIC	??_7StringSource@CryptoPP@@6BWaitable@1@@	; CryptoPP::StringSource::`vftable'
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	??_7Tiger@CryptoPP@@6B@				; CryptoPP::Tiger::`vftable'
PUBLIC	??_C@_05LIOENMIE@Tiger@				; `string'
PUBLIC	??_7SHA1@CryptoPP@@6B@				; CryptoPP::SHA1::`vftable'
PUBLIC	??_C@_05HJMENKNE@SHA?91@			; `string'
PUBLIC	??_7RIPEMD128@CryptoPP@@6B@			; CryptoPP::RIPEMD128::`vftable'
PUBLIC	??_C@_0L@DFIJCONE@RIPEMD?9128@			; `string'
PUBLIC	??_7Whirlpool@CryptoPP@@6B@			; CryptoPP::Whirlpool::`vftable'
PUBLIC	??_C@_09HLDHDDJL@Whirlpool@			; `string'
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_7codecvt_base@std@@6B@			; std::codecvt_base::`vftable'
PUBLIC	??_7?$codecvt@_WDU_Mbstatet@@@std@@6B@		; std::codecvt<wchar_t,char,_Mbstatet>::`vftable'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@_W@std@@6B@				; std::ctype<wchar_t>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_7ios_base@std@@6B@				; std::ios_base::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_C@_04FPOLKAEB@?4log@				; `string'
PUBLIC	??_C@_04BKIDJPM@?4err@				; `string'
PUBLIC	??_C@_01NOFIACDB@w@				; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_09BOOFBHDC@Error?3?5?$CFs@		; `string'
PUBLIC	??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vftable'
PUBLIC	??_8?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@7B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
PUBLIC	??_C@_04OLDEJNOH@?4eix@				; `string'
PUBLIC	??_C@_04JJCMEEIK@?4epk@				; `string'
PUBLIC	??_C@_0CO@LCLPMBOA@EncryptIndex?3?5Cannot?5open?5pack?5@ ; `string'
PUBLIC	??_C@_0CB@BKLKOCID@EncryptIndex?3?5Cannot?5encrypt?$CB?5?$CF@ ; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_C@_0CP@NIHCOGLD@EncryptIndex?3?5Cannot?5open?5file?5@ ; `string'
PUBLIC	??_C@_0CH@FFDEAKBO@Encryptindex?3?5Cannot?5write?5to?5f@ ; `string'
PUBLIC	??_C@_0CA@IACKDODI@Cannot?5open?5pack?5index?5file?$CB?5?$CFs@ ; `string'
PUBLIC	??_C@_0CB@KNLDPAAC@Pack?5index?5file?5header?5error?$CB?5?$CF@ ; `string'
PUBLIC	??_C@_0CB@HPBCEBAA@Pack?5index?5file?5fourcc?5error?$CB?5?$CF@ ; `string'
PUBLIC	??_C@_0CC@KGHAJIDH@Pack?5index?5file?5version?5error?$CB?5@ ; `string'
PUBLIC	??_C@_0CO@JMMFBMPC@Pack?5index?5file?5size?5error?$CB?5?$CFs?0@ ; `string'
PUBLIC	??_C@_0BK@CFBHFFAK@Failed?5to?5decompress?5?3?5?$CFs@ ; `string'
PUBLIC	??_C@_0BH@CFAPLGOA@Failed?5to?5encrypt?5?3?5?$CFs@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6@			; `string'
PUBLIC	??_C@_0BC@OILLCEPM@cannot?5decompress@		; `string'
PUBLIC	??_C@_0EE@JIDJMBKL@EterPack?3?3Put?5?3?5Cannot?5put?5to?5e@ ; `string'
PUBLIC	??_C@_0BH@IGHIDEHN@Overwrite?$FLtype?3?$CFu?$FN?5?$CFs?6@ ; `string'
PUBLIC	??_C@_0BD@JEPAOIH@Write?$FLtype?3?$CFu?$FN?5?$CFs?6@ ; `string'
PUBLIC	??_C@_02JDPG@rb@				; `string'
PUBLIC	??_C@_0EC@IGPMDEEF@SYSERR?3?5WriteNewData?$CI?$CJ?3?5CRITICA@ ; `string'
PUBLIC	??_C@_0P@MDGHMGJK@Unref?5File?5?$CFs?6@		; `string'
PUBLIC	??_7?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`vftable'
PUBLIC	??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vftable'
PUBLIC	??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vftable'
PUBLIC	??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vftable'
PUBLIC	??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vftable'
PUBLIC	??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vftable'
PUBLIC	??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vftable'
PUBLIC	??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vftable'
PUBLIC	??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vftable'
PUBLIC	??_C@_0CA@GEOIKNCG@NAME_COLLISION?3?5OLD?3?5?$CFs?5NEW?3?5?$CFs@ ; `string'
PUBLIC	??_7InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`vftable'
PUBLIC	__TI4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
PUBLIC	__CTA4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
PUBLIC	??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z40
PUBLIC	??_C@_0BE@NDOICOBI@OutputStringPointer@		; `string'
PUBLIC	??_C@_0CO@DDPAKADP@StringSink?3?5OutputStringPointer@ ; `string'
PUBLIC	??_R0?AVConstByteArrayParameter@CryptoPP@@@8	; CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor'
PUBLIC	??_7InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable'
PUBLIC	__TI4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
PUBLIC	__CTA4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
PUBLIC	??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z40
PUBLIC	??_C@_0DI@JMMKBAHA@BufferedTransformation?3?5this?5ob@ ; `string'
PUBLIC	??_C@_09LKKJKGIK@Panama?9BE@			; `string'
PUBLIC	??_C@_09LADHILIA@Panama?9LE@			; `string'
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init'::`2'::_Stinit
PUBLIC	??_C@_0DL@LFCPKOMM@AllocatorBase?3?5requested?5size?5w@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<wchar_t,char,_Mbstatet> >::_Psave
PUBLIC	??_R0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_string<char,std::char_traits<char>,std::allocator<char> > * `RTTI Type Descriptor'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ios_base@std@@6B@				; std::ios_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category2@std@@@8	; std::_Iostream_error_category2 `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category2@std@@8	; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CEterPack@@6B@				; CEterPack::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCEterPack@@@8				; CEterPack `RTTI Type Descriptor'
PUBLIC	??_R3CEterPack@@8				; CEterPack::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CEterPack@@8				; CEterPack::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CEterPack@@8			; CEterPack::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVRandomNumberGenerator@CryptoPP@@@8	; CryptoPP::RandomNumberGenerator `RTTI Type Descriptor'
PUBLIC	??_R3RandomNumberGenerator@CryptoPP@@8		; CryptoPP::RandomNumberGenerator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RandomNumberGenerator@CryptoPP@@8		; CryptoPP::RandomNumberGenerator::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RandomNumberGenerator@CryptoPP@@8	; CryptoPP::RandomNumberGenerator::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Algorithm@CryptoPP@@8		; CryptoPP::Algorithm::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVAlgorithm@CryptoPP@@@8			; CryptoPP::Algorithm `RTTI Type Descriptor'
PUBLIC	??_R3Algorithm@CryptoPP@@8			; CryptoPP::Algorithm::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Algorithm@CryptoPP@@8			; CryptoPP::Algorithm::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Clonable@CryptoPP@@8		; CryptoPP::Clonable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVClonable@CryptoPP@@@8			; CryptoPP::Clonable `RTTI Type Descriptor'
PUBLIC	??_R3Clonable@CryptoPP@@8			; CryptoPP::Clonable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Clonable@CryptoPP@@8			; CryptoPP::Clonable::`RTTI Base Class Array'
PUBLIC	??_R0?AVBufferedTransformation@CryptoPP@@@8	; CryptoPP::BufferedTransformation `RTTI Type Descriptor'
PUBLIC	??_R3BufferedTransformation@CryptoPP@@8		; CryptoPP::BufferedTransformation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2BufferedTransformation@CryptoPP@@8		; CryptoPP::BufferedTransformation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8 ; CryptoPP::BufferedTransformation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@Waitable@CryptoPP@@8		; CryptoPP::Waitable::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVWaitable@CryptoPP@@@8			; CryptoPP::Waitable `RTTI Type Descriptor'
PUBLIC	??_R3Waitable@CryptoPP@@8			; CryptoPP::Waitable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Waitable@CryptoPP@@8			; CryptoPP::Waitable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Waitable@CryptoPP@@8		; CryptoPP::Waitable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Exception@CryptoPP@@6B@			; CryptoPP::Exception::`RTTI Complete Object Locator'
PUBLIC	??_R3Exception@CryptoPP@@8			; CryptoPP::Exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Exception@CryptoPP@@8			; CryptoPP::Exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Exception@CryptoPP@@8		; CryptoPP::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4InvalidArgument@CryptoPP@@6B@		; CryptoPP::InvalidArgument::`RTTI Complete Object Locator'
PUBLIC	??_R3InvalidArgument@CryptoPP@@8		; CryptoPP::InvalidArgument::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InvalidArgument@CryptoPP@@8		; CryptoPP::InvalidArgument::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InvalidArgument@CryptoPP@@8	; CryptoPP::InvalidArgument::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4NotImplemented@CryptoPP@@6B@		; CryptoPP::NotImplemented::`RTTI Complete Object Locator'
PUBLIC	??_R3NotImplemented@CryptoPP@@8			; CryptoPP::NotImplemented::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2NotImplemented@CryptoPP@@8			; CryptoPP::NotImplemented::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@NotImplemented@CryptoPP@@8	; CryptoPP::NotImplemented::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@ ; CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Complete Object Locator'
PUBLIC	??_R3ValueTypeMismatch@NameValuePairs@CryptoPP@@8 ; CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ValueTypeMismatch@NameValuePairs@CryptoPP@@8 ; CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ValueTypeMismatch@NameValuePairs@CryptoPP@@8 ; CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSimpleKeyingInterface@CryptoPP@@@8	; CryptoPP::SimpleKeyingInterface `RTTI Type Descriptor'
PUBLIC	??_R3SimpleKeyingInterface@CryptoPP@@8		; CryptoPP::SimpleKeyingInterface::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SimpleKeyingInterface@CryptoPP@@8		; CryptoPP::SimpleKeyingInterface::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8	; CryptoPP::SimpleKeyingInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVStreamTransformation@CryptoPP@@@8	; CryptoPP::StreamTransformation `RTTI Type Descriptor'
PUBLIC	??_R3StreamTransformation@CryptoPP@@8		; CryptoPP::StreamTransformation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StreamTransformation@CryptoPP@@8		; CryptoPP::StreamTransformation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@StreamTransformation@CryptoPP@@8	; CryptoPP::StreamTransformation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVHashTransformation@CryptoPP@@@8		; CryptoPP::HashTransformation `RTTI Type Descriptor'
PUBLIC	??_R3HashTransformation@CryptoPP@@8		; CryptoPP::HashTransformation::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2HashTransformation@CryptoPP@@8		; CryptoPP::HashTransformation::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@HashTransformation@CryptoPP@@8	; CryptoPP::HashTransformation::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSymmetricCipher@CryptoPP@@@8		; CryptoPP::SymmetricCipher `RTTI Type Descriptor'
PUBLIC	??_R3SymmetricCipher@CryptoPP@@8		; CryptoPP::SymmetricCipher::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SymmetricCipher@CryptoPP@@8		; CryptoPP::SymmetricCipher::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8	; CryptoPP::SymmetricCipher::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@StreamTransformation@CryptoPP@@8	; CryptoPP::StreamTransformation::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R13?0A@EA@Algorithm@CryptoPP@@8		; CryptoPP::Algorithm::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R13?0A@EA@Clonable@CryptoPP@@8		; CryptoPP::Clonable::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVStore@CryptoPP@@@8			; CryptoPP::Store `RTTI Type Descriptor'
PUBLIC	??_R3Store@CryptoPP@@8				; CryptoPP::Store::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Store@CryptoPP@@8				; CryptoPP::Store::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Store@CryptoPP@@8			; CryptoPP::Store::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> > `RTTI Type Descriptor'
PUBLIC	??_R3?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> `RTTI Type Descriptor'
PUBLIC	??_R3?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::`RTTI Base Class Array'
PUBLIC	??_R4InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`RTTI Complete Object Locator'
PUBLIC	??_R3InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVSink@CryptoPP@@@8			; CryptoPP::Sink `RTTI Type Descriptor'
PUBLIC	??_R3Sink@CryptoPP@@8				; CryptoPP::Sink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Sink@CryptoPP@@8				; CryptoPP::Sink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Sink@CryptoPP@@8			; CryptoPP::Sink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$Bufferless@VSink@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::Bufferless<CryptoPP::Sink> `RTTI Type Descriptor'
PUBLIC	??_R3?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8	; CryptoPP::Bufferless<CryptoPP::Sink>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8	; CryptoPP::Bufferless<CryptoPP::Sink>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8 ; CryptoPP::Bufferless<CryptoPP::Sink>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4AlgorithmParametersBase@CryptoPP@@6B@	; CryptoPP::AlgorithmParametersBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVAlgorithmParametersBase@CryptoPP@@@8	; CryptoPP::AlgorithmParametersBase `RTTI Type Descriptor'
PUBLIC	??_R3AlgorithmParametersBase@CryptoPP@@8	; CryptoPP::AlgorithmParametersBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AlgorithmParametersBase@CryptoPP@@8	; CryptoPP::AlgorithmParametersBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AlgorithmParametersBase@CryptoPP@@8 ; CryptoPP::AlgorithmParametersBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@ ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`RTTI Complete Object Locator'
PUBLIC	??_R3ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8 ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8 ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8 ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter> `RTTI Type Descriptor'
PUBLIC	??_R3?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Filter@CryptoPP@@8		; CryptoPP::Filter::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVFilter@CryptoPP@@@8			; CryptoPP::Filter `RTTI Type Descriptor'
PUBLIC	??_R3Filter@CryptoPP@@8				; CryptoPP::Filter::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Filter@CryptoPP@@8				; CryptoPP::Filter::`RTTI Base Class Array'
PUBLIC	??_R1M@?0A@EA@NotCopyable@CryptoPP@@8		; CryptoPP::NotCopyable::`RTTI Base Class Descriptor at (12,-1,0,64)'
PUBLIC	??_R0?AVNotCopyable@CryptoPP@@@8		; CryptoPP::NotCopyable `RTTI Type Descriptor'
PUBLIC	??_R3NotCopyable@CryptoPP@@8			; CryptoPP::NotCopyable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2NotCopyable@CryptoPP@@8			; CryptoPP::NotCopyable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@NotCopyable@CryptoPP@@8		; CryptoPP::NotCopyable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@@8 ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8 ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8 ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8 ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@ ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R4ArraySink@CryptoPP@@6BAlgorithm@1@@	; CryptoPP::ArraySink::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVArraySink@CryptoPP@@@8			; CryptoPP::ArraySink `RTTI Type Descriptor'
PUBLIC	??_R3ArraySink@CryptoPP@@8			; CryptoPP::ArraySink::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ArraySink@CryptoPP@@8			; CryptoPP::ArraySink::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ArraySink@CryptoPP@@8		; CryptoPP::ArraySink::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ArraySink@CryptoPP@@6BWaitable@1@@		; CryptoPP::ArraySink::`RTTI Complete Object Locator'
PUBLIC	??_R4StringStore@CryptoPP@@6BAlgorithm@1@@	; CryptoPP::StringStore::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVStringStore@CryptoPP@@@8		; CryptoPP::StringStore `RTTI Type Descriptor'
PUBLIC	??_R3StringStore@CryptoPP@@8			; CryptoPP::StringStore::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StringStore@CryptoPP@@8			; CryptoPP::StringStore::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@StringStore@CryptoPP@@8		; CryptoPP::StringStore::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4StringStore@CryptoPP@@6BWaitable@1@@	; CryptoPP::StringStore::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSource@CryptoPP@@@8			; CryptoPP::Source `RTTI Type Descriptor'
PUBLIC	??_R3Source@CryptoPP@@8				; CryptoPP::Source::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Source@CryptoPP@@8				; CryptoPP::Source::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Source@CryptoPP@@8		; CryptoPP::Source::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter> `RTTI Type Descriptor'
PUBLIC	??_R3?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::`RTTI Base Class Array'
PUBLIC	??_R4InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Complete Object Locator'
PUBLIC	??_R3InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4StringSource@CryptoPP@@6BAlgorithm@1@@	; CryptoPP::StringSource::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVStringSource@CryptoPP@@@8		; CryptoPP::StringSource `RTTI Type Descriptor'
PUBLIC	??_R3StringSource@CryptoPP@@8			; CryptoPP::StringSource::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2StringSource@CryptoPP@@8			; CryptoPP::StringSource::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@StringSource@CryptoPP@@8		; CryptoPP::StringSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8 ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::SourceTemplate<CryptoPP::StringStore> `RTTI Type Descriptor'
PUBLIC	??_R3?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8 ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8 ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Base Class Array'
PUBLIC	??_R4StringSource@CryptoPP@@6BWaitable@1@@	; CryptoPP::StringSource::`RTTI Complete Object Locator'
PUBLIC	??_R4?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BWaitable@1@@ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUAdditiveCipherAbstractPolicy@CryptoPP@@@8 ; CryptoPP::AdditiveCipherAbstractPolicy `RTTI Type Descriptor'
PUBLIC	??_R3AdditiveCipherAbstractPolicy@CryptoPP@@8	; CryptoPP::AdditiveCipherAbstractPolicy::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2AdditiveCipherAbstractPolicy@CryptoPP@@8	; CryptoPP::AdditiveCipherAbstractPolicy::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@AdditiveCipherAbstractPolicy@CryptoPP@@8 ; CryptoPP::AdditiveCipherAbstractPolicy::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@8 ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> `RTTI Type Descriptor'
PUBLIC	??_R3?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8 ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8 ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8 ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> > `RTTI Type Descriptor'
PUBLIC	??_R3?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EC@Algorithm@CryptoPP@@8		; CryptoPP::Algorithm::`RTTI Base Class Descriptor at (4,-1,0,66)'
PUBLIC	??_R13?0A@EC@Clonable@CryptoPP@@8		; CryptoPP::Clonable::`RTTI Base Class Descriptor at (4,-1,0,66)'
PUBLIC	??_R17?0A@EA@RandomNumberGenerator@CryptoPP@@8	; CryptoPP::RandomNumberGenerator::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R17?0A@EC@Algorithm@CryptoPP@@8		; CryptoPP::Algorithm::`RTTI Base Class Descriptor at (8,-1,0,66)'
PUBLIC	??_R17?0A@EC@Clonable@CryptoPP@@8		; CryptoPP::Clonable::`RTTI Base Class Descriptor at (8,-1,0,66)'
PUBLIC	??_R0?AV?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Tiger@CryptoPP@@6B@			; CryptoPP::Tiger::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVTiger@CryptoPP@@@8			; CryptoPP::Tiger `RTTI Type Descriptor'
PUBLIC	??_R3Tiger@CryptoPP@@8				; CryptoPP::Tiger::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Tiger@CryptoPP@@8				; CryptoPP::Tiger::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Tiger@CryptoPP@@8			; CryptoPP::Tiger::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@@8 ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> > `RTTI Type Descriptor'
PUBLIC	??_R3?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> `RTTI Type Descriptor'
PUBLIC	??_R3?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
PUBLIC	??_R4SHA1@CryptoPP@@6B@				; CryptoPP::SHA1::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSHA1@CryptoPP@@@8			; CryptoPP::SHA1 `RTTI Type Descriptor'
PUBLIC	??_R3SHA1@CryptoPP@@8				; CryptoPP::SHA1::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SHA1@CryptoPP@@8				; CryptoPP::SHA1::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SHA1@CryptoPP@@8			; CryptoPP::SHA1::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@@8 ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> > `RTTI Type Descriptor'
PUBLIC	??_R3?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> `RTTI Type Descriptor'
PUBLIC	??_R3?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
PUBLIC	??_R4RIPEMD128@CryptoPP@@6B@			; CryptoPP::RIPEMD128::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVRIPEMD128@CryptoPP@@@8			; CryptoPP::RIPEMD128 `RTTI Type Descriptor'
PUBLIC	??_R3RIPEMD128@CryptoPP@@8			; CryptoPP::RIPEMD128::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2RIPEMD128@CryptoPP@@8			; CryptoPP::RIPEMD128::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@RIPEMD128@CryptoPP@@8		; CryptoPP::RIPEMD128::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@@8 ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> > `RTTI Type Descriptor'
PUBLIC	??_R3?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> `RTTI Type Descriptor'
PUBLIC	??_R3?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::`RTTI Base Class Array'
PUBLIC	??_R4Whirlpool@CryptoPP@@6B@			; CryptoPP::Whirlpool::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVWhirlpool@CryptoPP@@@8			; CryptoPP::Whirlpool `RTTI Type Descriptor'
PUBLIC	??_R3Whirlpool@CryptoPP@@8			; CryptoPP::Whirlpool::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Whirlpool@CryptoPP@@8			; CryptoPP::Whirlpool::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Whirlpool@CryptoPP@@8		; CryptoPP::Whirlpool::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@@8 ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> > `RTTI Type Descriptor'
PUBLIC	??_R3?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> `RTTI Type Descriptor'
PUBLIC	??_R3?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
PUBLIC	??_R3?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
PUBLIC	??_R0?AU?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy> `RTTI Type Descriptor'
PUBLIC	??_R3?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R4codecvt_base@std@@6B@			; std::codecvt_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVcodecvt_base@std@@@8			; std::codecvt_base `RTTI Type Descriptor'
PUBLIC	??_R3codecvt_base@std@@8			; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2codecvt_base@std@@8			; std::codecvt_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@codecvt_base@std@@8		; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$codecvt@_WDU_Mbstatet@@@std@@6B@		; std::codecvt<wchar_t,char,_Mbstatet>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$codecvt@_WDU_Mbstatet@@@std@@@8	; std::codecvt<wchar_t,char,_Mbstatet> `RTTI Type Descriptor'
PUBLIC	??_R3?$codecvt@_WDU_Mbstatet@@@std@@8		; std::codecvt<wchar_t,char,_Mbstatet>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$codecvt@_WDU_Mbstatet@@@std@@8		; std::codecvt<wchar_t,char,_Mbstatet>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$codecvt@_WDU_Mbstatet@@@std@@8	; std::codecvt<wchar_t,char,_Mbstatet>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@_W@std@@6B@			; std::ctype<wchar_t>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@_W@std@@@8			; std::ctype<wchar_t> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@_W@std@@8				; std::ctype<wchar_t>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@_W@std@@8			; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > `RTTI Type Descriptor'
PUBLIC	??_R3?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > `RTTI Type Descriptor'
PUBLIC	??_R3?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@@8 ; CryptoPP::FixedKeyLength<32,0,32> `RTTI Type Descriptor'
PUBLIC	??_R3?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R17?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (8,-1,0,77)'
PUBLIC	??_R0?AV?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > `RTTI Type Descriptor'
PUBLIC	??_R3?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@@8 ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy> `RTTI Type Descriptor'
PUBLIC	??_R3?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8 ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8 ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8 ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1CA@?0A@EN@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (32,-1,0,77)'
PUBLIC	??_R1CA@?0A@EJ@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Descriptor at (32,-1,0,73)'
PUBLIC	??_R1CA@?0A@EJ@AdditiveCipherAbstractPolicy@CryptoPP@@8 ; CryptoPP::AdditiveCipherAbstractPolicy::`RTTI Base Class Descriptor at (32,-1,0,73)'
PUBLIC	??_R1CE@?0A@EJ@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (36,-1,0,73)'
PUBLIC	??_R1CE@?0A@EJ@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Base Class Descriptor at (36,-1,0,73)'
PUBLIC	??_R1CI@?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (40,-1,0,77)'
PUBLIC	??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Complete Object Locator'
PUBLIC	??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Array'
PUBLIC	??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Complete Object Locator'
PUBLIC	__real@3f800000
PUBLIC	__real@3ff0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	___std_terminate:PROC
EXTRN	__invalid_parameter_noinfo:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_tolower:PROC
EXTRN	__errno:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strchr:PROC
EXTRN	_wcslen:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	__imp__CreateDirectoryA@8:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fgetwc:PROC
EXTRN	_fputwc:PROC
EXTRN	_ungetwc:PROC
EXTRN	__get_stream_buffer_pointers:PROC
EXTRN	_fclose:PROC
EXTRN	_fflush:PROC
EXTRN	_fgetc:PROC
EXTRN	_fgetpos:PROC
EXTRN	_fopen:PROC
EXTRN	_fsetpos:PROC
EXTRN	__fseeki64:PROC
EXTRN	_fwrite:PROC
EXTRN	_setvbuf:PROC
EXTRN	_ungetc:PROC
EXTRN	__lock_file:PROC
EXTRN	__unlock_file:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	_ceil:PROC
EXTRN	_floor:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	_exit:PROC
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	___std_type_info_compare:PROC
EXTRN	___std_type_info_name:PROC
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Iostream_error_category2@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category2::`vector deleting destructor'
EXTRN	??0CLZObject@@QAE@XZ:PROC			; CLZObject::CLZObject
EXTRN	??1CLZObject@@QAE@XZ:PROC			; CLZObject::~CLZObject
EXTRN	?Clear@CLZObject@@QAEXXZ:PROC			; CLZObject::Clear
EXTRN	?GetSize@CLZObject@@QAEKXZ:PROC			; CLZObject::GetSize
EXTRN	?AllocBuffer@CLZObject@@QAEXK@Z:PROC		; CLZObject::AllocBuffer
EXTRN	?CompressMemory@CLZO@@QAE_NAAVCLZObject@@PBXI@Z:PROC ; CLZO::CompressMemory
EXTRN	?CompressEncryptedMemory@CLZO@@QAE_NAAVCLZObject@@PBXIPAK@Z:PROC ; CLZO::CompressEncryptedMemory
EXTRN	?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z:PROC ; CLZO::Decompress
EXTRN	??0CFileBase@@QAE@XZ:PROC			; CFileBase::CFileBase
EXTRN	??1CFileBase@@UAE@XZ:PROC			; CFileBase::~CFileBase
EXTRN	?Destroy@CFileBase@@QAEXXZ:PROC			; CFileBase::Destroy
EXTRN	?Close@CFileBase@@QAEXXZ:PROC			; CFileBase::Close
EXTRN	?Create@CFileBase@@QAEHPBDW4EFileMode@1@@Z:PROC	; CFileBase::Create
EXTRN	?Size@CFileBase@@QAEKXZ:PROC			; CFileBase::Size
EXTRN	?Seek@CFileBase@@QAEXK@Z:PROC			; CFileBase::Seek
EXTRN	?Write@CFileBase@@UAEHPBXH@Z:PROC		; CFileBase::Write
EXTRN	?Read@CFileBase@@QAEHPAXH@Z:PROC		; CFileBase::Read
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Create@CMappedFile@@QAEHPBDPAPBXHH@Z:PROC	; CMappedFile::Create
EXTRN	?Destroy@CMappedFile@@QAEXXZ:PROC		; CMappedFile::Destroy
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	?BindLZObject@CMappedFile@@QAEXPAVCLZObject@@@Z:PROC ; CMappedFile::BindLZObject
EXTRN	?BindLZObjectWithBufferedSize@CMappedFile@@QAEXPAVCLZObject@@@Z:PROC ; CMappedFile::BindLZObjectWithBufferedSize
EXTRN	?AppendDataBlock@CMappedFile@@QAEPAEPBXK@Z:PROC	; CMappedFile::AppendDataBlock
EXTRN	??_ECEterPack@@UAEPAXI@Z:PROC			; CEterPack::`vector deleting destructor'
EXTRN	??_EException@CryptoPP@@UAEPAXI@Z:PROC		; CryptoPP::Exception::`vector deleting destructor'
EXTRN	??_EInvalidArgument@CryptoPP@@UAEPAXI@Z:PROC	; CryptoPP::InvalidArgument::`vector deleting destructor'
EXTRN	??_ENotImplemented@CryptoPP@@UAEPAXI@Z:PROC	; CryptoPP::NotImplemented::`vector deleting destructor'
EXTRN	??_EValueTypeMismatch@NameValuePairs@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::NameValuePairs::ValueTypeMismatch::`vector deleting destructor'
EXTRN	??0Algorithm@CryptoPP@@QAE@_N@Z:PROC		; CryptoPP::Algorithm::Algorithm
EXTRN	?SetKey@SimpleKeyingInterface@CryptoPP@@UAEXPBEIABVNameValuePairs@2@@Z:PROC ; CryptoPP::SimpleKeyingInterface::SetKey
EXTRN	?SetKeyWithIV@SimpleKeyingInterface@CryptoPP@@QAEXPBEI0I@Z:PROC ; CryptoPP::SimpleKeyingInterface::SetKeyWithIV
EXTRN	?GetNextIV@SimpleKeyingInterface@CryptoPP@@UAEXAAVRandomNumberGenerator@2@PAE@Z:PROC ; CryptoPP::SimpleKeyingInterface::GetNextIV
EXTRN	?ProcessLastBlock@StreamTransformation@CryptoPP@@UAEXPAEPBEI@Z:PROC ; CryptoPP::StreamTransformation::ProcessLastBlock
EXTRN	?TruncatedVerify@HashTransformation@CryptoPP@@UAE_NPBEI@Z:PROC ; CryptoPP::HashTransformation::TruncatedVerify
EXTRN	?GenerateByte@RandomNumberGenerator@CryptoPP@@UAEEXZ:PROC ; CryptoPP::RandomNumberGenerator::GenerateByte
EXTRN	?GenerateBit@RandomNumberGenerator@CryptoPP@@UAEIXZ:PROC ; CryptoPP::RandomNumberGenerator::GenerateBit
EXTRN	?GenerateWord32@RandomNumberGenerator@CryptoPP@@UAEIII@Z:PROC ; CryptoPP::RandomNumberGenerator::GenerateWord32
EXTRN	?DiscardBytes@RandomNumberGenerator@CryptoPP@@UAEXI@Z:PROC ; CryptoPP::RandomNumberGenerator::DiscardBytes
EXTRN	?GenerateIntoBufferedTransformation@RandomNumberGenerator@CryptoPP@@UAEXAAVBufferedTransformation@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z:PROC ; CryptoPP::RandomNumberGenerator::GenerateIntoBufferedTransformation
EXTRN	?GetMaxWaitObjectCount@BufferedTransformation@CryptoPP@@UBEIXZ:PROC ; CryptoPP::BufferedTransformation::GetMaxWaitObjectCount
EXTRN	?GetWaitObjects@BufferedTransformation@CryptoPP@@UAEXAAVWaitObjectContainer@2@ABVCallStack@2@@Z:PROC ; CryptoPP::BufferedTransformation::GetWaitObjects
EXTRN	?Initialize@BufferedTransformation@CryptoPP@@UAEXABVNameValuePairs@2@H@Z:PROC ; CryptoPP::BufferedTransformation::Initialize
EXTRN	?Flush@BufferedTransformation@CryptoPP@@UAE_N_NH0@Z:PROC ; CryptoPP::BufferedTransformation::Flush
EXTRN	?MessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_NH_N@Z:PROC ; CryptoPP::BufferedTransformation::MessageSeriesEnd
EXTRN	?MaxRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ:PROC ; CryptoPP::BufferedTransformation::MaxRetrievable
EXTRN	?AnyRetrievable@BufferedTransformation@CryptoPP@@UBE_NXZ:PROC ; CryptoPP::BufferedTransformation::AnyRetrievable
EXTRN	?Get@BufferedTransformation@CryptoPP@@UAEIAAE@Z:PROC ; CryptoPP::BufferedTransformation::Get
EXTRN	?Get@BufferedTransformation@CryptoPP@@UAEIPAEI@Z:PROC ; CryptoPP::BufferedTransformation::Get
EXTRN	?Peek@BufferedTransformation@CryptoPP@@UBEIAAE@Z:PROC ; CryptoPP::BufferedTransformation::Peek
EXTRN	?Peek@BufferedTransformation@CryptoPP@@UBEIPAEI@Z:PROC ; CryptoPP::BufferedTransformation::Peek
EXTRN	?Skip@BufferedTransformation@CryptoPP@@UAE_K_K@Z:PROC ; CryptoPP::BufferedTransformation::Skip
EXTRN	?TotalBytesRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ:PROC ; CryptoPP::BufferedTransformation::TotalBytesRetrievable
EXTRN	?NumberOfMessages@BufferedTransformation@CryptoPP@@UBEIXZ:PROC ; CryptoPP::BufferedTransformation::NumberOfMessages
EXTRN	?AnyMessages@BufferedTransformation@CryptoPP@@UBE_NXZ:PROC ; CryptoPP::BufferedTransformation::AnyMessages
EXTRN	?GetNextMessage@BufferedTransformation@CryptoPP@@UAE_NXZ:PROC ; CryptoPP::BufferedTransformation::GetNextMessage
EXTRN	?SkipMessages@BufferedTransformation@CryptoPP@@UAEII@Z:PROC ; CryptoPP::BufferedTransformation::SkipMessages
EXTRN	?SkipAll@BufferedTransformation@CryptoPP@@UAEXXZ:PROC ; CryptoPP::BufferedTransformation::SkipAll
EXTRN	?TransferMessagesTo2@BufferedTransformation@CryptoPP@@QAEIAAV12@AAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; CryptoPP::BufferedTransformation::TransferMessagesTo2
EXTRN	?TransferAllTo2@BufferedTransformation@CryptoPP@@QAEIAAV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; CryptoPP::BufferedTransformation::TransferAllTo2
EXTRN	?ChannelCreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAI@Z:PROC ; CryptoPP::BufferedTransformation::ChannelCreatePutSpace
EXTRN	?ChannelPut2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z:PROC ; CryptoPP::BufferedTransformation::ChannelPut2
EXTRN	?ChannelPutModifiable2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEIH_N@Z:PROC ; CryptoPP::BufferedTransformation::ChannelPutModifiable2
EXTRN	?ChannelFlush@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NH1@Z:PROC ; CryptoPP::BufferedTransformation::ChannelFlush
EXTRN	?ChannelMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z:PROC ; CryptoPP::BufferedTransformation::ChannelMessageSeriesEnd
EXTRN	?SetRetrievalChannel@BufferedTransformation@CryptoPP@@UAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; CryptoPP::BufferedTransformation::SetRetrievalChannel
EXTRN	?Attach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z:PROC ; CryptoPP::BufferedTransformation::Attach
EXTRN	?AlignedAllocate@CryptoPP@@YAPAXI@Z:PROC	; CryptoPP::AlignedAllocate
EXTRN	?AlignedDeallocate@CryptoPP@@YAXPAX@Z:PROC	; CryptoPP::AlignedDeallocate
EXTRN	?UnalignedAllocate@CryptoPP@@YAPAXI@Z:PROC	; CryptoPP::UnalignedAllocate
EXTRN	?UnalignedDeallocate@CryptoPP@@YAXPAX@Z:PROC	; CryptoPP::UnalignedDeallocate
EXTRN	?GetNextMessage@Store@CryptoPP@@UAE_NXZ:PROC	; CryptoPP::Store::GetNextMessage
EXTRN	??1EterPackPolicy_CSHybridCrypt@@QAE@XZ:PROC	; EterPackPolicy_CSHybridCrypt::~EterPackPolicy_CSHybridCrypt
EXTRN	?GenerateCryptKey@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; EterPackPolicy_CSHybridCrypt::GenerateCryptKey
EXTRN	?EncryptMemory@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEHAAVCLZObject@@@Z:PROC ; EterPackPolicy_CSHybridCrypt::EncryptMemory
EXTRN	?DecryptMemory@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEHAAVCLZObject@@@Z:PROC ; EterPackPolicy_CSHybridCrypt::DecryptMemory
EXTRN	?GenerateSupplementaryDataBlock@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@PBEHAAPAEAAH@Z:PROC ; EterPackPolicy_CSHybridCrypt::GenerateSupplementaryDataBlock
EXTRN	?GetSupplementaryDataBlock@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAEAAH@Z:PROC ; EterPackPolicy_CSHybridCrypt::GetSupplementaryDataBlock
EXTRN	??_EParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vector deleting destructor'
EXTRN	??_EAlgorithmParametersBase@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::AlgorithmParametersBase::`vector deleting destructor'
EXTRN	??_E?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vector deleting destructor'
EXTRN	??0AlgorithmParameters@CryptoPP@@QAE@XZ:PROC	; CryptoPP::AlgorithmParameters::AlgorithmParameters
EXTRN	??0AlgorithmParameters@CryptoPP@@QAE@ABV01@@Z:PROC ; CryptoPP::AlgorithmParameters::AlgorithmParameters
EXTRN	??0Filter@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z:PROC ; CryptoPP::Filter::Filter
EXTRN	?AttachedTransformation@Filter@CryptoPP@@UAEPAVBufferedTransformation@2@XZ:PROC ; CryptoPP::Filter::AttachedTransformation
EXTRN	?AttachedTransformation@Filter@CryptoPP@@UBEPBVBufferedTransformation@2@XZ:PROC ; CryptoPP::Filter::AttachedTransformation
EXTRN	?Detach@Filter@CryptoPP@@UAEXPAVBufferedTransformation@2@@Z:PROC ; CryptoPP::Filter::Detach
EXTRN	?TransferTo2@Filter@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; CryptoPP::Filter::TransferTo2
EXTRN	?CopyRangeTo2@Filter@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; CryptoPP::Filter::CopyRangeTo2
EXTRN	?Initialize@Filter@CryptoPP@@UAEXABVNameValuePairs@2@H@Z:PROC ; CryptoPP::Filter::Initialize
EXTRN	?Flush@Filter@CryptoPP@@UAE_N_NH0@Z:PROC	; CryptoPP::Filter::Flush
EXTRN	?MessageSeriesEnd@Filter@CryptoPP@@UAE_NH_N@Z:PROC ; CryptoPP::Filter::MessageSeriesEnd
EXTRN	?NewDefaultAttachment@Filter@CryptoPP@@MBEPAVBufferedTransformation@2@XZ:PROC ; CryptoPP::Filter::NewDefaultAttachment
EXTRN	??0StreamTransformationFilter@CryptoPP@@QAE@AAVStreamTransformation@1@PAVBufferedTransformation@1@W4BlockPaddingScheme@BlockPaddingSchemeDef@1@_N@Z:PROC ; CryptoPP::StreamTransformationFilter::StreamTransformationFilter
EXTRN	??0HashFilter@CryptoPP@@QAE@AAVHashTransformation@1@PAVBufferedTransformation@1@_NHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@3@Z:PROC ; CryptoPP::HashFilter::HashFilter
EXTRN	??_E?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vector deleting destructor'
EXTRN	?IsolatedInitialize@ArraySink@CryptoPP@@UAEXABVNameValuePairs@2@@Z:PROC ; CryptoPP::ArraySink::IsolatedInitialize
EXTRN	?CreatePutSpace@ArraySink@CryptoPP@@UAEPAEAAI@Z:PROC ; CryptoPP::ArraySink::CreatePutSpace
EXTRN	?Put2@ArraySink@CryptoPP@@UAEIPBEIH_N@Z:PROC	; CryptoPP::ArraySink::Put2
EXTRN	??_EArraySink@CryptoPP@@UAEPAXI@Z:PROC		; CryptoPP::ArraySink::`vector deleting destructor'
EXTRN	?TransferTo2@StringStore@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; CryptoPP::StringStore::TransferTo2
EXTRN	?CopyRangeTo2@StringStore@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:PROC ; CryptoPP::StringStore::CopyRangeTo2
EXTRN	?StoreInitialize@StringStore@CryptoPP@@EAEXABVNameValuePairs@2@@Z:PROC ; CryptoPP::StringStore::StoreInitialize
EXTRN	??_EStringStore@CryptoPP@@UAEPAXI@Z:PROC	; CryptoPP::StringStore::`vector deleting destructor'
EXTRN	??_E?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vector deleting destructor'
EXTRN	??_EStringSource@CryptoPP@@UAEPAXI@Z:PROC	; CryptoPP::StringSource::`vector deleting destructor'
EXTRN	?GenerateBlock@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPAEI@Z:PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::GenerateBlock
EXTRN	?ProcessData@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPAEPBEI@Z:PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::ProcessData
EXTRN	?Resynchronize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPBEH@Z:PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::Resynchronize
EXTRN	?Seek@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEX_K@Z:PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::Seek
EXTRN	?UncheckedSetKey@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@MAEXPBEIABVNameValuePairs@2@@Z:PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::UncheckedSetKey
EXTRN	?Update@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z:PROC ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::Update
EXTRN	?CreateUpdateSpace@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z:PROC ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::CreateUpdateSpace
EXTRN	?Restart@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ:PROC ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::Restart
EXTRN	?HashMultipleBlocks@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPB_KI@Z:PROC ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::HashMultipleBlocks
EXTRN	?Update@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z:PROC ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::Update
EXTRN	?CreateUpdateSpace@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z:PROC ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::CreateUpdateSpace
EXTRN	?Restart@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ:PROC ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::Restart
EXTRN	?TruncatedFinal@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPAEI@Z:PROC ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::TruncatedFinal
EXTRN	?HashMultipleBlocks@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPBII@Z:PROC ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::HashMultipleBlocks
EXTRN	?InitState@Tiger@CryptoPP@@SAXPA_K@Z:PROC	; CryptoPP::Tiger::InitState
EXTRN	?Transform@Tiger@CryptoPP@@SAXPA_KPB_K@Z:PROC	; CryptoPP::Tiger::Transform
EXTRN	?TruncatedFinal@Tiger@CryptoPP@@UAEXPAEI@Z:PROC	; CryptoPP::Tiger::TruncatedFinal
EXTRN	??_ETiger@CryptoPP@@UAEPAXI@Z:PROC		; CryptoPP::Tiger::`vector deleting destructor'
EXTRN	?InitState@SHA1@CryptoPP@@SAXPAI@Z:PROC		; CryptoPP::SHA1::InitState
EXTRN	?Transform@SHA1@CryptoPP@@SAXPAIPBI@Z:PROC	; CryptoPP::SHA1::Transform
EXTRN	??_ESHA1@CryptoPP@@UAEPAXI@Z:PROC		; CryptoPP::SHA1::`vector deleting destructor'
EXTRN	?InitState@RIPEMD128@CryptoPP@@SAXPAI@Z:PROC	; CryptoPP::RIPEMD128::InitState
EXTRN	?Transform@RIPEMD128@CryptoPP@@SAXPAIPBI@Z:PROC	; CryptoPP::RIPEMD128::Transform
EXTRN	??_ERIPEMD128@CryptoPP@@UAEPAXI@Z:PROC		; CryptoPP::RIPEMD128::`vector deleting destructor'
EXTRN	?InitState@Whirlpool@CryptoPP@@SAXPA_K@Z:PROC	; CryptoPP::Whirlpool::InitState
EXTRN	?Transform@Whirlpool@CryptoPP@@SAXPA_KPB_K@Z:PROC ; CryptoPP::Whirlpool::Transform
EXTRN	?TruncatedFinal@Whirlpool@CryptoPP@@UAEXPAEI@Z:PROC ; CryptoPP::Whirlpool::TruncatedFinal
EXTRN	??_EWhirlpool@CryptoPP@@UAEPAXI@Z:PROC		; CryptoPP::Whirlpool::`vector deleting destructor'
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?GetCRC32@@YAKPBDI@Z:PROC			; GetCRC32
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Mbrtowc:PROC
EXTRN	__Wcrtomb:PROC
EXTRN	__Getwctype:PROC
EXTRN	__Getwctypes:PROC
EXTRN	__Towlower:PROC
EXTRN	__Towupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ecodecvt_base@std@@UAEPAXI@Z:PROC		; std::codecvt_base::`vector deleting destructor'
EXTRN	??_E?$codecvt@_WDU_Mbstatet@@@std@@MAEPAXI@Z:PROC ; std::codecvt<wchar_t,char,_Mbstatet>::`vector deleting destructor'
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@_W@std@@MAEPAXI@Z:PROC		; std::ctype<wchar_t>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	?_Addstd@ios_base@std@@SAXPAV12@@Z:PROC		; std::ios_base::_Addstd
EXTRN	?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z:PROC	; std::ios_base::_Ios_base_dtor
EXTRN	??_Eios_base@std@@UAEPAXI@Z:PROC		; std::ios_base::`vector deleting destructor'
EXTRN	?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z:PROC		; std::_Fiopen
EXTRN	??_E?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
EXTRN	?CipherSetKey@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXABVNameValuePairs@2@PBEI@Z:PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::CipherSetKey
EXTRN	?OperateKeystream@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXW4KeystreamOperation@2@PAEPBEI@Z:PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::OperateKeystream
EXTRN	?CipherResynchronize@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXPAEPBEI@Z:PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::CipherResynchronize
EXTRN	?GetAlignment@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBEIXZ:PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::GetAlignment
EXTRN	??_E?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`vector deleting destructor'
EXTRN	??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor'
EXTRN	??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor'
EXTRN	??_EInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`vector deleting destructor'
EXTRN	??_EInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEPAXI@Z:PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__allmul:PROC
EXTRN	__dtoui3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?__type_info_root_node@@3U__type_info_node@@A:BYTE ; __type_info_root_node
EXTRN	?ms_dwFourCC@CLZObject@@2KA:DWORD		; CLZObject::ms_dwFourCC
EXTRN	?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B:BYTE ; CryptoPP::DEFAULT_CHANNEL
EXTRN	?g_pAssignIntToInteger@CryptoPP@@3P6A_NABVtype_info@@PAXPBX@ZA:DWORD ; CryptoPP::g_pAssignIntToInteger
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$codecvt@_WDU_Mbstatet@@@std@@2V0locale@2@A:DWORD ; std::codecvt<wchar_t,char,_Mbstatet>::id
EXTRN	?id@?$ctype@_W@std@@2V0locale@2@A:DWORD		; std::ctype<wchar_t>::id
EXTRN	?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A:BYTE ; std::wcout
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A DD 01H DUP (?) ; CSingleton<CLZO>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4V2@A
_BSS	SEGMENT
?s_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4V2@A DB 038H DUP (?) ; `CMakePackLog::GetSingleton'::`2'::s_kMakePackLog
_BSS	ENDS
;	COMDAT ?$TSS0@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4HA
_BSS	SEGMENT
?$TSS0@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4HA DD 01H DUP (?) ; `CMakePackLog::GetSingleton'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?tmpFilename@?1??FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z@4PADA
_BSS	SEGMENT
?tmpFilename@?1??FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z@4PADA DB 0105H DUP (?) ; `CEterPack::FindIndex'::`2'::tmpFilename
_BSS	ENDS
;	COMDAT ?tiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VTiger@CryptoPP@@A
_BSS	SEGMENT
?tiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VTiger@CryptoPP@@A DB 0b8H DUP (?) ; `CEterPack::__CreateFileNameKey_Panama'::`2'::tiger
_BSS	ENDS
;	COMDAT ?$TSS0@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
_BSS	SEGMENT
?$TSS0@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA DD 01H DUP (?) ; `CEterPack::__CreateFileNameKey_Panama'::`2'::$TSS0
_BSS	ENDS
;	COMDAT ?sha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VSHA1@CryptoPP@@A
_BSS	SEGMENT
?sha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VSHA1@CryptoPP@@A DB 0b0H DUP (?) ; `CEterPack::__CreateFileNameKey_Panama'::`2'::sha1
_BSS	ENDS
;	COMDAT ?$TSS1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
_BSS	SEGMENT
?$TSS1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA DD 01H DUP (?) ; `CEterPack::__CreateFileNameKey_Panama'::`2'::$TSS1
_BSS	ENDS
;	COMDAT ?ripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VRIPEMD128@CryptoPP@@A
_BSS	SEGMENT
?ripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VRIPEMD128@CryptoPP@@A DB 0b0H DUP (?) ; `CEterPack::__CreateFileNameKey_Panama'::`2'::ripemd128
_BSS	ENDS
;	COMDAT ?$TSS2@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
_BSS	SEGMENT
?$TSS2@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA DD 01H DUP (?) ; `CEterPack::__CreateFileNameKey_Panama'::`2'::$TSS2
_BSS	ENDS
;	COMDAT ?whirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VWhirlpool@CryptoPP@@A
_BSS	SEGMENT
?whirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VWhirlpool@CryptoPP@@A DB 0b8H DUP (?) ; `CEterPack::__CreateFileNameKey_Panama'::`2'::whirlpool
_BSS	ENDS
;	COMDAT ?$TSS3@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
_BSS	SEGMENT
?$TSS3@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA DD 01H DUP (?) ; `CEterPack::__CreateFileNameKey_Panama'::`2'::$TSS3
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::codecvt<wchar_t,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
_BSS	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT ??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@
rdata$r	SEGMENT
??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ DD 00H ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Complete Object Locator'
	DD	020H
	DD	00H
	DD	FLAT:??_R0?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8
	DD	FLAT:??_R3?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@
rdata$r	SEGMENT
??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ DD 00H ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8
	DD	FLAT:??_R3?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@
rdata$r	SEGMENT
??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@ DD 00H ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8
	DD	FLAT:??_R3?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@StreamTransformation@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R17?0A@EA@RandomNumberGenerator@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EN@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EJ@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EJ@AdditiveCipherAbstractPolicy@CryptoPP@@8
	DD	FLAT:??_R1CE@?0A@EJ@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CE@?0A@EJ@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
	DD	FLAT:??_R1CI@?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD 00H ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	012H
	DD	FLAT:??_R2?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@'
	DB	'V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A'
	DB	'@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractP'
	DB	'olicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetri'
	DB	'cCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@Cryp'
	DB	'toPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@'
	DB	'@$0A@@CryptoPP@@@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	011H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@StreamTransformation@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R17?0A@EA@RandomNumberGenerator@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EN@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EJ@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EJ@AdditiveCipherAbstractPolicy@CryptoPP@@8
	DD	FLAT:??_R1CE@?0A@EJ@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CE@?0A@EJ@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
	DD	FLAT:??_R1CI@?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD 00H ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	013H
	DD	FLAT:??_R2?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$Conc'
	DB	'retePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOr'
	DB	'der@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemp'
	DB	'late@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@Cr'
	DB	'yptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstr'
	DB	'actPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4By'
	DB	'teOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCiphe'
	DB	'rInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@'
	DB	'CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	012H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	013H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@StreamTransformation@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R17?0A@EA@RandomNumberGenerator@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EN@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EJ@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EJ@AdditiveCipherAbstractPolicy@CryptoPP@@8
	DD	FLAT:??_R1CE@?0A@EJ@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CE@?0A@EJ@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
	DD	FLAT:??_R1CI@?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8 DD 00H ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	014H
	DD	FLAT:??_R2?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$Pa'
	DB	'namaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@Cry'
	DB	'ptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicy'
	DB	'Holder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCiph'
	DB	'er@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@'
	DB	'@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@'
	DB	'@CryptoPP@@@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@
rdata$r	SEGMENT
??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ DD 00H ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@@8
	DD	FLAT:??_R3?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@
rdata$r	SEGMENT
??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ DD 00H ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Complete Object Locator'
	DD	020H
	DD	00H
	DD	FLAT:??_R0?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@@8
	DD	FLAT:??_R3?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@
rdata$r	SEGMENT
??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ DD 00H ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Complete Object Locator'
	DD	08H
	DD	00H
	DD	FLAT:??_R0?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@@8
	DD	FLAT:??_R3?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@
rdata$r	SEGMENT
??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@ DD 00H ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@@8
	DD	FLAT:??_R3?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1CI@?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1CI@?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (40,-1,0,77)'
	DD	00H
	DD	028H
	DD	0ffffffffH
	DD	00H
	DD	04dH
	DD	FLAT:??_R3?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1CE@?0A@EJ@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	SEGMENT
??_R1CE@?0A@EJ@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 DD FLAT:??_R0?AV?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Base Class Descriptor at (36,-1,0,73)'
	DD	00H
	DD	024H
	DD	0ffffffffH
	DD	00H
	DD	049H
	DD	FLAT:??_R3?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1CE@?0A@EJ@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1CE@?0A@EJ@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AU?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (36,-1,0,73)'
	DD	01H
	DD	024H
	DD	0ffffffffH
	DD	00H
	DD	049H
	DD	FLAT:??_R3?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1CA@?0A@EJ@AdditiveCipherAbstractPolicy@CryptoPP@@8
rdata$r	SEGMENT
??_R1CA@?0A@EJ@AdditiveCipherAbstractPolicy@CryptoPP@@8 DD FLAT:??_R0?AUAdditiveCipherAbstractPolicy@CryptoPP@@@8 ; CryptoPP::AdditiveCipherAbstractPolicy::`RTTI Base Class Descriptor at (32,-1,0,73)'
	DD	00H
	DD	020H
	DD	0ffffffffH
	DD	00H
	DD	049H
	DD	FLAT:??_R3AdditiveCipherAbstractPolicy@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1CA@?0A@EJ@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1CA@?0A@EJ@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AU?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Descriptor at (32,-1,0,73)'
	DD	01H
	DD	020H
	DD	0ffffffffH
	DD	00H
	DD	049H
	DD	FLAT:??_R3?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1CA@?0A@EN@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1CA@?0A@EN@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (32,-1,0,77)'
	DD	05H
	DD	020H
	DD	0ffffffffH
	DD	00H
	DD	04dH
	DD	FLAT:??_R3?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@@8 ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	010H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8 ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@StreamTransformation@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R17?0A@EA@RandomNumberGenerator@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EN@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EJ@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CA@?0A@EJ@AdditiveCipherAbstractPolicy@CryptoPP@@8
	DD	FLAT:??_R1CE@?0A@EJ@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1CE@?0A@EJ@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
	DD	FLAT:??_R1CI@?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8 DD 00H ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	011H
	DD	FLAT:??_R2?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$Enum'
	DB	'ToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$Add'
	DB	'itiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAb'
	DB	'stractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAddi'
	DB	'tiveCipherAbstractPolicy@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@
rdata$r	SEGMENT
??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ DD 00H ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@@8
	DD	FLAT:??_R3?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@Cr'
	DB	'yptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R17?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R17?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (8,-1,0,77)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	04dH
	DD	FLAT:??_R3?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 DD FLAT:??_R0?AV?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 DD 00H	; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::FixedKeyLength<32,0,32> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8 DD FLAT:??_R0?AV?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@@8 ; CryptoPP::FixedKeyLength<32,0,32>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AU?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AU?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoP'
	DB	'P@@$0A@@CryptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R13?0A@EA@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AU?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@AdditiveCipherAbstractPolicy@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@?$FixedKeyLength@$0CA@$0A@$0CA@@CryptoPP@@8
	DD	FLAT:??_R17?0A@EN@?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@Crypt'
	DB	'oPP@@$0A@@CryptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@ DD 00H ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@@8
	DD	FLAT:??_R3?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@_W@std@@8 DD FLAT:??_R0?AV?$ctype@_W@std@@@8 ; std::ctype<wchar_t>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R2?$ctype@_W@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@_W@std@@8 ; std::ctype<wchar_t>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@_W@std@@8
rdata$r	SEGMENT
??_R3?$ctype@_W@std@@8 DD 00H				; std::ctype<wchar_t>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@_W@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@_W@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<wchar_t> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@_W@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@_W@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@_W@std@@6B@ DD 00H				; std::ctype<wchar_t>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@_W@std@@@8
	DD	FLAT:??_R3?$ctype@_W@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$codecvt@_WDU_Mbstatet@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$codecvt@_WDU_Mbstatet@@@std@@8 DD FLAT:??_R0?AV?$codecvt@_WDU_Mbstatet@@@std@@@8 ; std::codecvt<wchar_t,char,_Mbstatet>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$codecvt@_WDU_Mbstatet@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$codecvt@_WDU_Mbstatet@@@std@@8
rdata$r	SEGMENT
??_R2?$codecvt@_WDU_Mbstatet@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$codecvt@_WDU_Mbstatet@@@std@@8 ; std::codecvt<wchar_t,char,_Mbstatet>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@codecvt_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$codecvt@_WDU_Mbstatet@@@std@@8
rdata$r	SEGMENT
??_R3?$codecvt@_WDU_Mbstatet@@@std@@8 DD 00H		; std::codecvt<wchar_t,char,_Mbstatet>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$codecvt@_WDU_Mbstatet@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$codecvt@_WDU_Mbstatet@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$codecvt@_WDU_Mbstatet@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::codecvt<wchar_t,char,_Mbstatet> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$codecvt@_WDU_Mbstatet@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$codecvt@_WDU_Mbstatet@@@std@@6B@
rdata$r	SEGMENT
??_R4?$codecvt@_WDU_Mbstatet@@@std@@6B@ DD 00H		; std::codecvt<wchar_t,char,_Mbstatet>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$codecvt@_WDU_Mbstatet@@@std@@@8
	DD	FLAT:??_R3?$codecvt@_WDU_Mbstatet@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@codecvt_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@codecvt_base@std@@8 DD FLAT:??_R0?AVcodecvt_base@std@@@8 ; std::codecvt_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2codecvt_base@std@@8
rdata$r	SEGMENT
??_R2codecvt_base@std@@8 DD FLAT:??_R1A@?0A@EA@codecvt_base@std@@8 ; std::codecvt_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3codecvt_base@std@@8
rdata$r	SEGMENT
??_R3codecvt_base@std@@8 DD 00H				; std::codecvt_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVcodecvt_base@std@@@8
data$rs	SEGMENT
??_R0?AVcodecvt_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::codecvt_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVcodecvt_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4codecvt_base@std@@6B@
rdata$r	SEGMENT
??_R4codecvt_base@std@@6B@ DD 00H			; std::codecvt_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVcodecvt_base@std@@@8
	DD	FLAT:??_R3codecvt_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AU?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AdditiveCipherAbstractPolicy@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AU?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCiphe'
	DB	'rAbstractPolicy@CryptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R2?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@'
	DB	'@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8 DD 00H ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4By'
	DB	'teOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@C'
	DB	'ryptoPP@@VWhirlpool@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8 DD 00H ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	07H
	DD	FLAT:??_R2?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl'
	DB	'@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@Cr'
	DB	'yptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2'
	DB	'@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@@8 ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	08H
	DD	FLAT:??_R2?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4'
	DB	'ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@'
	DB	'$0A@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	07H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Whirlpool@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Whirlpool@CryptoPP@@8 DD FLAT:??_R0?AVWhirlpool@CryptoPP@@@8 ; CryptoPP::Whirlpool::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Whirlpool@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Whirlpool@CryptoPP@@8
rdata$r	SEGMENT
??_R2Whirlpool@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Whirlpool@CryptoPP@@8 ; CryptoPP::Whirlpool::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3Whirlpool@CryptoPP@@8
rdata$r	SEGMENT
??_R3Whirlpool@CryptoPP@@8 DD 00H			; CryptoPP::Whirlpool::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	09H
	DD	FLAT:??_R2Whirlpool@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWhirlpool@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVWhirlpool@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::Whirlpool `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWhirlpool@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Whirlpool@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4Whirlpool@CryptoPP@@6B@ DD 00H			; CryptoPP::Whirlpool::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVWhirlpool@CryptoPP@@@8
	DD	FLAT:??_R3Whirlpool@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8 DD 00H ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4Byt'
	DB	'eOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@C'
	DB	'ryptoPP@@VRIPEMD128@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8 DD 00H ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	07H
	DD	FLAT:??_R2?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl'
	DB	'@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@Cr'
	DB	'yptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2'
	DB	'@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@@8 ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	08H
	DD	FLAT:??_R2?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4B'
	DB	'yteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@'
	DB	'$0A@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	07H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RIPEMD128@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RIPEMD128@CryptoPP@@8 DD FLAT:??_R0?AVRIPEMD128@CryptoPP@@@8 ; CryptoPP::RIPEMD128::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RIPEMD128@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2RIPEMD128@CryptoPP@@8
rdata$r	SEGMENT
??_R2RIPEMD128@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@RIPEMD128@CryptoPP@@8 ; CryptoPP::RIPEMD128::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3RIPEMD128@CryptoPP@@8
rdata$r	SEGMENT
??_R3RIPEMD128@CryptoPP@@8 DD 00H			; CryptoPP::RIPEMD128::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	09H
	DD	FLAT:??_R2RIPEMD128@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRIPEMD128@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVRIPEMD128@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::RIPEMD128 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRIPEMD128@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4RIPEMD128@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4RIPEMD128@CryptoPP@@6B@ DD 00H			; CryptoPP::RIPEMD128::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVRIPEMD128@CryptoPP@@@8
	DD	FLAT:??_R3RIPEMD128@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@'
	DB	'$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@'
	DB	'$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8 DD 00H ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4Byt'
	DB	'eOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@Cr'
	DB	'yptoPP@@VSHA1@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8 DD 00H ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	07H
	DD	FLAT:??_R2?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$I'
	DB	'teratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP'
	DB	'@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@'
	DB	'@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@@8 ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	08H
	DD	FLAT:??_R2?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4B'
	DB	'yteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@C'
	DB	'ryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	07H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SHA1@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SHA1@CryptoPP@@8 DD FLAT:??_R0?AVSHA1@CryptoPP@@@8 ; CryptoPP::SHA1::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SHA1@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2SHA1@CryptoPP@@8
rdata$r	SEGMENT
??_R2SHA1@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@SHA1@CryptoPP@@8 ; CryptoPP::SHA1::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3SHA1@CryptoPP@@8
rdata$r	SEGMENT
??_R3SHA1@CryptoPP@@8 DD 00H				; CryptoPP::SHA1::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	09H
	DD	FLAT:??_R2SHA1@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSHA1@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVSHA1@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@	; CryptoPP::SHA1 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSHA1@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4SHA1@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4SHA1@CryptoPP@@6B@ DD 00H				; CryptoPP::SHA1::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSHA1@CryptoPP@@@8
	DD	FLAT:??_R3SHA1@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@'
	DB	'@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@@8 ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8 DD 00H ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	06H
	DD	FLAT:??_R2?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4By'
	DB	'teOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@'
	DB	'CryptoPP@@VTiger@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@@8 ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8 ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8 DD 00H ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	07H
	DD	FLAT:??_R2?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$'
	DB	'IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@Crypt'
	DB	'oPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@Crypt'
	DB	'oPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@@8 ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	08H
	DD	FLAT:??_R2?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4'
	DB	'ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A'
	DB	'@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@@8 ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	07H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Tiger@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Tiger@CryptoPP@@8 DD FLAT:??_R0?AVTiger@CryptoPP@@@8 ; CryptoPP::Tiger::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Tiger@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Tiger@CryptoPP@@8
rdata$r	SEGMENT
??_R2Tiger@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Tiger@CryptoPP@@8 ; CryptoPP::Tiger::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3Tiger@CryptoPP@@8
rdata$r	SEGMENT
??_R3Tiger@CryptoPP@@8 DD 00H				; CryptoPP::Tiger::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	09H
	DD	FLAT:??_R2Tiger@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTiger@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVTiger@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@	; CryptoPP::Tiger `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTiger@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Tiger@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4Tiger@CryptoPP@@6B@ DD 00H				; CryptoPP::Tiger::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVTiger@CryptoPP@@@8
	DD	FLAT:??_R3Tiger@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHashBase@IVHashTransformation@CryptoPP@@@C'
	DB	'ryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@'
	DB	'CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R17?0A@EC@Clonable@CryptoPP@@8
rdata$r	SEGMENT
??_R17?0A@EC@Clonable@CryptoPP@@8 DD FLAT:??_R0?AVClonable@CryptoPP@@@8 ; CryptoPP::Clonable::`RTTI Base Class Descriptor at (8,-1,0,66)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EC@Algorithm@CryptoPP@@8
rdata$r	SEGMENT
??_R17?0A@EC@Algorithm@CryptoPP@@8 DD FLAT:??_R0?AVAlgorithm@CryptoPP@@@8 ; CryptoPP::Algorithm::`RTTI Base Class Descriptor at (8,-1,0,66)'
	DD	01H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3Algorithm@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@RandomNumberGenerator@CryptoPP@@8
rdata$r	SEGMENT
??_R17?0A@EA@RandomNumberGenerator@CryptoPP@@8 DD FLAT:??_R0?AVRandomNumberGenerator@CryptoPP@@@8 ; CryptoPP::RandomNumberGenerator::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	02H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RandomNumberGenerator@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EC@Clonable@CryptoPP@@8
rdata$r	SEGMENT
??_R13?0A@EC@Clonable@CryptoPP@@8 DD FLAT:??_R0?AVClonable@CryptoPP@@@8 ; CryptoPP::Clonable::`RTTI Base Class Descriptor at (4,-1,0,66)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EC@Algorithm@CryptoPP@@8
rdata$r	SEGMENT
??_R13?0A@EC@Algorithm@CryptoPP@@8 DD FLAT:??_R0?AVAlgorithm@CryptoPP@@@8 ; CryptoPP::Algorithm::`RTTI Base Class Descriptor at (4,-1,0,66)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	042H
	DD	FLAT:??_R3Algorithm@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@StreamTransformation@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R13?0A@EC@Clonable@CryptoPP@@8
	DD	FLAT:??_R17?0A@EA@RandomNumberGenerator@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Algorithm@CryptoPP@@8
	DD	FLAT:??_R17?0A@EC@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::`RTTI Class Hierarchy Descriptor'
	DD	05H
	DD	0aH
	DD	FLAT:??_R2?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAd'
	DB	'ditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@Cryp'
	DB	'toPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8 DD FLAT:??_R0?AV?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@8 ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8 ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@StreamTransformation@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8 DD 00H ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy'
	DB	'@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@AdditiveCipherAbstractPolicy@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AdditiveCipherAbstractPolicy@CryptoPP@@8 DD FLAT:??_R0?AUAdditiveCipherAbstractPolicy@CryptoPP@@@8 ; CryptoPP::AdditiveCipherAbstractPolicy::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AdditiveCipherAbstractPolicy@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2AdditiveCipherAbstractPolicy@CryptoPP@@8
rdata$r	SEGMENT
??_R2AdditiveCipherAbstractPolicy@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@AdditiveCipherAbstractPolicy@CryptoPP@@8 ; CryptoPP::AdditiveCipherAbstractPolicy::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3AdditiveCipherAbstractPolicy@CryptoPP@@8
rdata$r	SEGMENT
??_R3AdditiveCipherAbstractPolicy@CryptoPP@@8 DD 00H	; CryptoPP::AdditiveCipherAbstractPolicy::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AdditiveCipherAbstractPolicy@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUAdditiveCipherAbstractPolicy@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AUAdditiveCipherAbstractPolicy@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AdditiveCipherAbstractPolicy `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUAdditiveCipherAbstractPolicy@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BWaitable@1@@
rdata$r	SEGMENT
??_R4?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BWaitable@1@@ DD 00H ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AV?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@@8
	DD	FLAT:??_R3?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BAlgorithm@1@@
rdata$r	SEGMENT
??_R4?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BAlgorithm@1@@ DD 00H ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@@8
	DD	FLAT:??_R3?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4StringSource@CryptoPP@@6BWaitable@1@@
rdata$r	SEGMENT
??_R4StringSource@CryptoPP@@6BWaitable@1@@ DD 00H	; CryptoPP::StringSource::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVStringSource@CryptoPP@@@8
	DD	FLAT:??_R3StringSource@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8 ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Source@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Filter@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
	DD	FLAT:??_R1M@?0A@EA@NotCopyable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	09H
	DD	FLAT:??_R2?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::SourceTemplate<CryptoPP::StringStore> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@StringSource@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StringSource@CryptoPP@@8 DD FLAT:??_R0?AVStringSource@CryptoPP@@@8 ; CryptoPP::StringSource::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3StringSource@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2StringSource@CryptoPP@@8
rdata$r	SEGMENT
??_R2StringSource@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@StringSource@CryptoPP@@8 ; CryptoPP::StringSource::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Source@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Filter@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
	DD	FLAT:??_R1M@?0A@EA@NotCopyable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3StringSource@CryptoPP@@8
rdata$r	SEGMENT
??_R3StringSource@CryptoPP@@8 DD 00H			; CryptoPP::StringSource::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	0aH
	DD	FLAT:??_R2StringSource@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVStringSource@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVStringSource@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::StringSource `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVStringSource@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4StringSource@CryptoPP@@6BAlgorithm@1@@
rdata$r	SEGMENT
??_R4StringSource@CryptoPP@@6BAlgorithm@1@@ DD 00H	; CryptoPP::StringSource::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVStringSource@CryptoPP@@@8
	DD	FLAT:??_R3StringSource@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@NotImplemented@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Exception@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@ DD 00H ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8
	DD	FLAT:??_R3InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Filter@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
	DD	FLAT:??_R1M@?0A@EA@NotCopyable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::InputRejecting<CryptoPP::Filter>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	07H
	DD	FLAT:??_R2?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::InputRejecting<CryptoPP::Filter> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::InputRejecting<CryptoPP::Filter>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Source@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Source@CryptoPP@@8 DD FLAT:??_R0?AVSource@CryptoPP@@@8 ; CryptoPP::Source::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	07H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Source@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Source@CryptoPP@@8
rdata$r	SEGMENT
??_R2Source@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Source@CryptoPP@@8 ; CryptoPP::Source::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Filter@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
	DD	FLAT:??_R1M@?0A@EA@NotCopyable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3Source@CryptoPP@@8
rdata$r	SEGMENT
??_R3Source@CryptoPP@@8 DD 00H				; CryptoPP::Source::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	08H
	DD	FLAT:??_R2Source@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSource@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVSource@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@	; CryptoPP::Source `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSource@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4StringStore@CryptoPP@@6BWaitable@1@@
rdata$r	SEGMENT
??_R4StringStore@CryptoPP@@6BWaitable@1@@ DD 00H	; CryptoPP::StringStore::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVStringStore@CryptoPP@@@8
	DD	FLAT:??_R3StringStore@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@StringStore@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StringStore@CryptoPP@@8 DD FLAT:??_R0?AVStringStore@CryptoPP@@@8 ; CryptoPP::StringStore::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	07H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3StringStore@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2StringStore@CryptoPP@@8
rdata$r	SEGMENT
??_R2StringStore@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@StringStore@CryptoPP@@8 ; CryptoPP::StringStore::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Store@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3StringStore@CryptoPP@@8
rdata$r	SEGMENT
??_R3StringStore@CryptoPP@@8 DD 00H			; CryptoPP::StringStore::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	08H
	DD	FLAT:??_R2StringStore@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVStringStore@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVStringStore@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::StringStore `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVStringStore@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4StringStore@CryptoPP@@6BAlgorithm@1@@
rdata$r	SEGMENT
??_R4StringStore@CryptoPP@@6BAlgorithm@1@@ DD 00H	; CryptoPP::StringStore::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVStringStore@CryptoPP@@@8
	DD	FLAT:??_R3StringStore@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4ArraySink@CryptoPP@@6BWaitable@1@@
rdata$r	SEGMENT
??_R4ArraySink@CryptoPP@@6BWaitable@1@@ DD 00H		; CryptoPP::ArraySink::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVArraySink@CryptoPP@@@8
	DD	FLAT:??_R3ArraySink@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ArraySink@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ArraySink@CryptoPP@@8 DD FLAT:??_R0?AVArraySink@CryptoPP@@@8 ; CryptoPP::ArraySink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ArraySink@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2ArraySink@CryptoPP@@8
rdata$r	SEGMENT
??_R2ArraySink@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@ArraySink@CryptoPP@@8 ; CryptoPP::ArraySink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Sink@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3ArraySink@CryptoPP@@8
rdata$r	SEGMENT
??_R3ArraySink@CryptoPP@@8 DD 00H			; CryptoPP::ArraySink::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	07H
	DD	FLAT:??_R2ArraySink@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVArraySink@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVArraySink@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::ArraySink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVArraySink@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ArraySink@CryptoPP@@6BAlgorithm@1@@
rdata$r	SEGMENT
??_R4ArraySink@CryptoPP@@6BAlgorithm@1@@ DD 00H		; CryptoPP::ArraySink::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVArraySink@CryptoPP@@@8
	DD	FLAT:??_R3ArraySink@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@
rdata$r	SEGMENT
??_R4?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@ DD 00H ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AV?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@@8
	DD	FLAT:??_R3?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8 DD FLAT:??_R0?AV?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@@8 ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8 ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Sink@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8 DD 00H ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	07H
	DD	FLAT:??_R2?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$StringSinkTemplate@V?$basic_string@DU?$char_traits'
	DB	'@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@
rdata$r	SEGMENT
??_R4?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@ DD 00H ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@@8
	DD	FLAT:??_R3?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@NotCopyable@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@NotCopyable@CryptoPP@@8 DD FLAT:??_R0?AVNotCopyable@CryptoPP@@@8 ; CryptoPP::NotCopyable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3NotCopyable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2NotCopyable@CryptoPP@@8
rdata$r	SEGMENT
??_R2NotCopyable@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@NotCopyable@CryptoPP@@8 ; CryptoPP::NotCopyable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3NotCopyable@CryptoPP@@8
rdata$r	SEGMENT
??_R3NotCopyable@CryptoPP@@8 DD 00H			; CryptoPP::NotCopyable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2NotCopyable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVNotCopyable@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVNotCopyable@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::NotCopyable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVNotCopyable@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1M@?0A@EA@NotCopyable@CryptoPP@@8
rdata$r	SEGMENT
??_R1M@?0A@EA@NotCopyable@CryptoPP@@8 DD FLAT:??_R0?AVNotCopyable@CryptoPP@@@8 ; CryptoPP::NotCopyable::`RTTI Base Class Descriptor at (12,-1,0,64)'
	DD	00H
	DD	0cH
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3NotCopyable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Filter@CryptoPP@@8
rdata$r	SEGMENT
??_R2Filter@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Filter@CryptoPP@@8 ; CryptoPP::Filter::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
	DD	FLAT:??_R1M@?0A@EA@NotCopyable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3Filter@CryptoPP@@8
rdata$r	SEGMENT
??_R3Filter@CryptoPP@@8 DD 00H				; CryptoPP::Filter::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2Filter@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVFilter@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVFilter@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@	; CryptoPP::Filter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVFilter@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Filter@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Filter@CryptoPP@@8 DD FLAT:??_R0?AVFilter@CryptoPP@@@8 ; CryptoPP::Filter::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Filter@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@AlgorithmParametersBase@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AlgorithmParametersTemplate@VConstByteArrayParamet'
	DB	'er@CryptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@ DD 00H ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@@8
	DD	FLAT:??_R3?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8 DD FLAT:??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8 ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8
rdata$r	SEGMENT
??_R2ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8 ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8
rdata$r	SEGMENT
??_R3ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8 DD 00H ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@ DD 00H ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8
	DD	FLAT:??_R3ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@AlgorithmParametersBase@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@AlgorithmParametersBase@CryptoPP@@8 DD FLAT:??_R0?AVAlgorithmParametersBase@CryptoPP@@@8 ; CryptoPP::AlgorithmParametersBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3AlgorithmParametersBase@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2AlgorithmParametersBase@CryptoPP@@8
rdata$r	SEGMENT
??_R2AlgorithmParametersBase@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@AlgorithmParametersBase@CryptoPP@@8 ; CryptoPP::AlgorithmParametersBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3AlgorithmParametersBase@CryptoPP@@8
rdata$r	SEGMENT
??_R3AlgorithmParametersBase@CryptoPP@@8 DD 00H		; CryptoPP::AlgorithmParametersBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2AlgorithmParametersBase@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAlgorithmParametersBase@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVAlgorithmParametersBase@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AlgorithmParametersBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAlgorithmParametersBase@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R4AlgorithmParametersBase@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4AlgorithmParametersBase@CryptoPP@@6B@ DD 00H	; CryptoPP::AlgorithmParametersBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVAlgorithmParametersBase@CryptoPP@@@8
	DD	FLAT:??_R3AlgorithmParametersBase@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$Bufferless@VSink@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::Bufferless<CryptoPP::Sink>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8 ; CryptoPP::Bufferless<CryptoPP::Sink>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Sink@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8 DD 00H	; CryptoPP::Bufferless<CryptoPP::Sink>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2?$Bufferless@VSink@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$Bufferless@VSink@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$Bufferless@VSink@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::Bufferless<CryptoPP::Sink> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$Bufferless@VSink@CryptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Sink@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Sink@CryptoPP@@8 DD FLAT:??_R0?AVSink@CryptoPP@@@8 ; CryptoPP::Sink::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Sink@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Sink@CryptoPP@@8
rdata$r	SEGMENT
??_R2Sink@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Sink@CryptoPP@@8 ; CryptoPP::Sink::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3Sink@CryptoPP@@8
rdata$r	SEGMENT
??_R3Sink@CryptoPP@@8 DD 00H				; CryptoPP::Sink::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2Sink@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSink@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVSink@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@	; CryptoPP::Sink `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSink@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@NotImplemented@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Exception@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@ DD 00H ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8
	DD	FLAT:??_R3InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$InputRejecting@VBufferedTransformation@CryptoPP@@@'
	DB	'CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R2?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8 ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R3?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8 DD 00H ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	06H
	DD	FLAT:??_R2?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AV?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$AutoSignaling@V?$InputRejecting@VBufferedTransform'
	DB	'ation@CryptoPP@@@CryptoPP@@@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8 DD FLAT:??_R0?AV?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@@8 ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	05H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Store@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Store@CryptoPP@@8 DD FLAT:??_R0?AVStore@CryptoPP@@@8 ; CryptoPP::Store::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	06H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Store@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Store@CryptoPP@@8
rdata$r	SEGMENT
??_R2Store@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Store@CryptoPP@@8 ; CryptoPP::Store::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3Store@CryptoPP@@8
rdata$r	SEGMENT
??_R3Store@CryptoPP@@8 DD 00H				; CryptoPP::Store::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	07H
	DD	FLAT:??_R2Store@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVStore@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVStore@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@	; CryptoPP::Store `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVStore@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@Clonable@CryptoPP@@8
rdata$r	SEGMENT
??_R13?0A@EA@Clonable@CryptoPP@@8 DD FLAT:??_R0?AVClonable@CryptoPP@@@8 ; CryptoPP::Clonable::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@Algorithm@CryptoPP@@8
rdata$r	SEGMENT
??_R13?0A@EA@Algorithm@CryptoPP@@8 DD FLAT:??_R0?AVAlgorithm@CryptoPP@@@8 ; CryptoPP::Algorithm::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	01H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Algorithm@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R13?0A@EA@StreamTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R13?0A@EA@StreamTransformation@CryptoPP@@8 DD FLAT:??_R0?AVStreamTransformation@CryptoPP@@@8 ; CryptoPP::StreamTransformation::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	02H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3StreamTransformation@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8 DD FLAT:??_R0?AVSymmetricCipher@CryptoPP@@@8 ; CryptoPP::SymmetricCipher::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SymmetricCipher@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2SymmetricCipher@CryptoPP@@8
rdata$r	SEGMENT
??_R2SymmetricCipher@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@SymmetricCipher@CryptoPP@@8 ; CryptoPP::SymmetricCipher::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@StreamTransformation@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3SymmetricCipher@CryptoPP@@8
rdata$r	SEGMENT
??_R3SymmetricCipher@CryptoPP@@8 DD 00H			; CryptoPP::SymmetricCipher::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2SymmetricCipher@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSymmetricCipher@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVSymmetricCipher@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::SymmetricCipher `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSymmetricCipher@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@HashTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@HashTransformation@CryptoPP@@8 DD FLAT:??_R0?AVHashTransformation@CryptoPP@@@8 ; CryptoPP::HashTransformation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3HashTransformation@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2HashTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R2HashTransformation@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@HashTransformation@CryptoPP@@8 ; CryptoPP::HashTransformation::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3HashTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R3HashTransformation@CryptoPP@@8 DD 00H		; CryptoPP::HashTransformation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2HashTransformation@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVHashTransformation@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVHashTransformation@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::HashTransformation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVHashTransformation@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@StreamTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@StreamTransformation@CryptoPP@@8 DD FLAT:??_R0?AVStreamTransformation@CryptoPP@@@8 ; CryptoPP::StreamTransformation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3StreamTransformation@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2StreamTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R2StreamTransformation@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@StreamTransformation@CryptoPP@@8 ; CryptoPP::StreamTransformation::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3StreamTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R3StreamTransformation@CryptoPP@@8 DD 00H		; CryptoPP::StreamTransformation::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2StreamTransformation@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVStreamTransformation@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVStreamTransformation@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::StreamTransformation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVStreamTransformation@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8 DD FLAT:??_R0?AVSimpleKeyingInterface@CryptoPP@@@8 ; CryptoPP::SimpleKeyingInterface::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SimpleKeyingInterface@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2SimpleKeyingInterface@CryptoPP@@8
rdata$r	SEGMENT
??_R2SimpleKeyingInterface@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@SimpleKeyingInterface@CryptoPP@@8 ; CryptoPP::SimpleKeyingInterface::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SimpleKeyingInterface@CryptoPP@@8
rdata$r	SEGMENT
??_R3SimpleKeyingInterface@CryptoPP@@8 DD 00H		; CryptoPP::SimpleKeyingInterface::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SimpleKeyingInterface@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSimpleKeyingInterface@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVSimpleKeyingInterface@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::SimpleKeyingInterface `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSimpleKeyingInterface@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@ValueTypeMismatch@NameValuePairs@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ValueTypeMismatch@NameValuePairs@CryptoPP@@8 DD FLAT:??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8 ; CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ValueTypeMismatch@NameValuePairs@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2ValueTypeMismatch@NameValuePairs@CryptoPP@@8
rdata$r	SEGMENT
??_R2ValueTypeMismatch@NameValuePairs@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@ValueTypeMismatch@NameValuePairs@CryptoPP@@8 ; CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@InvalidArgument@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Exception@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ValueTypeMismatch@NameValuePairs@CryptoPP@@8
rdata$r	SEGMENT
??_R3ValueTypeMismatch@NameValuePairs@CryptoPP@@8 DD 00H ; CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2ValueTypeMismatch@NameValuePairs@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@ DD 00H ; CryptoPP::NameValuePairs::ValueTypeMismatch::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8
	DD	FLAT:??_R3ValueTypeMismatch@NameValuePairs@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@NotImplemented@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@NotImplemented@CryptoPP@@8 DD FLAT:??_R0?AVNotImplemented@CryptoPP@@@8 ; CryptoPP::NotImplemented::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3NotImplemented@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2NotImplemented@CryptoPP@@8
rdata$r	SEGMENT
??_R2NotImplemented@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@NotImplemented@CryptoPP@@8 ; CryptoPP::NotImplemented::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3NotImplemented@CryptoPP@@8
rdata$r	SEGMENT
??_R3NotImplemented@CryptoPP@@8 DD 00H			; CryptoPP::NotImplemented::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2NotImplemented@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4NotImplemented@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4NotImplemented@CryptoPP@@6B@ DD 00H		; CryptoPP::NotImplemented::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVNotImplemented@CryptoPP@@@8
	DD	FLAT:??_R3NotImplemented@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@InvalidArgument@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@InvalidArgument@CryptoPP@@8 DD FLAT:??_R0?AVInvalidArgument@CryptoPP@@@8 ; CryptoPP::InvalidArgument::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3InvalidArgument@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2InvalidArgument@CryptoPP@@8
rdata$r	SEGMENT
??_R2InvalidArgument@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@InvalidArgument@CryptoPP@@8 ; CryptoPP::InvalidArgument::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Exception@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3InvalidArgument@CryptoPP@@8
rdata$r	SEGMENT
??_R3InvalidArgument@CryptoPP@@8 DD 00H			; CryptoPP::InvalidArgument::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2InvalidArgument@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4InvalidArgument@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4InvalidArgument@CryptoPP@@6B@ DD 00H		; CryptoPP::InvalidArgument::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVInvalidArgument@CryptoPP@@@8
	DD	FLAT:??_R3InvalidArgument@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Exception@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Exception@CryptoPP@@8 DD FLAT:??_R0?AVException@CryptoPP@@@8 ; CryptoPP::Exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Exception@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Exception@CryptoPP@@8
rdata$r	SEGMENT
??_R2Exception@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Exception@CryptoPP@@8 ; CryptoPP::Exception::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3Exception@CryptoPP@@8
rdata$r	SEGMENT
??_R3Exception@CryptoPP@@8 DD 00H			; CryptoPP::Exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Exception@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R4Exception@CryptoPP@@6B@
rdata$r	SEGMENT
??_R4Exception@CryptoPP@@6B@ DD 00H			; CryptoPP::Exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVException@CryptoPP@@@8
	DD	FLAT:??_R3Exception@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Waitable@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Waitable@CryptoPP@@8 DD FLAT:??_R0?AVWaitable@CryptoPP@@@8 ; CryptoPP::Waitable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Waitable@CryptoPP@@8
rdata$r	SEGMENT
??_R2Waitable@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Waitable@CryptoPP@@8 ; CryptoPP::Waitable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Waitable@CryptoPP@@8
rdata$r	SEGMENT
??_R3Waitable@CryptoPP@@8 DD 00H			; CryptoPP::Waitable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVWaitable@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVWaitable@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::Waitable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVWaitable@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	SEGMENT
??_R13?0A@EA@Waitable@CryptoPP@@8 DD FLAT:??_R0?AVWaitable@CryptoPP@@@8 ; CryptoPP::Waitable::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8 DD FLAT:??_R0?AVBufferedTransformation@CryptoPP@@@8 ; CryptoPP::BufferedTransformation::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3BufferedTransformation@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2BufferedTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R2BufferedTransformation@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@BufferedTransformation@CryptoPP@@8 ; CryptoPP::BufferedTransformation::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
	DD	FLAT:??_R13?0A@EA@Waitable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3BufferedTransformation@CryptoPP@@8
rdata$r	SEGMENT
??_R3BufferedTransformation@CryptoPP@@8 DD 00H		; CryptoPP::BufferedTransformation::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2BufferedTransformation@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVBufferedTransformation@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVBufferedTransformation@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::BufferedTransformation `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBufferedTransformation@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R2Clonable@CryptoPP@@8
rdata$r	SEGMENT
??_R2Clonable@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8 ; CryptoPP::Clonable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Clonable@CryptoPP@@8
rdata$r	SEGMENT
??_R3Clonable@CryptoPP@@8 DD 00H			; CryptoPP::Clonable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVClonable@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVClonable@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::Clonable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVClonable@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Clonable@CryptoPP@@8 DD FLAT:??_R0?AVClonable@CryptoPP@@@8 ; CryptoPP::Clonable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2Algorithm@CryptoPP@@8
rdata$r	SEGMENT
??_R2Algorithm@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8 ; CryptoPP::Algorithm::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3Algorithm@CryptoPP@@8
rdata$r	SEGMENT
??_R3Algorithm@CryptoPP@@8 DD 00H			; CryptoPP::Algorithm::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2Algorithm@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVAlgorithm@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVAlgorithm@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::Algorithm `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVAlgorithm@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Algorithm@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Algorithm@CryptoPP@@8 DD FLAT:??_R0?AVAlgorithm@CryptoPP@@@8 ; CryptoPP::Algorithm::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Algorithm@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@RandomNumberGenerator@CryptoPP@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@RandomNumberGenerator@CryptoPP@@8 DD FLAT:??_R0?AVRandomNumberGenerator@CryptoPP@@@8 ; CryptoPP::RandomNumberGenerator::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3RandomNumberGenerator@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R2RandomNumberGenerator@CryptoPP@@8
rdata$r	SEGMENT
??_R2RandomNumberGenerator@CryptoPP@@8 DD FLAT:??_R1A@?0A@EA@RandomNumberGenerator@CryptoPP@@8 ; CryptoPP::RandomNumberGenerator::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Algorithm@CryptoPP@@8
	DD	FLAT:??_R1A@?0A@EA@Clonable@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R3RandomNumberGenerator@CryptoPP@@8
rdata$r	SEGMENT
??_R3RandomNumberGenerator@CryptoPP@@8 DD 00H		; CryptoPP::RandomNumberGenerator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2RandomNumberGenerator@CryptoPP@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVRandomNumberGenerator@CryptoPP@@@8
data$rs	SEGMENT
??_R0?AVRandomNumberGenerator@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::RandomNumberGenerator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVRandomNumberGenerator@CryptoPP@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CEterPack@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CEterPack@@8 DD FLAT:??_R0?AVCEterPack@@@8 ; CEterPack::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CEterPack@@8
rdata$r	ENDS
;	COMDAT ??_R2CEterPack@@8
rdata$r	SEGMENT
??_R2CEterPack@@8 DD FLAT:??_R1A@?0A@EA@CEterPack@@8	; CEterPack::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CEterPack@@8
rdata$r	SEGMENT
??_R3CEterPack@@8 DD 00H				; CEterPack::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CEterPack@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCEterPack@@@8
data$rs	SEGMENT
??_R0?AVCEterPack@@@8 DD FLAT:??_7type_info@@6B@	; CEterPack `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCEterPack@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CEterPack@@6B@
rdata$r	SEGMENT
??_R4CEterPack@@6B@ DD 00H				; CEterPack::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCEterPack@@@8
	DD	FLAT:??_R3CEterPack@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category2@std@@8 DD FLAT:??_R0?AV_Iostream_error_category2@std@@@8 ; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category2@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category2@std@@8 ; std::_Iostream_error_category2::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category2@std@@8 DD 00H		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category2@std@@@8
data$rs	SEGMENT
??_R0?AV_Iostream_error_category2@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category2@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Iostream_error_category2@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category2@std@@6B@ DD 00H		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category2@std@@@8
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	070H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	018H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_istream@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_istream@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8 DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ DD 00H ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_ios@_WU?$char_traits@_W@std@@@std@@@8
	DD	FLAT:??_R3?$basic_ios@_WU?$char_traits@_W@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$rs	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ios_base@std@@6B@
rdata$r	SEGMENT
??_R4ios_base@std@@6B@ DD 00H				; std::ios_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVios_base@std@@@8
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> > * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D'
	DB	'@2@@std@@', 00H
data$r	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A DD FLAT:??_7_Iostream_error_category2@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
	DD	05H
_DATA	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@LFCPKOMM@AllocatorBase?3?5requested?5size?5w@
CONST	SEGMENT
??_C@_0DL@LFCPKOMM@AllocatorBase?3?5requested?5size?5w@ DB 'AllocatorBase'
	DB	': requested size would cause integer overflow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LADHILIA@Panama?9LE@
CONST	SEGMENT
??_C@_09LADHILIA@Panama?9LE@ DB 'Panama-LE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LKKJKGIK@Panama?9BE@
CONST	SEGMENT
??_C@_09LKKJKGIK@Panama?9BE@ DB 'Panama-BE', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JMMKBAHA@BufferedTransformation?3?5this?5ob@
CONST	SEGMENT
??_C@_0DI@JMMKBAHA@BufferedTransformation?3?5this?5ob@ DB 'BufferedTransf'
	DB	'ormation: this object doesn''t allow input', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z40
xdata$x	SEGMENT
__CT??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z40 DD 00H
	DD	FLAT:??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8
data$r	SEGMENT
??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUInputRejected@?$InputRejecting@VBufferedTransformati'
	DB	'on@CryptoPP@@@CryptoPP@@', 00H
data$r	ENDS
;	COMDAT __CTA4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
xdata$x	SEGMENT
__CTA4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@ DD 04H
	DD	FLAT:__CT??_R0?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@8??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z40
	DD	FLAT:__CT??_R0?AVNotImplemented@CryptoPP@@@8??0NotImplemented@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
xdata$x	SEGMENT
__TI4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@ DD 00H
	DD	FLAT:??1InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
xdata$x	ENDS
;	COMDAT ??_7InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@
CONST	SEGMENT
??_7InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@ DD FLAT:??_R4InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`vftable'
	DD	FLAT:??_EInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?what@Exception@CryptoPP@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R0?AVConstByteArrayParameter@CryptoPP@@@8
data$r	SEGMENT
??_R0?AVConstByteArrayParameter@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::ConstByteArrayParameter `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVConstByteArrayParameter@CryptoPP@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0CO@DDPAKADP@StringSink?3?5OutputStringPointer@
CONST	SEGMENT
??_C@_0CO@DDPAKADP@StringSink?3?5OutputStringPointer@ DB 'StringSink: Out'
	DB	'putStringPointer not specified', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NDOICOBI@OutputStringPointer@
CONST	SEGMENT
??_C@_0BE@NDOICOBI@OutputStringPointer@ DB 'OutputStringPointer', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z40
xdata$x	SEGMENT
__CT??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z40 DD 00H
	DD	FLAT:??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8
data$r	SEGMENT
??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@Cr'
	DB	'yptoPP@@', 00H
data$r	ENDS
;	COMDAT __CTA4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
xdata$x	SEGMENT
__CTA4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@ DD 04H
	DD	FLAT:__CT??_R0?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@@8??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z40
	DD	FLAT:__CT??_R0?AVNotImplemented@CryptoPP@@@8??0NotImplemented@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
xdata$x	SEGMENT
__TI4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@ DD 00H
	DD	FLAT:??1InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
xdata$x	ENDS
;	COMDAT ??_7InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@
CONST	SEGMENT
??_7InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@ DD FLAT:??_R4InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`vftable'
	DD	FLAT:??_EInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?what@Exception@CryptoPP@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0CA@GEOIKNCG@NAME_COLLISION?3?5OLD?3?5?$CFs?5NEW?3?5?$CFs@
CONST	SEGMENT
??_C@_0CA@GEOIKNCG@NAME_COLLISION?3?5OLD?3?5?$CFs?5NEW?3?5?$CFs@ DB 'NAME'
	DB	'_COLLISION: OLD: %s NEW: %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@
CONST	SEGMENT
??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ DD FLAT:??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vftable'
	DD	FLAT:??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@WCA@AEPAXI@Z
	DD	FLAT:?GetAlignment@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBEIXZ
	DD	FLAT:?GetBytesPerIteration@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?GetOptimalBlockSize@AdditiveCipherAbstractPolicy@CryptoPP@@UBEIXZ
	DD	FLAT:?GetIterationsToBuffer@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?WriteKeystream@AdditiveCipherAbstractPolicy@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?CanOperateKeystream@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBE_NXZ
	DD	FLAT:?OperateKeystream@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXW4KeystreamOperation@2@PAEPBEI@Z
	DD	FLAT:?CipherSetKey@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXABVNameValuePairs@2@PBEI@Z
	DD	FLAT:?CipherResynchronize@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXPAEPBEI@Z
	DD	FLAT:?CipherIsRandomAccess@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBE_NXZ
	DD	FLAT:?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z
CONST	ENDS
;	COMDAT ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@
CONST	SEGMENT
??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ DD FLAT:??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vftable'
	DD	FLAT:??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W7AEPAXI@Z
	DD	FLAT:?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BEPAVClonable@2@XZ
	DD	FLAT:?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z
	DD	FLAT:?CanIncorporateEntropy@RandomNumberGenerator@CryptoPP@@UBE_NXZ
	DD	FLAT:?GenerateByte@RandomNumberGenerator@CryptoPP@@UAEEXZ
	DD	FLAT:?GenerateBit@RandomNumberGenerator@CryptoPP@@UAEIXZ
	DD	FLAT:?GenerateWord32@RandomNumberGenerator@CryptoPP@@UAEIII@Z
	DD	FLAT:?GenerateBlock@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?DiscardBytes@RandomNumberGenerator@CryptoPP@@UAEXI@Z
	DD	FLAT:?GenerateIntoBufferedTransformation@RandomNumberGenerator@CryptoPP@@UAEXAAVBufferedTransformation@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
CONST	ENDS
;	COMDAT ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@
CONST	SEGMENT
??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@ DD FLAT:??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vftable'
	DD	FLAT:??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3AEPAXI@Z
	DD	FLAT:?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	FLAT:?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?MandatoryBlockSize@StreamTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalBlockSize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?GetOptimalBlockSizeUsed@StreamTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalDataAlignment@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?ProcessData@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPAEPBEI@Z
	DD	FLAT:?ProcessLastBlock@StreamTransformation@CryptoPP@@UAEXPAEPBEI@Z
	DD	FLAT:?MinLastBlockSize@StreamTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?IsRandomAccess@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
	DD	FLAT:?Seek@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEX_K@Z
	DD	FLAT:?IsSelfInverting@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
	DD	FLAT:?IsForwardTransformation@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
CONST	ENDS
;	COMDAT ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@
CONST	SEGMENT
??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ DD FLAT:??_R4?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vftable'
	DD	FLAT:??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?MinKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ
	DD	FLAT:?MaxKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ
	DD	FLAT:?DefaultKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ
	DD	FLAT:?GetValidKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEII@Z
	DD	FLAT:?IsValidKeyLength@SimpleKeyingInterface@CryptoPP@@UBE_NI@Z
	DD	FLAT:?SetKey@SimpleKeyingInterface@CryptoPP@@UAEXPBEIABVNameValuePairs@2@@Z
	DD	FLAT:?IVRequirement@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AW4IV_Requirement@SimpleKeyingInterface@2@XZ
	DD	FLAT:?IVSize@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ
	DD	FLAT:?MinIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ
	DD	FLAT:?MaxIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ
	DD	FLAT:?Resynchronize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPBEH@Z
	DD	FLAT:?GetNextIV@SimpleKeyingInterface@CryptoPP@@UAEXAAVRandomNumberGenerator@2@PAE@Z
	DD	FLAT:?GetAlgorithm@SymmetricCipher@CryptoPP@@MBEABVAlgorithm@2@XZ
	DD	FLAT:?UncheckedSetKey@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@MAEXPBEIABVNameValuePairs@2@@Z
	DD	FLAT:?GetPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MBEABUAdditiveCipherAbstractPolicy@2@XZ
	DD	FLAT:?AccessPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MAEAAUAdditiveCipherAbstractPolicy@2@XZ
CONST	ENDS
;	COMDAT ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@
CONST	SEGMENT
??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ DD FLAT:??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vftable'
	DD	FLAT:??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@WCA@AEPAXI@Z
	DD	FLAT:?GetAlignment@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBEIXZ
	DD	FLAT:?GetBytesPerIteration@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?GetOptimalBlockSize@AdditiveCipherAbstractPolicy@CryptoPP@@UBEIXZ
	DD	FLAT:?GetIterationsToBuffer@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?WriteKeystream@AdditiveCipherAbstractPolicy@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?CanOperateKeystream@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBE_NXZ
	DD	FLAT:?OperateKeystream@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXW4KeystreamOperation@2@PAEPBEI@Z
	DD	FLAT:?CipherSetKey@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXABVNameValuePairs@2@PBEI@Z
	DD	FLAT:?CipherResynchronize@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXPAEPBEI@Z
	DD	FLAT:?CipherIsRandomAccess@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBE_NXZ
	DD	FLAT:?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z
CONST	ENDS
;	COMDAT ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@
CONST	SEGMENT
??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ DD FLAT:??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vftable'
	DD	FLAT:??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W7AEPAXI@Z
	DD	FLAT:?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
	DD	FLAT:?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z
	DD	FLAT:?CanIncorporateEntropy@RandomNumberGenerator@CryptoPP@@UBE_NXZ
	DD	FLAT:?GenerateByte@RandomNumberGenerator@CryptoPP@@UAEEXZ
	DD	FLAT:?GenerateBit@RandomNumberGenerator@CryptoPP@@UAEIXZ
	DD	FLAT:?GenerateWord32@RandomNumberGenerator@CryptoPP@@UAEIII@Z
	DD	FLAT:?GenerateBlock@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?DiscardBytes@RandomNumberGenerator@CryptoPP@@UAEXI@Z
	DD	FLAT:?GenerateIntoBufferedTransformation@RandomNumberGenerator@CryptoPP@@UAEXAAVBufferedTransformation@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
CONST	ENDS
;	COMDAT ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@
CONST	SEGMENT
??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@ DD FLAT:??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vftable'
	DD	FLAT:??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W3AEPAXI@Z
	DD	FLAT:?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
	DD	FLAT:?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?MandatoryBlockSize@StreamTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalBlockSize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?GetOptimalBlockSizeUsed@StreamTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalDataAlignment@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?ProcessData@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPAEPBEI@Z
	DD	FLAT:?ProcessLastBlock@StreamTransformation@CryptoPP@@UAEXPAEPBEI@Z
	DD	FLAT:?MinLastBlockSize@StreamTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?IsRandomAccess@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
	DD	FLAT:?Seek@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEX_K@Z
	DD	FLAT:?IsSelfInverting@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
	DD	FLAT:?IsForwardTransformation@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
CONST	ENDS
;	COMDAT ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@
CONST	SEGMENT
??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ DD FLAT:??_R4?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@ ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vftable'
	DD	FLAT:??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?IsValidKeyLength@SimpleKeyingInterface@CryptoPP@@UBE_NI@Z
	DD	FLAT:?SetKey@SimpleKeyingInterface@CryptoPP@@UAEXPBEIABVNameValuePairs@2@@Z
	DD	FLAT:__purecall
	DD	FLAT:?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ
	DD	FLAT:?MinIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ
	DD	FLAT:?MaxIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ
	DD	FLAT:?Resynchronize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAEXPBEH@Z
	DD	FLAT:?GetNextIV@SimpleKeyingInterface@CryptoPP@@UAEXAAVRandomNumberGenerator@2@PAE@Z
	DD	FLAT:?GetAlgorithm@SymmetricCipher@CryptoPP@@MBEABVAlgorithm@2@XZ
	DD	FLAT:?UncheckedSetKey@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@MAEXPBEIABVNameValuePairs@2@@Z
	DD	FLAT:?GetPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MBEABUAdditiveCipherAbstractPolicy@2@XZ
	DD	FLAT:?AccessPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MAEAAUAdditiveCipherAbstractPolicy@2@XZ
CONST	ENDS
;	COMDAT ??_7?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@
CONST	SEGMENT
??_7?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@ DD FLAT:??_R4?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`vftable'
	DD	FLAT:??_E?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?GetAlignment@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBEIXZ
	DD	FLAT:?GetBytesPerIteration@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?GetOptimalBlockSize@AdditiveCipherAbstractPolicy@CryptoPP@@UBEIXZ
	DD	FLAT:?GetIterationsToBuffer@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?WriteKeystream@AdditiveCipherAbstractPolicy@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?CanOperateKeystream@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBE_NXZ
	DD	FLAT:?OperateKeystream@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXW4KeystreamOperation@2@PAEPBEI@Z
	DD	FLAT:?CipherSetKey@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXABVNameValuePairs@2@PBEI@Z
	DD	FLAT:?CipherResynchronize@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MAEXPAEPBEI@Z
	DD	FLAT:?CipherIsRandomAccess@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBE_NXZ
	DD	FLAT:?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z
CONST	ENDS
;	COMDAT ??_C@_0P@MDGHMGJK@Unref?5File?5?$CFs?6@
CONST	SEGMENT
??_C@_0P@MDGHMGJK@Unref?5File?5?$CFs?6@ DB 'Unref File %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@IGPMDEEF@SYSERR?3?5WriteNewData?$CI?$CJ?3?5CRITICA@
CONST	SEGMENT
??_C@_0EC@IGPMDEEF@SYSERR?3?5WriteNewData?$CI?$CJ?3?5CRITICA@ DB 'SYSERR:'
	DB	' WriteNewData(): CRITICAL ERROR: empty_size lower than 0!', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb@
CONST	SEGMENT
??_C@_02JDPG@rb@ DB 'rb', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JEPAOIH@Write?$FLtype?3?$CFu?$FN?5?$CFs?6@
CONST	SEGMENT
??_C@_0BD@JEPAOIH@Write?$FLtype?3?$CFu?$FN?5?$CFs?6@ DB 'Write[type:%u] %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@IGHIDEHN@Overwrite?$FLtype?3?$CFu?$FN?5?$CFs?6@
CONST	SEGMENT
??_C@_0BH@IGHIDEHN@Overwrite?$FLtype?3?$CFu?$FN?5?$CFs?6@ DB 'Overwrite[t'
	DB	'ype:%u] %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@JIDJMBKL@EterPack?3?3Put?5?3?5Cannot?5put?5to?5e@
CONST	SEGMENT
??_C@_0EE@JIDJMBKL@EterPack?3?3Put?5?3?5Cannot?5put?5to?5e@ DB 'EterPack:'
	DB	':Put : Cannot put to encrypted pack (filename: %s, DB: %s)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OILLCEPM@cannot?5decompress@
CONST	SEGMENT
??_C@_0BC@OILLCEPM@cannot?5decompress@ DB 'cannot decompress', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFAPLGOA@Failed?5to?5encrypt?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0BH@CFAPLGOA@Failed?5to?5encrypt?5?3?5?$CFs@ DB 'Failed to encrypt '
	DB	': %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@CFBHFFAK@Failed?5to?5decompress?5?3?5?$CFs@
CONST	SEGMENT
??_C@_0BK@CFBHFFAK@Failed?5to?5decompress?5?3?5?$CFs@ DB 'Failed to decom'
	DB	'press : %s', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@JMMFBMPC@Pack?5index?5file?5size?5error?$CB?5?$CFs?0@
CONST	SEGMENT
??_C@_0CO@JMMFBMPC@Pack?5index?5file?5size?5error?$CB?5?$CFs?0@ DB 'Pack '
	DB	'index file size error! %s, indexCount %d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KGHAJIDH@Pack?5index?5file?5version?5error?$CB?5@
CONST	SEGMENT
??_C@_0CC@KGHAJIDH@Pack?5index?5file?5version?5error?$CB?5@ DB 'Pack inde'
	DB	'x file version error! %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@HPBCEBAA@Pack?5index?5file?5fourcc?5error?$CB?5?$CF@
CONST	SEGMENT
??_C@_0CB@HPBCEBAA@Pack?5index?5file?5fourcc?5error?$CB?5?$CF@ DB 'Pack i'
	DB	'ndex file fourcc error! %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KNLDPAAC@Pack?5index?5file?5header?5error?$CB?5?$CF@
CONST	SEGMENT
??_C@_0CB@KNLDPAAC@Pack?5index?5file?5header?5error?$CB?5?$CF@ DB 'Pack i'
	DB	'ndex file header error! %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@IACKDODI@Cannot?5open?5pack?5index?5file?$CB?5?$CFs@
CONST	SEGMENT
??_C@_0CA@IACKDODI@Cannot?5open?5pack?5index?5file?$CB?5?$CFs@ DB 'Cannot'
	DB	' open pack index file! %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@FFDEAKBO@Encryptindex?3?5Cannot?5write?5to?5f@
CONST	SEGMENT
??_C@_0CH@FFDEAKBO@Encryptindex?3?5Cannot?5write?5to?5f@ DB 'Encryptindex'
	DB	': Cannot write to file! %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NIHCOGLD@EncryptIndex?3?5Cannot?5open?5file?5@
CONST	SEGMENT
??_C@_0CP@NIHCOGLD@EncryptIndex?3?5Cannot?5open?5file?5@ DB 'EncryptIndex'
	DB	': Cannot open file for writing! %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BKLKOCID@EncryptIndex?3?5Cannot?5encrypt?$CB?5?$CF@
CONST	SEGMENT
??_C@_0CB@BKLKOCID@EncryptIndex?3?5Cannot?5encrypt?$CB?5?$CF@ DB 'Encrypt'
	DB	'Index: Cannot encrypt! %s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LCLPMBOA@EncryptIndex?3?5Cannot?5open?5pack?5@
CONST	SEGMENT
??_C@_0CO@LCLPMBOA@EncryptIndex?3?5Cannot?5open?5pack?5@ DB 'EncryptIndex'
	DB	': Cannot open pack index file! %s', 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?s_adwEterPackKey@@3PAKA DD 02b09eb9H			; s_adwEterPackKey
	DD	0581696fH
	DD	0289b9863H
	DD	01a1879H
?s_adwEterPackSecurityKey@@3PAKA DD 04b4b822H		; s_adwEterPackSecurityKey
	DD	01f6eb264H
	DD	018eaaeH
	DD	01cfbf6a6H
_DATA	ENDS
;	COMDAT ??_C@_04JJCMEEIK@?4epk@
CONST	SEGMENT
??_C@_04JJCMEEIK@?4epk@ DB '.epk', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04OLDEJNOH@?4eix@
CONST	SEGMENT
??_C@_04OLDEJNOH@?4eix@ DB '.eix', 00H			; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	070H
CONST	ENDS
;	COMDAT ??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z
	DD	FLAT:?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
	DD	FLAT:?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
	DD	FLAT:?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@ DD 00H ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbtable'
	DD	018H
CONST	ENDS
;	COMDAT ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ DD FLAT:??_R4?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`vftable'
	DD	FLAT:??_E?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_09BOOFBHDC@Error?3?5?$CFs@
CONST	SEGMENT
??_C@_09BOOFBHDC@Error?3?5?$CFs@ DB 'Error: %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w@
CONST	SEGMENT
??_C@_01NOFIACDB@w@ DB 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04BKIDJPM@?4err@
CONST	SEGMENT
??_C@_04BKIDJPM@?4err@ DB '.err', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FPOLKAEB@?4log@
CONST	SEGMENT
??_C@_04FPOLKAEB@?4log@ DB '.log', 00H			; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7ios_base@std@@6B@
CONST	SEGMENT
??_7ios_base@std@@6B@ DD FLAT:??_R4ios_base@std@@6B@	; std::ios_base::`vftable'
	DD	FLAT:??_Eios_base@std@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@_W@std@@6B@
CONST	SEGMENT
??_7?$ctype@_W@std@@6B@ DD FLAT:??_R4?$ctype@_W@std@@6B@ ; std::ctype<wchar_t>::`vftable'
	DD	FLAT:??_E?$ctype@_W@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
	DD	FLAT:?do_is@?$ctype@_W@std@@MBE_NF_W@Z
	DD	FLAT:?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
	DD	FLAT:?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
	DD	FLAT:?do_widen@?$ctype@_W@std@@MBE_WD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@_W@std@@MBED_WD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_7?$codecvt@_WDU_Mbstatet@@@std@@6B@
CONST	SEGMENT
??_7?$codecvt@_WDU_Mbstatet@@@std@@6B@ DD FLAT:??_R4?$codecvt@_WDU_Mbstatet@@@std@@6B@ ; std::codecvt<wchar_t,char,_Mbstatet>::`vftable'
	DD	FLAT:??_E?$codecvt@_WDU_Mbstatet@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_always_noconv@?$codecvt@_WDU_Mbstatet@@@std@@MBE_NXZ
	DD	FLAT:?do_max_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ
	DD	FLAT:?do_encoding@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ
	DD	FLAT:?do_in@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPA_W3AAPA_W@Z
	DD	FLAT:?do_out@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PB_W1AAPB_WPAD3AAPAD@Z
	DD	FLAT:?do_unshift@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z
	DD	FLAT:?do_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z
CONST	ENDS
;	COMDAT ??_7codecvt_base@std@@6B@
CONST	SEGMENT
??_7codecvt_base@std@@6B@ DD FLAT:??_R4codecvt_base@std@@6B@ ; std::codecvt_base::`vftable'
	DD	FLAT:??_Ecodecvt_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_always_noconv@codecvt_base@std@@MBE_NXZ
	DD	FLAT:?do_max_length@codecvt_base@std@@MBEHXZ
	DD	FLAT:?do_encoding@codecvt_base@std@@MBEHXZ
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_C@_09HLDHDDJL@Whirlpool@
CONST	SEGMENT
??_C@_09HLDHDDJL@Whirlpool@ DB 'Whirlpool', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7Whirlpool@CryptoPP@@6B@
CONST	SEGMENT
??_7Whirlpool@CryptoPP@@6B@ DD FLAT:??_R4Whirlpool@CryptoPP@@6B@ ; CryptoPP::Whirlpool::`vftable'
	DD	FLAT:??_EWhirlpool@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	FLAT:?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Update@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z
	DD	FLAT:?CreateUpdateSpace@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?Final@HashTransformation@CryptoPP@@UAEXPAE@Z
	DD	FLAT:?Restart@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ
	DD	FLAT:?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UBEIXZ
	DD	FLAT:?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalBlockSize@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalDataAlignment@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?CalculateDigest@HashTransformation@CryptoPP@@UAEXPAEPBEI@Z
	DD	FLAT:?Verify@HashTransformation@CryptoPP@@UAE_NPBE@Z
	DD	FLAT:?VerifyDigest@HashTransformation@CryptoPP@@UAE_NPBE0I@Z
	DD	FLAT:?TruncatedFinal@Whirlpool@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?CalculateTruncatedDigest@HashTransformation@CryptoPP@@UAEXPAEIPBEI@Z
	DD	FLAT:?TruncatedVerify@HashTransformation@CryptoPP@@UAE_NPBEI@Z
	DD	FLAT:?VerifyTruncatedDigest@HashTransformation@CryptoPP@@UAE_NPBEI0I@Z
	DD	FLAT:?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXXZ
	DD	FLAT:?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ
	DD	FLAT:?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z
	DD	FLAT:?HashMultipleBlocks@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPB_KI@Z
	DD	FLAT:?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ
	DD	FLAT:?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ
CONST	ENDS
;	COMDAT ??_C@_0L@DFIJCONE@RIPEMD?9128@
CONST	SEGMENT
??_C@_0L@DFIJCONE@RIPEMD?9128@ DB 'RIPEMD-128', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7RIPEMD128@CryptoPP@@6B@
CONST	SEGMENT
??_7RIPEMD128@CryptoPP@@6B@ DD FLAT:??_R4RIPEMD128@CryptoPP@@6B@ ; CryptoPP::RIPEMD128::`vftable'
	DD	FLAT:??_ERIPEMD128@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	FLAT:?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Update@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z
	DD	FLAT:?CreateUpdateSpace@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?Final@HashTransformation@CryptoPP@@UAEXPAE@Z
	DD	FLAT:?Restart@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ
	DD	FLAT:?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UBEIXZ
	DD	FLAT:?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalBlockSize@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalDataAlignment@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?CalculateDigest@HashTransformation@CryptoPP@@UAEXPAEPBEI@Z
	DD	FLAT:?Verify@HashTransformation@CryptoPP@@UAE_NPBE@Z
	DD	FLAT:?VerifyDigest@HashTransformation@CryptoPP@@UAE_NPBE0I@Z
	DD	FLAT:?TruncatedFinal@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?CalculateTruncatedDigest@HashTransformation@CryptoPP@@UAEXPAEIPBEI@Z
	DD	FLAT:?TruncatedVerify@HashTransformation@CryptoPP@@UAE_NPBEI@Z
	DD	FLAT:?VerifyTruncatedDigest@HashTransformation@CryptoPP@@UAE_NPBEI0I@Z
	DD	FLAT:?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXXZ
	DD	FLAT:?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ
	DD	FLAT:?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z
	DD	FLAT:?HashMultipleBlocks@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPBII@Z
	DD	FLAT:?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ
	DD	FLAT:?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEPAIXZ
CONST	ENDS
;	COMDAT ??_C@_05HJMENKNE@SHA?91@
CONST	SEGMENT
??_C@_05HJMENKNE@SHA?91@ DB 'SHA-1', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7SHA1@CryptoPP@@6B@
CONST	SEGMENT
??_7SHA1@CryptoPP@@6B@ DD FLAT:??_R4SHA1@CryptoPP@@6B@	; CryptoPP::SHA1::`vftable'
	DD	FLAT:??_ESHA1@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	FLAT:?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Update@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z
	DD	FLAT:?CreateUpdateSpace@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?Final@HashTransformation@CryptoPP@@UAEXPAE@Z
	DD	FLAT:?Restart@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ
	DD	FLAT:?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UBEIXZ
	DD	FLAT:?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalBlockSize@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalDataAlignment@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?CalculateDigest@HashTransformation@CryptoPP@@UAEXPAEPBEI@Z
	DD	FLAT:?Verify@HashTransformation@CryptoPP@@UAE_NPBE@Z
	DD	FLAT:?VerifyDigest@HashTransformation@CryptoPP@@UAE_NPBE0I@Z
	DD	FLAT:?TruncatedFinal@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?CalculateTruncatedDigest@HashTransformation@CryptoPP@@UAEXPAEIPBEI@Z
	DD	FLAT:?TruncatedVerify@HashTransformation@CryptoPP@@UAE_NPBEI@Z
	DD	FLAT:?VerifyTruncatedDigest@HashTransformation@CryptoPP@@UAE_NPBEI0I@Z
	DD	FLAT:?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXXZ
	DD	FLAT:?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ
	DD	FLAT:?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z
	DD	FLAT:?HashMultipleBlocks@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPBII@Z
	DD	FLAT:?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ
	DD	FLAT:?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEPAIXZ
CONST	ENDS
;	COMDAT ??_C@_05LIOENMIE@Tiger@
CONST	SEGMENT
??_C@_05LIOENMIE@Tiger@ DB 'Tiger', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7Tiger@CryptoPP@@6B@
CONST	SEGMENT
??_7Tiger@CryptoPP@@6B@ DD FLAT:??_R4Tiger@CryptoPP@@6B@ ; CryptoPP::Tiger::`vftable'
	DD	FLAT:??_ETiger@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	FLAT:?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?Update@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEXPBEI@Z
	DD	FLAT:?CreateUpdateSpace@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?Final@HashTransformation@CryptoPP@@UAEXPAE@Z
	DD	FLAT:?Restart@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAEXXZ
	DD	FLAT:?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UBEIXZ
	DD	FLAT:?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalBlockSize@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?OptimalDataAlignment@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
	DD	FLAT:?CalculateDigest@HashTransformation@CryptoPP@@UAEXPAEPBEI@Z
	DD	FLAT:?Verify@HashTransformation@CryptoPP@@UAE_NPBE@Z
	DD	FLAT:?VerifyDigest@HashTransformation@CryptoPP@@UAE_NPBE0I@Z
	DD	FLAT:?TruncatedFinal@Tiger@CryptoPP@@UAEXPAEI@Z
	DD	FLAT:?CalculateTruncatedDigest@HashTransformation@CryptoPP@@UAEXPAEIPBEI@Z
	DD	FLAT:?TruncatedVerify@HashTransformation@CryptoPP@@UAE_NPBEI@Z
	DD	FLAT:?VerifyTruncatedDigest@HashTransformation@CryptoPP@@UAE_NPBEI0I@Z
	DD	FLAT:?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXXZ
	DD	FLAT:?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ
	DD	FLAT:?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z
	DD	FLAT:?HashMultipleBlocks@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@MAEIPB_KI@Z
	DD	FLAT:?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ
	DD	FLAT:?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ
CONST	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT ??_7StringSource@CryptoPP@@6BWaitable@1@@
CONST	SEGMENT
??_7StringSource@CryptoPP@@6BWaitable@1@@ DD FLAT:??_R4StringSource@CryptoPP@@6BWaitable@1@@ ; CryptoPP::StringSource::`vftable'
	DD	FLAT:??_EStringSource@CryptoPP@@W3AEPAXI@Z
	DD	FLAT:?GetMaxWaitObjectCount@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?GetWaitObjects@BufferedTransformation@CryptoPP@@UAEXAAVWaitObjectContainer@2@ABVCallStack@2@@Z
CONST	ENDS
;	COMDAT ??_7StringSource@CryptoPP@@6BAlgorithm@1@@
CONST	SEGMENT
??_7StringSource@CryptoPP@@6BAlgorithm@1@@ DD FLAT:??_R4StringSource@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::StringSource::`vftable'
	DD	FLAT:??_EStringSource@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
	DD	FLAT:?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Put2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z
	DD	FLAT:?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z
	DD	FLAT:?IsolatedInitialize@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z
	DD	FLAT:?IsolatedFlush@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N0@Z
	DD	FLAT:?IsolatedMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N@Z
	DD	FLAT:?Initialize@Filter@CryptoPP@@UAEXABVNameValuePairs@2@H@Z
	DD	FLAT:?Flush@Filter@CryptoPP@@UAE_N_NH0@Z
	DD	FLAT:?MessageSeriesEnd@Filter@CryptoPP@@UAE_NH_N@Z
	DD	FLAT:?SetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXH@Z
	DD	FLAT:?GetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBEHXZ
	DD	FLAT:?MaxRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?AnyRetrievable@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIPAEI@Z
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIAAE@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIPAEI@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIAAE@Z
	DD	FLAT:?Skip@BufferedTransformation@CryptoPP@@UAE_K_K@Z
	DD	FLAT:?TotalBytesRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?NumberOfMessages@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?AnyMessages@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?GetNextMessage@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?SkipMessages@BufferedTransformation@CryptoPP@@UAEII@Z
	DD	FLAT:?SkipAll@BufferedTransformation@CryptoPP@@UAEXXZ
	DD	FLAT:?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?TransferTo2@Filter@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?CopyRangeTo2@Filter@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?ChannelCreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAI@Z
	DD	FLAT:?ChannelPut2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z
	DD	FLAT:?ChannelPutModifiable2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEIH_N@Z
	DD	FLAT:?ChannelFlush@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NH1@Z
	DD	FLAT:?ChannelMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
	DD	FLAT:?SetRetrievalChannel@BufferedTransformation@CryptoPP@@UAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?Attachable@Filter@CryptoPP@@UAE_NXZ
	DD	FLAT:?AttachedTransformation@Filter@CryptoPP@@UBEPBVBufferedTransformation@2@XZ
	DD	FLAT:?AttachedTransformation@Filter@CryptoPP@@UAEPAVBufferedTransformation@2@XZ
	DD	FLAT:?Detach@Filter@CryptoPP@@UAEXPAVBufferedTransformation@2@@Z
	DD	FLAT:?Attach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
	DD	FLAT:?NewDefaultAttachment@Filter@CryptoPP@@MBEPAVBufferedTransformation@2@XZ
	DD	FLAT:?ShouldPropagateMessageEnd@Filter@CryptoPP@@MBE_NXZ
	DD	FLAT:?ShouldPropagateMessageSeriesEnd@Filter@CryptoPP@@MBE_NXZ
	DD	FLAT:?Pump2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAA_K_N@Z
	DD	FLAT:?PumpMessages2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAAI_N@Z
	DD	FLAT:?PumpAll2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEI_N@Z
	DD	FLAT:?SourceExhausted@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBE_NXZ
CONST	ENDS
;	COMDAT ??_7?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BWaitable@1@@
CONST	SEGMENT
??_7?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BWaitable@1@@ DD FLAT:??_R4?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BWaitable@1@@ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable'
	DD	FLAT:??_E?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@W3AEPAXI@Z
	DD	FLAT:?GetMaxWaitObjectCount@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?GetWaitObjects@BufferedTransformation@CryptoPP@@UAEXAAVWaitObjectContainer@2@ABVCallStack@2@@Z
CONST	ENDS
;	COMDAT ??_7?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BAlgorithm@1@@
CONST	SEGMENT
??_7?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BAlgorithm@1@@ DD FLAT:??_R4?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vftable'
	DD	FLAT:??_E?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
	DD	FLAT:?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Put2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z
	DD	FLAT:?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z
	DD	FLAT:?IsolatedInitialize@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z
	DD	FLAT:?IsolatedFlush@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N0@Z
	DD	FLAT:?IsolatedMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N@Z
	DD	FLAT:?Initialize@Filter@CryptoPP@@UAEXABVNameValuePairs@2@H@Z
	DD	FLAT:?Flush@Filter@CryptoPP@@UAE_N_NH0@Z
	DD	FLAT:?MessageSeriesEnd@Filter@CryptoPP@@UAE_NH_N@Z
	DD	FLAT:?SetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXH@Z
	DD	FLAT:?GetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBEHXZ
	DD	FLAT:?MaxRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?AnyRetrievable@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIPAEI@Z
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIAAE@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIPAEI@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIAAE@Z
	DD	FLAT:?Skip@BufferedTransformation@CryptoPP@@UAE_K_K@Z
	DD	FLAT:?TotalBytesRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?NumberOfMessages@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?AnyMessages@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?GetNextMessage@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?SkipMessages@BufferedTransformation@CryptoPP@@UAEII@Z
	DD	FLAT:?SkipAll@BufferedTransformation@CryptoPP@@UAEXXZ
	DD	FLAT:?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?TransferTo2@Filter@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?CopyRangeTo2@Filter@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?ChannelCreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAI@Z
	DD	FLAT:?ChannelPut2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z
	DD	FLAT:?ChannelPutModifiable2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEIH_N@Z
	DD	FLAT:?ChannelFlush@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NH1@Z
	DD	FLAT:?ChannelMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
	DD	FLAT:?SetRetrievalChannel@BufferedTransformation@CryptoPP@@UAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?Attachable@Filter@CryptoPP@@UAE_NXZ
	DD	FLAT:?AttachedTransformation@Filter@CryptoPP@@UBEPBVBufferedTransformation@2@XZ
	DD	FLAT:?AttachedTransformation@Filter@CryptoPP@@UAEPAVBufferedTransformation@2@XZ
	DD	FLAT:?Detach@Filter@CryptoPP@@UAEXPAVBufferedTransformation@2@@Z
	DD	FLAT:?Attach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
	DD	FLAT:?NewDefaultAttachment@Filter@CryptoPP@@MBEPAVBufferedTransformation@2@XZ
	DD	FLAT:?ShouldPropagateMessageEnd@Filter@CryptoPP@@MBE_NXZ
	DD	FLAT:?ShouldPropagateMessageSeriesEnd@Filter@CryptoPP@@MBE_NXZ
	DD	FLAT:?Pump2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAA_K_N@Z
	DD	FLAT:?PumpMessages2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAAI_N@Z
	DD	FLAT:?PumpAll2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEI_N@Z
	DD	FLAT:?SourceExhausted@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBE_NXZ
CONST	ENDS
;	COMDAT ??_C@_0M@JMHEFFAI@InputBuffer@
CONST	SEGMENT
??_C@_0M@JMHEFFAI@InputBuffer@ DB 'InputBuffer', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7StringStore@CryptoPP@@6BWaitable@1@@
CONST	SEGMENT
??_7StringStore@CryptoPP@@6BWaitable@1@@ DD FLAT:??_R4StringStore@CryptoPP@@6BWaitable@1@@ ; CryptoPP::StringStore::`vftable'
	DD	FLAT:??_EStringStore@CryptoPP@@W3AEPAXI@Z
	DD	FLAT:?GetMaxWaitObjectCount@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?GetWaitObjects@BufferedTransformation@CryptoPP@@UAEXAAVWaitObjectContainer@2@ABVCallStack@2@@Z
CONST	ENDS
;	COMDAT ??_7StringStore@CryptoPP@@6BAlgorithm@1@@
CONST	SEGMENT
??_7StringStore@CryptoPP@@6BAlgorithm@1@@ DD FLAT:??_R4StringStore@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::StringStore::`vftable'
	DD	FLAT:??_EStringStore@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
	DD	FLAT:?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Put2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z
	DD	FLAT:?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z
	DD	FLAT:?IsolatedInitialize@Store@CryptoPP@@UAEXABVNameValuePairs@2@@Z
	DD	FLAT:?IsolatedFlush@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N0@Z
	DD	FLAT:?IsolatedMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N@Z
	DD	FLAT:?Initialize@BufferedTransformation@CryptoPP@@UAEXABVNameValuePairs@2@H@Z
	DD	FLAT:?Flush@BufferedTransformation@CryptoPP@@UAE_N_NH0@Z
	DD	FLAT:?MessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_NH_N@Z
	DD	FLAT:?SetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UAEXH@Z
	DD	FLAT:?GetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UBEHXZ
	DD	FLAT:?MaxRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?AnyRetrievable@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIPAEI@Z
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIAAE@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIPAEI@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIAAE@Z
	DD	FLAT:?Skip@BufferedTransformation@CryptoPP@@UAE_K_K@Z
	DD	FLAT:?TotalBytesRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?NumberOfMessages@Store@CryptoPP@@UBEIXZ
	DD	FLAT:?AnyMessages@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?GetNextMessage@Store@CryptoPP@@UAE_NXZ
	DD	FLAT:?SkipMessages@BufferedTransformation@CryptoPP@@UAEII@Z
	DD	FLAT:?SkipAll@BufferedTransformation@CryptoPP@@UAEXXZ
	DD	FLAT:?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?TransferTo2@StringStore@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?CopyRangeTo2@StringStore@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?ChannelCreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAI@Z
	DD	FLAT:?ChannelPut2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z
	DD	FLAT:?ChannelPutModifiable2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEIH_N@Z
	DD	FLAT:?ChannelFlush@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NH1@Z
	DD	FLAT:?ChannelMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
	DD	FLAT:?SetRetrievalChannel@BufferedTransformation@CryptoPP@@UAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?Attachable@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?AttachedTransformation@BufferedTransformation@CryptoPP@@UBEPBV12@XZ
	DD	FLAT:?AttachedTransformation@BufferedTransformation@CryptoPP@@UAEPAV12@XZ
	DD	FLAT:?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
	DD	FLAT:?Attach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
	DD	FLAT:?StoreInitialize@StringStore@CryptoPP@@EAEXABVNameValuePairs@2@@Z
CONST	ENDS
;	COMDAT ??_7ArraySink@CryptoPP@@6BWaitable@1@@
CONST	SEGMENT
??_7ArraySink@CryptoPP@@6BWaitable@1@@ DD FLAT:??_R4ArraySink@CryptoPP@@6BWaitable@1@@ ; CryptoPP::ArraySink::`vftable'
	DD	FLAT:??_EArraySink@CryptoPP@@W3AEPAXI@Z
	DD	FLAT:?GetMaxWaitObjectCount@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?GetWaitObjects@BufferedTransformation@CryptoPP@@UAEXAAVWaitObjectContainer@2@ABVCallStack@2@@Z
CONST	ENDS
;	COMDAT ??_7ArraySink@CryptoPP@@6BAlgorithm@1@@
CONST	SEGMENT
??_7ArraySink@CryptoPP@@6BAlgorithm@1@@ DD FLAT:??_R4ArraySink@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::ArraySink::`vftable'
	DD	FLAT:??_EArraySink@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
	DD	FLAT:?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CreatePutSpace@ArraySink@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Put2@ArraySink@CryptoPP@@UAEIPBEIH_N@Z
	DD	FLAT:?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z
	DD	FLAT:?IsolatedInitialize@ArraySink@CryptoPP@@UAEXABVNameValuePairs@2@@Z
	DD	FLAT:?IsolatedFlush@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@UAE_N_N0@Z
	DD	FLAT:?IsolatedMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_N_N@Z
	DD	FLAT:?Initialize@BufferedTransformation@CryptoPP@@UAEXABVNameValuePairs@2@H@Z
	DD	FLAT:?Flush@BufferedTransformation@CryptoPP@@UAE_N_NH0@Z
	DD	FLAT:?MessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_NH_N@Z
	DD	FLAT:?SetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UAEXH@Z
	DD	FLAT:?GetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UBEHXZ
	DD	FLAT:?MaxRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?AnyRetrievable@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIPAEI@Z
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIAAE@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIPAEI@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIAAE@Z
	DD	FLAT:?Skip@BufferedTransformation@CryptoPP@@UAE_K_K@Z
	DD	FLAT:?TotalBytesRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?NumberOfMessages@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?AnyMessages@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?GetNextMessage@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?SkipMessages@BufferedTransformation@CryptoPP@@UAEII@Z
	DD	FLAT:?SkipAll@BufferedTransformation@CryptoPP@@UAEXXZ
	DD	FLAT:?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?TransferTo2@Sink@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?CopyRangeTo2@Sink@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?ChannelCreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAI@Z
	DD	FLAT:?ChannelPut2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z
	DD	FLAT:?ChannelPutModifiable2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEIH_N@Z
	DD	FLAT:?ChannelFlush@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NH1@Z
	DD	FLAT:?ChannelMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
	DD	FLAT:?SetRetrievalChannel@BufferedTransformation@CryptoPP@@UAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?Attachable@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?AttachedTransformation@BufferedTransformation@CryptoPP@@UBEPBV12@XZ
	DD	FLAT:?AttachedTransformation@BufferedTransformation@CryptoPP@@UAEPAV12@XZ
	DD	FLAT:?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
	DD	FLAT:?Attach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
CONST	ENDS
;	COMDAT ??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@
CONST	SEGMENT
??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@ DD FLAT:??_R4?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@ ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vftable'
	DD	FLAT:??_E?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@W3AEPAXI@Z
	DD	FLAT:?GetMaxWaitObjectCount@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?GetWaitObjects@BufferedTransformation@CryptoPP@@UAEXAAVWaitObjectContainer@2@ABVCallStack@2@@Z
CONST	ENDS
;	COMDAT ??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@
CONST	SEGMENT
??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@ DD FLAT:??_R4?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@ ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vftable'
	DD	FLAT:??_E?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
	DD	FLAT:?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	FLAT:?CreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEAAI@Z
	DD	FLAT:?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Put2@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEIPBEIH_N@Z
	DD	FLAT:?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z
	DD	FLAT:?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z
	DD	FLAT:?IsolatedFlush@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@UAE_N_N0@Z
	DD	FLAT:?IsolatedMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_N_N@Z
	DD	FLAT:?Initialize@BufferedTransformation@CryptoPP@@UAEXABVNameValuePairs@2@H@Z
	DD	FLAT:?Flush@BufferedTransformation@CryptoPP@@UAE_N_NH0@Z
	DD	FLAT:?MessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_NH_N@Z
	DD	FLAT:?SetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UAEXH@Z
	DD	FLAT:?GetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UBEHXZ
	DD	FLAT:?MaxRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?AnyRetrievable@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIPAEI@Z
	DD	FLAT:?Get@BufferedTransformation@CryptoPP@@UAEIAAE@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIPAEI@Z
	DD	FLAT:?Peek@BufferedTransformation@CryptoPP@@UBEIAAE@Z
	DD	FLAT:?Skip@BufferedTransformation@CryptoPP@@UAE_K_K@Z
	DD	FLAT:?TotalBytesRetrievable@BufferedTransformation@CryptoPP@@UBE_KXZ
	DD	FLAT:?NumberOfMessages@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?AnyMessages@BufferedTransformation@CryptoPP@@UBE_NXZ
	DD	FLAT:?GetNextMessage@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?SkipMessages@BufferedTransformation@CryptoPP@@UAEII@Z
	DD	FLAT:?SkipAll@BufferedTransformation@CryptoPP@@UAEXXZ
	DD	FLAT:?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ
	DD	FLAT:?TransferTo2@Sink@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?CopyRangeTo2@Sink@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	FLAT:?ChannelCreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAI@Z
	DD	FLAT:?ChannelPut2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z
	DD	FLAT:?ChannelPutModifiable2@BufferedTransformation@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAEIH_N@Z
	DD	FLAT:?ChannelFlush@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NH1@Z
	DD	FLAT:?ChannelMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
	DD	FLAT:?SetRetrievalChannel@BufferedTransformation@CryptoPP@@UAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	FLAT:?Attachable@BufferedTransformation@CryptoPP@@UAE_NXZ
	DD	FLAT:?AttachedTransformation@BufferedTransformation@CryptoPP@@UBEPBV12@XZ
	DD	FLAT:?AttachedTransformation@BufferedTransformation@CryptoPP@@UAEPAV12@XZ
	DD	FLAT:?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
	DD	FLAT:?Attach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
CONST	ENDS
;	COMDAT ??_7?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@
CONST	SEGMENT
??_7?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@ DD FLAT:??_R4?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@ ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`vftable'
	DD	FLAT:??_E?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?AssignValue@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPBDABVtype_info@@PAX@Z
	DD	FLAT:?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z40
xdata$x	SEGMENT
__CT??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z40 DD 00H
	DD	FLAT:??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8
data$r	SEGMENT
??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@
xdata$x	SEGMENT
__CTA3?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@ DD 03H
	DD	FLAT:__CT??_R0?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@@8??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z40
	DD	FLAT:__CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@
xdata$x	SEGMENT
__TI3?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@ DD 00H
	DD	FLAT:??1ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@
xdata$x	ENDS
;	COMDAT ??_C@_0CF@BLINCPFB@AlgorithmParametersBase?3?5parame@
CONST	SEGMENT
??_C@_0CF@BLINCPFB@AlgorithmParametersBase?3?5parame@ DB 'AlgorithmParame'
	DB	'tersBase: parameter "', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IAABKFFP@?$CC?5not?5used@
CONST	SEGMENT
??_C@_0L@IAABKFFP@?$CC?5not?5used@ DB '" not used', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7AlgorithmParametersBase@CryptoPP@@6B@
CONST	SEGMENT
??_7AlgorithmParametersBase@CryptoPP@@6B@ DD FLAT:??_R4AlgorithmParametersBase@CryptoPP@@6B@ ; CryptoPP::AlgorithmParametersBase::`vftable'
	DD	FLAT:??_EAlgorithmParametersBase@CryptoPP@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@
CONST	SEGMENT
??_7ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@ DD FLAT:??_R4ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@ ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`vftable'
	DD	FLAT:??_EParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?what@Exception@CryptoPP@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0DG@FIHMKEGL@BufferedTransformation?3?5this?5ob@
CONST	SEGMENT
??_C@_0DG@FIHMKEGL@BufferedTransformation?3?5this?5ob@ DB 'BufferedTransf'
	DB	'ormation: this object is not attachable', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@CFJCNMFC@RandomNumberGenerator?3?5Incorpor@
CONST	SEGMENT
??_C@_0DK@CFJCNMFC@RandomNumberGenerator?3?5Incorpor@ DB 'RandomNumberGen'
	DB	'erator: IncorporateEntropy not implemented', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@BPAJPOGP@StreamTransformation?3?5this?5obje@
CONST	SEGMENT
??_C@_0EA@BPAJPOGP@StreamTransformation?3?5this?5obje@ DB 'StreamTransfor'
	DB	'mation: this object doesn''t support random access', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CJIHPKKH@?3?5this?5object?5doesn?8t?5support?5r@
CONST	SEGMENT
??_C@_0DA@CJIHPKKH@?3?5this?5object?5doesn?8t?5support?5r@ DB ': this obj'
	DB	'ect doesn''t support resynchronization', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@CCPAJEEJ@Clone?$CI?$CJ?5is?5not?5implemented?5yet?4@
CONST	SEGMENT
??_C@_0CA@CCPAJEEJ@Clone?$CI?$CJ?5is?5not?5implemented?5yet?4@ DB 'Clone('
	DB	') is not implemented yet.', 00H		; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVNotImplemented@CryptoPP@@@8??0NotImplemented@CryptoPP@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVNotImplemented@CryptoPP@@@8??0NotImplemented@CryptoPP@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVNotImplemented@CryptoPP@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0NotImplemented@CryptoPP@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVNotImplemented@CryptoPP@@@8
data$r	SEGMENT
??_R0?AVNotImplemented@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::NotImplemented `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVNotImplemented@CryptoPP@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVNotImplemented@CryptoPP@@
xdata$x	SEGMENT
__CTA3?AVNotImplemented@CryptoPP@@ DD 03H
	DD	FLAT:__CT??_R0?AVNotImplemented@CryptoPP@@@8??0NotImplemented@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVNotImplemented@CryptoPP@@
xdata$x	SEGMENT
__TI3?AVNotImplemented@CryptoPP@@ DD 00H
	DD	FLAT:??1NotImplemented@CryptoPP@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVNotImplemented@CryptoPP@@
xdata$x	ENDS
;	COMDAT __CTA3?AVInvalidArgument@CryptoPP@@
xdata$x	SEGMENT
__CTA3?AVInvalidArgument@CryptoPP@@ DD 03H
	DD	FLAT:__CT??_R0?AVInvalidArgument@CryptoPP@@@8??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVInvalidArgument@CryptoPP@@
xdata$x	SEGMENT
__TI3?AVInvalidArgument@CryptoPP@@ DD 00H
	DD	FLAT:??1InvalidArgument@CryptoPP@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVInvalidArgument@CryptoPP@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVException@CryptoPP@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0Exception@CryptoPP@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVException@CryptoPP@@@8
data$r	SEGMENT
??_R0?AVException@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::Exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVException@CryptoPP@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVInvalidArgument@CryptoPP@@@8??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVInvalidArgument@CryptoPP@@@8??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVInvalidArgument@CryptoPP@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVInvalidArgument@CryptoPP@@@8
data$r	SEGMENT
??_R0?AVInvalidArgument@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::InvalidArgument `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInvalidArgument@CryptoPP@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z48
xdata$x	SEGMENT
__CT??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z48 DD 00H
	DD	FLAT:??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	030H
	DD	FLAT:??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8
data$r	SEGMENT
??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8 DD FLAT:??_7type_info@@6B@ ; CryptoPP::NameValuePairs::ValueTypeMismatch `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVValueTypeMismatch@NameValuePairs@CryptoPP@@', 00H
data$r	ENDS
;	COMDAT __CTA4?AVValueTypeMismatch@NameValuePairs@CryptoPP@@
xdata$x	SEGMENT
__CTA4?AVValueTypeMismatch@NameValuePairs@CryptoPP@@ DD 04H
	DD	FLAT:__CT??_R0?AVValueTypeMismatch@NameValuePairs@CryptoPP@@@8??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z48
	DD	FLAT:__CT??_R0?AVInvalidArgument@CryptoPP@@@8??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVException@CryptoPP@@@8??0Exception@CryptoPP@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AVValueTypeMismatch@NameValuePairs@CryptoPP@@
xdata$x	SEGMENT
__TI4?AVValueTypeMismatch@NameValuePairs@CryptoPP@@ DD 00H
	DD	FLAT:??1ValueTypeMismatch@NameValuePairs@CryptoPP@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVValueTypeMismatch@NameValuePairs@CryptoPP@@
xdata$x	ENDS
;	COMDAT ??_C@_0CE@LNMKHLKF@NameValuePairs?3?5type?5mismatch?5f@
CONST	SEGMENT
??_C@_0CE@LNMKHLKF@NameValuePairs?3?5type?5mismatch?5f@ DB 'NameValuePair'
	DB	's: type mismatch for ''', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@PGGGIJHH@?8?0?5stored?5?8@
CONST	SEGMENT
??_C@_0M@PGGGIJHH@?8?0?5stored?5?8@ DB ''', stored ''', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CPJAGCKP@?8?0?5trying?5to?5retrieve?5?8@
CONST	SEGMENT
??_C@_0BI@CPJAGCKP@?8?0?5trying?5to?5retrieve?5?8@ DB ''', trying to retr'
	DB	'ieve ''', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8@
CONST	SEGMENT
??_C@_01GEODFPGF@?8@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@
CONST	SEGMENT
??_7ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@ DD FLAT:??_R4ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@ ; CryptoPP::NameValuePairs::ValueTypeMismatch::`vftable'
	DD	FLAT:??_EValueTypeMismatch@NameValuePairs@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?what@Exception@CryptoPP@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7NotImplemented@CryptoPP@@6B@
CONST	SEGMENT
??_7NotImplemented@CryptoPP@@6B@ DD FLAT:??_R4NotImplemented@CryptoPP@@6B@ ; CryptoPP::NotImplemented::`vftable'
	DD	FLAT:??_ENotImplemented@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?what@Exception@CryptoPP@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7InvalidArgument@CryptoPP@@6B@
CONST	SEGMENT
??_7InvalidArgument@CryptoPP@@6B@ DD FLAT:??_R4InvalidArgument@CryptoPP@@6B@ ; CryptoPP::InvalidArgument::`vftable'
	DD	FLAT:??_EInvalidArgument@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?what@Exception@CryptoPP@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7Exception@CryptoPP@@6B@
CONST	SEGMENT
??_7Exception@CryptoPP@@6B@ DD FLAT:??_R4Exception@CryptoPP@@6B@ ; CryptoPP::Exception::`vftable'
	DD	FLAT:??_EException@CryptoPP@@UAEPAXI@Z
	DD	FLAT:?what@Exception@CryptoPP@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7CEterPack@@6B@
CONST	SEGMENT
??_7CEterPack@@6B@ DD FLAT:??_R4CEterPack@@6B@		; CEterPack::`vftable'
	DD	FLAT:??_ECEterPack@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ?length@?$prime_list_template@I@detail@unordered@boost@@2HB
CONST	SEGMENT
?length@?$prime_list_template@I@detail@unordered@boost@@2HB DD 026H ; boost::unordered::detail::prime_list_template<unsigned int>::length
CONST	ENDS
;	COMDAT ?value@?$prime_list_template@I@detail@unordered@boost@@2QBIB
CONST	SEGMENT
?value@?$prime_list_template@I@detail@unordered@boost@@2QBIB DD 011H ; boost::unordered::detail::prime_list_template<unsigned int>::value
	DD	01dH
	DD	025H
	DD	035H
	DD	043H
	DD	04fH
	DD	061H
	DD	083H
	DD	0c1H
	DD	0101H
	DD	0185H
	DD	0209H
	DD	0301H
	DD	0407H
	DD	0607H
	DD	0805H
	DD	0c07H
	DD	01807H
	DD	03001H
	DD	06011H
	DD	0c005H
	DD	01800dH
	DD	030005H
	DD	060019H
	DD	0c0001H
	DD	0180005H
	DD	030000bH
	DD	060000dH
	DD	0c00005H
	DD	01800013H
	DD	03000005H
	DD	06000017H
	DD	0c000013H
	DD	018000005H
	DD	030000059H
	DD	060000005H
	DD	0c0000001H
	DD	0fffffffbH
CONST	ENDS
;	COMDAT ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 069H ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	DB	06fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category2@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category2@std@@6B@ DD FLAT:??_R4_Iostream_error_category2@std@@6B@ ; std::_Iostream_error_category2::`vftable'
	DD	FLAT:??_E_Iostream_error_category2@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category2@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z$0
__ehfuncinfo$??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$13 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$0
__tryblocktable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$13
__unwindtable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z$0
__ehfuncinfo$??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z$0
__ehfuncinfo$??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z$39 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z$0
__unwindtable$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z$39
__ehfuncinfo$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$14 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0
__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$14
__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z$0
__ehfuncinfo$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z$0
__ehfuncinfo$??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z$0
__ehfuncinfo$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z$0
__ehfuncinfo$??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$1
__ehfuncinfo$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z$1
__ehfuncinfo$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$43 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$0
__tryblocktable$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z DD 03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:__catchsym$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$43
__ehfuncinfo$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$3
	DD	01H
	DD	00H
	DD	01H
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ$0
__ehfuncinfo$??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ$0
__ehfuncinfo$??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z$40 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z$0
__unwindtable$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z$40
__ehfuncinfo$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0
__ehfuncinfo$?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ$0
__ehfuncinfo$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ$1
__ehfuncinfo$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0
__ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ$0
__ehfuncinfo$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z$0
__ehfuncinfo$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z$5
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z$2
__ehfuncinfo$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z$18 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z$18
__unwindtable$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z$0
__ehfuncinfo$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$0
__ehfuncinfo$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gios_base@std@@UAEPAXI@Z DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Gios_base@std@@UAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@ios_base@std@@IAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?_Init@ios_base@std@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@ios_base@std@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$1
__ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
__ehfuncinfo$?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ$1
__ehfuncinfo$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$2
__ehfuncinfo$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ$0
__ehfuncinfo$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ$1
__ehfuncinfo$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$2
__ehfuncinfo$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ$0
__ehfuncinfo$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ$1
__ehfuncinfo$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$2
__ehfuncinfo$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ$0
__ehfuncinfo$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ$1
__ehfuncinfo$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$2
__ehfuncinfo$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ$0
__ehfuncinfo$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ$1
__ehfuncinfo$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z$0
__ehfuncinfo$?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$0
__ehfuncinfo$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z$2
__ehfuncinfo$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z$14
	DD	00H
	DD	FLAT:__unwindfunclet$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z$1
	DD	02H
	DD	FLAT:__unwindfunclet$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z$2
__ehfuncinfo$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z$0
__ehfuncinfo$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z$0
__ehfuncinfo$??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0StringStore@CryptoPP@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StringStore@CryptoPP@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0StringStore@CryptoPP@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0StringStore@CryptoPP@@QAE@PBD@Z$2
__ehfuncinfo$??0StringStore@CryptoPP@@QAE@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0StringStore@CryptoPP@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z$0
__ehfuncinfo$?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z$1
__ehfuncinfo$?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1AlgorithmParametersBase@CryptoPP@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z$0
__ehfuncinfo$??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z$2
__ehfuncinfo$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z$0
__ehfuncinfo$??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z$0
__ehfuncinfo$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z$0
__ehfuncinfo$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z$0
__ehfuncinfo$?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z$0
__ehfuncinfo$?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z$0
__ehfuncinfo$?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ$1
__ehfuncinfo$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Clone@Clonable@CryptoPP@@UBEPAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Clone@Clonable@CryptoPP@@UBEPAV12@XZ$0
__ehfuncinfo$?Clone@Clonable@CryptoPP@@UBEPAV12@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z$0
__ehfuncinfo$?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Exception@CryptoPP@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Exception@CryptoPP@@QAE@ABV01@@Z$0
__ehfuncinfo$??0Exception@CryptoPP@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Exception@CryptoPP@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FlushError@CMakePackLog@@QAEXXZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?FlushError@CMakePackLog@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FlushError@CMakePackLog@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$10
	DD	00H
	DD	FLAT:__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$3
	DD	04H
	DD	FLAT:__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetSingleton@CMakePackLog@@SAAAV1@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetSingleton@CMakePackLog@@SAAAV1@XZ$0
__ehfuncinfo$?GetSingleton@CMakePackLog@@SAAAV1@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetSingleton@CMakePackLog@@SAAAV1@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$3
__ehfuncinfo$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$3
__ehfuncinfo$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$4
	DD	00H
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$6
	DD	00H
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$8
	DD	07H
	DD	FLAT:__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z$0
__ehfuncinfo$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0
__unwindtable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$2
__ehfuncinfo$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0
__ehfuncinfo$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z$0
__ehfuncinfo$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z$0
__ehfuncinfo$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0
__unwindtable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$2
__ehfuncinfo$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0
__ehfuncinfo$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z$0
__ehfuncinfo$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z$0
__ehfuncinfo$?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z$1
__ehfuncinfo$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$2
__ehfuncinfo$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DeleteUnreferencedData@CEterPack@@QAEKXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?DeleteUnreferencedData@CEterPack@@QAEKXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DeleteUnreferencedData@CEterPack@@QAEKXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?DecryptIndexFile@CEterPack@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?DecryptIndexFile@CEterPack@@QAE_NXZ$0
__ehfuncinfo$?DecryptIndexFile@CEterPack@@QAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?DecryptIndexFile@CEterPack@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?EncryptIndexFile@CEterPack@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?EncryptIndexFile@CEterPack@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?EncryptIndexFile@CEterPack@@QAE_NXZ$1
__ehfuncinfo$?EncryptIndexFile@CEterPack@@QAE_NXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?EncryptIndexFile@CEterPack@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Extract@CEterPack@@QAE_NXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Extract@CEterPack@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Extract@CEterPack@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Put@CEterPack@@QAE_NPBDPBXJE@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?Put@CEterPack@@QAE_NPBDPBXJE@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Put@CEterPack@@QAE_NPBDPBXJE@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
__ehfuncinfo$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Destroy@CEterPack@@QAEXXZ DD 0ffffffffH
	DD	FLAT:___std_terminate
__ehfuncinfo$?Destroy@CEterPack@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Destroy@CEterPack@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CEterPack@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CEterPack@@QAE@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$??0CEterPack@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CEterPack@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??0CEterPack@@QAE@XZ$32
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z$0
__ehfuncinfo$?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0
__unwindtable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$2
__ehfuncinfo$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0
__ehfuncinfo$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@WCA@AEPAXI@Z
_TEXT	SEGMENT
??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@WCA@AEPAXI@Z PROC ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor', COMDAT
  00000	83 e9 20	 sub	 ecx, 32			; 00000020H
  00003	e9 00 00 00 00	 jmp	 ??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z
??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@WCA@AEPAXI@Z ENDP ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; [thunk]:CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::AlgorithmName`adjustor{4}', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::AlgorithmName
?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; [thunk]:CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::AlgorithmName`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BEPAVClonable@2@XZ
_TEXT	SEGMENT
?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BEPAVClonable@2@XZ PROC ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::Clone`adjustor{4}', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::Clone
?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3BEPAVClonable@2@XZ ENDP ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::Clone`adjustor{4}'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W7AEPAXI@Z
_TEXT	SEGMENT
??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W7AEPAXI@Z PROC ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor', COMDAT
  00000	83 e9 08	 sub	 ecx, 8
  00003	e9 00 00 00 00	 jmp	 ??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z
??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W7AEPAXI@Z ENDP ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3AEPAXI@Z
_TEXT	SEGMENT
??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3AEPAXI@Z PROC ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z
??_E?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@W3AEPAXI@Z ENDP ; [thunk]:CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@WCA@AEPAXI@Z
_TEXT	SEGMENT
??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@WCA@AEPAXI@Z PROC ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor', COMDAT
  00000	83 e9 20	 sub	 ecx, 32			; 00000020H
  00003	e9 00 00 00 00	 jmp	 ??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z
??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@WCA@AEPAXI@Z ENDP ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W7AEPAXI@Z
_TEXT	SEGMENT
??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W7AEPAXI@Z PROC ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor', COMDAT
  00000	83 e9 08	 sub	 ecx, 8
  00003	e9 00 00 00 00	 jmp	 ??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z
??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W7AEPAXI@Z ENDP ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W3AEPAXI@Z
_TEXT	SEGMENT
??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W3AEPAXI@Z PROC ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z
??_E?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@W3AEPAXI@Z ENDP ; [thunk]:CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@W3AEPAXI@Z
_TEXT	SEGMENT
??_E?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@W3AEPAXI@Z PROC ; [thunk]:CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_E?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEPAXI@Z
??_E?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@W3AEPAXI@Z ENDP ; [thunk]:CryptoPP::SourceTemplate<CryptoPP::StringStore>::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_EStringSource@CryptoPP@@W3AEPAXI@Z
_TEXT	SEGMENT
??_EStringSource@CryptoPP@@W3AEPAXI@Z PROC		; [thunk]:CryptoPP::StringSource::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_EStringSource@CryptoPP@@UAEPAXI@Z
??_EStringSource@CryptoPP@@W3AEPAXI@Z ENDP		; [thunk]:CryptoPP::StringSource::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_EStringStore@CryptoPP@@W3AEPAXI@Z
_TEXT	SEGMENT
??_EStringStore@CryptoPP@@W3AEPAXI@Z PROC		; [thunk]:CryptoPP::StringStore::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_EStringStore@CryptoPP@@UAEPAXI@Z
??_EStringStore@CryptoPP@@W3AEPAXI@Z ENDP		; [thunk]:CryptoPP::StringStore::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_EArraySink@CryptoPP@@W3AEPAXI@Z
_TEXT	SEGMENT
??_EArraySink@CryptoPP@@W3AEPAXI@Z PROC			; [thunk]:CryptoPP::ArraySink::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_EArraySink@CryptoPP@@UAEPAXI@Z
??_EArraySink@CryptoPP@@W3AEPAXI@Z ENDP			; [thunk]:CryptoPP::ArraySink::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@W3AEPAXI@Z
_TEXT	SEGMENT
??_E?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@W3AEPAXI@Z PROC ; [thunk]:CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_E?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEPAXI@Z
??_E?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@W3AEPAXI@Z ENDP ; [thunk]:CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor', COMDAT
  00000	2b 49 fc	 sub	 ecx, DWORD PTR [ecx-4]
  00003	e9 00 00 00 00	 jmp	 ??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
??_E?$basic_istream@_WU?$char_traits@_W@std@@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocs@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocs@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z PROC ; std::_Pocs<std::allocator<wchar_t> >, COMDAT

; 932  : void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 933  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_swap::value) {
; 934  :         _Swap_adl(_Left, _Right);
; 935  :     } else {
; 936  :         _STL_ASSERT(_Left == _Right, "containers incompatible for swap");
; 937  :     }
; 938  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocs@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ENDP ; std::_Pocs<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z
_TEXT	SEGMENT
__Count$ = -40						; size = 4
$T1 = -36						; size = 4
$T2 = -32						; size = 4
__Ans$ = -28						; size = 4
$T3 = -24						; size = 4
tv88 = -20						; size = 4
tv75 = -16						; size = 4
__N$ = -12						; size = 4
__S2$ = -8						; size = 4
__S1$ = -4						; size = 4
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z PROC ; std::_Traits_compare<std::char_traits<wchar_t> >, COMDAT

; 566  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00006	8b 45 14	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR __Left_size$[ebp]
  0000c	73 08		 jae	 SHORT $LN8@Traits_com
  0000e	8d 45 14	 lea	 eax, DWORD PTR __Right_size$[ebp]
  00011	89 45 f0	 mov	 DWORD PTR tv75[ebp], eax
  00014	eb 06		 jmp	 SHORT $LN9@Traits_com
$LN8@Traits_com:
  00016	8d 45 0c	 lea	 eax, DWORD PTR __Left_size$[ebp]
  00019	89 45 f0	 mov	 DWORD PTR tv75[ebp], eax
$LN9@Traits_com:
  0001c	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  0001f	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00022	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00025	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 568  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00028	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 d8	 mov	 DWORD PTR __Count$[ebp], eax

; 235  :         return _CSTD wmemcmp(

  00030	8b 45 d8	 mov	 eax, DWORD PTR __Count$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR __N$[ebp], eax
  00036	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  00039	89 45 f8	 mov	 DWORD PTR __S2$[ebp], eax
  0003c	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0003f	89 45 fc	 mov	 DWORD PTR __S1$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\wchar.h

; 215  :         for (; 0 < _N; ++_S1, ++_S2, --_N)

  00042	eb 17		 jmp	 SHORT $LN17@Traits_com
$LN15@Traits_com:
  00044	8b 45 fc	 mov	 eax, DWORD PTR __S1$[ebp]
  00047	40		 inc	 eax
  00048	40		 inc	 eax
  00049	89 45 fc	 mov	 DWORD PTR __S1$[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR __S2$[ebp]
  0004f	40		 inc	 eax
  00050	40		 inc	 eax
  00051	89 45 f8	 mov	 DWORD PTR __S2$[ebp], eax
  00054	8b 45 f4	 mov	 eax, DWORD PTR __N$[ebp]
  00057	48		 dec	 eax
  00058	89 45 f4	 mov	 DWORD PTR __N$[ebp], eax
$LN17@Traits_com:
  0005b	83 7d f4 00	 cmp	 DWORD PTR __N$[ebp], 0
  0005f	76 37		 jbe	 SHORT $LN16@Traits_com

; 216  :             if (*_S1 != *_S2)

  00061	8b 45 fc	 mov	 eax, DWORD PTR __S1$[ebp]
  00064	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00067	8b 4d f8	 mov	 ecx, DWORD PTR __S2$[ebp]
  0006a	0f b7 09	 movzx	 ecx, WORD PTR [ecx]
  0006d	3b c1		 cmp	 eax, ecx
  0006f	74 25		 je	 SHORT $LN18@Traits_com

; 217  :                 return *_S1 < *_S2 ? -1 : 1;

  00071	8b 45 fc	 mov	 eax, DWORD PTR __S1$[ebp]
  00074	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00077	8b 4d f8	 mov	 ecx, DWORD PTR __S2$[ebp]
  0007a	0f b7 09	 movzx	 ecx, WORD PTR [ecx]
  0007d	3b c1		 cmp	 eax, ecx
  0007f	7d 06		 jge	 SHORT $LN20@Traits_com
  00081	83 4d ec ff	 or	 DWORD PTR tv88[ebp], -1
  00085	eb 07		 jmp	 SHORT $LN21@Traits_com
$LN20@Traits_com:
  00087	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
$LN21@Traits_com:
  0008e	8b 45 ec	 mov	 eax, DWORD PTR tv88[ebp]
  00091	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  00094	eb 06		 jmp	 SHORT $LN14@Traits_com
$LN18@Traits_com:
  00096	eb ac		 jmp	 SHORT $LN15@Traits_com
$LN16@Traits_com:

; 218  : 
; 219  :         return 0;

  00098	83 65 e8 00	 and	 DWORD PTR $T3[ebp], 0
$LN14@Traits_com:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 235  :         return _CSTD wmemcmp(

  0009c	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  0009f	89 45 e4	 mov	 DWORD PTR __Ans$[ebp], eax

; 569  : 
; 570  :     if (_Ans != 0) {

  000a2	83 7d e4 00	 cmp	 DWORD PTR __Ans$[ebp], 0
  000a6	74 05		 je	 SHORT $LN2@Traits_com

; 571  :         return _Ans;

  000a8	8b 45 e4	 mov	 eax, DWORD PTR __Ans$[ebp]
  000ab	eb 1c		 jmp	 SHORT $LN5@Traits_com
$LN2@Traits_com:

; 572  :     }
; 573  : 
; 574  :     if (_Left_size < _Right_size) {

  000ad	8b 45 0c	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000b0	3b 45 14	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000b3	73 05		 jae	 SHORT $LN3@Traits_com

; 575  :         return -1;

  000b5	83 c8 ff	 or	 eax, -1
  000b8	eb 0f		 jmp	 SHORT $LN5@Traits_com
$LN3@Traits_com:

; 576  :     }
; 577  : 
; 578  :     if (_Left_size > _Right_size) {

  000ba	8b 45 0c	 mov	 eax, DWORD PTR __Left_size$[ebp]
  000bd	3b 45 14	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  000c0	76 05		 jbe	 SHORT $LN4@Traits_com

; 579  :         return 1;

  000c2	33 c0		 xor	 eax, eax
  000c4	40		 inc	 eax
  000c5	eb 02		 jmp	 SHORT $LN5@Traits_com
$LN4@Traits_com:

; 580  :     }
; 581  : 
; 582  :     return 0;

  000c7	33 c0		 xor	 eax, eax
$LN5@Traits_com:

; 583  : }

  000c9	c9		 leave
  000ca	c3		 ret	 0
??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z ENDP ; std::_Traits_compare<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4438 : /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4439 :     _Left.swap(_Right);

  00003	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00009	e8 00 00 00 00	 call	 ?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::swap

; 4440 : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z PROC ; std::_Med3_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >, COMDAT

; 7434 : _CONSTEXPR20 void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00004	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00007	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx
  00011	88 45 ff	 mov	 BYTE PTR $T3[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7436 :     if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  00014	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00018	85 c0		 test	 eax, eax
  0001a	74 0d		 je	 SHORT $LN2@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  0001c	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001f	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00022	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00027	59		 pop	 ecx
  00028	59		 pop	 ecx
$LN2@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00029	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0002c	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx
  00036	88 45 fe	 mov	 BYTE PTR $T2[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7440 :     if (_DEBUG_LT_PRED(_Pred, *_Last, *_Mid)) { // swap middle and last, then test first again

  00039	0f b6 45 fe	 movzx	 eax, BYTE PTR $T2[ebp]
  0003d	85 c0		 test	 eax, eax
  0003f	74 32		 je	 SHORT $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  00041	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00044	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00047	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0004c	59		 pop	 ecx
  0004d	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0004e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00051	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  00054	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx
  0005b	88 45 fd	 mov	 BYTE PTR $T1[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7443 :         if (_DEBUG_LT_PRED(_Pred, *_Mid, *_First)) {

  0005e	0f b6 45 fd	 movzx	 eax, BYTE PTR $T1[ebp]
  00062	85 c0		 test	 eax, eax
  00064	74 0d		 je	 SHORT $LN1@Med3_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  00066	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00069	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0006c	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00071	59		 pop	 ecx
  00072	59		 pop	 ecx
$LN1@Med3_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7447 : }

  00073	c9		 leave
  00074	c3		 ret	 0
??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ENDP ; std::_Med3_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Push_heap_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 1
$T2 = -36						; size = 4
$T3 = -32						; size = 1
$T4 = -28						; size = 4
_this$ = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
$T6 = -12						; size = 4
__Idx$7 = -8						; size = 4
$T8 = -1						; size = 1
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Top$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Push_heap_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z PROC ; std::_Push_heap_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >, COMDAT

; 6073 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Top, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 6074 :     // percolate _Hole to _Top or where _Val belongs
; 6075 :     using _Diff = _Iter_diff_t<_RanIt>;
; 6076 :     for (_Diff _Idx = (_Hole - 1) >> 1; // shift for codegen

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00009	48		 dec	 eax
  0000a	d1 f8		 sar	 eax, 1
  0000c	89 45 f8	 mov	 DWORD PTR __Idx$7[ebp], eax
  0000f	eb 09		 jmp	 SHORT $LN4@Push_heap_
$LN2@Push_heap_:

; 6078 :          _Idx = (_Hole - 1) >> 1) { // shift for codegen

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00014	48		 dec	 eax
  00015	d1 f8		 sar	 eax, 1
  00017	89 45 f8	 mov	 DWORD PTR __Idx$7[ebp], eax
$LN4@Push_heap_:

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  0001a	8b 45 10	 mov	 eax, DWORD PTR __Top$[ebp]
  0001d	3b 45 0c	 cmp	 eax, DWORD PTR __Hole$[ebp]
  00020	7d 5a		 jge	 SHORT $LN3@Push_heap_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00022	ff 75 14	 push	 DWORD PTR __Val$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00025	6b 45 f8 18	 imul	 eax, DWORD PTR __Idx$7[ebp], 24
  00029	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
  00034	88 45 ff	 mov	 BYTE PTR $T8[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6077 :          _Top < _Hole && _DEBUG_LT_PRED(_Pred, *(_First + _Idx), _Val); //

  00037	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0003b	85 c0		 test	 eax, eax
  0003d	74 3d		 je	 SHORT $LN3@Push_heap_

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  0003f	6b 45 f8 18	 imul	 eax, DWORD PTR __Idx$7[ebp], 24
  00043	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00046	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6080 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00049	6b 45 0c 18	 imul	 eax, DWORD PTR __Hole$[ebp], 24
  0004d	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00053	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	3b 45 e4	 cmp	 eax, DWORD PTR $T4[ebp]
  0005f	74 13		 je	 SHORT $LN14@Push_heap_

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00061	33 c0		 xor	 eax, eax
  00063	88 45 e0	 mov	 BYTE PTR $T3[ebp], al
  00066	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00069	ff 75 f4	 push	 DWORD PTR $T6[ebp]
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN14@Push_heap_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6081 :         _Hole             = _Idx;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Idx$7[ebp]
  00077	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 6082 :     }

  0007a	eb 95		 jmp	 SHORT $LN2@Push_heap_
$LN3@Push_heap_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0007c	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  0007f	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6084 :     *(_First + _Hole) = _STD forward<_Ty>(_Val); // drop _Val into final hole

  00082	6b 45 0c 18	 imul	 eax, DWORD PTR __Hole$[ebp], 24
  00086	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00089	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0008c	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  0008f	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  00092	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	3b 45 dc	 cmp	 eax, DWORD PTR $T2[ebp]
  00098	74 13		 je	 SHORT $LN1@Push_heap_

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  0009a	33 c0		 xor	 eax, eax
  0009c	88 45 d8	 mov	 BYTE PTR $T1[ebp], al
  0009f	ff 75 d8	 push	 DWORD PTR $T1[ebp]
  000a2	ff 75 ec	 push	 DWORD PTR $T5[ebp]
  000a5	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN1@Push_heap_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6085 : }

  000ad	c9		 leave
  000ae	c3		 ret	 0
??$_Push_heap_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z ENDP ; std::_Push_heap_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z PROC ; std::_Pocma<std::allocator<wchar_t> >, COMDAT

; 908  : void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 909  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 910  :         _Left = _STD move(_Right);
; 911  :     }
; 912  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ENDP ; std::_Pocma<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00033	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00036	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 1547 :         ++_Last;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 18	 add	 eax, 24			; 00000018H
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0004d	c9		 leave
  0004e	c2 04 00	 ret	 4
??$_Emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Guess_median_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z
_TEXT	SEGMENT
__Two_step$1 = -12					; size = 4
__Count$ = -8						; size = 4
__Step$2 = -4						; size = 4
__First$ = 8						; size = 4
__Mid$ = 12						; size = 4
__Last$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Guess_median_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z PROC ; std::_Guess_median_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >, COMDAT

; 7450 : _CONSTEXPR20 void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 7451 :     // sort median element to middle
; 7452 :     using _Diff        = _Iter_diff_t<_RanIt>;
; 7453 :     const _Diff _Count = _Last - _First;

  00006	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00009	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000c	99		 cdq
  0000d	6a 18		 push	 24			; 00000018H
  0000f	59		 pop	 ecx
  00010	f7 f9		 idiv	 ecx
  00012	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 7454 :     if (40 < _Count) { // Tukey's ninther

  00015	83 7d f8 28	 cmp	 DWORD PTR __Count$[ebp], 40 ; 00000028H
  00019	0f 8e 94 00 00
	00		 jle	 $LN2@Guess_medi

; 7455 :         const _Diff _Step     = (_Count + 1) >> 3; // +1 can't overflow because range was made inclusive in caller

  0001f	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	40		 inc	 eax
  00023	c1 f8 03	 sar	 eax, 3
  00026	89 45 fc	 mov	 DWORD PTR __Step$2[ebp], eax

; 7456 :         const _Diff _Two_step = _Step << 1; // note: intentionally discards low-order bit

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Step$2[ebp]
  0002c	d1 e0		 shl	 eax, 1
  0002e	89 45 f4	 mov	 DWORD PTR __Two_step$1[ebp], eax

; 7457 :         _Med3_unchecked(_First, _First + _Step, _First + _Two_step, _Pred);

  00031	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00034	6b 45 f4 18	 imul	 eax, DWORD PTR __Two_step$1[ebp], 24
  00038	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  0003b	50		 push	 eax
  0003c	6b 45 fc 18	 imul	 eax, DWORD PTR __Step$2[ebp], 24
  00040	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  00043	50		 push	 eax
  00044	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00047	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ; std::_Med3_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  0004c	83 c4 10	 add	 esp, 16			; 00000010H

; 7458 :         _Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);

  0004f	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00052	6b 45 fc 18	 imul	 eax, DWORD PTR __Step$2[ebp], 24
  00056	03 45 0c	 add	 eax, DWORD PTR __Mid$[ebp]
  00059	50		 push	 eax
  0005a	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  0005d	6b 45 fc 18	 imul	 eax, DWORD PTR __Step$2[ebp], 24
  00061	8b 4d 0c	 mov	 ecx, DWORD PTR __Mid$[ebp]
  00064	2b c8		 sub	 ecx, eax
  00066	51		 push	 ecx
  00067	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ; std::_Med3_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  0006c	83 c4 10	 add	 esp, 16			; 00000010H

; 7459 :         _Med3_unchecked(_Last - _Two_step, _Last - _Step, _Last, _Pred);

  0006f	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00072	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  00075	6b 45 fc 18	 imul	 eax, DWORD PTR __Step$2[ebp], 24
  00079	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0007c	2b c8		 sub	 ecx, eax
  0007e	51		 push	 ecx
  0007f	6b 45 f4 18	 imul	 eax, DWORD PTR __Two_step$1[ebp], 24
  00083	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  00086	2b c8		 sub	 ecx, eax
  00088	51		 push	 ecx
  00089	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ; std::_Med3_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 7460 :         _Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);

  00091	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00094	6b 45 fc 18	 imul	 eax, DWORD PTR __Step$2[ebp], 24
  00098	8b 4d 10	 mov	 ecx, DWORD PTR __Last$[ebp]
  0009b	2b c8		 sub	 ecx, eax
  0009d	51		 push	 ecx
  0009e	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000a1	6b 45 fc 18	 imul	 eax, DWORD PTR __Step$2[ebp], 24
  000a5	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ; std::_Med3_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  000ae	83 c4 10	 add	 esp, 16			; 00000010H

; 7461 :     } else {

  000b1	eb 14		 jmp	 SHORT $LN1@Guess_medi
$LN2@Guess_medi:

; 7462 :         _Med3_unchecked(_First, _Mid, _Last, _Pred);

  000b3	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000b6	ff 75 10	 push	 DWORD PTR __Last$[ebp]
  000b9	ff 75 0c	 push	 DWORD PTR __Mid$[ebp]
  000bc	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000bf	e8 00 00 00 00	 call	 ??$_Med3_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ; std::_Med3_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  000c4	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Guess_medi:

; 7463 :     }
; 7464 : }

  000c7	c9		 leave
  000c8	c3		 ret	 0
??$_Guess_median_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ENDP ; std::_Guess_median_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 1
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
__Val$8 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z PROC ; std::_Pop_heap_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >, COMDAT

; 6226 : _CONSTEXPR20 void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 6227 :     // pop *_First to *(_Last - 1) and reheap
; 6228 :     if (2 <= _Last - _First) {

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002b	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0002e	99		 cdq
  0002f	6a 18		 push	 24			; 00000018H
  00031	59		 pop	 ecx
  00032	f7 f9		 idiv	 ecx
  00034	83 f8 02	 cmp	 eax, 2
  00037	7c 7d		 jl	 SHORT $LN1@Pop_heap_u

; 6229 :         --_Last;

  00039	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0003c	83 e8 18	 sub	 eax, 24			; 00000018H
  0003f	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00045	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6230 :         _Iter_value_t<_RanIt> _Val = _STD move(*_Last);

  00048	ff 75 d0	 push	 DWORD PTR $T6[ebp]
  0004b	8d 4d d8	 lea	 ecx, DWORD PTR __Val$8[ebp]
  0004e	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00053	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00057	8d 45 d8	 lea	 eax, DWORD PTR __Val$8[ebp]
  0005a	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  0005d	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00060	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00063	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00066	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  00069	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0006c	3b 45 cc	 cmp	 eax, DWORD PTR $T5[ebp]
  0006f	74 13		 je	 SHORT $LN63@Pop_heap_u

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00071	33 c0		 xor	 eax, eax
  00073	88 45 c8	 mov	 BYTE PTR $T4[ebp], al
  00076	ff 75 c8	 push	 DWORD PTR $T4[ebp]
  00079	ff 75 d4	 push	 DWORD PTR $T7[ebp]
  0007c	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0007f	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN63@Pop_heap_u:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00084	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00087	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6221 :     _Pop_heap_hole_by_index(

  0008a	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0008d	ff 75 c0	 push	 DWORD PTR $T2[ebp]
  00090	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00093	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00096	99		 cdq
  00097	6a 18		 push	 24			; 00000018H
  00099	59		 pop	 ecx
  0009a	f7 f9		 idiv	 ecx
  0009c	50		 push	 eax
  0009d	6a 00		 push	 0
  0009f	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000a2	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >
  000a7	83 c4 14	 add	 esp, 20			; 00000014H

; 6231 :         _Pop_heap_hole_unchecked(_First, _Last, _Last, _STD move(_Val), _Pred);
; 6232 :     }

  000aa	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000ae	8d 4d d8	 lea	 ecx, DWORD PTR __Val$8[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
$LN1@Pop_heap_u:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6233 : }

  000b6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c0	59		 pop	 ecx
  000c1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c4	33 cd		 xor	 ecx, ebp
  000c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cb	c9		 leave
  000cc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Val$8[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ENDP ; std::_Pop_heap_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Pop_heap_hole_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z
_TEXT	SEGMENT
__Top$ = -52						; size = 4
$T1 = -48						; size = 4
$T2 = -44						; size = 1
$T3 = -40						; size = 4
$T4 = -36						; size = 1
$T5 = -32						; size = 4
_this$ = -28						; size = 4
$T6 = -24						; size = 4
__Max_sequence_non_leaf$ = -20				; size = 4
_this$ = -16						; size = 4
$T7 = -12						; size = 4
__Idx$ = -8						; size = 4
$T8 = -1						; size = 1
__First$ = 8						; size = 4
__Hole$ = 12						; size = 4
__Bottom$ = 16						; size = 4
__Val$ = 20						; size = 4
__Pred$ = 24						; size = 1
??$_Pop_heap_hole_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z PROC ; std::_Pop_heap_hole_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >, COMDAT

; 6186 :     _RanIt _First, _Iter_diff_t<_RanIt> _Hole, _Iter_diff_t<_RanIt> _Bottom, _Ty&& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 6187 :     // percolate _Hole to _Bottom, then push _Val
; 6188 :     _STL_INTERNAL_CHECK(_Bottom > 0);
; 6189 : 
; 6190 :     using _Diff      = _Iter_diff_t<_RanIt>;
; 6191 :     const _Diff _Top = _Hole;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  00009	89 45 cc	 mov	 DWORD PTR __Top$[ebp], eax

; 6192 :     _Diff _Idx       = _Hole;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Hole$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax

; 6193 : 
; 6194 :     // Check whether _Idx can have a child before calculating that child's index, since
; 6195 :     // calculating the child's index can trigger integer overflows
; 6196 :     const _Diff _Max_sequence_non_leaf = (_Bottom - 1) >> 1; // shift for codegen

  00012	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  00015	48		 dec	 eax
  00016	d1 f8		 sar	 eax, 1
  00018	89 45 ec	 mov	 DWORD PTR __Max_sequence_non_leaf$[ebp], eax
$LN2@Pop_heap_h:

; 6197 :     while (_Idx < _Max_sequence_non_leaf) { // move _Hole down to larger child

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  0001e	3b 45 ec	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  00021	7d 73		 jge	 SHORT $LN3@Pop_heap_h

; 6198 :         _Idx = 2 * _Idx + 2;

  00023	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00026	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0002a	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00030	48		 dec	 eax
  00031	6b c0 18	 imul	 eax, eax, 24
  00034	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00037	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  00038	6b 45 f8 18	 imul	 eax, DWORD PTR __Idx$[ebp], 24
  0003c	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx
  00047	88 45 ff	 mov	 BYTE PTR $T8[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6199 :         if (_DEBUG_LT_PRED(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)))) {

  0004a	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0004e	85 c0		 test	 eax, eax
  00050	74 07		 je	 SHORT $LN4@Pop_heap_h

; 6200 :             --_Idx;

  00052	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00055	48		 dec	 eax
  00056	89 45 f8	 mov	 DWORD PTR __Idx$[ebp], eax
$LN4@Pop_heap_h:

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00059	6b 45 f8 18	 imul	 eax, DWORD PTR __Idx$[ebp], 24
  0005d	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00060	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6202 :         *(_First + _Hole) = _STD move(*(_First + _Idx));

  00063	6b 45 0c 18	 imul	 eax, DWORD PTR __Hole$[ebp], 24
  00067	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  0006a	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0006d	8b 45 f4	 mov	 eax, DWORD PTR $T7[ebp]
  00070	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  00073	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00076	3b 45 e0	 cmp	 eax, DWORD PTR $T5[ebp]
  00079	74 13		 je	 SHORT $LN15@Pop_heap_h

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  0007b	33 c0		 xor	 eax, eax
  0007d	88 45 dc	 mov	 BYTE PTR $T4[ebp], al
  00080	ff 75 dc	 push	 DWORD PTR $T4[ebp]
  00083	ff 75 f4	 push	 DWORD PTR $T7[ebp]
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN15@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6203 :         _Hole             = _Idx;

  0008e	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00091	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax

; 6204 :     }

  00094	eb 85		 jmp	 SHORT $LN2@Pop_heap_h
$LN3@Pop_heap_h:

; 6205 : 
; 6206 :     if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0) { // only child at bottom, move _Hole down to it

  00096	8b 45 f8	 mov	 eax, DWORD PTR __Idx$[ebp]
  00099	3b 45 ec	 cmp	 eax, DWORD PTR __Max_sequence_non_leaf$[ebp]
  0009c	75 52		 jne	 SHORT $LN5@Pop_heap_h
  0009e	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000a1	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000a6	79 05		 jns	 SHORT $LN193@Pop_heap_h
  000a8	48		 dec	 eax
  000a9	83 c8 fe	 or	 eax, -2			; fffffffeH
  000ac	40		 inc	 eax
$LN193@Pop_heap_h:
  000ad	85 c0		 test	 eax, eax
  000af	75 3f		 jne	 SHORT $LN5@Pop_heap_h

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000b1	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000b4	48		 dec	 eax
  000b5	6b c0 18	 imul	 eax, eax, 24
  000b8	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000bb	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6207 :         *(_First + _Hole) = _STD move(*(_First + (_Bottom - 1)));

  000be	6b 45 0c 18	 imul	 eax, DWORD PTR __Hole$[ebp], 24
  000c2	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
  000c5	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000c8	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  000cb	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  000ce	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	3b 45 d8	 cmp	 eax, DWORD PTR $T3[ebp]
  000d4	74 13		 je	 SHORT $LN58@Pop_heap_h

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  000d6	33 c0		 xor	 eax, eax
  000d8	88 45 d4	 mov	 BYTE PTR $T2[ebp], al
  000db	ff 75 d4	 push	 DWORD PTR $T2[ebp]
  000de	ff 75 e8	 push	 DWORD PTR $T6[ebp]
  000e1	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN58@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6208 :         _Hole             = _Bottom - 1;

  000e9	8b 45 10	 mov	 eax, DWORD PTR __Bottom$[ebp]
  000ec	48		 dec	 eax
  000ed	89 45 0c	 mov	 DWORD PTR __Hole$[ebp], eax
$LN5@Pop_heap_h:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000f0	8b 45 14	 mov	 eax, DWORD PTR __Val$[ebp]
  000f3	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6211 :     _Push_heap_by_index(_First, _Hole, _Top, _STD forward<_Ty>(_Val), _Pred);

  000f6	ff 75 18	 push	 DWORD PTR __Pred$[ebp]
  000f9	ff 75 d0	 push	 DWORD PTR $T1[ebp]
  000fc	ff 75 cc	 push	 DWORD PTR __Top$[ebp]
  000ff	ff 75 0c	 push	 DWORD PTR __Hole$[ebp]
  00102	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00105	e8 00 00 00 00	 call	 ??$_Push_heap_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z ; std::_Push_heap_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >
  0010a	83 c4 14	 add	 esp, 20			; 00000014H

; 6212 : }

  0010d	c9		 leave
  0010e	c3		 ret	 0
??$_Pop_heap_hole_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z ENDP ; std::_Pop_heap_hole_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00@Z
_TEXT	SEGMENT
$T1 = -12						; size = 1
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00@Z PROC ; std::_Move_backward_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>, COMDAT

; 4688 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
$LN2@Move_backw:

; 4689 :     // move [_First, _Last) backwards to [..., _Dest)
; 4690 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 4691 :     if constexpr (_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable) {
; 4692 : #ifdef __cpp_lib_is_constant_evaluated
; 4693 :         if (!_STD is_constant_evaluated())
; 4694 : #endif // __cpp_lib_is_constant_evaluated
; 4695 :         {
; 4696 :             return _Copy_backward_memmove(_First, _Last, _Dest);
; 4697 :         }
; 4698 :     }
; 4699 : 
; 4700 :     while (_First != _Last) {

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000c	74 3b		 je	 SHORT $LN3@Move_backw

; 4701 :         *--_Dest = _STD move(*--_Last);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	83 e8 18	 sub	 eax, 24			; 00000018H
  00014	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
  00017	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001a	83 e8 18	 sub	 eax, 24			; 00000018H
  0001d	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00020	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00023	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00026	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00029	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  0002c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0002f	3b 45 f8	 cmp	 eax, DWORD PTR $T2[ebp]
  00032	74 13		 je	 SHORT $LN10@Move_backw

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00034	33 c0		 xor	 eax, eax
  00036	88 45 f4	 mov	 BYTE PTR $T1[ebp], al
  00039	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0003c	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN10@Move_backw:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4702 :     }

  00047	eb bd		 jmp	 SHORT $LN2@Move_backw
$LN3@Move_backw:

; 4703 : 
; 4704 :     return _Dest;

  00049	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 4705 : }

  0004c	c9		 leave
  0004d	c3		 ret	 0
??$_Move_backward_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00@Z ENDP ; std::_Move_backward_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z PROC ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4586 :     const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4587 :     return _Left.compare(_Right) < 0;

  00004	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000a	e8 00 00 00 00	 call	 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
  0000f	85 c0		 test	 eax, eax
  00011	7d 09		 jge	 SHORT $LN3@operator
  00013	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001a	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001c	83 65 fc 00	 and	 DWORD PTR tv68[ebp], 0
$LN4@operator:
  00020	8a 45 fc	 mov	 al, BYTE PTR tv68[ebp]

; 4588 : }

  00023	c9		 leave
  00024	c3		 ret	 0
??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ENDP ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 18	 add	 eax, 24			; 00000018H
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
_TEXT	SEGMENT
__Oldwidth$2 = -56					; size = 8
__Ok$ = -48						; size = 8
$T3 = -40						; size = 8
$T4 = -32						; size = 8
tv464 = -24						; size = 8
__$EHRec$ = -16						; size = 16
tv337 = 0						; size = 8
$T5 = 8							; size = 8
$T6 = 16						; size = 4
$T7 = 20						; size = 4
$T8 = 24						; size = 4
$T9 = 28						; size = 4
$T10 = 32						; size = 2
$T11 = 36						; size = 4
$T12 = 40						; size = 2
$T13 = 44						; size = 4
tv326 = 48						; size = 4
tv297 = 52						; size = 4
_this$ = 56						; size = 4
tv307 = 60						; size = 4
$T14 = 64						; size = 4
tv290 = 68						; size = 4
_this$ = 72						; size = 4
_this$ = 76						; size = 4
$T15 = 80						; size = 2
$T16 = 82						; size = 2
tv343 = 84						; size = 2
$T17 = 86						; size = 2
$T18 = 88						; size = 2
tv135 = 90						; size = 2
__Pad$ = 92						; size = 4
$T19 = 97						; size = 1
$T20 = 98						; size = 1
$T21 = 99						; size = 1
__State$ = 100						; size = 4
__Ostr$ = 112						; size = 4
__Data$ = 116						; size = 4
__Size$ = 120						; size = 4
??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z PROC ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>, COMDAT

; 479  :     basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size) {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	83 ec 68	 sub	 esp, 104		; 00000068H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 28	 sub	 esp, 40			; 00000028H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 480  :     // insert a character-type sequence into _Ostr as if through a basic_string copy
; 481  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 482  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

  00031	83 65 64 00	 and	 DWORD PTR __State$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  00035	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00038	8b 00		 mov	 eax, DWORD PTR [eax]
  0003a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003d	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00040	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  00044	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  00048	89 55 08	 mov	 DWORD PTR $T5[ebp], edx
  0004b	89 45 0c	 mov	 DWORD PTR $T5[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 485  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  0004e	83 7d 0c 00	 cmp	 DWORD PTR $T5[ebp+4], 0
  00052	7c 29		 jl	 SHORT $LN10@Insert_str
  00054	7f 06		 jg	 SHORT $LN141@Insert_str
  00056	83 7d 08 00	 cmp	 DWORD PTR $T5[ebp], 0
  0005a	76 21		 jbe	 SHORT $LN10@Insert_str
$LN141@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  0005c	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00067	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  0006b	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  0006f	89 55 e0	 mov	 DWORD PTR $T4[ebp], edx
  00072	89 45 e4	 mov	 DWORD PTR $T4[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 485  :     if (_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size) {

  00075	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00078	3b 45 78	 cmp	 eax, DWORD PTR __Size$[ebp]
  0007b	77 06		 ja	 SHORT $LN8@Insert_str
$LN10@Insert_str:

; 486  :         _Pad = 0;

  0007d	83 65 5c 00	 and	 DWORD PTR __Pad$[ebp], 0

; 487  :     } else {

  00081	eb 22		 jmp	 SHORT $LN9@Insert_str
$LN8@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  00083	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00086	8b 00		 mov	 eax, DWORD PTR [eax]
  00088	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008b	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0008e	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  00092	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  00096	89 55 d8	 mov	 DWORD PTR $T3[ebp], edx
  00099	89 45 dc	 mov	 DWORD PTR $T3[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 488  :         _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;

  0009c	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0009f	2b 45 78	 sub	 eax, DWORD PTR __Size$[ebp]
  000a2	89 45 5c	 mov	 DWORD PTR __Pad$[ebp], eax
$LN9@Insert_str:

; 489  :     }
; 490  : 
; 491  :     const typename _Ostr_t::sentry _Ok(_Ostr);

  000a5	ff 75 70	 push	 DWORD PTR __Ostr$[ebp]
  000a8	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000ab	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  000b0	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 125  :             return _Ok;

  000b4	8a 45 d4	 mov	 al, BYTE PTR __Ok$[ebp+4]
  000b7	88 45 63	 mov	 BYTE PTR $T21[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 493  :     if (!_Ok) {

  000ba	0f b6 45 63	 movzx	 eax, BYTE PTR $T21[ebp]
  000be	85 c0		 test	 eax, eax
  000c0	75 0e		 jne	 SHORT $LN11@Insert_str

; 494  :         _State |= _Ostr_t::badbit;

  000c2	8b 45 64	 mov	 eax, DWORD PTR __State$[ebp]
  000c5	83 c8 04	 or	 eax, 4
  000c8	89 45 64	 mov	 DWORD PTR __State$[ebp], eax

; 495  :     } else { // state okay, insert characters

  000cb	e9 18 02 00 00	 jmp	 $LN12@Insert_str
$LN11@Insert_str:

; 496  :         _TRY_IO_BEGIN

  000d0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 326  :         return _Fmtfl;

  000d4	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]
  000d9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dc	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000df	8b 44 01 14	 mov	 eax, DWORD PTR [ecx+eax+20]
  000e3	89 45 2c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 497  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {

  000e6	8b 45 2c	 mov	 eax, DWORD PTR $T13[ebp]
  000e9	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000ee	83 f8 40	 cmp	 eax, 64			; 00000040H
  000f1	0f 84 8c 00 00
	00		 je	 $LN14@Insert_str

; 498  :             for (; 0 < _Pad; --_Pad) { // pad on left

  000f7	eb 07		 jmp	 SHORT $LN4@Insert_str
$LN2@Insert_str:
  000f9	8b 45 5c	 mov	 eax, DWORD PTR __Pad$[ebp]
  000fc	48		 dec	 eax
  000fd	89 45 5c	 mov	 DWORD PTR __Pad$[ebp], eax
$LN4@Insert_str:
  00100	83 7d 5c 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00104	76 7d		 jbe	 SHORT $LN14@Insert_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 101  :         return _Fillch;

  00106	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00109	8b 00		 mov	 eax, DWORD PTR [eax]
  0010b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0010e	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00111	66 8b 44 01 40	 mov	 ax, WORD PTR [ecx+eax+64]
  00116	66 89 45 28	 mov	 WORD PTR $T12[ebp], ax

; 80   :         return _Mystrbuf;

  0011a	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0011d	8b 00		 mov	 eax, DWORD PTR [eax]
  0011f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00122	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00125	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00129	89 45 24	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 499  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0012c	ff 75 28	 push	 DWORD PTR $T12[ebp]
  0012f	8b 4d 24	 mov	 ecx, DWORD PTR $T11[ebp]
  00132	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
  00137	66 89 45 5a	 mov	 WORD PTR tv135[ebp], ax
  0013b	66 8b 45 5a	 mov	 ax, WORD PTR tv135[ebp]
  0013f	66 89 45 58	 mov	 WORD PTR $T18[ebp], ax

; 309  :         return WEOF;

  00143	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00148	66 89 45 56	 mov	 WORD PTR $T17[ebp], ax

; 301  :         return _Left == _Right;

  0014c	0f b7 45 58	 movzx	 eax, WORD PTR $T18[ebp]
  00150	0f b7 4d 56	 movzx	 ecx, WORD PTR $T17[ebp]
  00154	3b c8		 cmp	 ecx, eax
  00156	75 09		 jne	 SHORT $LN60@Insert_str
  00158	c7 45 44 01 00
	00 00		 mov	 DWORD PTR tv290[ebp], 1
  0015f	eb 04		 jmp	 SHORT $LN61@Insert_str
$LN60@Insert_str:
  00161	83 65 44 00	 and	 DWORD PTR tv290[ebp], 0
$LN61@Insert_str:
  00165	8a 45 44	 mov	 al, BYTE PTR tv290[ebp]
  00168	88 45 62	 mov	 BYTE PTR $T20[ebp], al

; 499  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0016b	0f b6 45 62	 movzx	 eax, BYTE PTR $T20[ebp]
  0016f	85 c0		 test	 eax, eax
  00171	74 0b		 je	 SHORT $LN15@Insert_str

; 500  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  00173	8b 45 64	 mov	 eax, DWORD PTR __State$[ebp]
  00176	83 c8 04	 or	 eax, 4
  00179	89 45 64	 mov	 DWORD PTR __State$[ebp], eax

; 501  :                     break;

  0017c	eb 05		 jmp	 SHORT $LN14@Insert_str
$LN15@Insert_str:

; 502  :                 }
; 503  :             }

  0017e	e9 76 ff ff ff	 jmp	 $LN2@Insert_str
$LN14@Insert_str:

; 507  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  00183	83 7d 64 00	 cmp	 DWORD PTR __State$[ebp], 0
  00187	75 56		 jne	 SHORT $LN16@Insert_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  00189	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0018c	8b 00		 mov	 eax, DWORD PTR [eax]
  0018e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00191	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00194	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00198	89 45 40	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 507  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  0019b	8b 45 78	 mov	 eax, DWORD PTR __Size$[ebp]
  0019e	33 c9		 xor	 ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 172  :         return xsputn(_Ptr, _Count);

  001a0	51		 push	 ecx
  001a1	50		 push	 eax
  001a2	ff 75 74	 push	 DWORD PTR __Data$[ebp]
  001a5	8b 45 40	 mov	 eax, DWORD PTR $T14[ebp]
  001a8	8b 00		 mov	 eax, DWORD PTR [eax]
  001aa	8b 4d 40	 mov	 ecx, DWORD PTR $T14[ebp]
  001ad	ff 50 24	 call	 DWORD PTR [eax+36]
  001b0	89 45 00	 mov	 DWORD PTR tv337[ebp], eax
  001b3	89 55 04	 mov	 DWORD PTR tv337[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 507  :             && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size)) {

  001b6	8b 45 78	 mov	 eax, DWORD PTR __Size$[ebp]
  001b9	33 c9		 xor	 ecx, ecx
  001bb	89 45 e8	 mov	 DWORD PTR tv464[ebp], eax
  001be	89 4d ec	 mov	 DWORD PTR tv464[ebp+4], ecx
  001c1	8b 45 00	 mov	 eax, DWORD PTR tv337[ebp]
  001c4	3b 45 e8	 cmp	 eax, DWORD PTR tv464[ebp]
  001c7	75 08		 jne	 SHORT $LN142@Insert_str
  001c9	8b 45 04	 mov	 eax, DWORD PTR tv337[ebp+4]
  001cc	3b 45 ec	 cmp	 eax, DWORD PTR tv464[ebp+4]
  001cf	74 0e		 je	 SHORT $LN16@Insert_str
$LN142@Insert_str:

; 508  :             _State |= _Ostr_t::badbit;

  001d1	8b 45 64	 mov	 eax, DWORD PTR __State$[ebp]
  001d4	83 c8 04	 or	 eax, 4
  001d7	89 45 64	 mov	 DWORD PTR __State$[ebp], eax

; 509  :         } else {

  001da	e9 8c 00 00 00	 jmp	 $LN17@Insert_str
$LN16@Insert_str:

; 510  :             for (; 0 < _Pad; --_Pad) { // pad on right

  001df	eb 07		 jmp	 SHORT $LN7@Insert_str
$LN5@Insert_str:
  001e1	8b 45 5c	 mov	 eax, DWORD PTR __Pad$[ebp]
  001e4	48		 dec	 eax
  001e5	89 45 5c	 mov	 DWORD PTR __Pad$[ebp], eax
$LN7@Insert_str:
  001e8	83 7d 5c 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  001ec	76 7d		 jbe	 SHORT $LN17@Insert_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 101  :         return _Fillch;

  001ee	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001f1	8b 00		 mov	 eax, DWORD PTR [eax]
  001f3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001f6	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001f9	66 8b 44 01 40	 mov	 ax, WORD PTR [ecx+eax+64]
  001fe	66 89 45 20	 mov	 WORD PTR $T10[ebp], ax

; 80   :         return _Mystrbuf;

  00202	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00205	8b 00		 mov	 eax, DWORD PTR [eax]
  00207	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0020a	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0020d	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00211	89 45 1c	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 511  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00214	ff 75 20	 push	 DWORD PTR $T10[ebp]
  00217	8b 4d 1c	 mov	 ecx, DWORD PTR $T9[ebp]
  0021a	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
  0021f	66 89 45 54	 mov	 WORD PTR tv343[ebp], ax
  00223	66 8b 45 54	 mov	 ax, WORD PTR tv343[ebp]
  00227	66 89 45 52	 mov	 WORD PTR $T16[ebp], ax

; 309  :         return WEOF;

  0022b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00230	66 89 45 50	 mov	 WORD PTR $T15[ebp], ax

; 301  :         return _Left == _Right;

  00234	0f b7 45 52	 movzx	 eax, WORD PTR $T16[ebp]
  00238	0f b7 4d 50	 movzx	 ecx, WORD PTR $T15[ebp]
  0023c	3b c8		 cmp	 ecx, eax
  0023e	75 09		 jne	 SHORT $LN92@Insert_str
  00240	c7 45 3c 01 00
	00 00		 mov	 DWORD PTR tv307[ebp], 1
  00247	eb 04		 jmp	 SHORT $LN93@Insert_str
$LN92@Insert_str:
  00249	83 65 3c 00	 and	 DWORD PTR tv307[ebp], 0
$LN93@Insert_str:
  0024d	8a 45 3c	 mov	 al, BYTE PTR tv307[ebp]
  00250	88 45 61	 mov	 BYTE PTR $T19[ebp], al

; 511  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00253	0f b6 45 61	 movzx	 eax, BYTE PTR $T19[ebp]
  00257	85 c0		 test	 eax, eax
  00259	74 0b		 je	 SHORT $LN18@Insert_str

; 512  :                     _State |= _Ostr_t::badbit; // insertion failed, quit

  0025b	8b 45 64	 mov	 eax, DWORD PTR __State$[ebp]
  0025e	83 c8 04	 or	 eax, 4
  00261	89 45 64	 mov	 DWORD PTR __State$[ebp], eax

; 513  :                     break;

  00264	eb 05		 jmp	 SHORT $LN17@Insert_str
$LN18@Insert_str:

; 514  :                 }
; 515  :             }

  00266	e9 76 ff ff ff	 jmp	 $LN5@Insert_str
$LN17@Insert_str:

; 518  :         _Ostr.width(0);

  0026b	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0026e	8b 00		 mov	 eax, DWORD PTR [eax]
  00270	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00273	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00276	89 4d 38	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 367  :         const streamsize _Oldwidth = _Wide;

  00279	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  0027c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0027f	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00282	89 4d c8	 mov	 DWORD PTR __Oldwidth$2[ebp], ecx
  00285	89 45 cc	 mov	 DWORD PTR __Oldwidth$2[ebp+4], eax

; 368  :         _Wide                      = _Newwidth;

  00288	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  0028b	33 c9		 xor	 ecx, ecx
  0028d	33 d2		 xor	 edx, edx
  0028f	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00292	89 50 24	 mov	 DWORD PTR [eax+36], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 518  :         _Ostr.width(0);

  00295	eb 47		 jmp	 SHORT $LN20@Insert_str
__catch$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$0:

; 519  :         _CATCH_IO_(_Ostr_t, _Ostr)

  00297	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0029a	8b 00		 mov	 eax, DWORD PTR [eax]
  0029c	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0029f	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  002a2	89 4d 4c	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  002a5	8b 45 4c	 mov	 eax, DWORD PTR _this$[ebp]
  002a8	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002ab	89 45 18	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  002ae	8b 45 4c	 mov	 eax, DWORD PTR _this$[ebp]
  002b1	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  002b5	74 06		 je	 SHORT $LN103@Insert_str
  002b7	83 65 34 00	 and	 DWORD PTR tv297[ebp], 0
  002bb	eb 07		 jmp	 SHORT $LN104@Insert_str
$LN103@Insert_str:
  002bd	c7 45 34 04 00
	00 00		 mov	 DWORD PTR tv297[ebp], 4
$LN104@Insert_str:
  002c4	6a 01		 push	 1

; 53   :         clear(rdstate() | _State, _Reraise);

  002c6	8b 45 18	 mov	 eax, DWORD PTR $T8[ebp]
  002c9	83 c8 04	 or	 eax, 4

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  002cc	0b 45 34	 or	 eax, DWORD PTR tv297[ebp]
  002cf	50		 push	 eax
  002d0	8b 4d 4c	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 519  :         _CATCH_IO_(_Ostr_t, _Ostr)

  002d8	b8 00 00 00 00	 mov	 eax, $LN24@Insert_str
  002dd	c3		 ret	 0
$LN20@Insert_str:
  002de	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  002e2	eb 04		 jmp	 SHORT $LN12@Insert_str
$LN24@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
  002e4	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
$LN12@Insert_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 520  :     }
; 521  : 
; 522  :     _Ostr.setstate(_State);

  002e8	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002eb	8b 00		 mov	 eax, DWORD PTR [eax]
  002ed	8b 4d 70	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002f0	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  002f3	89 4d 48	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  002f6	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  002f9	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002fc	89 45 14	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  002ff	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00302	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00306	74 06		 je	 SHORT $LN119@Insert_str
  00308	83 65 30 00	 and	 DWORD PTR tv326[ebp], 0
  0030c	eb 07		 jmp	 SHORT $LN120@Insert_str
$LN119@Insert_str:
  0030e	c7 45 30 04 00
	00 00		 mov	 DWORD PTR tv326[ebp], 4
$LN120@Insert_str:
  00315	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  00317	8b 45 14	 mov	 eax, DWORD PTR $T7[ebp]
  0031a	0b 45 64	 or	 eax, DWORD PTR __State$[ebp]

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0031d	0b 45 30	 or	 eax, DWORD PTR tv326[ebp]
  00320	50		 push	 eax
  00321	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  00324	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 523  :     return _Ostr;

  00329	8b 45 70	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0032c	89 45 10	 mov	 DWORD PTR $T6[ebp], eax
  0032f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00333	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00336	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  0033b	8b 45 10	 mov	 eax, DWORD PTR $T6[ebp]

; 524  : }

  0033e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00341	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00348	59		 pop	 ecx
  00349	5f		 pop	 edi
  0034a	5e		 pop	 esi
  0034b	5b		 pop	 ebx
  0034c	83 c5 68	 add	 ebp, 104		; 00000068H
  0034f	c9		 leave
  00350	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z$2:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ENDP ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -40					; size = 4
___formal$ = -36					; size = 4
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_v$ = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$6 = -1				; size = 1
?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::create_node, COMDAT
; _this$ = ecx

; 1983 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1985 :         node_ = node_allocator_traits::allocate(alloc_, 1);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 dc	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00011	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$6[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00015	c7 45 d8 ff ff
	ff 0f		 mov	 DWORD PTR __Max_possible$1[ebp], 268435455 ; 0fffffffH

; 60   :         if (_Count > _Max_possible) {

  0001c	33 c0		 xor	 eax, eax
  0001e	40		 inc	 eax
  0001f	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  00024	76 05		 jbe	 SHORT $LN6@create_nod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00026	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@create_nod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0002b	33 c0		 xor	 eax, eax
  0002d	40		 inc	 eax
  0002e	c1 e0 04	 shl	 eax, 4
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  00034	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  00037	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0003c	59		 pop	 ecx
  0003d	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1985 :         node_ = node_allocator_traits::allocate(alloc_, 1);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00046	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1986 :         new ((void*)boost::to_address(node_)) node();

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	89 45 e8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00052	8b 45 e8	 mov	 eax, DWORD PTR _v$[ebp]
  00055	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00058	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  0005b	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2579 :         ptr_bucket() : next_(0) {}

  0005e	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00061	83 20 00	 and	 DWORD PTR [eax], 0

; 4865 :         ptr_node() : bucket_base(), bucket_info_(0) {}

  00064	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00067	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0006b	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  0006e	83 c0 08	 add	 eax, 8
  00071	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax

; 754  :         value_base() : data_() {}

  00074	33 c0		 xor	 eax, eax
  00076	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	89 01		 mov	 DWORD PTR [ecx], eax
  0007b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN9@create_nod:

; 1987 :       }

  0007e	c9		 leave
  0007f	c3		 ret	 0
?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::create_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
_v$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ PROC ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >, COMDAT
; _this$ = ecx

; 1975 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1976 :         if (node_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 31		 je	 SHORT $LN3@node_const

; 1977 :           boost::unordered::detail::func::destroy(boost::to_address(node_));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1978 :           node_allocator_traits::deallocate(alloc_, node_, 1);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	c1 e0 04	 shl	 eax, 4
  00038	50		 push	 eax
  00039	ff 75 f4	 push	 DWORD PTR __Ptr$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx
$LN3@node_const:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1980 :       }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ENDP ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Partition_by_median_guess_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
__Left$ = -36						; size = 4
__Right$ = -32						; size = 4
__Right$ = -28						; size = 4
__Left$ = -24						; size = 4
__Left$ = -20						; size = 4
__Right$ = -16						; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
__Left$ = -4						; size = 4
__Left$ = 0						; size = 4
__Right$ = 4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
__Left$ = 16						; size = 4
__Left$ = 20						; size = 4
__Right$ = 24						; size = 4
__Left$ = 28						; size = 4
__Right$ = 32						; size = 4
__Left$ = 36						; size = 4
__Right$ = 40						; size = 4
__Mid$ = 44						; size = 4
__First$ = 48						; size = 4
__First$ = 52						; size = 4
__First$ = 56						; size = 4
__First$ = 60						; size = 4
__First$ = 64						; size = 4
__First$ = 68						; size = 4
__First$ = 72						; size = 4
__First$ = 76						; size = 4
$T3 = 80						; size = 1
$T4 = 81						; size = 1
$T5 = 82						; size = 1
$T6 = 83						; size = 1
$T7 = 84						; size = 1
$T8 = 85						; size = 1
$T9 = 86						; size = 1
$T10 = 87						; size = 1
__Gfirst$ = 88						; size = 4
__Glast$ = 92						; size = 4
__Plast$ = 96						; size = 4
__Pfirst$ = 100						; size = 4
___$ReturnUdt$ = 112					; size = 4
__First$ = 116						; size = 4
__Last$ = 120						; size = 4
__Pred$ = 124						; size = 1
??$_Partition_by_median_guess_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z PROC ; std::_Partition_by_median_guess_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >, COMDAT

; 7467 : _CONSTEXPR20 pair<_RanIt, _RanIt> _Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH

; 7468 :     // partition [_First, _Last)
; 7469 :     _RanIt _Mid = _First + ((_Last - _First) >> 1); // shift for codegen

  0000b	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	2b 45 74	 sub	 eax, DWORD PTR __First$[ebp]
  00011	99		 cdq
  00012	6a 18		 push	 24			; 00000018H
  00014	59		 pop	 ecx
  00015	f7 f9		 idiv	 ecx
  00017	d1 f8		 sar	 eax, 1
  00019	6b c0 18	 imul	 eax, eax, 24
  0001c	03 45 74	 add	 eax, DWORD PTR __First$[ebp]
  0001f	89 45 2c	 mov	 DWORD PTR __Mid$[ebp], eax

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  00022	8b 45 78	 mov	 eax, DWORD PTR __Last$[ebp]
  00025	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00028	8b 45 4c	 mov	 eax, DWORD PTR __First$[ebp]
  0002b	83 e8 18	 sub	 eax, 24			; 00000018H
  0002e	89 45 4c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7470 :     _Guess_median_unchecked(_First, _Mid, _Prev_iter(_Last), _Pred);

  00031	ff 75 7c	 push	 DWORD PTR __Pred$[ebp]
  00034	ff 75 4c	 push	 DWORD PTR __First$[ebp]
  00037	ff 75 2c	 push	 DWORD PTR __Mid$[ebp]
  0003a	ff 75 74	 push	 DWORD PTR __First$[ebp]
  0003d	e8 00 00 00 00	 call	 ??$_Guess_median_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@00U?$less@X@0@@Z ; std::_Guess_median_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  00042	83 c4 10	 add	 esp, 16			; 00000010H

; 7471 :     _RanIt _Pfirst = _Mid;

  00045	8b 45 2c	 mov	 eax, DWORD PTR __Mid$[ebp]
  00048	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  0004b	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0004e	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1837 :     return ++_First;

  00051	8b 45 48	 mov	 eax, DWORD PTR __First$[ebp]
  00054	83 c0 18	 add	 eax, 24			; 00000018H
  00057	89 45 48	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7472 :     _RanIt _Plast  = _Next_iter(_Pfirst);

  0005a	8b 45 48	 mov	 eax, DWORD PTR __First$[ebp]
  0005d	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN2@Partition_:

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00060	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  00063	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00066	73 65		 jae	 SHORT $LN4@Partition_
  00068	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0006b	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0006e	8b 45 44	 mov	 eax, DWORD PTR __First$[ebp]
  00071	83 e8 18	 sub	 eax, 24			; 00000018H
  00074	89 45 44	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  00077	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0007a	89 45 28	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0007d	ff 75 28	 push	 DWORD PTR __Right$[ebp]
  00080	ff 75 44	 push	 DWORD PTR __First$[ebp]
  00083	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00088	59		 pop	 ecx
  00089	59		 pop	 ecx
  0008a	88 45 57	 mov	 BYTE PTR $T10[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  0008d	0f b6 45 57	 movzx	 eax, BYTE PTR $T10[ebp]
  00091	85 c0		 test	 eax, eax
  00093	75 38		 jne	 SHORT $LN4@Partition_
  00095	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00098	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0009b	8b 45 40	 mov	 eax, DWORD PTR __First$[ebp]
  0009e	83 e8 18	 sub	 eax, 24			; 00000018H
  000a1	89 45 40	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000a4	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000a7	89 45 24	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000aa	ff 75 40	 push	 DWORD PTR __First$[ebp]
  000ad	ff 75 24	 push	 DWORD PTR __Left$[ebp]
  000b0	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000b5	59		 pop	 ecx
  000b6	59		 pop	 ecx
  000b7	88 45 56	 mov	 BYTE PTR $T9[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7475 :            && !_Pred(*_Pfirst, *_Prev_iter(_Pfirst))) {

  000ba	0f b6 45 56	 movzx	 eax, BYTE PTR $T9[ebp]
  000be	85 c0		 test	 eax, eax
  000c0	75 0b		 jne	 SHORT $LN4@Partition_

; 7476 :         --_Pfirst;

  000c2	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000c5	83 e8 18	 sub	 eax, 24			; 00000018H
  000c8	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7477 :     }

  000cb	eb 93		 jmp	 SHORT $LN2@Partition_
$LN4@Partition_:

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000cd	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000d0	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  000d3	73 53		 jae	 SHORT $LN5@Partition_
  000d5	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  000d8	89 45 20	 mov	 DWORD PTR __Right$[ebp], eax
  000db	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000de	89 45 1c	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000e1	ff 75 20	 push	 DWORD PTR __Right$[ebp]
  000e4	ff 75 1c	 push	 DWORD PTR __Left$[ebp]
  000e7	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000ec	59		 pop	 ecx
  000ed	59		 pop	 ecx
  000ee	88 45 55	 mov	 BYTE PTR $T8[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  000f1	0f b6 45 55	 movzx	 eax, BYTE PTR $T8[ebp]
  000f5	85 c0		 test	 eax, eax
  000f7	75 2f		 jne	 SHORT $LN5@Partition_
  000f9	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  000fc	89 45 18	 mov	 DWORD PTR __Right$[ebp], eax
  000ff	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00102	89 45 14	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00105	ff 75 18	 push	 DWORD PTR __Right$[ebp]
  00108	ff 75 14	 push	 DWORD PTR __Left$[ebp]
  0010b	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00110	59		 pop	 ecx
  00111	59		 pop	 ecx
  00112	88 45 54	 mov	 BYTE PTR $T7[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7479 :     while (_Plast < _Last && !_DEBUG_LT_PRED(_Pred, *_Plast, *_Pfirst) && !_Pred(*_Pfirst, *_Plast)) {

  00115	0f b6 45 54	 movzx	 eax, BYTE PTR $T7[ebp]
  00119	85 c0		 test	 eax, eax
  0011b	75 0b		 jne	 SHORT $LN5@Partition_

; 7480 :         ++_Plast;

  0011d	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00120	83 c0 18	 add	 eax, 24			; 00000018H
  00123	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7481 :     }

  00126	eb a5		 jmp	 SHORT $LN4@Partition_
$LN5@Partition_:

; 7482 : 
; 7483 :     _RanIt _Gfirst = _Plast;

  00128	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0012b	89 45 58	 mov	 DWORD PTR __Gfirst$[ebp], eax

; 7484 :     _RanIt _Glast  = _Pfirst;

  0012e	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00131	89 45 5c	 mov	 DWORD PTR __Glast$[ebp], eax
$LN8@Partition_:

; 7485 : 
; 7486 :     for (;;) { // partition
; 7487 :         for (; _Gfirst < _Last; ++_Gfirst) {

  00134	eb 09		 jmp	 SHORT $LN11@Partition_
$LN9@Partition_:
  00136	8b 45 58	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00139	83 c0 18	 add	 eax, 24			; 00000018H
  0013c	89 45 58	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN11@Partition_:
  0013f	8b 45 58	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00142	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00145	73 78		 jae	 SHORT $LN10@Partition_

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  00147	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0014a	89 45 10	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0014d	ff 75 58	 push	 DWORD PTR __Gfirst$[ebp]
  00150	ff 75 10	 push	 DWORD PTR __Left$[ebp]
  00153	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00158	59		 pop	 ecx
  00159	59		 pop	 ecx
  0015a	88 45 53	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7488 :             if (_DEBUG_LT_PRED(_Pred, *_Pfirst, *_Gfirst)) {

  0015d	0f b6 45 53	 movzx	 eax, BYTE PTR $T6[ebp]
  00161	85 c0		 test	 eax, eax
  00163	74 04		 je	 SHORT $LN15@Partition_

; 7489 :                 continue;

  00165	eb cf		 jmp	 SHORT $LN9@Partition_
  00167	eb 51		 jmp	 SHORT $LN16@Partition_
$LN15@Partition_:

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  00169	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0016c	89 45 0c	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0016f	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00172	ff 75 58	 push	 DWORD PTR __Gfirst$[ebp]
  00175	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0017a	59		 pop	 ecx
  0017b	59		 pop	 ecx
  0017c	88 45 52	 mov	 BYTE PTR $T5[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7490 :             } else if (_Pred(*_Gfirst, *_Pfirst)) {

  0017f	0f b6 45 52	 movzx	 eax, BYTE PTR $T5[ebp]
  00183	85 c0		 test	 eax, eax
  00185	74 04		 je	 SHORT $LN17@Partition_

; 7491 :                 break;

  00187	eb 36		 jmp	 SHORT $LN10@Partition_
  00189	eb 2f		 jmp	 SHORT $LN16@Partition_
$LN17@Partition_:

; 7492 :             } else if (_Plast != _Gfirst) {

  0018b	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  0018e	3b 45 58	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  00191	74 1e		 je	 SHORT $LN19@Partition_

; 7493 :                 _STD iter_swap(_Plast, _Gfirst);

  00193	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00196	89 45 08	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  00199	ff 75 58	 push	 DWORD PTR __Gfirst$[ebp]
  0019c	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  0019f	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  001a4	59		 pop	 ecx
  001a5	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7494 :                 ++_Plast;

  001a6	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001a9	83 c0 18	 add	 eax, 24			; 00000018H
  001ac	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7495 :             } else {

  001af	eb 09		 jmp	 SHORT $LN16@Partition_
$LN19@Partition_:

; 7496 :                 ++_Plast;

  001b1	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  001b4	83 c0 18	 add	 eax, 24			; 00000018H
  001b7	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
$LN16@Partition_:

; 7497 :             }
; 7498 :         }

  001ba	e9 77 ff ff ff	 jmp	 $LN9@Partition_
$LN10@Partition_:

; 7499 : 
; 7500 :         for (; _First < _Glast; --_Glast) {

  001bf	eb 09		 jmp	 SHORT $LN14@Partition_
$LN12@Partition_:
  001c1	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  001c4	83 e8 18	 sub	 eax, 24			; 00000018H
  001c7	89 45 5c	 mov	 DWORD PTR __Glast$[ebp], eax
$LN14@Partition_:
  001ca	8b 45 74	 mov	 eax, DWORD PTR __First$[ebp]
  001cd	3b 45 5c	 cmp	 eax, DWORD PTR __Glast$[ebp]
  001d0	0f 83 a9 00 00
	00		 jae	 $LN13@Partition_

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  001d6	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  001d9	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  001dc	8b 45 3c	 mov	 eax, DWORD PTR __First$[ebp]
  001df	83 e8 18	 sub	 eax, 24			; 00000018H
  001e2	89 45 3c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  001e5	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  001e8	89 45 04	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  001eb	ff 75 04	 push	 DWORD PTR __Right$[ebp]
  001ee	ff 75 3c	 push	 DWORD PTR __First$[ebp]
  001f1	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  001f6	59		 pop	 ecx
  001f7	59		 pop	 ecx
  001f8	88 45 51	 mov	 BYTE PTR $T4[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7501 :             if (_DEBUG_LT_PRED(_Pred, *_Prev_iter(_Glast), *_Pfirst)) {

  001fb	0f b6 45 51	 movzx	 eax, BYTE PTR $T4[ebp]
  001ff	85 c0		 test	 eax, eax
  00201	74 04		 je	 SHORT $LN21@Partition_

; 7502 :                 continue;

  00203	eb bc		 jmp	 SHORT $LN12@Partition_
  00205	eb 73		 jmp	 SHORT $LN22@Partition_
$LN21@Partition_:

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  00207	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  0020a	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0020d	8b 45 38	 mov	 eax, DWORD PTR __First$[ebp]
  00210	83 e8 18	 sub	 eax, 24			; 00000018H
  00213	89 45 38	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  00216	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00219	89 45 00	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0021c	ff 75 38	 push	 DWORD PTR __First$[ebp]
  0021f	ff 75 00	 push	 DWORD PTR __Left$[ebp]
  00222	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00227	59		 pop	 ecx
  00228	59		 pop	 ecx
  00229	88 45 50	 mov	 BYTE PTR $T3[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7503 :             } else if (_Pred(*_Pfirst, *_Prev_iter(_Glast))) {

  0022c	0f b6 45 50	 movzx	 eax, BYTE PTR $T3[ebp]
  00230	85 c0		 test	 eax, eax
  00232	74 04		 je	 SHORT $LN23@Partition_

; 7504 :                 break;

  00234	eb 49		 jmp	 SHORT $LN13@Partition_
  00236	eb 42		 jmp	 SHORT $LN22@Partition_
$LN23@Partition_:

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  00238	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0023b	83 e8 18	 sub	 eax, 24			; 00000018H
  0023e	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  00241	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  00244	89 45 34	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  00247	8b 45 34	 mov	 eax, DWORD PTR __First$[ebp]
  0024a	83 e8 18	 sub	 eax, 24			; 00000018H
  0024d	89 45 34	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7505 :             } else if (--_Pfirst != _Prev_iter(_Glast)) {

  00250	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00253	3b 45 34	 cmp	 eax, DWORD PTR __First$[ebp]
  00256	74 22		 je	 SHORT $LN22@Partition_

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  00258	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  0025b	89 45 30	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1852 :     return --_First;

  0025e	8b 45 30	 mov	 eax, DWORD PTR __First$[ebp]
  00261	83 e8 18	 sub	 eax, 24			; 00000018H
  00264	89 45 30	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7506 :                 _STD iter_swap(_Pfirst, _Prev_iter(_Glast));

  00267	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  0026a	89 45 fc	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  0026d	ff 75 30	 push	 DWORD PTR __First$[ebp]
  00270	ff 75 fc	 push	 DWORD PTR __Left$[ebp]
  00273	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00278	59		 pop	 ecx
  00279	59		 pop	 ecx
$LN22@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7508 :         }

  0027a	e9 42 ff ff ff	 jmp	 $LN12@Partition_
$LN13@Partition_:

; 7509 : 
; 7510 :         if (_Glast == _First && _Gfirst == _Last) {

  0027f	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  00282	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  00285	75 31		 jne	 SHORT $LN26@Partition_
  00287	8b 45 58	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  0028a	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  0028d	75 29		 jne	 SHORT $LN26@Partition_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0028f	8d 45 64	 lea	 eax, DWORD PTR __Pfirst$[ebp]
  00292	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00295	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00298	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  0029b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0029d	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0029f	8d 45 60	 lea	 eax, DWORD PTR __Plast$[ebp]
  002a2	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  002a5	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002a8	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  002ab	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002ad	89 48 04	 mov	 DWORD PTR [eax+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7511 :             return pair<_RanIt, _RanIt>(_Pfirst, _Plast);

  002b0	8b 45 70	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  002b3	e9 d6 00 00 00	 jmp	 $LN1@Partition_
$LN26@Partition_:

; 7512 :         }
; 7513 : 
; 7514 :         if (_Glast == _First) { // no room at bottom, rotate pivot upward

  002b8	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  002bb	3b 45 74	 cmp	 eax, DWORD PTR __First$[ebp]
  002be	75 51		 jne	 SHORT $LN27@Partition_

; 7515 :             if (_Plast != _Gfirst) {

  002c0	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  002c3	3b 45 58	 cmp	 eax, DWORD PTR __Gfirst$[ebp]
  002c6	74 19		 je	 SHORT $LN29@Partition_

; 7516 :                 _STD iter_swap(_Pfirst, _Plast);

  002c8	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  002cb	89 45 f0	 mov	 DWORD PTR __Right$[ebp], eax
  002ce	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002d1	89 45 ec	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  002d4	ff 75 f0	 push	 DWORD PTR __Right$[ebp]
  002d7	ff 75 ec	 push	 DWORD PTR __Left$[ebp]
  002da	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  002df	59		 pop	 ecx
  002e0	59		 pop	 ecx
$LN29@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7519 :             ++_Plast;

  002e1	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  002e4	83 c0 18	 add	 eax, 24			; 00000018H
  002e7	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax

; 7520 :             _STD iter_swap(_Pfirst, _Gfirst);

  002ea	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  002ed	89 45 e8	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  002f0	ff 75 58	 push	 DWORD PTR __Gfirst$[ebp]
  002f3	ff 75 e8	 push	 DWORD PTR __Left$[ebp]
  002f6	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  002fb	59		 pop	 ecx
  002fc	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7521 :             ++_Pfirst;

  002fd	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00300	83 c0 18	 add	 eax, 24			; 00000018H
  00303	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax

; 7522 :             ++_Gfirst;

  00306	8b 45 58	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00309	83 c0 18	 add	 eax, 24			; 00000018H
  0030c	89 45 58	 mov	 DWORD PTR __Gfirst$[ebp], eax
  0030f	eb 78		 jmp	 SHORT $LN28@Partition_
$LN27@Partition_:

; 7523 :         } else if (_Gfirst == _Last) { // no room at top, rotate pivot downward

  00311	8b 45 58	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00314	3b 45 78	 cmp	 eax, DWORD PTR __Last$[ebp]
  00317	75 51		 jne	 SHORT $LN30@Partition_

; 7524 :             if (--_Glast != --_Pfirst) {

  00319	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  0031c	83 e8 18	 sub	 eax, 24			; 00000018H
  0031f	89 45 5c	 mov	 DWORD PTR __Glast$[ebp], eax
  00322	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00325	83 e8 18	 sub	 eax, 24			; 00000018H
  00328	89 45 64	 mov	 DWORD PTR __Pfirst$[ebp], eax
  0032b	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  0032e	3b 45 64	 cmp	 eax, DWORD PTR __Pfirst$[ebp]
  00331	74 13		 je	 SHORT $LN32@Partition_

; 7525 :                 _STD iter_swap(_Glast, _Pfirst);

  00333	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00336	89 45 e4	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  00339	ff 75 e4	 push	 DWORD PTR __Right$[ebp]
  0033c	ff 75 5c	 push	 DWORD PTR __Glast$[ebp]
  0033f	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00344	59		 pop	 ecx
  00345	59		 pop	 ecx
$LN32@Partition_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7528 :             _STD iter_swap(_Pfirst, --_Plast);

  00346	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00349	83 e8 18	 sub	 eax, 24			; 00000018H
  0034c	89 45 60	 mov	 DWORD PTR __Plast$[ebp], eax
  0034f	8b 45 60	 mov	 eax, DWORD PTR __Plast$[ebp]
  00352	89 45 e0	 mov	 DWORD PTR __Right$[ebp], eax
  00355	8b 45 64	 mov	 eax, DWORD PTR __Pfirst$[ebp]
  00358	89 45 dc	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  0035b	ff 75 e0	 push	 DWORD PTR __Right$[ebp]
  0035e	ff 75 dc	 push	 DWORD PTR __Left$[ebp]
  00361	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00366	59		 pop	 ecx
  00367	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7529 :         } else {

  00368	eb 1f		 jmp	 SHORT $LN28@Partition_
$LN30@Partition_:

; 7530 :             _STD iter_swap(_Gfirst, --_Glast);

  0036a	8b 45 5c	 mov	 eax, DWORD PTR __Glast$[ebp]
  0036d	83 e8 18	 sub	 eax, 24			; 00000018H
  00370	89 45 5c	 mov	 DWORD PTR __Glast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 81   :     swap(*_Left, *_Right);

  00373	ff 75 5c	 push	 DWORD PTR __Glast$[ebp]
  00376	ff 75 58	 push	 DWORD PTR __Gfirst$[ebp]
  00379	e8 00 00 00 00	 call	 ??$swap@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@YAXAAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::swap<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0037e	59		 pop	 ecx
  0037f	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7531 :             ++_Gfirst;

  00380	8b 45 58	 mov	 eax, DWORD PTR __Gfirst$[ebp]
  00383	83 c0 18	 add	 eax, 24			; 00000018H
  00386	89 45 58	 mov	 DWORD PTR __Gfirst$[ebp], eax
$LN28@Partition_:

; 7532 :         }
; 7533 :     }

  00389	e9 a6 fd ff ff	 jmp	 $LN8@Partition_
$LN1@Partition_:

; 7534 : }

  0038e	83 c5 68	 add	 ebp, 104		; 00000068H
  00391	c9		 leave
  00392	c3		 ret	 0
??$_Partition_by_median_guess_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ENDP ; std::_Partition_by_median_guess_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
_TEXT	SEGMENT
$T2 = -56						; size = 4
$T3 = -52						; size = 4
__Bottom$ = -48						; size = 4
__Hole$4 = -44						; size = 4
__Val$5 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z PROC ; std::_Make_heap_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >, COMDAT

; 6357 : _CONSTEXPR20 void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 6358 :     // make [_First, _Last) into a heap
; 6359 :     using _Diff   = _Iter_diff_t<_RanIt>;
; 6360 :     _Diff _Bottom = _Last - _First;

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002b	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0002e	99		 cdq
  0002f	6a 18		 push	 24			; 00000018H
  00031	59		 pop	 ecx
  00032	f7 f9		 idiv	 ecx
  00034	89 45 d0	 mov	 DWORD PTR __Bottom$[ebp], eax

; 6361 :     for (_Diff _Hole = _Bottom >> 1; _Hole > 0;) { // shift for codegen

  00037	8b 45 d0	 mov	 eax, DWORD PTR __Bottom$[ebp]
  0003a	d1 f8		 sar	 eax, 1
  0003c	89 45 d4	 mov	 DWORD PTR __Hole$4[ebp], eax
$LN4@Make_heap_:
  0003f	83 7d d4 00	 cmp	 DWORD PTR __Hole$4[ebp], 0
  00043	7e 4b		 jle	 SHORT $LN1@Make_heap_

; 6362 :         // reheap top half, bottom to top
; 6363 :         --_Hole;

  00045	8b 45 d4	 mov	 eax, DWORD PTR __Hole$4[ebp]
  00048	48		 dec	 eax
  00049	89 45 d4	 mov	 DWORD PTR __Hole$4[ebp], eax

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  0004c	6b 45 d4 18	 imul	 eax, DWORD PTR __Hole$4[ebp], 24
  00050	03 45 08	 add	 eax, DWORD PTR __First$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00053	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6364 :         _Iter_value_t<_RanIt> _Val = _STD move(*(_First + _Hole));

  00056	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00059	8d 4d d8	 lea	 ecx, DWORD PTR __Val$5[ebp]
  0005c	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00061	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00065	8d 45 d8	 lea	 eax, DWORD PTR __Val$5[ebp]
  00068	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6365 :         _Pop_heap_hole_by_index(_First, _Hole, _Bottom, _STD move(_Val), _Pred);

  0006b	ff 75 10	 push	 DWORD PTR __Pred$[ebp]
  0006e	ff 75 c8	 push	 DWORD PTR $T2[ebp]
  00071	ff 75 d0	 push	 DWORD PTR __Bottom$[ebp]
  00074	ff 75 d4	 push	 DWORD PTR __Hole$4[ebp]
  00077	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0007a	e8 00 00 00 00	 call	 ??$_Pop_heap_hole_by_index@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V12@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@HH$$QAV10@U?$less@X@0@@Z ; std::_Pop_heap_hole_by_index<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::less<void> >
  0007f	83 c4 14	 add	 esp, 20			; 00000014H

; 6366 :     }

  00082	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00086	8d 4d d8	 lea	 ecx, DWORD PTR __Val$5[ebp]
  00089	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 6366 :     }

  0008e	eb af		 jmp	 SHORT $LN4@Make_heap_
$LN1@Make_heap_:

; 6367 : }

  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0009e	33 cd		 xor	 ecx, ebp
  000a0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a5	c9		 leave
  000a6	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Val$5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ENDP ; std::_Make_heap_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z
_TEXT	SEGMENT
$T2 = -96						; size = 1
$T3 = -92						; size = 4
$T4 = -88						; size = 1
$T5 = -84						; size = 4
$T6 = -80						; size = 1
$T7 = -76						; size = 4
$T8 = -72						; size = 4
$T9 = -68						; size = 4
$T10 = -64						; size = 4
$T11 = -60						; size = 4
__Prev$12 = -56						; size = 4
__Mid$13 = -52						; size = 4
$T14 = -46						; size = 1
$T15 = -45						; size = 1
__Hole$16 = -44						; size = 4
__Val$17 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z PROC ; std::_Insertion_sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >, COMDAT

; 7410 : _CONSTEXPR20 _BidIt _Insertion_sort_unchecked(const _BidIt _First, const _BidIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 7411 :     // insertion sort [_First, _Last)
; 7412 :     if (_First != _Last) {

  00028	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0002b	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0002e	0f 84 26 01 00
	00		 je	 $LN8@Insertion_

; 7413 :         for (_BidIt _Mid = _First; ++_Mid != _Last;) { // order next element

  00034	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00037	89 45 cc	 mov	 DWORD PTR __Mid$13[ebp], eax
$LN4@Insertion_:
  0003a	8b 45 cc	 mov	 eax, DWORD PTR __Mid$13[ebp]
  0003d	83 c0 18	 add	 eax, 24			; 00000018H
  00040	89 45 cc	 mov	 DWORD PTR __Mid$13[ebp], eax
  00043	8b 45 cc	 mov	 eax, DWORD PTR __Mid$13[ebp]
  00046	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00049	0f 84 0b 01 00
	00		 je	 $LN8@Insertion_

; 7414 :             _BidIt _Hole               = _Mid;

  0004f	8b 45 cc	 mov	 eax, DWORD PTR __Mid$13[ebp]
  00052	89 45 d4	 mov	 DWORD PTR __Hole$16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00055	8b 45 cc	 mov	 eax, DWORD PTR __Mid$13[ebp]
  00058	89 45 b8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7415 :             _Iter_value_t<_BidIt> _Val = _STD move(*_Mid);

  0005b	ff 75 b8	 push	 DWORD PTR $T8[ebp]
  0005e	8d 4d d8	 lea	 ecx, DWORD PTR __Val$17[ebp]
  00061	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00066	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  0006a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0006d	8d 45 d8	 lea	 eax, DWORD PTR __Val$17[ebp]
  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00076	59		 pop	 ecx
  00077	59		 pop	 ecx
  00078	88 45 d3	 mov	 BYTE PTR $T15[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7417 :             if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) { // found new earliest element, move to front

  0007b	0f b6 45 d3	 movzx	 eax, BYTE PTR $T15[ebp]
  0007f	85 c0		 test	 eax, eax
  00081	74 46		 je	 SHORT $LN9@Insertion_

; 7418 :                 _Move_backward_unchecked(_First, _Mid, ++_Hole);

  00083	8b 45 d4	 mov	 eax, DWORD PTR __Hole$16[ebp]
  00086	83 c0 18	 add	 eax, 24			; 00000018H
  00089	89 45 d4	 mov	 DWORD PTR __Hole$16[ebp], eax
  0008c	ff 75 d4	 push	 DWORD PTR __Hole$16[ebp]
  0008f	ff 75 cc	 push	 DWORD PTR __Mid$13[ebp]
  00092	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00095	e8 00 00 00 00	 call	 ??$_Move_backward_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PAV10@00@Z ; std::_Move_backward_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *>
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0009d	8d 45 d8	 lea	 eax, DWORD PTR __Val$17[ebp]
  000a0	89 45 c4	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000a3	8b 45 c4	 mov	 eax, DWORD PTR $T11[ebp]
  000a6	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  000a9	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000ac	3b 45 b4	 cmp	 eax, DWORD PTR $T7[ebp]
  000af	74 13		 je	 SHORT $LN62@Insertion_

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  000b1	33 c0		 xor	 eax, eax
  000b3	88 45 b0	 mov	 BYTE PTR $T6[ebp], al
  000b6	ff 75 b0	 push	 DWORD PTR $T6[ebp]
  000b9	ff 75 c4	 push	 DWORD PTR $T11[ebp]
  000bc	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000bf	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN62@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7420 :             } else { // look for insertion point after first

  000c4	e9 80 00 00 00	 jmp	 $LN10@Insertion_
$LN9@Insertion_:

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  000c9	8b 45 d4	 mov	 eax, DWORD PTR __Hole$16[ebp]
  000cc	89 45 c8	 mov	 DWORD PTR __Prev$12[ebp], eax
  000cf	eb 06		 jmp	 SHORT $LN7@Insertion_
$LN5@Insertion_:
  000d1	8b 45 c8	 mov	 eax, DWORD PTR __Prev$12[ebp]
  000d4	89 45 d4	 mov	 DWORD PTR __Hole$16[ebp], eax
$LN7@Insertion_:
  000d7	8b 45 c8	 mov	 eax, DWORD PTR __Prev$12[ebp]
  000da	83 e8 18	 sub	 eax, 24			; 00000018H
  000dd	89 45 c8	 mov	 DWORD PTR __Prev$12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  000e0	ff 75 c8	 push	 DWORD PTR __Prev$12[ebp]
  000e3	8d 45 d8	 lea	 eax, DWORD PTR __Val$17[ebp]
  000e6	50		 push	 eax
  000e7	e8 00 00 00 00	 call	 ??$?M_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0@Z ; std::operator<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000ec	59		 pop	 ecx
  000ed	59		 pop	 ecx
  000ee	88 45 d2	 mov	 BYTE PTR $T14[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7421 :                 for (_BidIt _Prev = _Hole; _DEBUG_LT_PRED(_Pred, _Val, *--_Prev); _Hole = _Prev) {

  000f1	0f b6 45 d2	 movzx	 eax, BYTE PTR $T14[ebp]
  000f5	85 c0		 test	 eax, eax
  000f7	74 29		 je	 SHORT $LN6@Insertion_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000f9	8b 45 c8	 mov	 eax, DWORD PTR __Prev$12[ebp]
  000fc	89 45 c0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000ff	8b 45 c0	 mov	 eax, DWORD PTR $T10[ebp]
  00102	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  00105	8b 45 d4	 mov	 eax, DWORD PTR __Hole$16[ebp]
  00108	3b 45 ac	 cmp	 eax, DWORD PTR $T5[ebp]
  0010b	74 13		 je	 SHORT $LN102@Insertion_

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  0010d	33 c0		 xor	 eax, eax
  0010f	88 45 a8	 mov	 BYTE PTR $T4[ebp], al
  00112	ff 75 a8	 push	 DWORD PTR $T4[ebp]
  00115	ff 75 c0	 push	 DWORD PTR $T10[ebp]
  00118	8b 4d d4	 mov	 ecx, DWORD PTR __Hole$16[ebp]
  0011b	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN102@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7423 :                 }

  00120	eb af		 jmp	 SHORT $LN5@Insertion_
$LN6@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00122	8d 45 d8	 lea	 eax, DWORD PTR __Val$17[ebp]
  00125	89 45 bc	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00128	8b 45 bc	 mov	 eax, DWORD PTR $T9[ebp]
  0012b	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2665 :         if (this != _STD addressof(_Right)) {

  0012e	8b 45 d4	 mov	 eax, DWORD PTR __Hole$16[ebp]
  00131	3b 45 a4	 cmp	 eax, DWORD PTR $T3[ebp]
  00134	74 13		 je	 SHORT $LN10@Insertion_

; 2666 :             _Move_assign(_Right, _Choose_pocma<_Alty>{});

  00136	33 c0		 xor	 eax, eax
  00138	88 45 a0	 mov	 BYTE PTR $T2[ebp], al
  0013b	ff 75 a0	 push	 DWORD PTR $T2[ebp]
  0013e	ff 75 bc	 push	 DWORD PTR $T9[ebp]
  00141	8b 4d d4	 mov	 ecx, DWORD PTR __Hole$16[ebp]
  00144	e8 00 00 00 00	 call	 ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
$LN10@Insertion_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7427 :         }

  00149	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0014d	8d 4d d8	 lea	 ecx, DWORD PTR __Val$17[ebp]
  00150	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7427 :         }

  00155	e9 e0 fe ff ff	 jmp	 $LN4@Insertion_
$LN8@Insertion_:

; 7428 :     }
; 7429 : 
; 7430 :     return _Last;

  0015a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 7431 : }

  0015d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00160	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00167	59		 pop	 ecx
  00168	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016b	33 cd		 xor	 ecx, ebp
  0016d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00172	c9		 leave
  00173	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Val$17[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z ENDP ; std::_Insertion_sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
;	COMDAT ??$?8V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z
_TEXT	SEGMENT
tv70 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z PROC ; std::operator==<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>, COMDAT

; 291  :     const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 274  :         return _Myistr == _Right._Myistr;

  00004	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0000e	75 09		 jne	 SHORT $LN5@operator
  00010	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  00017	eb 04		 jmp	 SHORT $LN3@operator
$LN5@operator:
  00019	83 65 fc 00	 and	 DWORD PTR tv70[ebp], 0
$LN3@operator:

; 292  :     return _Left._Equal(_Right);

  0001d	8a 45 fc	 mov	 al, BYTE PTR tv70[ebp]

; 293  : }

  00020	c9		 leave
  00021	c3		 ret	 0
??$?8V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z ENDP ; std::operator==<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@std@@SAXAAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@1@QAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
_this$ = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
___formal$ = -16					; size = 1
___formal$ = -12					; size = 1
___formal$ = -8						; size = 1
$T8 = -3						; size = 1
$T9 = -2						; size = 1
$T10 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 4
??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@std@@SAXAAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@1@QAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >, COMDAT

; 700  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000c	8b 45 18	 mov	 eax, DWORD PTR _<_Args_2>$[ebp]
  0000f	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00012	8d 45 fd	 lea	 eax, DWORD PTR $T8[ebp]
  00015	89 45 cc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 14	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0001b	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0001e	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00021	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

  00024	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00031	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00034	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00037	8a 00		 mov	 al, BYTE PTR [eax]
  00039	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 986  :     : pair(_Val1, _Val2, index_sequence_for<_Types1...>{}, index_sequence_for<_Types2...>{}) {}

  0003c	33 c0		 xor	 eax, eax
  0003e	88 45 ff	 mov	 BYTE PTR $T10[ebp], al
  00041	33 c0		 xor	 eax, eax
  00043	88 45 fe	 mov	 BYTE PTR $T9[ebp], al
  00046	8a 45 ff	 mov	 al, BYTE PTR $T10[ebp]
  00049	88 45 f4	 mov	 BYTE PTR ___formal$[ebp], al
  0004c	8a 45 fe	 mov	 al, BYTE PTR $T9[ebp]
  0004f	88 45 f0	 mov	 BYTE PTR ___formal$[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00052	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00055	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 790  :     return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);

  00058	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0005b	8b 00		 mov	 eax, DWORD PTR [eax]
  0005d	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 980  :     : first(_STD get<_Indexes1>(_STD move(_Val1))...), second(_STD get<_Indexes2>(_STD move(_Val2))...) {}

  00060	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  00063	8b 4d d4	 mov	 ecx, DWORD PTR $T2[ebp]
  00066	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00068	89 08		 mov	 DWORD PTR [eax], ecx
  0006a	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  0006d	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 702  :     }

  00071	c9		 leave
  00072	c3		 ret	 0
??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@std@@SAXAAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@1@QAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -40					; size = 4
___formal$ = -36					; size = 4
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_v$ = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$6 = -1				; size = 1
?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::create_node, COMDAT
; _this$ = ecx

; 1983 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1985 :         node_ = node_allocator_traits::allocate(alloc_, 1);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 dc	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00011	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$6[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00015	c7 45 d8 ff ff
	ff 0f		 mov	 DWORD PTR __Max_possible$1[ebp], 268435455 ; 0fffffffH

; 60   :         if (_Count > _Max_possible) {

  0001c	33 c0		 xor	 eax, eax
  0001e	40		 inc	 eax
  0001f	3d ff ff ff 0f	 cmp	 eax, 268435455		; 0fffffffH
  00024	76 05		 jbe	 SHORT $LN6@create_nod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00026	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@create_nod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0002b	33 c0		 xor	 eax, eax
  0002d	40		 inc	 eax
  0002e	c1 e0 04	 shl	 eax, 4
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  00034	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  00037	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0003c	59		 pop	 ecx
  0003d	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1985 :         node_ = node_allocator_traits::allocate(alloc_, 1);

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00046	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1986 :         new ((void*)boost::to_address(node_)) node();

  00049	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	89 45 e8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00052	8b 45 e8	 mov	 eax, DWORD PTR _v$[ebp]
  00055	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00058	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  0005b	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2579 :         ptr_bucket() : next_(0) {}

  0005e	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00061	83 20 00	 and	 DWORD PTR [eax], 0

; 4865 :         ptr_node() : bucket_base(), bucket_info_(0) {}

  00064	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00067	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0006b	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  0006e	83 c0 08	 add	 eax, 8
  00071	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax

; 754  :         value_base() : data_() {}

  00074	33 c0		 xor	 eax, eax
  00076	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	89 01		 mov	 DWORD PTR [ecx], eax
  0007b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN9@create_nod:

; 1987 :       }

  0007e	c9		 leave
  0007f	c3		 ret	 0
?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::create_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
_v$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ PROC ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >, COMDAT
; _this$ = ecx

; 1975 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1976 :         if (node_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 31		 je	 SHORT $LN3@node_const

; 1977 :           boost::unordered::detail::func::destroy(boost::to_address(node_));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1978 :           node_allocator_traits::deallocate(alloc_, node_, 1);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	c1 e0 04	 shl	 eax, 4
  00038	50		 push	 eax
  00039	ff 75 f4	 push	 DWORD PTR __Ptr$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx
$LN3@node_const:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1980 :       }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ENDP ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Zero_uncaught_exceptions$ = -14			; size = 1
tv72 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00027	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	85 c0		 test	 eax, eax
  00031	75 06		 jne	 SHORT $LN4@sentry
  00033	c6 45 f3 01	 mov	 BYTE PTR tv72[ebp], 1
  00037	eb 04		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  00039	c6 45 f3 00	 mov	 BYTE PTR tv72[ebp], 0
$LN5@sentry:
  0003d	8a 45 f3	 mov	 al, BYTE PTR tv72[ebp]
  00040	88 45 f2	 mov	 BYTE PTR __Zero_uncaught_exceptions$[ebp], al

; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  00043	0f b6 45 f2	 movzx	 eax, BYTE PTR __Zero_uncaught_exceptions$[ebp]
  00047	85 c0		 test	 eax, eax
  00049	74 0a		 je	 SHORT $LN1@sentry

; 119  :                 this->_Myostr._Osfx();

  0004b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
$LN1@sentry:

; 120  :             }
; 121  :         }

  00055	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	c9		 leave
  00069	c3		 ret	 0
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
  0006e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
tv218 = -28						; size = 4
tv168 = -24						; size = 4
__Tied$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry, COMDAT
; _this$ = ecx

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	ff 75 08	 push	 DWORD PTR __Ostr$[ebp]
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  00037	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00042	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  00046	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax

; 295  :         return rdstate() == ios_base::goodbit;

  00049	83 7d e0 00	 cmp	 DWORD PTR $T3[ebp], 0
  0004d	75 09		 jne	 SHORT $LN14@sentry
  0004f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv168[ebp], 1
  00056	eb 04		 jmp	 SHORT $LN12@sentry
$LN14@sentry:
  00058	83 65 e8 00	 and	 DWORD PTR tv168[ebp], 0
$LN12@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 93   :             if (!_Ostr.good()) {

  0005c	0f b6 45 e8	 movzx	 eax, BYTE PTR tv168[ebp]
  00060	85 c0		 test	 eax, eax
  00062	75 09		 jne	 SHORT $LN2@sentry

; 94   :                 _Ok = false;

  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 95   :                 return;

  0006b	eb 5f		 jmp	 SHORT $LN1@sentry
$LN2@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 70   :         return _Tiestr;

  0006d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00070	8b 00		 mov	 eax, DWORD PTR [eax]
  00072	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00075	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00078	8b 44 01 3c	 mov	 eax, DWORD PTR [ecx+eax+60]
  0007c	89 45 ec	 mov	 DWORD PTR __Tied$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  0007f	83 7d ec 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  00083	74 08		 je	 SHORT $LN4@sentry
  00085	8b 45 ec	 mov	 eax, DWORD PTR __Tied$[ebp]
  00088	3b 45 08	 cmp	 eax, DWORD PTR __Ostr$[ebp]
  0008b	75 09		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

  0008d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00090	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 101  :                 return;

  00094	eb 36		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 102  :             }
; 103  : 
; 104  :             _Tied->flush();

  00096	8b 4d ec	 mov	 ecx, DWORD PTR __Tied$[ebp]
  00099	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  0009e	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a6	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000a9	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  000ad	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 295  :         return rdstate() == ios_base::goodbit;

  000b0	83 7d dc 00	 cmp	 DWORD PTR $T2[ebp], 0
  000b4	75 09		 jne	 SHORT $LN61@sentry
  000b6	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv218[ebp], 1
  000bd	eb 04		 jmp	 SHORT $LN59@sentry
$LN61@sentry:
  000bf	83 65 e4 00	 and	 DWORD PTR tv218[ebp], 0
$LN59@sentry:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000c3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	8a 4d e4	 mov	 cl, BYTE PTR tv218[ebp]
  000c9	88 48 04	 mov	 BYTE PTR [eax+4], cl
$LN1@sentry:

; 106  :         }

  000cc	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000d0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dd	59		 pop	 ecx
  000de	c9		 leave
  000df	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv72 = -20						; size = 4
__Rdbuf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00028	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  00030	8b 45 ec	 mov	 eax, DWORD PTR tv72[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	8b 4d ec	 mov	 ecx, DWORD PTR tv72[ebp]
  0003b	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  0003f	89 45 f0	 mov	 DWORD PTR __Rdbuf$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 80   :             if (_Rdbuf) {

  00042	83 7d f0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00046	74 0b		 je	 SHORT $LN3@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00048	8b 45 f0	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00050	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@Sentry_bas:

; 82   :             }
; 83   :         }

  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	c9		 leave
  0005f	c3		 ret	 0
  00060	cc		 int	 3
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Rdbuf$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  00019	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  00024	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00028	89 45 fc	 mov	 DWORD PTR __Rdbuf$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 73   :             if (_Rdbuf) {

  0002b	83 7d fc 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0002f	74 0b		 je	 SHORT $LN1@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00039	ff 50 04	 call	 DWORD PTR [eax+4]
$LN1@Sentry_bas:

; 75   :             }
; 76   :         }

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c9		 leave
  00040	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 18		 push	 24			; 00000018H
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 18		 push	 24			; 00000018H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 aa aa
	aa 0a		 mov	 DWORD PTR $T22[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000b7	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABEII@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$2[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 aa aa
	aa 0a		 cmp	 DWORD PTR __Newcapacity$[ebp], 178956970 ; 0aaaaaaaH
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 18	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 24
  00104	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 10	 push	 DWORD PTR $T14[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  0011e	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00144	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00147	ff 75 04	 push	 DWORD PTR $T11[ebp]
  0014a	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  0014d	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00152	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  00156	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00159	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015c	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015f	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00162	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00164	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00166	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00169	8b 00		 mov	 eax, DWORD PTR [eax]
  0016b	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016e	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00171	8b 00		 mov	 eax, DWORD PTR [eax]
  00173	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00176	33 c0		 xor	 eax, eax
  00178	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0017b	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017e	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00181	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00184	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00187	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0018a	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018d	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  00190	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00193	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00196	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00199	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  0019e	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001a1	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a3	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a6	8b 00		 mov	 eax, DWORD PTR [eax]
  001a8	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001ab	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ae	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001b1	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b4	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b7	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001ba	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bd	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001c0	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c3	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  001c8	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001cb	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ce	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001d1	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d4	8b 00		 mov	 eax, DWORD PTR [eax]
  001d6	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d9	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001dc	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001df	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e2	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e5	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e8	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  001ec	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ef	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f3	50		 push	 eax
  001f4	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f7	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001fa	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  001ff	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00202	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00204	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00207	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0020a	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00212	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00215	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00218	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0021b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate

; 762  :         _RERAISE;

  00220	6a 00		 push	 0
  00222	6a 00		 push	 0
  00224	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00229	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022e	c3		 ret	 0
$LN7@Emplace_re:
  0022f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00233	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00235	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00239	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023c	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023f	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00242	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@II@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0024a	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  0024e	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  00251	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00254	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025b	59		 pop	 ecx
  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
  0025f	83 c5 70	 add	 ebp, 112		; 00000070H
  00262	c9		 leave
  00263	c2 08 00	 ret	 8
  00266	cc		 int	 3
  00267	cc		 int	 3
  00268	cc		 int	 3
  00269	cc		 int	 3
  0026a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back_with_unused_capacity<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00057	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	83 c0 18	 add	 eax, 24			; 00000018H
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00064	c9		 leave
  00065	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back_with_unused_capacity<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_back_with_unused_capacity<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@QAV21@ABV21@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Emplace_reallocate<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z
_TEXT	SEGMENT
__Max_possible$1 = -88					; size = 4
__Al$ = -84						; size = 4
$T2 = -80						; size = 4
__Ptr$ = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
__Old_ptr$6 = -60					; size = 4
__Old_capacity$ = -56					; size = 4
__New_capacity$ = -52					; size = 4
__New_size$ = -48					; size = 4
__Count$ = -44						; size = 4
__New_ptr$ = -40					; size = 4
_this$ = -36						; size = 4
__Raw_new$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Old_size$ = -24					; size = 4
$T7 = -18						; size = 2
__Ch$ = -16						; size = 2
$T8 = -10						; size = 2
__Ch$ = -8						; size = 2
__Overflow_is_possible$9 = -1				; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 2
??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 e8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00020	2b 45 e8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 d0	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 c8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00047	50		 push	 eax
  00048	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 d0	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 cc	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  00065	89 45 ac	 mov	 DWORD PTR __Al$[ebp], eax

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00068	8b 45 cc	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006b	40		 inc	 eax
  0006c	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0006f	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$9[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00073	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  0007a	81 7d d4 ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  00081	76 05		 jbe	 SHORT $LN68@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00083	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN68@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00088	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  0008b	d1 e0		 shl	 eax, 1
  0008d	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00090	ff 75 bc	 push	 DWORD PTR $T4[ebp]
  00093	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00098	59		 pop	 ecx
  00099	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0009c	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
  0009f	89 45 d8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  000a2	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a5	8b 4d d0	 mov	 ecx, DWORD PTR __New_size$[ebp]
  000a8	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  000ab	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ae	8b 4d cc	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000b1	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  000b4	8b 45 d8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000b7	89 45 b4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000ba	8b 45 b4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000bd	89 45 e0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  000c0	83 7d c8 08	 cmp	 DWORD PTR __Old_capacity$[ebp], 8
  000c4	72 69		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000c6	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000c9	8b 00		 mov	 eax, DWORD PTR [eax]
  000cb	89 45 c4	 mov	 DWORD PTR __Old_ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000ce	8b 45 c4	 mov	 eax, DWORD PTR __Old_ptr$6[ebp]
  000d1	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000d4	66 8b 45 10	 mov	 ax, WORD PTR _<_Args_0>$[ebp]
  000d8	66 89 45 f8	 mov	 WORD PTR __Ch$[ebp], ax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000dc	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000df	d1 e0		 shl	 eax, 1
  000e1	50		 push	 eax
  000e2	ff 75 b0	 push	 DWORD PTR $T2[ebp]
  000e5	ff 75 e0	 push	 DWORD PTR __Raw_new$[ebp]
  000e8	e8 00 00 00 00	 call	 _memcpy
  000ed	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  :         _Left = _Right;

  000f0	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000f3	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000f6	66 8b 55 f8	 mov	 dx, WORD PTR __Ch$[ebp]
  000fa	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000fe	33 c0		 xor	 eax, eax
  00100	66 89 45 f6	 mov	 WORD PTR $T8[ebp], ax

; 281  :         _Left = _Right;

  00104	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00107	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0010a	66 8b 55 f6	 mov	 dx, WORD PTR $T8[ebp]
  0010e	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00113	8b 45 c8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  00116	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  0011a	50		 push	 eax
  0011b	ff 75 c4	 push	 DWORD PTR __Old_ptr$6[ebp]
  0011e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00123	59		 pop	 ecx
  00124	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  00125	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00128	8b 4d d8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0012b	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  0012d	eb 4d		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  0012f	66 8b 45 10	 mov	 ax, WORD PTR _<_Args_0>$[ebp]
  00133	66 89 45 f0	 mov	 WORD PTR __Ch$[ebp], ax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00137	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0013a	d1 e0		 shl	 eax, 1
  0013c	50		 push	 eax
  0013d	ff 75 e4	 push	 DWORD PTR __My_data$[ebp]
  00140	ff 75 e0	 push	 DWORD PTR __Raw_new$[ebp]
  00143	e8 00 00 00 00	 call	 _memcpy
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  :         _Left = _Right;

  0014b	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0014e	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  00151	66 8b 55 f0	 mov	 dx, WORD PTR __Ch$[ebp]
  00155	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00159	33 c0		 xor	 eax, eax
  0015b	66 89 45 ee	 mov	 WORD PTR $T7[ebp], ax

; 281  :         _Left = _Right;

  0015f	8b 45 e8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00162	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  00165	66 8b 55 ee	 mov	 dx, WORD PTR $T7[ebp]
  00169	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0016e	8d 45 d8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00171	50		 push	 eax
  00172	ff 75 e4	 push	 DWORD PTR __My_data$[ebp]
  00175	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  0017a	59		 pop	 ecx
  0017b	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0017c	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
$LN71@Reallocate:

; 4357 :     }

  0017f	c9		 leave
  00180	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@IABKABU?$equal_to@K@std@@@Z
_TEXT	SEGMENT
_bucket_index$ = -16					; size = 4
tv73 = -12						; size = 4
_this$ = -8						; size = 4
_n$ = -4						; size = 4
_key_hash$ = 8						; size = 4
_k$ = 12						; size = 4
_eq$ = 16						; size = 4
??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@IABKABU?$equal_to@K@std@@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >, COMDAT
; _this$ = ecx

; 3587 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2604 :           return hash % bucket_count;

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	8b 45 08	 mov	 eax, DWORD PTR _key_hash$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	f7 71 04	 div	 DWORD PTR [ecx+4]

; 3588 :           std::size_t bucket_index = this->hash_to_bucket(key_hash);

  00014	89 55 f0	 mov	 DWORD PTR _bucket_index$[ebp], edx

; 3589 :           node_pointer n = this->begin(bucket_index);

  00017	ff 75 f0	 push	 DWORD PTR _bucket_index$[ebp]
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
  00022	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@find_node_:

; 3590 : 
; 3591 :           for (;;) {
; 3592 :             if (!n)

  00025	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00029	75 05		 jne	 SHORT $LN25@find_node_

; 3593 :               return n;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0002e	eb 4b		 jmp	 SHORT $LN1@find_node_
$LN25@find_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 91   :         return _Left == _Right;

  00030	8b 45 0c	 mov	 eax, DWORD PTR _k$[ebp]
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0003b	75 09		 jne	 SHORT $LN35@find_node_
  0003d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  00044	eb 04		 jmp	 SHORT $LN33@find_node_
$LN35@find_node_:
  00046	83 65 f4 00	 and	 DWORD PTR tv73[ebp], 0
$LN33@find_node_:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3595 :             if (eq(k, this->get_key(n))) {

  0004a	0f b6 45 f4	 movzx	 eax, BYTE PTR tv73[ebp]
  0004e	85 c0		 test	 eax, eax
  00050	74 07		 je	 SHORT $LN37@find_node_

; 3596 :               return n;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00055	eb 24		 jmp	 SHORT $LN1@find_node_

; 3597 :             } else if (this->node_bucket(n) != bucket_index) {

  00057	eb 14		 jmp	 SHORT $LN7@find_node_
$LN37@find_node_:

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0005c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005f	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 3597 :             } else if (this->node_bucket(n) != bucket_index) {

  00064	3b 45 f0	 cmp	 eax, DWORD PTR _bucket_index$[ebp]
  00067	74 04		 je	 SHORT $LN7@find_node_

; 3598 :               return node_pointer();

  00069	33 c0		 xor	 eax, eax
  0006b	eb 0e		 jmp	 SHORT $LN1@find_node_
$LN7@find_node_:

; 3599 :             }
; 3600 : 
; 3601 :             n = next_for_find(n);

  0006d	ff 75 fc	 push	 DWORD PTR _n$[ebp]
  00070	e8 00 00 00 00	 call	 ?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
  00075	59		 pop	 ecx
  00076	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 3602 :           }

  00079	eb aa		 jmp	 SHORT $LN4@find_node_
$LN1@find_node_:

; 3603 :         }

  0007b	c9		 leave
  0007c	c2 0c 00	 ret	 12			; 0000000cH
??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@IABKABU?$equal_to@K@std@@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
_v$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ PROC ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >, COMDAT
; _this$ = ecx

; 2013 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2014 :         if (node_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 31		 je	 SHORT $LN3@node_tmp

; 2015 :           BOOST_UNORDERED_CALL_DESTROY(
; 2016 :             node_allocator_traits, alloc_, node_->value_ptr());
; 2017 :           boost::unordered::detail::func::destroy(boost::to_address(node_));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2018 :           node_allocator_traits::deallocate(alloc_, node_, 1);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	c1 e0 04	 shl	 eax, 4
  00038	50		 push	 eax
  00039	ff 75 f4	 push	 DWORD PTR __Ptr$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx
$LN3@node_tmp:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2020 :       }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ENDP ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
_v$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ PROC ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >, COMDAT
; _this$ = ecx

; 2013 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2014 :         if (node_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 31		 je	 SHORT $LN3@node_tmp

; 2015 :           BOOST_UNORDERED_CALL_DESTROY(
; 2016 :             node_allocator_traits, alloc_, node_->value_ptr());
; 2017 :           boost::unordered::detail::func::destroy(boost::to_address(node_));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2018 :           node_allocator_traits::deallocate(alloc_, node_, 1);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	c1 e0 04	 shl	 eax, 4
  00038	50		 push	 eax
  00039	ff 75 f4	 push	 DWORD PTR __Ptr$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx
$LN3@node_tmp:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2020 :       }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ENDP ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
;	COMDAT ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
_TEXT	SEGMENT
__Oldwidth$2 = -64					; size = 8
__Ok$ = -56						; size = 8
tv339 = -48						; size = 8
$T3 = -40						; size = 8
$T4 = -32						; size = 8
$T5 = -24						; size = 8
__$EHRec$ = -16						; size = 16
$T6 = 0							; size = 2
$T7 = 4							; size = 4
$T8 = 8							; size = 4
$T9 = 12						; size = 4
$T10 = 16						; size = 4
$T11 = 20						; size = 4
$T12 = 24						; size = 4
$T13 = 28						; size = 2
$T14 = 32						; size = 4
tv135 = 36						; size = 8
tv328 = 44						; size = 4
tv299 = 48						; size = 4
_this$ = 52						; size = 4
tv309 = 56						; size = 4
$T15 = 60						; size = 4
tv292 = 64						; size = 4
_this$ = 68						; size = 4
_this$ = 72						; size = 4
$T16 = 76						; size = 2
$T17 = 78						; size = 2
tv345 = 80						; size = 2
$T18 = 82						; size = 2
$T19 = 84						; size = 2
tv137 = 86						; size = 2
__Count$ = 88						; size = 8
__Pad$ = 96						; size = 8
$T20 = 105						; size = 1
$T21 = 106						; size = 1
$T22 = 107						; size = 1
__State$ = 108						; size = 4
__Ostr$ = 120						; size = 4
__Val$ = 124						; size = 4
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 816  : basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val) { // insert NTCS

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 30	 sub	 esp, 48			; 00000030H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 817  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 818  : 
; 819  :     ios_base::iostate _State = ios_base::goodbit;

  00031	83 65 6c 00	 and	 DWORD PTR __State$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 249  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));

  00035	ff 75 7c	 push	 DWORD PTR __Val$[ebp]
  00038	e8 00 00 00 00	 call	 _wcslen
  0003d	59		 pop	 ecx
  0003e	89 45 08	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 820  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  00041	8b 45 08	 mov	 eax, DWORD PTR $T8[ebp]
  00044	33 c9		 xor	 ecx, ecx
  00046	89 45 58	 mov	 DWORD PTR __Count$[ebp], eax
  00049	89 4d 5c	 mov	 DWORD PTR __Count$[ebp+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  0004c	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00054	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00057	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  0005b	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  0005f	89 55 e8	 mov	 DWORD PTR $T5[ebp], edx
  00062	89 45 ec	 mov	 DWORD PTR $T5[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 821  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00065	83 7d ec 00	 cmp	 DWORD PTR $T5[ebp+4], 0
  00069	7c 60		 jl	 SHORT $LN17@operator
  0006b	7f 06		 jg	 SHORT $LN143@operator
  0006d	83 7d e8 00	 cmp	 DWORD PTR $T5[ebp], 0
  00071	76 58		 jbe	 SHORT $LN17@operator
$LN143@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  00073	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00076	8b 00		 mov	 eax, DWORD PTR [eax]
  00078	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007b	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0007e	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  00082	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  00086	89 55 e0	 mov	 DWORD PTR $T4[ebp], edx
  00089	89 45 e4	 mov	 DWORD PTR $T4[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 821  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  0008c	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp+4]
  0008f	3b 45 5c	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  00092	7c 37		 jl	 SHORT $LN17@operator
  00094	7f 08		 jg	 SHORT $LN144@operator
  00096	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00099	3b 45 58	 cmp	 eax, DWORD PTR __Count$[ebp]
  0009c	76 2d		 jbe	 SHORT $LN17@operator
$LN144@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  0009e	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a6	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000a9	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  000ad	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  000b1	89 55 d8	 mov	 DWORD PTR $T3[ebp], edx
  000b4	89 45 dc	 mov	 DWORD PTR $T3[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 821  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  000b7	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  000ba	2b 45 58	 sub	 eax, DWORD PTR __Count$[ebp]
  000bd	8b 4d dc	 mov	 ecx, DWORD PTR $T3[ebp+4]
  000c0	1b 4d 5c	 sbb	 ecx, DWORD PTR __Count$[ebp+4]
  000c3	89 45 24	 mov	 DWORD PTR tv135[ebp], eax
  000c6	89 4d 28	 mov	 DWORD PTR tv135[ebp+4], ecx
  000c9	eb 08		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000cb	0f 57 c0	 xorps	 xmm0, xmm0
  000ce	66 0f 13 45 24	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  000d3	8b 45 24	 mov	 eax, DWORD PTR tv135[ebp]
  000d6	8b 4d 28	 mov	 ecx, DWORD PTR tv135[ebp+4]
  000d9	89 45 60	 mov	 DWORD PTR __Pad$[ebp], eax
  000dc	89 4d 64	 mov	 DWORD PTR __Pad$[ebp+4], ecx

; 822  :     const typename _Myos::sentry _Ok(_Ostr);

  000df	ff 75 78	 push	 DWORD PTR __Ostr$[ebp]
  000e2	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000e5	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  000ea	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 125  :             return _Ok;

  000ee	8a 45 cc	 mov	 al, BYTE PTR __Ok$[ebp+4]
  000f1	88 45 6b	 mov	 BYTE PTR $T22[ebp], al

; 823  : 
; 824  :     if (!_Ok) {

  000f4	0f b6 45 6b	 movzx	 eax, BYTE PTR $T22[ebp]
  000f8	85 c0		 test	 eax, eax
  000fa	75 0e		 jne	 SHORT $LN8@operator

; 825  :         _State |= ios_base::badbit;

  000fc	8b 45 6c	 mov	 eax, DWORD PTR __State$[ebp]
  000ff	83 c8 04	 or	 eax, 4
  00102	89 45 6c	 mov	 DWORD PTR __State$[ebp], eax

; 826  :     } else { // state okay, insert

  00105	e9 3f 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 827  :         _TRY_IO_BEGIN

  0010a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 326  :         return _Fmtfl;

  0010e	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00111	8b 00		 mov	 eax, DWORD PTR [eax]
  00113	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00116	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00119	8b 44 01 14	 mov	 eax, DWORD PTR [ecx+eax+20]
  0011d	89 45 04	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 828  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00120	8b 45 04	 mov	 eax, DWORD PTR $T7[ebp]
  00123	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00128	83 f8 40	 cmp	 eax, 64			; 00000040H
  0012b	0f 84 a3 00 00
	00		 je	 $LN11@operator

; 829  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00131	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00133	8b 45 60	 mov	 eax, DWORD PTR __Pad$[ebp]
  00136	83 e8 01	 sub	 eax, 1
  00139	8b 4d 64	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  0013c	83 d9 00	 sbb	 ecx, 0
  0013f	89 45 60	 mov	 DWORD PTR __Pad$[ebp], eax
  00142	89 4d 64	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
  00145	83 7d 64 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  00149	0f 8c 85 00 00
	00		 jl	 $LN11@operator
  0014f	7f 06		 jg	 SHORT $LN145@operator
  00151	83 7d 60 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00155	76 7d		 jbe	 SHORT $LN11@operator
$LN145@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 101  :         return _Fillch;

  00157	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0015a	8b 00		 mov	 eax, DWORD PTR [eax]
  0015c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0015f	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00162	66 8b 44 01 40	 mov	 ax, WORD PTR [ecx+eax+64]
  00167	66 89 45 00	 mov	 WORD PTR $T6[ebp], ax

; 80   :         return _Mystrbuf;

  0016b	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0016e	8b 00		 mov	 eax, DWORD PTR [eax]
  00170	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00173	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00176	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  0017a	89 45 20	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 830  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0017d	ff 75 00	 push	 DWORD PTR $T6[ebp]
  00180	8b 4d 20	 mov	 ecx, DWORD PTR $T14[ebp]
  00183	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
  00188	66 89 45 56	 mov	 WORD PTR tv137[ebp], ax
  0018c	66 8b 45 56	 mov	 ax, WORD PTR tv137[ebp]
  00190	66 89 45 54	 mov	 WORD PTR $T19[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00194	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00199	66 89 45 52	 mov	 WORD PTR $T18[ebp], ax

; 301  :         return _Left == _Right;

  0019d	0f b7 45 54	 movzx	 eax, WORD PTR $T19[ebp]
  001a1	0f b7 4d 52	 movzx	 ecx, WORD PTR $T18[ebp]
  001a5	3b c8		 cmp	 ecx, eax
  001a7	75 09		 jne	 SHORT $LN62@operator
  001a9	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv292[ebp], 1
  001b0	eb 04		 jmp	 SHORT $LN63@operator
$LN62@operator:
  001b2	83 65 40 00	 and	 DWORD PTR tv292[ebp], 0
$LN63@operator:
  001b6	8a 45 40	 mov	 al, BYTE PTR tv292[ebp]
  001b9	88 45 6a	 mov	 BYTE PTR $T21[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 830  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  001bc	0f b6 45 6a	 movzx	 eax, BYTE PTR $T21[ebp]
  001c0	85 c0		 test	 eax, eax
  001c2	74 0b		 je	 SHORT $LN12@operator

; 831  :                     _State |= ios_base::badbit; // insertion failed, quit

  001c4	8b 45 6c	 mov	 eax, DWORD PTR __State$[ebp]
  001c7	83 c8 04	 or	 eax, 4
  001ca	89 45 6c	 mov	 DWORD PTR __State$[ebp], eax

; 832  :                     break;

  001cd	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 833  :                 }
; 834  :             }

  001cf	e9 5f ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 837  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  001d4	83 7d 6c 00	 cmp	 DWORD PTR __State$[ebp], 0
  001d8	75 45		 jne	 SHORT $LN13@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  001da	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001dd	8b 00		 mov	 eax, DWORD PTR [eax]
  001df	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001e2	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001e5	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  001e9	89 45 3c	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 172  :         return xsputn(_Ptr, _Count);

  001ec	ff 75 5c	 push	 DWORD PTR __Count$[ebp+4]
  001ef	ff 75 58	 push	 DWORD PTR __Count$[ebp]
  001f2	ff 75 7c	 push	 DWORD PTR __Val$[ebp]
  001f5	8b 45 3c	 mov	 eax, DWORD PTR $T15[ebp]
  001f8	8b 00		 mov	 eax, DWORD PTR [eax]
  001fa	8b 4d 3c	 mov	 ecx, DWORD PTR $T15[ebp]
  001fd	ff 50 24	 call	 DWORD PTR [eax+36]
  00200	89 45 d0	 mov	 DWORD PTR tv339[ebp], eax
  00203	89 55 d4	 mov	 DWORD PTR tv339[ebp+4], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 837  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  00206	8b 45 d0	 mov	 eax, DWORD PTR tv339[ebp]
  00209	3b 45 58	 cmp	 eax, DWORD PTR __Count$[ebp]
  0020c	75 08		 jne	 SHORT $LN146@operator
  0020e	8b 45 d4	 mov	 eax, DWORD PTR tv339[ebp+4]
  00211	3b 45 5c	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  00214	74 09		 je	 SHORT $LN13@operator
$LN146@operator:

; 838  :             _State |= ios_base::badbit;

  00216	8b 45 6c	 mov	 eax, DWORD PTR __State$[ebp]
  00219	83 c8 04	 or	 eax, 4
  0021c	89 45 6c	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 839  :         }
; 840  : 
; 841  :         if (_State == ios_base::goodbit) {

  0021f	83 7d 6c 00	 cmp	 DWORD PTR __State$[ebp], 0
  00223	0f 85 a3 00 00
	00		 jne	 $LN14@operator

; 842  :             for (; 0 < _Pad; --_Pad) { // pad on right

  00229	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  0022b	8b 45 60	 mov	 eax, DWORD PTR __Pad$[ebp]
  0022e	83 e8 01	 sub	 eax, 1
  00231	8b 4d 64	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  00234	83 d9 00	 sbb	 ecx, 0
  00237	89 45 60	 mov	 DWORD PTR __Pad$[ebp], eax
  0023a	89 4d 64	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
  0023d	83 7d 64 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  00241	0f 8c 85 00 00
	00		 jl	 $LN14@operator
  00247	7f 06		 jg	 SHORT $LN147@operator
  00249	83 7d 60 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  0024d	76 7d		 jbe	 SHORT $LN14@operator
$LN147@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 101  :         return _Fillch;

  0024f	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00252	8b 00		 mov	 eax, DWORD PTR [eax]
  00254	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00257	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0025a	66 8b 44 01 40	 mov	 ax, WORD PTR [ecx+eax+64]
  0025f	66 89 45 1c	 mov	 WORD PTR $T13[ebp], ax

; 80   :         return _Mystrbuf;

  00263	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00266	8b 00		 mov	 eax, DWORD PTR [eax]
  00268	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0026b	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0026e	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00272	89 45 18	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 843  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00275	ff 75 1c	 push	 DWORD PTR $T13[ebp]
  00278	8b 4d 18	 mov	 ecx, DWORD PTR $T12[ebp]
  0027b	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
  00280	66 89 45 50	 mov	 WORD PTR tv345[ebp], ax
  00284	66 8b 45 50	 mov	 ax, WORD PTR tv345[ebp]
  00288	66 89 45 4e	 mov	 WORD PTR $T17[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0028c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00291	66 89 45 4c	 mov	 WORD PTR $T16[ebp], ax

; 301  :         return _Left == _Right;

  00295	0f b7 45 4e	 movzx	 eax, WORD PTR $T17[ebp]
  00299	0f b7 4d 4c	 movzx	 ecx, WORD PTR $T16[ebp]
  0029d	3b c8		 cmp	 ecx, eax
  0029f	75 09		 jne	 SHORT $LN94@operator
  002a1	c7 45 38 01 00
	00 00		 mov	 DWORD PTR tv309[ebp], 1
  002a8	eb 04		 jmp	 SHORT $LN95@operator
$LN94@operator:
  002aa	83 65 38 00	 and	 DWORD PTR tv309[ebp], 0
$LN95@operator:
  002ae	8a 45 38	 mov	 al, BYTE PTR tv309[ebp]
  002b1	88 45 69	 mov	 BYTE PTR $T20[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 843  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  002b4	0f b6 45 69	 movzx	 eax, BYTE PTR $T20[ebp]
  002b8	85 c0		 test	 eax, eax
  002ba	74 0b		 je	 SHORT $LN15@operator

; 844  :                     _State |= ios_base::badbit; // insertion failed, quit

  002bc	8b 45 6c	 mov	 eax, DWORD PTR __State$[ebp]
  002bf	83 c8 04	 or	 eax, 4
  002c2	89 45 6c	 mov	 DWORD PTR __State$[ebp], eax

; 845  :                     break;

  002c5	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 846  :                 }
; 847  :             }

  002c7	e9 5f ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 850  :         _Ostr.width(0);

  002cc	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002cf	8b 00		 mov	 eax, DWORD PTR [eax]
  002d1	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002d4	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  002d7	89 4d 34	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 367  :         const streamsize _Oldwidth = _Wide;

  002da	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  002dd	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  002e0	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  002e3	89 4d c0	 mov	 DWORD PTR __Oldwidth$2[ebp], ecx
  002e6	89 45 c4	 mov	 DWORD PTR __Oldwidth$2[ebp+4], eax

; 368  :         _Wide                      = _Newwidth;

  002e9	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  002ec	33 c9		 xor	 ecx, ecx
  002ee	33 d2		 xor	 edx, edx
  002f0	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  002f3	89 50 24	 mov	 DWORD PTR [eax+36], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 850  :         _Ostr.width(0);

  002f6	eb 47		 jmp	 SHORT $LN19@operator
__catch$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$0:

; 851  :         _CATCH_IO_(ios_base, _Ostr)

  002f8	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002fb	8b 00		 mov	 eax, DWORD PTR [eax]
  002fd	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00300	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00303	89 4d 48	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  00306	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00309	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0030c	89 45 14	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0030f	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00312	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00316	74 06		 je	 SHORT $LN105@operator
  00318	83 65 30 00	 and	 DWORD PTR tv299[ebp], 0
  0031c	eb 07		 jmp	 SHORT $LN106@operator
$LN105@operator:
  0031e	c7 45 30 04 00
	00 00		 mov	 DWORD PTR tv299[ebp], 4
$LN106@operator:
  00325	6a 01		 push	 1

; 53   :         clear(rdstate() | _State, _Reraise);

  00327	8b 45 14	 mov	 eax, DWORD PTR $T11[ebp]
  0032a	83 c8 04	 or	 eax, 4

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0032d	0b 45 30	 or	 eax, DWORD PTR tv299[ebp]
  00330	50		 push	 eax
  00331	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  00334	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 851  :         _CATCH_IO_(ios_base, _Ostr)

  00339	b8 00 00 00 00	 mov	 eax, $LN23@operator
  0033e	c3		 ret	 0
$LN19@operator:
  0033f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  00343	eb 04		 jmp	 SHORT $LN9@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
  00345	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 852  :     }
; 853  : 
; 854  :     _Ostr.setstate(_State);

  00349	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0034c	8b 00		 mov	 eax, DWORD PTR [eax]
  0034e	8b 4d 78	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00351	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00354	89 4d 44	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  00357	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  0035a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0035d	89 45 10	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00360	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  00363	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00367	74 06		 je	 SHORT $LN121@operator
  00369	83 65 2c 00	 and	 DWORD PTR tv328[ebp], 0
  0036d	eb 07		 jmp	 SHORT $LN122@operator
$LN121@operator:
  0036f	c7 45 2c 04 00
	00 00		 mov	 DWORD PTR tv328[ebp], 4
$LN122@operator:
  00376	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  00378	8b 45 10	 mov	 eax, DWORD PTR $T10[ebp]
  0037b	0b 45 6c	 or	 eax, DWORD PTR __State$[ebp]

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0037e	0b 45 2c	 or	 eax, DWORD PTR tv328[ebp]
  00381	50		 push	 eax
  00382	8b 4d 44	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 855  :     return _Ostr;

  0038a	8b 45 78	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0038d	89 45 0c	 mov	 DWORD PTR $T9[ebp], eax
  00390	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00394	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00397	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  0039c	8b 45 0c	 mov	 eax, DWORD PTR $T9[ebp]

; 856  : }

  0039f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  003a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003a9	59		 pop	 ecx
  003aa	5f		 pop	 edi
  003ab	5e		 pop	 esi
  003ac	5b		 pop	 ebx
  003ad	83 c5 70	 add	 ebp, 112		; 00000070H
  003b0	c9		 leave
  003b1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z$2:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Ostr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4725 :     basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 3770 :         return _Mypair._Myval2._Mysize;

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Str$[ebp]
  00007	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax

; 4726 :     return _Insert_string(_Ostr, _Str.data(), _Str.size());

  0000d	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00013	e8 00 00 00 00	 call	 ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
  00018	50		 push	 eax
  00019	ff 75 08	 push	 DWORD PTR __Ostr$[ebp]
  0001c	e8 00 00 00 00	 call	 ??$_Insert_string@_WU?$char_traits@_W@std@@I@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@QB_WI@Z ; std::_Insert_string<wchar_t,std::char_traits<wchar_t>,unsigned int>
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4727 : }

  00024	c9		 leave
  00025	c3		 ret	 0
??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
___formal$ = -28					; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 1545 :     void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00009	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00018	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00024	89 45 e4	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00027	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00033	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00036	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1547 :         ++_Last;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00044	83 c0 18	 add	 eax, 24			; 00000018H
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1548 :     }

  0004d	c9		 leave
  0004e	c2 04 00	 ret	 4
??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = ecx

; 1540 :     ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff 70 08	 push	 DWORD PTR [eax+8]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	ff 70 04	 push	 DWORD PTR [eax+4]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff 30		 push	 DWORD PTR [eax]
  00018	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -40					; size = 4
___formal$ = -36					; size = 4
_this$ = -32						; size = 4
$T2 = -28						; size = 4
_v$ = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$6 = -1				; size = 1
?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::create_node, COMDAT
; _this$ = ecx

; 1983 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	57		 push	 edi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1985 :         node_ = node_allocator_traits::allocate(alloc_, 1);

  0000a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 00		 mov	 eax, DWORD PTR [eax]
  0000f	89 45 dc	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00012	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$6[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00016	c7 45 d8 cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  00025	76 05		 jbe	 SHORT $LN6@create_nod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00027	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@create_nod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  0002c	33 c0		 xor	 eax, eax
  0002e	40		 inc	 eax
  0002f	6b c0 14	 imul	 eax, eax, 20
  00032	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  00035	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  00038	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0003d	59		 pop	 ecx
  0003e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1985 :         node_ = node_allocator_traits::allocate(alloc_, 1);

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00047	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1986 :         new ((void*)boost::to_address(node_)) node();

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00050	89 45 e8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00053	8b 45 e8	 mov	 eax, DWORD PTR _v$[ebp]
  00056	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00059	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2579 :         ptr_bucket() : next_(0) {}

  0005f	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00062	83 20 00	 and	 DWORD PTR [eax], 0

; 4865 :         ptr_node() : bucket_base(), bucket_info_(0) {}

  00065	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00068	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0006c	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  0006f	83 c0 08	 add	 eax, 8
  00072	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax

; 754  :         value_base() : data_() {}

  00075	33 c0		 xor	 eax, eax
  00077	8b 7d e0	 mov	 edi, DWORD PTR _this$[ebp]
  0007a	ab		 stosd
  0007b	ab		 stosd
  0007c	ab		 stosd
$LN9@create_nod:

; 1987 :       }

  0007d	5f		 pop	 edi
  0007e	c9		 leave
  0007f	c3		 ret	 0
?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::create_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
_v$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ PROC ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >, COMDAT
; _this$ = ecx

; 1975 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1976 :         if (node_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 31		 je	 SHORT $LN3@node_const

; 1977 :           boost::unordered::detail::func::destroy(boost::to_address(node_));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1978 :           node_allocator_traits::deallocate(alloc_, node_, 1);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 14	 imul	 eax, eax, 20
  00038	50		 push	 eax
  00039	ff 75 f4	 push	 DWORD PTR __Ptr$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx
$LN3@node_const:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1980 :       }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ENDP ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z
_TEXT	SEGMENT
_a$ = -48						; size = 8
$T2 = -40						; size = 4
_p$3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
_address$ = -20						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_alloc$ = 8						; size = 4
_<args_0>$ = 12						; size = 4
??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z PROC ; boost::unordered::detail::func::construct_node_from_args<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > >,std::pair<unsigned long const ,SEterPackIndex *> >, COMDAT

; 2037 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1946 :         node_constructor(node_allocator& n) : alloc_(n), node_() {}

  00025	8b 45 08	 mov	 eax, DWORD PTR _alloc$[ebp]
  00028	89 45 d0	 mov	 DWORD PTR _a$[ebp], eax
  0002b	83 65 d4 00	 and	 DWORD PTR _a$[ebp+4], 0

; 2038 :           node_constructor<Alloc> a(alloc);

  0002f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2039 :           a.create_node();

  00033	8d 4d d0	 lea	 ecx, DWORD PTR _a$[ebp]
  00036	e8 00 00 00 00	 call	 ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::create_node
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 249  :          {  return static_cast<T&&>(t);   }

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4869 :         value_type* value_ptr() { return value_base_.value_ptr(); }

  00041	8b 45 d4	 mov	 eax, DWORD PTR _a$[ebp+4]
  00044	83 c0 08	 add	 eax, 8

; 2040 :           construct_from_args(

  00047	89 45 ec	 mov	 DWORD PTR _address$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 249  :          {  return static_cast<T&&>(t);   }

  0004a	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00050	8b 45 ec	 mov	 eax, DWORD PTR _address$[ebp]
  00053	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00056	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00059	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0005c	8b 45 e4	 mov	 eax, DWORD PTR $T5[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00064	8b 55 e0	 mov	 edx, DWORD PTR $T4[ebp]
  00067	89 0a		 mov	 DWORD PTR [edx], ecx
  00069	89 42 04	 mov	 DWORD PTR [edx+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1956 :           node_pointer p = node_;

  0006c	8b 45 d4	 mov	 eax, DWORD PTR _a$[ebp+4]
  0006f	89 45 dc	 mov	 DWORD PTR _p$3[ebp], eax

; 1957 :           node_ = node_pointer();

  00072	83 65 d4 00	 and	 DWORD PTR _a$[ebp+4], 0

; 2041 :             alloc, a.node_->value_ptr(), BOOST_UNORDERED_EMPLACE_FORWARD);
; 2042 :           return a.release();

  00076	8b 45 dc	 mov	 eax, DWORD PTR _p$3[ebp]
  00079	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  0007c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	8d 4d d0	 lea	 ecx, DWORD PTR _a$[ebp]
  00083	e8 00 00 00 00	 call	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
  00088	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]

; 2043 :         }

  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	c9		 leave
  00097	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _a$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z ENDP ; boost::unordered::detail::func::construct_node_from_args<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > >,std::pair<unsigned long const ,SEterPackIndex *> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$_Sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0HU?$less@X@0@@Z
_TEXT	SEGMENT
__Mid$1 = -12						; size = 8
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ideal$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$_Sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0HU?$less@X@0@@Z PROC ; std::_Sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >, COMDAT

; 7537 : _CONSTEXPR20 void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Iter_diff_t<_RanIt> _Ideal, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
$LN4@Sort_unche:

; 7538 :     // order [_First, _Last)
; 7539 :     for (;;) {
; 7540 :         if (_Last - _First <= _ISORT_MAX) { // small

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000a	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000d	99		 cdq
  0000e	6a 18		 push	 24			; 00000018H
  00010	59		 pop	 ecx
  00011	f7 f9		 idiv	 ecx
  00013	83 f8 20	 cmp	 eax, 32			; 00000020H
  00016	7f 16		 jg	 SHORT $LN5@Sort_unche

; 7541 :             _Insertion_sort_unchecked(_First, _Last, _Pred);

  00018	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0001b	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001e	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Insertion_sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@0U?$less@X@0@@Z ; std::_Insertion_sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7542 :             return;

  00029	e9 cc 00 00 00	 jmp	 $LN1@Sort_unche
$LN5@Sort_unche:

; 7543 :         }
; 7544 : 
; 7545 :         if (_Ideal <= 0) { // heap sort if too many divisions

  0002e	83 7d 10 00	 cmp	 DWORD PTR __Ideal$[ebp], 0
  00032	7f 48		 jg	 SHORT $LN6@Sort_unche

; 7546 :             _Make_heap_unchecked(_First, _Last, _Pred);

  00034	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  00037	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0003a	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0003d	e8 00 00 00 00	 call	 ??$_Make_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ; std::_Make_heap_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 7547 :             _Sort_heap_unchecked(_First, _Last, _Pred);

  00045	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00048	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax

; 6592 :     for (; _Last - _First >= 2; --_Last) {

  0004b	eb 09		 jmp	 SHORT $LN149@Sort_unche
$LN147@Sort_unche:
  0004d	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  00050	83 e8 18	 sub	 eax, 24			; 00000018H
  00053	89 45 fc	 mov	 DWORD PTR __Last$[ebp], eax
$LN149@Sort_unche:
  00056	8b 45 fc	 mov	 eax, DWORD PTR __Last$[ebp]
  00059	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0005c	99		 cdq
  0005d	6a 18		 push	 24			; 00000018H
  0005f	59		 pop	 ecx
  00060	f7 f9		 idiv	 ecx
  00062	83 f8 02	 cmp	 eax, 2
  00065	7c 13		 jl	 SHORT $LN146@Sort_unche

; 6593 :         _Pop_heap_unchecked(_First, _Last, _Pred);

  00067	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0006a	ff 75 fc	 push	 DWORD PTR __Last$[ebp]
  0006d	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00070	e8 00 00 00 00	 call	 ??$_Pop_heap_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ; std::_Pop_heap_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 6594 :     }

  00078	eb d3		 jmp	 SHORT $LN147@Sort_unche
$LN146@Sort_unche:

; 7548 :             return;

  0007a	eb 7e		 jmp	 SHORT $LN1@Sort_unche
$LN6@Sort_unche:

; 7549 :         }
; 7550 : 
; 7551 :         // divide and conquer by quicksort
; 7552 :         auto _Mid = _Partition_by_median_guess_unchecked(_First, _Last, _Pred);

  0007c	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  0007f	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00082	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00085	8d 45 f4	 lea	 eax, DWORD PTR __Mid$1[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ??$_Partition_by_median_guess_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YA?AU?$pair@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PAV12@@0@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0U?$less@X@0@@Z ; std::_Partition_by_median_guess_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  0008e	83 c4 10	 add	 esp, 16			; 00000010H

; 7553 : 
; 7554 :         _Ideal = (_Ideal >> 1) + (_Ideal >> 2); // allow 1.5 log2(N) divisions

  00091	8b 45 10	 mov	 eax, DWORD PTR __Ideal$[ebp]
  00094	d1 f8		 sar	 eax, 1
  00096	8b 4d 10	 mov	 ecx, DWORD PTR __Ideal$[ebp]
  00099	c1 f9 02	 sar	 ecx, 2
  0009c	03 c1		 add	 eax, ecx
  0009e	89 45 10	 mov	 DWORD PTR __Ideal$[ebp], eax

; 7555 : 
; 7556 :         if (_Mid.first - _First < _Last - _Mid.second) { // loop on second half

  000a1	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000a4	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  000a7	99		 cdq
  000a8	6a 18		 push	 24			; 00000018H
  000aa	59		 pop	 ecx
  000ab	f7 f9		 idiv	 ecx
  000ad	8b c8		 mov	 ecx, eax
  000af	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  000b2	2b 45 f8	 sub	 eax, DWORD PTR __Mid$1[ebp+4]
  000b5	99		 cdq
  000b6	6a 18		 push	 24			; 00000018H
  000b8	5e		 pop	 esi
  000b9	f7 fe		 idiv	 esi
  000bb	3b c8		 cmp	 ecx, eax
  000bd	7d 1c		 jge	 SHORT $LN7@Sort_unche

; 7557 :             _Sort_unchecked(_First, _Mid.first, _Ideal, _Pred);

  000bf	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000c2	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000c5	ff 75 f4	 push	 DWORD PTR __Mid$1[ebp]
  000c8	ff 75 08	 push	 DWORD PTR __First$[ebp]
  000cb	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0HU?$less@X@0@@Z ; std::_Sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  000d0	83 c4 10	 add	 esp, 16			; 00000010H

; 7558 :             _First = _Mid.second;

  000d3	8b 45 f8	 mov	 eax, DWORD PTR __Mid$1[ebp+4]
  000d6	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 7559 :         } else { // loop on first half

  000d9	eb 1a		 jmp	 SHORT $LN8@Sort_unche
$LN7@Sort_unche:

; 7560 :             _Sort_unchecked(_Mid.second, _Last, _Ideal, _Pred);

  000db	ff 75 14	 push	 DWORD PTR __Pred$[ebp]
  000de	ff 75 10	 push	 DWORD PTR __Ideal$[ebp]
  000e1	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  000e4	ff 75 f8	 push	 DWORD PTR __Mid$1[ebp+4]
  000e7	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0HU?$less@X@0@@Z ; std::_Sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  000ec	83 c4 10	 add	 esp, 16			; 00000010H

; 7561 :             _Last = _Mid.first;

  000ef	8b 45 f4	 mov	 eax, DWORD PTR __Mid$1[ebp]
  000f2	89 45 0c	 mov	 DWORD PTR __Last$[ebp], eax
$LN8@Sort_unche:

; 7562 :         }
; 7563 :     }

  000f5	e9 0d ff ff ff	 jmp	 $LN4@Sort_unche
$LN1@Sort_unche:

; 7564 : }

  000fa	5e		 pop	 esi
  000fb	c9		 leave
  000fc	c3		 ret	 0
??$_Sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0HU?$less@X@0@@Z ENDP ; std::_Sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
;	COMDAT ??$?9V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z PROC ; std::operator!=<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>, COMDAT

; 297  :     const istream_iterator<_Ty, _Elem, _Traits, _Diff>& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 298  :     return !(_Left == _Right);

  00004	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$?8V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z ; std::operator==<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	83 65 fc 00	 and	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00025	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 299  : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$?9V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z ENDP ; std::operator!=<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z
_TEXT	SEGMENT
_a$ = -64						; size = 8
$T2 = -56						; size = 4
_p$3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
_this$8 = -32						; size = 4
$T9 = -28						; size = 4
$T10 = -24						; size = 4
$T11 = -20						; size = 4
$T12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_alloc$ = 8						; size = 4
_k$ = 12						; size = 4
??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z PROC ; boost::unordered::detail::func::construct_node_pair<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > >,unsigned long const &>, COMDAT

; 2064 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1946 :         node_constructor(node_allocator& n) : alloc_(n), node_() {}

  00025	8b 45 08	 mov	 eax, DWORD PTR _alloc$[ebp]
  00028	89 45 c0	 mov	 DWORD PTR _a$[ebp], eax
  0002b	83 65 c4 00	 and	 DWORD PTR _a$[ebp+4], 0

; 2065 :           node_constructor<Alloc> a(alloc);

  0002f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2066 :           a.create_node();

  00033	8d 4d c0	 lea	 ecx, DWORD PTR _a$[ebp]
  00036	e8 00 00 00 00	 call	 ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::create_node
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  0003b	8d 45 f3	 lea	 eax, DWORD PTR $T12[ebp]
  0003e	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 249  :          {  return static_cast<T&&>(t);   }

  00041	8b 45 0c	 mov	 eax, DWORD PTR _k$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00047	8b 45 ec	 mov	 eax, DWORD PTR $T11[ebp]
  0004a	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
  0004d	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  00050	89 45 e4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 245  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00053	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e0	 mov	 DWORD PTR _this$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00059	8b 45 e4	 mov	 eax, DWORD PTR $T9[ebp]
  0005c	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\tuple

; 163  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  0005f	8b 45 e0	 mov	 eax, DWORD PTR _this$8[ebp]
  00062	8b 4d dc	 mov	 ecx, DWORD PTR $T7[ebp]
  00065	89 08		 mov	 DWORD PTR [eax], ecx

; 854  :     return tuple<_Types&&...>(_STD forward<_Types>(_Args)...);

  00067	8d 45 d8	 lea	 eax, DWORD PTR $T6[ebp]
  0006a	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2067 :           boost::unordered::detail::allocator_traits<Alloc>::construct(alloc,

  0006d	ff 75 d4	 push	 DWORD PTR $T5[ebp]
  00070	ff 75 d0	 push	 DWORD PTR $T4[ebp]
  00073	68 00 00 00 00	 push	 OFFSET ?piecewise_construct@std@@3Upiecewise_construct_t@1@B

; 4869 :         value_type* value_ptr() { return value_base_.value_ptr(); }

  00078	8b 45 c4	 mov	 eax, DWORD PTR _a$[ebp+4]
  0007b	83 c0 08	 add	 eax, 8

; 2067 :           boost::unordered::detail::allocator_traits<Alloc>::construct(alloc,

  0007e	50		 push	 eax
  0007f	ff 75 08	 push	 DWORD PTR _alloc$[ebp]
  00082	e8 00 00 00 00	 call	 ??$construct@U?$pair@$$CBKK@std@@ABUpiecewise_construct_t@2@V?$tuple@ABK@2@V?$tuple@$$V@2@@?$_Default_allocator_traits@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@std@@SAXAAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@1@QAU?$pair@$$CBKK@1@ABUpiecewise_construct_t@1@$$QAV?$tuple@ABK@1@$$QAV?$tuple@$$V@1@@Z ; std::_Default_allocator_traits<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::construct<std::pair<unsigned long const ,unsigned long>,std::piecewise_construct_t const &,std::tuple<unsigned long const &>,std::tuple<> >
  00087	83 c4 14	 add	 esp, 20			; 00000014H

; 1956 :           node_pointer p = node_;

  0008a	8b 45 c4	 mov	 eax, DWORD PTR _a$[ebp+4]
  0008d	89 45 cc	 mov	 DWORD PTR _p$3[ebp], eax

; 1957 :           node_ = node_pointer();

  00090	83 65 c4 00	 and	 DWORD PTR _a$[ebp+4], 0

; 2068 :             a.node_->value_ptr(), std::piecewise_construct,
; 2069 :             std::forward_as_tuple(boost::forward<Key>(k)),
; 2070 :             std::forward_as_tuple());
; 2071 :           return a.release();

  00094	8b 45 cc	 mov	 eax, DWORD PTR _p$3[ebp]
  00097	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
  0009a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0009e	8d 4d c0	 lea	 ecx, DWORD PTR _a$[ebp]
  000a1	e8 00 00 00 00	 call	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
  000a6	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]

; 2072 :         }

  000a9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ac	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b3	59		 pop	 ecx
  000b4	c9		 leave
  000b5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _a$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z ENDP ; boost::unordered::detail::func::construct_node_pair<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > >,unsigned long const &>
; Function compile flags: /Odspy
;	COMDAT ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  0000f	c9		 leave
  00010	c3		 ret	 0
??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv72 = -20						; size = 4
__Rdbuf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 88   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :             const auto _Rdbuf = _Myistr.rdbuf();

  00028	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  00030	8b 45 ec	 mov	 eax, DWORD PTR tv72[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	8b 4d ec	 mov	 ecx, DWORD PTR tv72[ebp]
  0003b	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  0003f	89 45 f0	 mov	 DWORD PTR __Rdbuf$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 90   :             if (_Rdbuf) {

  00042	83 7d f0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00046	74 0b		 je	 SHORT $LN3@Sentry_bas

; 91   :                 _Rdbuf->_Unlock();

  00048	8b 45 f0	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00050	ff 50 08	 call	 DWORD PTR [eax+8]
$LN3@Sentry_bas:

; 92   :             }
; 93   :         }

  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	c9		 leave
  0005f	c3		 ret	 0
  00060	cc		 int	 3
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Rdbuf$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 81   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 82   :             const auto _Rdbuf = _Myistr.rdbuf();

  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  00019	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  00024	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00028	89 45 fc	 mov	 DWORD PTR __Rdbuf$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 83   :             if (_Rdbuf) {

  0002b	83 7d fc 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0002f	74 0b		 je	 SHORT $LN1@Sentry_bas

; 84   :                 _Rdbuf->_Lock();

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00039	ff 50 04	 call	 DWORD PTR [eax+4]
$LN1@Sentry_bas:

; 85   :             }
; 86   :         }

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c9		 leave
  00040	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@IABKABU?$equal_to@K@std@@@Z
_TEXT	SEGMENT
_bucket_index$ = -16					; size = 4
tv73 = -12						; size = 4
_this$ = -8						; size = 4
_n$ = -4						; size = 4
_key_hash$ = 8						; size = 4
_k$ = 12						; size = 4
_eq$ = 16						; size = 4
??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@IABKABU?$equal_to@K@std@@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >, COMDAT
; _this$ = ecx

; 3587 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2604 :           return hash % bucket_count;

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	8b 45 08	 mov	 eax, DWORD PTR _key_hash$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	f7 71 04	 div	 DWORD PTR [ecx+4]

; 3588 :           std::size_t bucket_index = this->hash_to_bucket(key_hash);

  00014	89 55 f0	 mov	 DWORD PTR _bucket_index$[ebp], edx

; 3589 :           node_pointer n = this->begin(bucket_index);

  00017	ff 75 f0	 push	 DWORD PTR _bucket_index$[ebp]
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
  00022	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@find_node_:

; 3590 : 
; 3591 :           for (;;) {
; 3592 :             if (!n)

  00025	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00029	75 05		 jne	 SHORT $LN25@find_node_

; 3593 :               return n;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0002e	eb 4b		 jmp	 SHORT $LN1@find_node_
$LN25@find_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 91   :         return _Left == _Right;

  00030	8b 45 0c	 mov	 eax, DWORD PTR _k$[ebp]
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0003b	75 09		 jne	 SHORT $LN35@find_node_
  0003d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  00044	eb 04		 jmp	 SHORT $LN33@find_node_
$LN35@find_node_:
  00046	83 65 f4 00	 and	 DWORD PTR tv73[ebp], 0
$LN33@find_node_:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3595 :             if (eq(k, this->get_key(n))) {

  0004a	0f b6 45 f4	 movzx	 eax, BYTE PTR tv73[ebp]
  0004e	85 c0		 test	 eax, eax
  00050	74 07		 je	 SHORT $LN37@find_node_

; 3596 :               return n;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00055	eb 24		 jmp	 SHORT $LN1@find_node_

; 3597 :             } else if (this->node_bucket(n) != bucket_index) {

  00057	eb 14		 jmp	 SHORT $LN7@find_node_
$LN37@find_node_:

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0005c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005f	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 3597 :             } else if (this->node_bucket(n) != bucket_index) {

  00064	3b 45 f0	 cmp	 eax, DWORD PTR _bucket_index$[ebp]
  00067	74 04		 je	 SHORT $LN7@find_node_

; 3598 :               return node_pointer();

  00069	33 c0		 xor	 eax, eax
  0006b	eb 0e		 jmp	 SHORT $LN1@find_node_
$LN7@find_node_:

; 3599 :             }
; 3600 : 
; 3601 :             n = next_for_find(n);

  0006d	ff 75 fc	 push	 DWORD PTR _n$[ebp]
  00070	e8 00 00 00 00	 call	 ?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
  00075	59		 pop	 ecx
  00076	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 3602 :           }

  00079	eb aa		 jmp	 SHORT $LN4@find_node_
$LN1@find_node_:

; 3603 :         }

  0007b	c9		 leave
  0007c	c2 0c 00	 ret	 12			; 0000000cH
??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@IABKABU?$equal_to@K@std@@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
___formal$ = -20					; size = 4
$T1 = -16						; size = 4
__Ptr$ = -12						; size = 4
_v$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ PROC ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >, COMDAT
; _this$ = ecx

; 2013 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2014 :         if (node_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 31		 je	 SHORT $LN3@node_tmp

; 2015 :           BOOST_UNORDERED_CALL_DESTROY(
; 2016 :             node_allocator_traits, alloc_, node_->value_ptr());
; 2017 :           boost::unordered::detail::func::destroy(boost::to_address(node_));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _v$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2018 :           node_allocator_traits::deallocate(alloc_, node_, 1);

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 45 ec	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 14	 imul	 eax, eax, 20
  00038	50		 push	 eax
  00039	ff 75 f4	 push	 DWORD PTR __Ptr$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx
$LN3@node_tmp:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2020 :       }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ENDP ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@IABKABU?$equal_to@K@std@@@Z
_TEXT	SEGMENT
_bucket_index$ = -16					; size = 4
tv73 = -12						; size = 4
_this$ = -8						; size = 4
_n$ = -4						; size = 4
_key_hash$ = 8						; size = 4
_k$ = 12						; size = 4
_eq$ = 16						; size = 4
??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@IABKABU?$equal_to@K@std@@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >, COMDAT
; _this$ = ecx

; 3587 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2604 :           return hash % bucket_count;

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	8b 45 08	 mov	 eax, DWORD PTR _key_hash$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	f7 71 04	 div	 DWORD PTR [ecx+4]

; 3588 :           std::size_t bucket_index = this->hash_to_bucket(key_hash);

  00014	89 55 f0	 mov	 DWORD PTR _bucket_index$[ebp], edx

; 3589 :           node_pointer n = this->begin(bucket_index);

  00017	ff 75 f0	 push	 DWORD PTR _bucket_index$[ebp]
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
  00022	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN4@find_node_:

; 3590 : 
; 3591 :           for (;;) {
; 3592 :             if (!n)

  00025	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00029	75 05		 jne	 SHORT $LN25@find_node_

; 3593 :               return n;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0002e	eb 4b		 jmp	 SHORT $LN1@find_node_
$LN25@find_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 91   :         return _Left == _Right;

  00030	8b 45 0c	 mov	 eax, DWORD PTR _k$[ebp]
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  0003b	75 09		 jne	 SHORT $LN35@find_node_
  0003d	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  00044	eb 04		 jmp	 SHORT $LN33@find_node_
$LN35@find_node_:
  00046	83 65 f4 00	 and	 DWORD PTR tv73[ebp], 0
$LN33@find_node_:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3595 :             if (eq(k, this->get_key(n))) {

  0004a	0f b6 45 f4	 movzx	 eax, BYTE PTR tv73[ebp]
  0004e	85 c0		 test	 eax, eax
  00050	74 07		 je	 SHORT $LN37@find_node_

; 3596 :               return n;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00055	eb 24		 jmp	 SHORT $LN1@find_node_

; 3597 :             } else if (this->node_bucket(n) != bucket_index) {

  00057	eb 14		 jmp	 SHORT $LN7@find_node_
$LN37@find_node_:

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  00059	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  0005c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005f	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 3597 :             } else if (this->node_bucket(n) != bucket_index) {

  00064	3b 45 f0	 cmp	 eax, DWORD PTR _bucket_index$[ebp]
  00067	74 04		 je	 SHORT $LN7@find_node_

; 3598 :               return node_pointer();

  00069	33 c0		 xor	 eax, eax
  0006b	eb 0e		 jmp	 SHORT $LN1@find_node_
$LN7@find_node_:

; 3599 :             }
; 3600 : 
; 3601 :             n = next_for_find(n);

  0006d	ff 75 fc	 push	 DWORD PTR _n$[ebp]
  00070	e8 00 00 00 00	 call	 ?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
  00075	59		 pop	 ecx
  00076	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 3602 :           }

  00079	eb aa		 jmp	 SHORT $LN4@find_node_
$LN1@find_node_:

; 3603 :         }

  0007b	c9		 leave
  0007c	c2 0c 00	 ret	 12			; 0000000cH
??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@IABKABU?$equal_to@K@std@@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Backout$2 = -40					; size = 12
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0002e	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00031	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00034	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	89 45 dc	 mov	 DWORD PTR __Backout$2[ebp+4], eax
  0003d	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00040	89 45 e0	 mov	 DWORD PTR __Backout$2[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00043	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00047	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00049	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	83 c0 18	 add	 eax, 24			; 00000018H
  0004f	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00052	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00055	3b 45 ec	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00058	74 13		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0005a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));

  00060	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  00063	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00066	e8 00 00 00 00	 call	 ??$_Emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 1699 :         }

  0006b	eb dc		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  0006d	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00070	89 45 d8	 mov	 DWORD PTR __Backout$2[ebp], eax

; 1552 :         return _Last;

  00073	8b 45 dc	 mov	 eax, DWORD PTR __Backout$2[ebp+4]
  00076	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1700 : 
; 1701 :         return _Backout._Release();

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 1541 :         _Destroy_range(_First, _Last, _Al);

  0007d	ff 75 e0	 push	 DWORD PTR __Backout$2[ebp+8]
  00080	ff 75 dc	 push	 DWORD PTR __Backout$2[ebp+4]
  00083	ff 75 d8	 push	 DWORD PTR __Backout$2[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  0008e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]

; 1702 :     }
; 1703 : }

  00091	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00094	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009b	59		 pop	 ecx
  0009c	c9		 leave
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~_Uninitialized_backout_al<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 18	 add	 eax, 24			; 00000018H
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 23		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  00025	33 c0		 xor	 eax, eax
  00027	83 e0 01	 and	 eax, 1
  0002a	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002c	6a 18		 push	 24			; 00000018H
  0002e	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  00038	eb cc		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003a	c9		 leave
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<SEterPackIndex *,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<SEterPackIndex *,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z
_TEXT	SEGMENT
_a$ = -48						; size = 8
$T2 = -40						; size = 4
_p$3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
_address$ = -20						; size = 4
$T7 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_alloc$ = 8						; size = 4
_<args_0>$ = 12						; size = 4
??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z PROC ; boost::unordered::detail::func::construct_node_from_args<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > >,std::pair<unsigned long const ,CEterFileDict::Item> >, COMDAT

; 2037 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1946 :         node_constructor(node_allocator& n) : alloc_(n), node_() {}

  00027	8b 45 08	 mov	 eax, DWORD PTR _alloc$[ebp]
  0002a	89 45 d0	 mov	 DWORD PTR _a$[ebp], eax
  0002d	83 65 d4 00	 and	 DWORD PTR _a$[ebp+4], 0

; 2038 :           node_constructor<Alloc> a(alloc);

  00031	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2039 :           a.create_node();

  00035	8d 4d d0	 lea	 ecx, DWORD PTR _a$[ebp]
  00038	e8 00 00 00 00	 call	 ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::create_node
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 249  :          {  return static_cast<T&&>(t);   }

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  00040	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4869 :         value_type* value_ptr() { return value_base_.value_ptr(); }

  00043	8b 45 d4	 mov	 eax, DWORD PTR _a$[ebp+4]
  00046	83 c0 08	 add	 eax, 8

; 2040 :           construct_from_args(

  00049	89 45 ec	 mov	 DWORD PTR _address$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 249  :          {  return static_cast<T&&>(t);   }

  0004c	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  0004f	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00052	8b 45 ec	 mov	 eax, DWORD PTR _address$[ebp]
  00055	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00058	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0005b	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0005e	8b 75 e4	 mov	 esi, DWORD PTR $T5[ebp]
  00061	8b 7d e0	 mov	 edi, DWORD PTR $T4[ebp]
  00064	a5		 movsd
  00065	a5		 movsd
  00066	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 1956 :           node_pointer p = node_;

  00067	8b 45 d4	 mov	 eax, DWORD PTR _a$[ebp+4]
  0006a	89 45 dc	 mov	 DWORD PTR _p$3[ebp], eax

; 1957 :           node_ = node_pointer();

  0006d	83 65 d4 00	 and	 DWORD PTR _a$[ebp+4], 0

; 2041 :             alloc, a.node_->value_ptr(), BOOST_UNORDERED_EMPLACE_FORWARD);
; 2042 :           return a.release();

  00071	8b 45 dc	 mov	 eax, DWORD PTR _p$3[ebp]
  00074	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  00077	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007b	8d 4d d0	 lea	 ecx, DWORD PTR _a$[ebp]
  0007e	e8 00 00 00 00	 call	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
  00083	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]

; 2043 :         }

  00086	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00089	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00090	59		 pop	 ecx
  00091	5f		 pop	 edi
  00092	5e		 pop	 esi
  00093	c9		 leave
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR _a$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z ENDP ; boost::unordered::detail::func::construct_node_from_args<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > >,std::pair<unsigned long const ,CEterFileDict::Item> >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??$emplace_unique@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK$$QAU?$pair@$$CBKPAUSEterPackIndex@@@5@@Z
_TEXT	SEGMENT
$T1 = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
_x$ = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
_v$9 = -28						; size = 4
$T10 = -24						; size = 4
_key_hash$ = -20					; size = 4
_this$ = -16						; size = 4
_pos$ = -12						; size = 4
_this$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_k$ = 12						; size = 4
_<args_0>$ = 16						; size = 4
??$emplace_unique@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK$$QAU?$pair@$$CBKPAUSEterPackIndex@@@5@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_unique<std::pair<unsigned long const ,SEterPackIndex *> >, COMDAT
; _this$ = ecx

; 3735 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2791 :           return *static_cast<function_pair const*>(

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000f	83 e0 01	 and	 eax, 1
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00019	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax

; 2599 :           return hf(x);

  0001c	8b 45 0c	 mov	 eax, DWORD PTR _k$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 e4	 mov	 DWORD PTR _v$9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp

; 621  :     BOOST_HASH_SPECIALIZE(unsigned long)

  00024	ff 75 e4	 push	 DWORD PTR _v$9[ebp]
  00027	e8 00 00 00 00	 call	 ??$hash_value@K@boost@@YAIK@Z ; boost::hash_value<unsigned long>
  0002c	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3736 :           std::size_t key_hash = this->hash(k);

  0002d	89 45 ec	 mov	 DWORD PTR _key_hash$[ebp], eax

; 3576 :           return this->find_node_impl(key_hash, k, this->key_eq());

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::key_eq
  00038	50		 push	 eax
  00039	ff 75 0c	 push	 DWORD PTR _k$[ebp]
  0003c	ff 75 ec	 push	 DWORD PTR _key_hash$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@IABKABU?$equal_to@K@std@@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >

; 3737 :           node_pointer pos = this->find_node(key_hash, k);

  00047	89 45 f4	 mov	 DWORD PTR _pos$[ebp], eax

; 3738 :           if (pos) {

  0004a	83 7d f4 00	 cmp	 DWORD PTR _pos$[ebp], 0
  0004e	74 32		 je	 SHORT $LN2@emplace_un

; 3739 :             return emplace_return(iterator(pos), false);

  00050	c6 45 ff 00	 mov	 BYTE PTR $T12[ebp], 0

; 2371 :           : node_(static_cast<node_pointer>(x))

  00054	8b 45 f4	 mov	 eax, DWORD PTR _pos$[ebp]
  00057	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0005a	8d 45 e0	 lea	 eax, DWORD PTR $T8[ebp]
  0005d	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00060	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00068	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006a	8d 45 ff	 lea	 eax, DWORD PTR $T12[ebp]
  0006d	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00070	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00073	8b 4d d8	 mov	 ecx, DWORD PTR $T6[ebp]
  00076	8a 09		 mov	 cl, BYTE PTR [ecx]
  00078	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3739 :             return emplace_return(iterator(pos), false);

  0007b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007e	eb 6a		 jmp	 SHORT $LN1@emplace_un

; 3740 :           } else {

  00080	eb 68		 jmp	 SHORT $LN1@emplace_un
$LN2@emplace_un:

; 3741 :             return emplace_return(

  00082	c6 45 fe 01	 mov	 BYTE PTR $T11[ebp], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 249  :          {  return static_cast<T&&>(t);   }

  00086	8b 45 10	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  00089	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	83 c0 03	 add	 eax, 3
  00092	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00095	74 09		 je	 SHORT $LN106@emplace_un
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	40		 inc	 eax
  0009b	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
  0009e	eb 04		 jmp	 SHORT $LN102@emplace_un
$LN106@emplace_un:
  000a0	83 65 e8 00	 and	 DWORD PTR $T10[ebp], 0
$LN102@emplace_un:

; 3741 :             return emplace_return(

  000a4	ff 75 ec	 push	 DWORD PTR _key_hash$[ebp]
  000a7	ff 75 d4	 push	 DWORD PTR $T5[ebp]
  000aa	ff 75 e8	 push	 DWORD PTR $T10[ebp]
  000ad	e8 00 00 00 00	 call	 ??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKPAUSEterPackIndex@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKPAUSEterPackIndex@@@6@@Z ; boost::unordered::detail::func::construct_node_from_args<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > >,std::pair<unsigned long const ,SEterPackIndex *> >
  000b2	59		 pop	 ecx
  000b3	59		 pop	 ecx
  000b4	50		 push	 eax
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::resize_and_add_node_unique
  000bd	89 45 d0	 mov	 DWORD PTR _x$[ebp], eax

; 2371 :           : node_(static_cast<node_pointer>(x))

  000c0	8b 45 d0	 mov	 eax, DWORD PTR _x$[ebp]
  000c3	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c6	8d 45 cc	 lea	 eax, DWORD PTR $T4[ebp]
  000c9	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000cc	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  000cf	8b 00		 mov	 eax, DWORD PTR [eax]
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000d4	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000d6	8d 45 fe	 lea	 eax, DWORD PTR $T11[ebp]
  000d9	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000dc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000df	8b 4d c4	 mov	 ecx, DWORD PTR $T2[ebp]
  000e2	8a 09		 mov	 cl, BYTE PTR [ecx]
  000e4	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3741 :             return emplace_return(

  000e7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@emplace_un:

; 3742 :               iterator(this->resize_and_add_node_unique(
; 3743 :                 boost::unordered::detail::func::construct_node_from_args(
; 3744 :                   this->node_alloc(), BOOST_UNORDERED_EMPLACE_FORWARD),
; 3745 :                 key_hash)),
; 3746 :               true);
; 3747 :           }
; 3748 :         }

  000ea	c9		 leave
  000eb	c2 0c 00	 ret	 12			; 0000000cH
??$emplace_unique@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK$$QAU?$pair@$$CBKPAUSEterPackIndex@@@5@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_unique<std::pair<unsigned long const ,SEterPackIndex *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > ><SEterPackIndex * const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00046	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	83 c0 08	 add	 eax, 8
  00052	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  00058	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00063	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00066	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00069	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006c	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0006f	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00072	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00075	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	c9		 leave
  0008c	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > ><SEterPackIndex * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 12		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 0c	 imul	 eax, eax, 12
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 0c	 imul	 eax, eax, 12
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 28
__Last$ = 40						; size = 28
__Dest$ = 68						; size = 4
??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z PROC ; std::_Copy_unchecked<std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>,std::back_insert_iterator<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >, COMDAT

; 4380 : _CONSTEXPR20 _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 4392 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  0002b	eb 08		 jmp	 SHORT $LN4@Copy_unche
$LN9@Copy_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator

; 263  :         _Getval();

  0002d	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Getval@?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@AAEXXZ ; std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>::_Getval
$LN4@Copy_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4392 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  00035	8d 45 28	 lea	 eax, DWORD PTR __Last$[ebp]
  00038	50		 push	 eax
  00039	8d 45 0c	 lea	 eax, DWORD PTR __First$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$?9V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@1@H@std@@YA_NABV?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0@Z ; std::operator!=<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>
  00042	59		 pop	 ecx
  00043	59		 pop	 ecx
  00044	0f b6 c0	 movzx	 eax, al
  00047	85 c0		 test	 eax, eax
  00049	74 1c		 je	 SHORT $LN3@Copy_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator

; 55   :         return *this;

  0004b	8d 45 44	 lea	 eax, DWORD PTR __Dest$[ebp]
  0004e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 45   :         container->push_back(_Val);

  00051	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 254  :         return _Myval;

  00059	8d 45 10	 lea	 eax, DWORD PTR __First$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0005c	50		 push	 eax
  0005d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ??$emplace_back@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAEXABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::emplace_back<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const &>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4394 :     }

  00065	eb c6		 jmp	 SHORT $LN9@Copy_unche
$LN3@Copy_unche:

; 4396 :     return _Dest;

  00067	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0006a	8b 4d 44	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0006d	89 08		 mov	 DWORD PTR [eax], ecx
  0006f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00073	8d 4d 10	 lea	 ecx, DWORD PTR __First$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00076	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4396 :     return _Dest;

  0007b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007f	8d 4d 2c	 lea	 ecx, DWORD PTR __Last$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00082	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4396 :     return _Dest;

  00087	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4397 : }

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	c9		 leave
  00096	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$0:
  00000	8d 4d 28	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
__unwindfunclet$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$1:
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z ENDP ; std::_Copy_unchecked<std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>,std::back_insert_iterator<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv83 = -16						; size = 4
__Ptr$ = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 2645 :     ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2646 :         if (_Mypair._Myval2) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 2f		 je	 SHORT $LN3@unique_ptr

; 2647 :             _Mypair._Get_first()(_Mypair._Myval2);

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory

; 2647 :             _Mypair._Get_first()(_Mypair._Myval2);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2537 :         delete _Ptr;

  0001f	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00022	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00025	83 7d f8 00	 cmp	 DWORD PTR $T2[ebp], 0
  00029	74 11		 je	 SHORT $LN9@unique_ptr
  0002b	6a 01		 push	 1
  0002d	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  00035	ff 10		 call	 DWORD PTR [eax]
  00037	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  0003a	eb 04		 jmp	 SHORT $LN3@unique_ptr
$LN9@unique_ptr:
  0003c	83 65 f0 00	 and	 DWORD PTR tv83[ebp], 0
$LN3@unique_ptr:

; 2648 :         }
; 2649 :     }

  00040	c9		 leave
  00041	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z
_TEXT	SEGMENT
$T2 = -56						; size = 4
_old_p$3 = -52						; size = 4
$T4 = -48						; size = 4
_old_p$5 = -44						; size = 4
$T6 = -40						; size = 4
_this$7 = -36						; size = 4
_this$ = -32						; size = 4
tv83 = -28						; size = 4
_p$ = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_value$ = 12						; size = 4
_throwIfNotUsed$ = 16					; size = 1
??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z PROC ; CryptoPP::AlgorithmParameters::operator()<CryptoPP::ConstByteArrayParameter>, COMDAT
; _this$ = ecx

; 353  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 354  : 		member_ptr<AlgorithmParametersBase> p(new AlgorithmParametersTemplate<T>(name, value, throwIfNotUsed));

  00028	6a 28		 push	 40			; 00000028H
  0002a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0002f	59		 pop	 ecx
  00030	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	83 7d f0 00	 cmp	 DWORD PTR $T8[ebp], 0
  0003b	74 58		 je	 SHORT $LN3@operator

; 266  : 		: m_name(name), m_throwIfNotUsed(throwIfNotUsed), m_used(false) {}

  0003d	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7AlgorithmParametersBase@CryptoPP@@6B@
  00046	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _name$[ebp]
  0004c	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00052	8a 4d 10	 mov	 cl, BYTE PTR _throwIfNotUsed$[ebp]
  00055	88 48 08	 mov	 BYTE PTR [eax+8], cl
  00058	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  0005b	c6 40 09 00	 mov	 BYTE PTR [eax+9], 0
  0005f	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00062	83 c0 0c	 add	 eax, 12			; 0000000cH
  00065	89 45 dc	 mov	 DWORD PTR _this$7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h

; 20   : 	explicit member_ptr(T *p = NULL) : m_p(p) {}

  00068	8b 45 dc	 mov	 eax, DWORD PTR _this$7[ebp]
  0006b	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 306  : 		: AlgorithmParametersBase(name, throwIfNotUsed), m_value(value)

  0006e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 307  : 	{

  00072	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00075	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@

; 306  : 		: AlgorithmParametersBase(name, throwIfNotUsed), m_value(value)

  0007b	ff 75 0c	 push	 DWORD PTR _value$[ebp]
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR $T8[ebp]
  00081	83 c1 10	 add	 ecx, 16			; 00000010H
  00084	e8 00 00 00 00	 call	 ??0ConstByteArrayParameter@CryptoPP@@QAE@ABV01@@Z

; 308  : 	}

  00089	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0

; 354  : 		member_ptr<AlgorithmParametersBase> p(new AlgorithmParametersTemplate<T>(name, value, throwIfNotUsed));

  0008d	8b 45 f0	 mov	 eax, DWORD PTR $T8[ebp]
  00090	89 45 e4	 mov	 DWORD PTR tv83[ebp], eax
  00093	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00095	83 65 e4 00	 and	 DWORD PTR tv83[ebp], 0
$LN4@operator:
  00099	8b 45 e4	 mov	 eax, DWORD PTR tv83[ebp]
  0009c	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
  0009f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h

; 20   : 	explicit member_ptr(T *p = NULL) : m_p(p) {}

  000a3	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  000a6	89 45 e8	 mov	 DWORD PTR _p$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 354  : 		member_ptr<AlgorithmParametersBase> p(new AlgorithmParametersTemplate<T>(name, value, throwIfNotUsed));

  000a9	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 355  : 		p->m_next.reset(m_next.release());

  000b0	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	83 c0 04	 add	 eax, 4
  000b6	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h

; 35   : 		T *old_p = m_p;

  000b9	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	8b 00		 mov	 eax, DWORD PTR [eax]
  000be	89 45 d4	 mov	 DWORD PTR _old_p$5[ebp], eax

; 36   : 		m_p = 0;

  000c1	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	83 20 00	 and	 DWORD PTR [eax], 0

; 28   : 	T* operator->() { return m_p; }

  000c7	8b 45 e8	 mov	 eax, DWORD PTR _p$[ebp]
  000ca	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 355  : 		p->m_next.reset(m_next.release());

  000cd	ff 75 d4	 push	 DWORD PTR _old_p$5[ebp]
  000d0	8b 4d d0	 mov	 ecx, DWORD PTR $T4[ebp]
  000d3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000d6	e8 00 00 00 00	 call	 ?reset@?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAEXPAVAlgorithmParametersBase@2@@Z ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::reset
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h

; 35   : 		T *old_p = m_p;

  000db	8b 45 e8	 mov	 eax, DWORD PTR _p$[ebp]
  000de	89 45 cc	 mov	 DWORD PTR _old_p$3[ebp], eax

; 36   : 		m_p = 0;

  000e1	83 65 e8 00	 and	 DWORD PTR _p$[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 356  : 		m_next.reset(p.release());

  000e5	ff 75 cc	 push	 DWORD PTR _old_p$3[ebp]
  000e8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	83 c1 04	 add	 ecx, 4
  000ee	e8 00 00 00 00	 call	 ?reset@?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAEXPAVAlgorithmParametersBase@2@@Z ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::reset

; 357  : 		m_defaultThrowIfNotUsed = throwIfNotUsed;

  000f3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	8a 4d 10	 mov	 cl, BYTE PTR _throwIfNotUsed$[ebp]
  000f9	88 48 08	 mov	 BYTE PTR [eax+8], cl

; 358  : 		return *this;

  000fc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ff	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
  00102	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00106	8d 4d e8	 lea	 ecx, DWORD PTR _p$[ebp]
  00109	e8 00 00 00 00	 call	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
  0010e	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]

; 359  : 	}

  00111	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00114	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011b	59		 pop	 ecx
  0011c	c9		 leave
  0011d	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z$0:
  00000	6a 28		 push	 40			; 00000028H
  00002	ff 75 f0	 push	 DWORD PTR $T8[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
__unwindfunclet$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z$2:
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR $T8[ebp]
  00010	e9 00 00 00 00	 jmp	 ??1AlgorithmParametersBase@CryptoPP@@UAE@XZ ; CryptoPP::AlgorithmParametersBase::~AlgorithmParametersBase
__unwindfunclet$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z$1:
  00015	8d 4d e8	 lea	 ecx, DWORD PTR _p$[ebp]
  00018	e9 00 00 00 00	 jmp	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
__ehhandler$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z:
  00022	90		 npad	 1
  00023	90		 npad	 1
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z ENDP ; CryptoPP::AlgorithmParameters::operator()<CryptoPP::ConstByteArrayParameter>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??$try_emplace_unique@ABK@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK@Z
_TEXT	SEGMENT
$T1 = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
_x$ = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
_v$9 = -28						; size = 4
$T10 = -24						; size = 4
_key_hash$ = -20					; size = 4
_this$ = -16						; size = 4
_pos$ = -12						; size = 4
_this$ = -8						; size = 4
$T11 = -2						; size = 1
$T12 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
_k$ = 12						; size = 4
??$try_emplace_unique@ABK@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::try_emplace_unique<unsigned long const &>, COMDAT
; _this$ = ecx

; 3791 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2791 :           return *static_cast<function_pair const*>(

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000f	83 e0 01	 and	 eax, 1
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00019	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax

; 2599 :           return hf(x);

  0001c	8b 45 0c	 mov	 eax, DWORD PTR _k$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 e4	 mov	 DWORD PTR _v$9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp

; 621  :     BOOST_HASH_SPECIALIZE(unsigned long)

  00024	ff 75 e4	 push	 DWORD PTR _v$9[ebp]
  00027	e8 00 00 00 00	 call	 ??$hash_value@K@boost@@YAIK@Z ; boost::hash_value<unsigned long>
  0002c	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3792 :           std::size_t key_hash = this->hash(k);

  0002d	89 45 ec	 mov	 DWORD PTR _key_hash$[ebp], eax

; 3576 :           return this->find_node_impl(key_hash, k, this->key_eq());

  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::key_eq
  00038	50		 push	 eax
  00039	ff 75 0c	 push	 DWORD PTR _k$[ebp]
  0003c	ff 75 ec	 push	 DWORD PTR _key_hash$[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@IABKABU?$equal_to@K@std@@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >

; 3793 :           node_pointer pos = this->find_node(key_hash, k);

  00047	89 45 f4	 mov	 DWORD PTR _pos$[ebp], eax

; 3794 :           if (pos) {

  0004a	83 7d f4 00	 cmp	 DWORD PTR _pos$[ebp], 0
  0004e	74 32		 je	 SHORT $LN2@try_emplac

; 3795 :             return emplace_return(iterator(pos), false);

  00050	c6 45 ff 00	 mov	 BYTE PTR $T12[ebp], 0

; 2371 :           : node_(static_cast<node_pointer>(x))

  00054	8b 45 f4	 mov	 eax, DWORD PTR _pos$[ebp]
  00057	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0005a	8d 45 e0	 lea	 eax, DWORD PTR $T8[ebp]
  0005d	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00060	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00068	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006a	8d 45 ff	 lea	 eax, DWORD PTR $T12[ebp]
  0006d	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00070	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00073	8b 4d d8	 mov	 ecx, DWORD PTR $T6[ebp]
  00076	8a 09		 mov	 cl, BYTE PTR [ecx]
  00078	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3795 :             return emplace_return(iterator(pos), false);

  0007b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0007e	eb 6a		 jmp	 SHORT $LN1@try_emplac

; 3796 :           } else {

  00080	eb 68		 jmp	 SHORT $LN1@try_emplac
$LN2@try_emplac:

; 3797 :             return emplace_return(

  00082	c6 45 fe 01	 mov	 BYTE PTR $T11[ebp], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 249  :          {  return static_cast<T&&>(t);   }

  00086	8b 45 0c	 mov	 eax, DWORD PTR _k$[ebp]
  00089	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  0008c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	83 c0 03	 add	 eax, 3
  00092	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00095	74 09		 je	 SHORT $LN106@try_emplac
  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	40		 inc	 eax
  0009b	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
  0009e	eb 04		 jmp	 SHORT $LN102@try_emplac
$LN106@try_emplac:
  000a0	83 65 e8 00	 and	 DWORD PTR $T10[ebp], 0
$LN102@try_emplac:

; 3797 :             return emplace_return(

  000a4	ff 75 ec	 push	 DWORD PTR _key_hash$[ebp]
  000a7	ff 75 d4	 push	 DWORD PTR $T5[ebp]
  000aa	ff 75 e8	 push	 DWORD PTR $T10[ebp]
  000ad	e8 00 00 00 00	 call	 ??$construct_node_pair@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKK@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@ABK@Z ; boost::unordered::detail::func::construct_node_pair<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > >,unsigned long const &>
  000b2	59		 pop	 ecx
  000b3	59		 pop	 ecx
  000b4	50		 push	 eax
  000b5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	e8 00 00 00 00	 call	 ?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::resize_and_add_node_unique
  000bd	89 45 d0	 mov	 DWORD PTR _x$[ebp], eax

; 2371 :           : node_(static_cast<node_pointer>(x))

  000c0	8b 45 d0	 mov	 eax, DWORD PTR _x$[ebp]
  000c3	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000c6	8d 45 cc	 lea	 eax, DWORD PTR $T4[ebp]
  000c9	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000cc	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  000cf	8b 00		 mov	 eax, DWORD PTR [eax]
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000d4	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000d6	8d 45 fe	 lea	 eax, DWORD PTR $T11[ebp]
  000d9	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  000dc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000df	8b 4d c4	 mov	 ecx, DWORD PTR $T2[ebp]
  000e2	8a 09		 mov	 cl, BYTE PTR [ecx]
  000e4	88 48 04	 mov	 BYTE PTR [eax+4], cl
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3797 :             return emplace_return(

  000e7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@try_emplac:

; 3798 :               iterator(this->resize_and_add_node_unique(
; 3799 :                 boost::unordered::detail::func::construct_node_pair(
; 3800 :                   this->node_alloc(), boost::forward<Key>(k)),
; 3801 :                 key_hash)),
; 3802 :               true);
; 3803 :           }
; 3804 :         }

  000ea	c9		 leave
  000eb	c2 08 00	 ret	 8
??$try_emplace_unique@ABK@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::try_emplace_unique<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$lower_bound@PBIIU?$less@X@std@@@std@@YAPBIPBIQBIABIU?$less@X@0@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
__UMid$2 = -32						; size = 4
tv77 = -28						; size = 4
__Count2$3 = -24					; size = 4
__First$ = -20						; size = 4
__First$ = -16						; size = 4
__UFirst$ = -12						; size = 4
__Count$ = -8						; size = 4
$T4 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
__Pred$ = 20						; size = 1
??$lower_bound@PBIIU?$less@X@std@@@std@@YAPBIPBIQBIABIU?$less@X@0@@Z PROC ; std::lower_bound<unsigned int const *,unsigned int,std::less<void> >, COMDAT

; 5849 : _NODISCARD _CONSTEXPR20 _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H

; 5850 :     // find first element not before _Val
; 5851 :     _Adl_verify_range(_First, _Last);
; 5852 :     auto _UFirst                = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1303 :         return _It + 0;

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax

; 1794 :         return _Last - _First; // assume the iterator will do debug checking

  00012	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  00015	2b 45 f4	 sub	 eax, DWORD PTR __UFirst$[ebp]
  00018	c1 f8 02	 sar	 eax, 2

; 5853 :     _Iter_diff_t<_FwdIt> _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));

  0001b	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
$LN2@lower_boun:

; 5854 : 
; 5855 :     while (0 < _Count) { // divide and conquer, find half that contains answer

  0001e	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00022	7e 75		 jle	 SHORT $LN3@lower_boun

; 5856 :         const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;

  00024	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	99		 cdq
  00028	2b c2		 sub	 eax, edx
  0002a	d1 f8		 sar	 eax, 1
  0002c	89 45 e8	 mov	 DWORD PTR __Count2$3[ebp], eax

; 5857 :         const auto _UMid                   = _STD next(_UFirst, _Count2);

  0002f	8b 45 f4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00032	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax

; 1714 :         _Where += _Off;

  00035	8b 45 e8	 mov	 eax, DWORD PTR __Count2$3[ebp]
  00038	8b 4d f0	 mov	 ecx, DWORD PTR __First$[ebp]
  0003b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0003e	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax

; 5857 :         const auto _UMid                   = _STD next(_UFirst, _Count2);

  00041	8b 45 f0	 mov	 eax, DWORD PTR __First$[ebp]
  00044	89 45 e0	 mov	 DWORD PTR __UMid$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 240  :         return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);

  00047	8b 45 e0	 mov	 eax, DWORD PTR __UMid$2[ebp]
  0004a	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0004d	8b 00		 mov	 eax, DWORD PTR [eax]
  0004f	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00051	73 09		 jae	 SHORT $LN21@lower_boun
  00053	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  0005a	eb 04		 jmp	 SHORT $LN22@lower_boun
$LN21@lower_boun:
  0005c	83 65 e4 00	 and	 DWORD PTR tv77[ebp], 0
$LN22@lower_boun:
  00060	8a 45 e4	 mov	 al, BYTE PTR tv77[ebp]
  00063	88 45 ff	 mov	 BYTE PTR $T4[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5858 :         if (_Pred(*_UMid, _Val)) { // try top half

  00066	0f b6 45 ff	 movzx	 eax, BYTE PTR $T4[ebp]
  0006a	85 c0		 test	 eax, eax
  0006c	74 23		 je	 SHORT $LN4@lower_boun

; 5859 :             _UFirst = _Next_iter(_UMid);

  0006e	8b 45 e0	 mov	 eax, DWORD PTR __UMid$2[ebp]
  00071	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax

; 1837 :     return ++_First;

  00074	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  00077	83 c0 04	 add	 eax, 4
  0007a	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax

; 5859 :             _UFirst = _Next_iter(_UMid);

  0007d	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  00080	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 5860 :             _Count -= _Count2 + 1;

  00083	8b 45 e8	 mov	 eax, DWORD PTR __Count2$3[ebp]
  00086	40		 inc	 eax
  00087	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  0008a	2b c8		 sub	 ecx, eax
  0008c	89 4d f8	 mov	 DWORD PTR __Count$[ebp], ecx

; 5861 :         } else {

  0008f	eb 06		 jmp	 SHORT $LN5@lower_boun
$LN4@lower_boun:

; 5862 :             _Count = _Count2;

  00091	8b 45 e8	 mov	 eax, DWORD PTR __Count2$3[ebp]
  00094	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
$LN5@lower_boun:

; 5863 :         }
; 5864 :     }

  00097	eb 85		 jmp	 SHORT $LN2@lower_boun
$LN3@lower_boun:

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00099	8b 45 f4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0009c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax

; 5865 : 
; 5866 :     _Seek_wrapped(_First, _UFirst);
; 5867 :     return _First;

  0009f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 5868 : }

  000a2	c9		 leave
  000a3	c3		 ret	 0
??$lower_bound@PBIIU?$less@X@std@@@std@@YAPBIPBIQBIABIU?$less@X@0@@Z ENDP ; std::lower_bound<unsigned int const *,unsigned int,std::less<void> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
__Lock$5 = -60						; size = 4
__Old_val$6 = -56					; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
_this$ = -44						; size = 4
__Ptr$ = -40						; size = 4
__Id$9 = -36						; size = 4
__Psave_guard$10 = -32					; size = 4
__Val$ = -28						; size = 4
__Pf$11 = -24						; size = 4
__Pfmod$12 = -20					; size = 4
__Psave$13 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<wchar_t> >, COMDAT

; 426  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	83 65 bc 00	 and	 DWORD PTR $T3[ebp], 0

; 427  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00029	6a 00		 push	 0
  0002b	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  0002e	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 428  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<wchar_t> >::_Psave
  0003c	89 45 f0	 mov	 DWORD PTR __Psave$13[ebp], eax

; 429  : 
; 430  :     const size_t _Id         = _Facet::id;

  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$ctype@_W@std@@2V0locale@2@A ; std::ctype<wchar_t>::id
  00044	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00049	89 45 dc	 mov	 DWORD PTR __Id$9[ebp], eax

; 431  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  0004c	ff 75 dc	 push	 DWORD PTR __Id$9[ebp]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00057	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax

; 432  : 
; 433  :     if (!_Pf) {

  0005a	83 7d e8 00	 cmp	 DWORD PTR __Pf$11[ebp], 0
  0005e	0f 85 9f 00 00
	00		 jne	 $LN2@use_facet

; 434  :         if (_Psave) {

  00064	83 7d f0 00	 cmp	 DWORD PTR __Psave$13[ebp], 0
  00068	74 0b		 je	 SHORT $LN3@use_facet

; 435  :             _Pf = _Psave; // lazy facet already allocated

  0006a	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  0006d	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax
  00070	e9 8e 00 00 00	 jmp	 $LN2@use_facet
$LN3@use_facet:

; 436  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  00075	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  00078	8d 45 f0	 lea	 eax, DWORD PTR __Psave$13[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<wchar_t>::_Getcat
  00081	59		 pop	 ecx
  00082	59		 pop	 ecx
  00083	83 f8 ff	 cmp	 eax, -1
  00086	75 07		 jne	 SHORT $LN5@use_facet

; 437  : #if _HAS_EXCEPTIONS
; 438  :             _Throw_bad_cast(); // lazy disallowed

  00088	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast

; 439  : #else // _HAS_EXCEPTIONS
; 440  :             _CSTD abort(); // lazy disallowed
; 441  : #endif // _HAS_EXCEPTIONS
; 442  :         } else { // queue up lazy facet for destruction

  0008d	eb 74		 jmp	 SHORT $LN2@use_facet
$LN5@use_facet:

; 443  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  0008f	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  00092	89 45 ec	 mov	 DWORD PTR __Pfmod$12[ebp], eax

; 444  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  00095	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$12[ebp]
  00098	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory

; 2590 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

  0009b	8d 45 e0	 lea	 eax, DWORD PTR __Psave_guard$10[ebp]
  0009e	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000a1	8d 45 d8	 lea	 eax, DWORD PTR __Ptr$[ebp]
  000a4	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a7	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 4d d0	 mov	 ecx, DWORD PTR $T8[ebp]
  000ad	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000af	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 444  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  000b1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 445  : 
; 446  : #if defined(_M_CEE)
; 447  :             _Facet_Register_m(_Pfmod);
; 448  : #else // defined(_M_CEE)
; 449  :             _Facet_Register(_Pfmod);

  000b5	ff 75 ec	 push	 DWORD PTR __Pfmod$12[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000bd	59		 pop	 ecx

; 450  : #endif // defined(_M_CEE)
; 451  : 
; 452  :             _Pfmod->_Incref();

  000be	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$12[ebp]
  000c1	8b 00		 mov	 eax, DWORD PTR [eax]
  000c3	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$12[ebp]
  000c6	ff 50 04	 call	 DWORD PTR [eax+4]

; 453  :             _Facetptr<_Facet>::_Psave = _Psave;

  000c9	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  000cc	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@_W@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<wchar_t> >::_Psave

; 454  :             _Pf                       = _Psave;

  000d1	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  000d4	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory

; 2676 :         return _STD exchange(_Mypair._Myval2, pointer());

  000d7	83 65 cc 00	 and	 DWORD PTR $T7[ebp], 0
  000db	8d 45 e0	 lea	 eax, DWORD PTR __Psave_guard$10[ebp]
  000de	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000e1	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000e4	8b 00		 mov	 eax, DWORD PTR [eax]
  000e6	89 45 c8	 mov	 DWORD PTR __Old_val$6[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000e9	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000ec	8b 4d cc	 mov	 ecx, DWORD PTR $T7[ebp]
  000ef	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  000f1	8b 45 c8	 mov	 eax, DWORD PTR __Old_val$6[ebp]
  000f4	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 457  :         }

  000f7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000fb	8d 4d e0	 lea	 ecx, DWORD PTR __Psave_guard$10[ebp]
  000fe	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 458  :     }
; 459  : 
; 460  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00103	8b 45 e8	 mov	 eax, DWORD PTR __Pf$11[ebp]
  00106	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  00109	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0010d	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00110	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00115	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
$LN7@use_facet:

; 461  :     _END_LOCK()
; 462  : } // end of use_facet body

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z$1:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Psave_guard$10[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<wchar_t> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {

  00004	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	83 c0 18	 add	 eax, 24			; 00000018H
  0000c	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  0000f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00012	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00015	74 23		 je	 SHORT $LN5@Destroy_ra
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00020	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  00025	33 c0		 xor	 eax, eax
  00027	83 e0 01	 and	 eax, 1
  0002a	74 0c		 je	 SHORT $LN9@Destroy_ra
  0002c	6a 18		 push	 24			; 00000018H
  0002e	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx
$LN9@Destroy_ra:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 968  :         }

  00038	eb cc		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 969  :     }
; 970  : }

  0003a	c9		 leave
  0003b	c3		 ret	 0
??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Al$ = -64						; size = 4
__First1$ = -60						; size = 4
__First1$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 65		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000c9	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000cc	ff 75 c8	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d7	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000db	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000de	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e4	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ea	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ed	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	50		 push	 eax
  000ef	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ff	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00101	eb 4c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00103	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00106	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00114	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00117	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  0011a	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00120	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00123	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012e	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  00132	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00135	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  00138	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0013b	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  0013e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00144	50		 push	 eax
  00145	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00148	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0014d	59		 pop	 ecx
  0014e	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  00152	c9		 leave
  00153	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Al$ = -68						; size = 4
$T1 = -64						; size = 4
__Ptr$ = -60						; size = 4
$T2 = -56						; size = 4
__Old_ptr$3 = -52					; size = 4
__Old_capacity$ = -48					; size = 4
__New_capacity$ = -44					; size = 4
__New_size$ = -40					; size = 4
__New_ptr$ = -36					; size = 4
_this$ = -32						; size = 4
__Raw_new$ = -28					; size = 4
__My_data$ = -24					; size = 4
__Old_size$ = -20					; size = 4
__Overflow_is_possible$4 = -14				; size = 1
$T5 = -13						; size = 1
__Ch$ = -12						; size = 1
$T6 = -5						; size = 1
__Ch$ = -4						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 ec	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 ec	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 ec	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 d8	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 d0	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 d8	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 d4	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 bc	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 f2 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 d4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 dc	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d d8	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d d4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 dc	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 c4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 e4	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d d0 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 59		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 cc	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 cc	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000ac	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]
  000af	88 45 fc	 mov	 BYTE PTR __Ch$[ebp], al

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b2	ff 75 ec	 push	 DWORD PTR __Old_size$[ebp]
  000b5	ff 75 c0	 push	 DWORD PTR $T1[ebp]
  000b8	ff 75 e4	 push	 DWORD PTR __Raw_new$[ebp]
  000bb	e8 00 00 00 00	 call	 _memcpy
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  :         _Left = _Right;

  000c3	8b 45 e4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c6	03 45 ec	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c9	8a 4d fc	 mov	 cl, BYTE PTR __Ch$[ebp]
  000cc	88 08		 mov	 BYTE PTR [eax], cl

; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  000ce	c6 45 fb 00	 mov	 BYTE PTR $T6[ebp], 0

; 428  :         _Left = _Right;

  000d2	8b 45 e4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000d5	03 45 ec	 add	 eax, DWORD PTR __Old_size$[ebp]
  000d8	8a 4d fb	 mov	 cl, BYTE PTR $T6[ebp]
  000db	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000de	8b 45 d0	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000e1	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000e2	50		 push	 eax
  000e3	ff 75 cc	 push	 DWORD PTR __Old_ptr$3[ebp]
  000e6	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000eb	59		 pop	 ecx
  000ec	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000ed	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f0	8b 4d dc	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000f3	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  000f5	eb 40		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000f7	8a 45 10	 mov	 al, BYTE PTR _<_Args_0>$[ebp]
  000fa	88 45 f4	 mov	 BYTE PTR __Ch$[ebp], al

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000fd	ff 75 ec	 push	 DWORD PTR __Old_size$[ebp]
  00100	ff 75 e8	 push	 DWORD PTR __My_data$[ebp]
  00103	ff 75 e4	 push	 DWORD PTR __Raw_new$[ebp]
  00106	e8 00 00 00 00	 call	 _memcpy
  0010b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 428  :         _Left = _Right;

  0010e	8b 45 e4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00111	03 45 ec	 add	 eax, DWORD PTR __Old_size$[ebp]
  00114	8a 4d f4	 mov	 cl, BYTE PTR __Ch$[ebp]
  00117	88 08		 mov	 BYTE PTR [eax], cl

; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00119	c6 45 f3 00	 mov	 BYTE PTR $T5[ebp], 0

; 428  :         _Left = _Right;

  0011d	8b 45 e4	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00120	03 45 ec	 add	 eax, DWORD PTR __Old_size$[ebp]
  00123	8a 4d f3	 mov	 cl, BYTE PTR $T5[ebp]
  00126	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00129	8d 45 dc	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  0012c	50		 push	 eax
  0012d	ff 75 e8	 push	 DWORD PTR __My_data$[ebp]
  00130	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00135	59		 pop	 ecx
  00136	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  00137	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  0013a	c9		 leave
  0013b	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z PROC		; std::_Destroy_in_place<wchar_t *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ENDP		; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<SEterPackIndex *,void *>::_Freenode0<std::allocator<std::_List_node<SEterPackIndex *,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<SEterPackIndex *,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<SEterPackIndex *,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 0c	 imul	 eax, eax, 12
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<SEterPackIndex *,void *>::_Freenode0<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??$StandardReallocate@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@YAPAEAAV?$AllocatorWithCleanup@E$0A@@0@PAEII_N@Z
_TEXT	SEGMENT
_n$ = -32						; size = 4
_n$ = -28						; size = 4
$T1 = -24						; size = 4
tv69 = -20						; size = 4
$T2 = -16						; size = 4
_n$ = -12						; size = 4
_newPointer$3 = -8					; size = 4
_n$ = -4						; size = 4
_a$ = 8							; size = 4
_p$ = 12						; size = 4
_oldSize$ = 16						; size = 4
_newSize$ = 20						; size = 4
_preserve$ = 24						; size = 1
??$StandardReallocate@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@YAPAEAAV?$AllocatorWithCleanup@E$0A@@0@PAEII_N@Z PROC ; CryptoPP::StandardReallocate<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >, COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 62   : 	if (oldSize == newSize)

  00006	8b 45 10	 mov	 eax, DWORD PTR _oldSize$[ebp]
  00009	3b 45 14	 cmp	 eax, DWORD PTR _newSize$[ebp]
  0000c	75 08		 jne	 SHORT $LN2@StandardRe

; 63   : 		return p;

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]
  00011	e9 10 01 00 00	 jmp	 $LN1@StandardRe
$LN2@StandardRe:

; 64   : 
; 65   : 	if (preserve)

  00016	0f b6 45 18	 movzx	 eax, BYTE PTR _preserve$[ebp]
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 9d 00 00
	00		 je	 $LN3@StandardRe

; 66   : 	{
; 67   : 		typename A::pointer newPointer = a.allocate(newSize, NULL);

  00022	8b 45 14	 mov	 eax, DWORD PTR _newSize$[ebp]
  00025	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax

; 91   : 		CheckSize(n);

  00028	ff 75 fc	 push	 DWORD PTR _n$[ebp]
  0002b	e8 00 00 00 00	 call	 ?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z ; CryptoPP::AllocatorBase<unsigned char>::CheckSize
  00030	59		 pop	 ecx

; 92   : 		if (n == 0)

  00031	83 7d fc 00	 cmp	 DWORD PTR _n$[ebp], 0
  00035	75 06		 jne	 SHORT $LN7@StandardRe

; 93   : 			return NULL;

  00037	83 65 f8 00	 and	 DWORD PTR _newPointer$3[ebp], 0
  0003b	eb 1e		 jmp	 SHORT $LN6@StandardRe
$LN7@StandardRe:

; 94   : 
; 95   : #if CRYPTOPP_BOOL_ALIGN16_ENABLED
; 96   : 		if (T_Align16 && n*sizeof(T) >= 16)

  0003d	33 c0		 xor	 eax, eax
  0003f	74 0e		 je	 SHORT $LN8@StandardRe

; 97   : 			return (pointer)AlignedAllocate(n*sizeof(T));

  00041	ff 75 fc	 push	 DWORD PTR _n$[ebp]
  00044	e8 00 00 00 00	 call	 ?AlignedAllocate@CryptoPP@@YAPAXI@Z ; CryptoPP::AlignedAllocate
  00049	59		 pop	 ecx
  0004a	89 45 f8	 mov	 DWORD PTR _newPointer$3[ebp], eax
  0004d	eb 0c		 jmp	 SHORT $LN6@StandardRe
$LN8@StandardRe:

; 98   : #endif
; 99   : 
; 100  : 		return (pointer)UnalignedAllocate(n*sizeof(T));

  0004f	ff 75 fc	 push	 DWORD PTR _n$[ebp]
  00052	e8 00 00 00 00	 call	 ?UnalignedAllocate@CryptoPP@@YAPAXI@Z ; CryptoPP::UnalignedAllocate
  00057	59		 pop	 ecx
  00058	89 45 f8	 mov	 DWORD PTR _newPointer$3[ebp], eax
$LN6@StandardRe:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h

; 179  : 	return b < a ? b : a;

  0005b	8b 45 14	 mov	 eax, DWORD PTR _newSize$[ebp]
  0005e	3b 45 10	 cmp	 eax, DWORD PTR _oldSize$[ebp]
  00061	73 08		 jae	 SHORT $LN28@StandardRe
  00063	8d 45 14	 lea	 eax, DWORD PTR _newSize$[ebp]
  00066	89 45 ec	 mov	 DWORD PTR tv69[ebp], eax
  00069	eb 06		 jmp	 SHORT $LN29@StandardRe
$LN28@StandardRe:
  0006b	8d 45 10	 lea	 eax, DWORD PTR _oldSize$[ebp]
  0006e	89 45 ec	 mov	 DWORD PTR tv69[ebp], eax
$LN29@StandardRe:
  00071	8b 45 ec	 mov	 eax, DWORD PTR tv69[ebp]
  00074	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 68   : 		memcpy_s(newPointer, sizeof(T)*newSize, p, sizeof(T)*STDMIN(oldSize, newSize));

  00077	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0007a	ff 30		 push	 DWORD PTR [eax]
  0007c	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  0007f	ff 75 14	 push	 DWORD PTR _newSize$[ebp]
  00082	ff 75 f8	 push	 DWORD PTR _newPointer$3[ebp]
  00085	e8 00 00 00 00	 call	 _memcpy_s
  0008a	83 c4 10	 add	 esp, 16			; 00000010H

; 69   : 		a.deallocate(p, oldSize);

  0008d	8b 45 10	 mov	 eax, DWORD PTR _oldSize$[ebp]
  00090	89 45 e4	 mov	 DWORD PTR _n$[ebp], eax

; 105  : 		SecureWipeArray((pointer)p, n);

  00093	ff 75 e4	 push	 DWORD PTR _n$[ebp]
  00096	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  00099	e8 00 00 00 00	 call	 ??$SecureWipeArray@E@CryptoPP@@YAXPAEI@Z ; CryptoPP::SecureWipeArray<unsigned char>
  0009e	59		 pop	 ecx
  0009f	59		 pop	 ecx

; 106  : 
; 107  : #if CRYPTOPP_BOOL_ALIGN16_ENABLED
; 108  : 		if (T_Align16 && n*sizeof(T) >= 16)

  000a0	33 c0		 xor	 eax, eax
  000a2	74 0b		 je	 SHORT $LN45@StandardRe

; 109  : 			return AlignedDeallocate(p);

  000a4	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  000a7	e8 00 00 00 00	 call	 ?AlignedDeallocate@CryptoPP@@YAXPAX@Z ; CryptoPP::AlignedDeallocate
  000ac	59		 pop	 ecx
  000ad	eb 09		 jmp	 SHORT $LN44@StandardRe
$LN45@StandardRe:

; 110  : #endif
; 111  : 
; 112  : 		UnalignedDeallocate(p);

  000af	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  000b2	e8 00 00 00 00	 call	 ?UnalignedDeallocate@CryptoPP@@YAXPAX@Z ; CryptoPP::UnalignedDeallocate
  000b7	59		 pop	 ecx
$LN44@StandardRe:

; 70   : 		return newPointer;

  000b8	8b 45 f8	 mov	 eax, DWORD PTR _newPointer$3[ebp]
  000bb	eb 69		 jmp	 SHORT $LN1@StandardRe

; 71   : 	}

  000bd	eb 67		 jmp	 SHORT $LN1@StandardRe
$LN3@StandardRe:

; 72   : 	else
; 73   : 	{
; 74   : 		a.deallocate(p, oldSize);

  000bf	8b 45 10	 mov	 eax, DWORD PTR _oldSize$[ebp]
  000c2	89 45 e0	 mov	 DWORD PTR _n$[ebp], eax

; 105  : 		SecureWipeArray((pointer)p, n);

  000c5	ff 75 e0	 push	 DWORD PTR _n$[ebp]
  000c8	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  000cb	e8 00 00 00 00	 call	 ??$SecureWipeArray@E@CryptoPP@@YAXPAEI@Z ; CryptoPP::SecureWipeArray<unsigned char>
  000d0	59		 pop	 ecx
  000d1	59		 pop	 ecx

; 106  : 
; 107  : #if CRYPTOPP_BOOL_ALIGN16_ENABLED
; 108  : 		if (T_Align16 && n*sizeof(T) >= 16)

  000d2	33 c0		 xor	 eax, eax
  000d4	74 0b		 je	 SHORT $LN66@StandardRe

; 109  : 			return AlignedDeallocate(p);

  000d6	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  000d9	e8 00 00 00 00	 call	 ?AlignedDeallocate@CryptoPP@@YAXPAX@Z ; CryptoPP::AlignedDeallocate
  000de	59		 pop	 ecx
  000df	eb 09		 jmp	 SHORT $LN65@StandardRe
$LN66@StandardRe:

; 110  : #endif
; 111  : 
; 112  : 		UnalignedDeallocate(p);

  000e1	ff 75 0c	 push	 DWORD PTR _p$[ebp]
  000e4	e8 00 00 00 00	 call	 ?UnalignedDeallocate@CryptoPP@@YAXPAX@Z ; CryptoPP::UnalignedDeallocate
  000e9	59		 pop	 ecx
$LN65@StandardRe:

; 75   : 		return a.allocate(newSize, NULL);

  000ea	8b 45 14	 mov	 eax, DWORD PTR _newSize$[ebp]
  000ed	89 45 f4	 mov	 DWORD PTR _n$[ebp], eax

; 91   : 		CheckSize(n);

  000f0	ff 75 f4	 push	 DWORD PTR _n$[ebp]
  000f3	e8 00 00 00 00	 call	 ?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z ; CryptoPP::AllocatorBase<unsigned char>::CheckSize
  000f8	59		 pop	 ecx

; 92   : 		if (n == 0)

  000f9	83 7d f4 00	 cmp	 DWORD PTR _n$[ebp], 0
  000fd	75 06		 jne	 SHORT $LN87@StandardRe

; 93   : 			return NULL;

  000ff	83 65 f0 00	 and	 DWORD PTR $T2[ebp], 0
  00103	eb 1e		 jmp	 SHORT $LN86@StandardRe
$LN87@StandardRe:

; 94   : 
; 95   : #if CRYPTOPP_BOOL_ALIGN16_ENABLED
; 96   : 		if (T_Align16 && n*sizeof(T) >= 16)

  00105	33 c0		 xor	 eax, eax
  00107	74 0e		 je	 SHORT $LN88@StandardRe

; 97   : 			return (pointer)AlignedAllocate(n*sizeof(T));

  00109	ff 75 f4	 push	 DWORD PTR _n$[ebp]
  0010c	e8 00 00 00 00	 call	 ?AlignedAllocate@CryptoPP@@YAPAXI@Z ; CryptoPP::AlignedAllocate
  00111	59		 pop	 ecx
  00112	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00115	eb 0c		 jmp	 SHORT $LN86@StandardRe
$LN88@StandardRe:

; 98   : #endif
; 99   : 
; 100  : 		return (pointer)UnalignedAllocate(n*sizeof(T));

  00117	ff 75 f4	 push	 DWORD PTR _n$[ebp]
  0011a	e8 00 00 00 00	 call	 ?UnalignedAllocate@CryptoPP@@YAPAXI@Z ; CryptoPP::UnalignedAllocate
  0011f	59		 pop	 ecx
  00120	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
$LN86@StandardRe:

; 75   : 		return a.allocate(newSize, NULL);

  00123	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@StandardRe:

; 76   : 	}
; 77   : }

  00126	c9		 leave
  00127	c3		 ret	 0
??$StandardReallocate@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@YAPAEAAV?$AllocatorWithCleanup@E$0A@@0@PAEII_N@Z ENDP ; CryptoPP::StandardReallocate<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h
;	COMDAT ??$SecureWipeArray@E@CryptoPP@@YAXPAEI@Z
_TEXT	SEGMENT
_p$1 = -16						; size = 4
_p$2 = -12						; size = 4
_p$3 = -8						; size = 4
_p$4 = -4						; size = 4
_buf$ = 8						; size = 4
_n$ = 12						; size = 4
??$SecureWipeArray@E@CryptoPP@@YAXPAEI@Z PROC		; CryptoPP::SecureWipeArray<unsigned char>, COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	57		 push	 edi

; 537  : 	if (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)

  00007	33 c0		 xor	 eax, eax
  00009	74 15		 je	 SHORT $LN2@SecureWipe

; 510  : 	volatile word32 *p = buf;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000e	89 45 fc	 mov	 DWORD PTR _p$4[ebp], eax

; 538  : 		SecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));

  00011	6b 4d 0c 00	 imul	 ecx, DWORD PTR _n$[ebp], 0

; 528  : 	SecureWipeBuffer((word32 *)buf, 2*n);

  00015	d1 e1		 shl	 ecx, 1

; 514  : 	__stosd((unsigned long *)(size_t)p, 0, n);

  00017	8b 7d fc	 mov	 edi, DWORD PTR _p$4[ebp]
  0001a	33 c0		 xor	 eax, eax
  0001c	f3 ab		 rep stosd

; 538  : 		SecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));

  0001e	eb 3f		 jmp	 SHORT $LN1@SecureWipe
$LN2@SecureWipe:

; 539  : 	else if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)

  00020	33 c0		 xor	 eax, eax
  00022	74 13		 je	 SHORT $LN4@SecureWipe

; 510  : 	volatile word32 *p = buf;

  00024	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00027	89 45 f8	 mov	 DWORD PTR _p$3[ebp], eax

; 540  : 		SecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));

  0002a	6b 4d 0c 00	 imul	 ecx, DWORD PTR _n$[ebp], 0

; 514  : 	__stosd((unsigned long *)(size_t)p, 0, n);

  0002e	8b 7d f8	 mov	 edi, DWORD PTR _p$3[ebp]
  00031	33 c0		 xor	 eax, eax
  00033	f3 ab		 rep stosd

; 540  : 		SecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));

  00035	eb 28		 jmp	 SHORT $LN1@SecureWipe
$LN4@SecureWipe:

; 541  : 	else if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)

  00037	33 c0		 xor	 eax, eax
  00039	74 14		 je	 SHORT $LN6@SecureWipe

; 500  : 	volatile word16 *p = buf;

  0003b	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0003e	89 45 f4	 mov	 DWORD PTR _p$2[ebp], eax

; 542  : 		SecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));

  00041	6b 4d 0c 00	 imul	 ecx, DWORD PTR _n$[ebp], 0

; 504  : 	__stosw((word16 *)(size_t)p, 0, n);

  00045	33 c0		 xor	 eax, eax
  00047	8b 7d f4	 mov	 edi, DWORD PTR _p$2[ebp]
  0004a	66 f3 ab	 rep stosw

; 542  : 		SecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));

  0004d	eb 10		 jmp	 SHORT $LN1@SecureWipe
$LN6@SecureWipe:

; 490  : 	volatile byte *p = buf;

  0004f	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00052	89 45 f0	 mov	 DWORD PTR _p$1[ebp], eax

; 491  : #ifdef __GNUC__
; 492  : 	asm volatile("rep stosb" : "+c"(n), "+D"(p) : "a"(0) : "memory");
; 493  : #else
; 494  : 	__stosb((byte *)(size_t)p, 0, n);

  00055	8b 7d f0	 mov	 edi, DWORD PTR _p$1[ebp]
  00058	32 c0		 xor	 al, al
  0005a	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  0005d	f3 aa		 rep stosb
$LN1@SecureWipe:

; 543  : 	else
; 544  : 		SecureWipeBuffer((byte *)buf, n * sizeof(T));
; 545  : }

  0005f	5f		 pop	 edi
  00060	c9		 leave
  00061	c3		 ret	 0
??$SecureWipeArray@E@CryptoPP@@YAXPAEI@Z ENDP		; CryptoPP::SecureWipeArray<unsigned char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h
;	COMDAT ??$SecureWipeArray@_K@CryptoPP@@YAXPA_KI@Z
_TEXT	SEGMENT
_p$1 = -40						; size = 4
_p$2 = -36						; size = 4
_p$3 = -32						; size = 4
_p$4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
$T8 = -12						; size = 4
$T9 = -8						; size = 4
$T10 = -4						; size = 4
_buf$ = 8						; size = 4
_n$ = 12						; size = 4
??$SecureWipeArray@_K@CryptoPP@@YAXPA_KI@Z PROC		; CryptoPP::SecureWipeArray<unsigned __int64>, COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	57		 push	 edi

; 537  : 	if (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)

  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax
  0000a	74 4d		 je	 SHORT $LN2@SecureWipe

; 366  : 	if (sizeof(T) < 16)

  0000c	33 c0		 xor	 eax, eax
  0000e	40		 inc	 eax
  0000f	74 09		 je	 SHORT $LN10@SecureWipe

; 367  : 		return 1;

  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR $T10[ebp], 1
  00018	eb 07		 jmp	 SHORT $LN9@SecureWipe
$LN10@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  0001a	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR $T10[ebp], 8
$LN9@SecureWipe:

; 366  : 	if (sizeof(T) < 16)

  00021	33 c0		 xor	 eax, eax
  00023	40		 inc	 eax
  00024	74 09		 je	 SHORT $LN13@SecureWipe

; 367  : 		return 1;

  00026	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR $T9[ebp], 1
  0002d	eb 07		 jmp	 SHORT $LN12@SecureWipe
$LN13@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  0002f	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR $T9[ebp], 8
$LN12@SecureWipe:

; 537  : 	if (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)

  00036	8b 45 fc	 mov	 eax, DWORD PTR $T10[ebp]
  00039	33 d2		 xor	 edx, edx
  0003b	f7 75 f8	 div	 DWORD PTR $T9[ebp]
  0003e	85 d2		 test	 edx, edx
  00040	75 17		 jne	 SHORT $LN2@SecureWipe

; 510  : 	volatile word32 *p = buf;

  00042	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00045	89 45 e4	 mov	 DWORD PTR _p$4[ebp], eax

; 528  : 	SecureWipeBuffer((word32 *)buf, 2*n);

  00048	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  0004b	d1 e1		 shl	 ecx, 1

; 514  : 	__stosd((unsigned long *)(size_t)p, 0, n);

  0004d	8b 7d e4	 mov	 edi, DWORD PTR _p$4[ebp]
  00050	33 c0		 xor	 eax, eax
  00052	f3 ab		 rep stosd

; 538  : 		SecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));

  00054	e9 b3 00 00 00	 jmp	 $LN1@SecureWipe
$LN2@SecureWipe:

; 539  : 	else if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)

  00059	33 c0		 xor	 eax, eax
  0005b	40		 inc	 eax
  0005c	74 4a		 je	 SHORT $LN4@SecureWipe

; 366  : 	if (sizeof(T) < 16)

  0005e	33 c0		 xor	 eax, eax
  00060	40		 inc	 eax
  00061	74 09		 je	 SHORT $LN20@SecureWipe

; 367  : 		return 1;

  00063	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR $T8[ebp], 1
  0006a	eb 07		 jmp	 SHORT $LN19@SecureWipe
$LN20@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  0006c	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR $T8[ebp], 8
$LN19@SecureWipe:

; 366  : 	if (sizeof(T) < 16)

  00073	33 c0		 xor	 eax, eax
  00075	40		 inc	 eax
  00076	74 09		 je	 SHORT $LN23@SecureWipe

; 367  : 		return 1;

  00078	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T7[ebp], 1
  0007f	eb 07		 jmp	 SHORT $LN22@SecureWipe
$LN23@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  00081	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR $T7[ebp], 4
$LN22@SecureWipe:

; 539  : 	else if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)

  00088	8b 45 f4	 mov	 eax, DWORD PTR $T8[ebp]
  0008b	33 d2		 xor	 edx, edx
  0008d	f7 75 f0	 div	 DWORD PTR $T7[ebp]
  00090	85 d2		 test	 edx, edx
  00092	75 14		 jne	 SHORT $LN4@SecureWipe

; 510  : 	volatile word32 *p = buf;

  00094	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00097	89 45 e0	 mov	 DWORD PTR _p$3[ebp], eax

; 540  : 		SecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));

  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  0009d	d1 e1		 shl	 ecx, 1

; 514  : 	__stosd((unsigned long *)(size_t)p, 0, n);

  0009f	8b 7d e0	 mov	 edi, DWORD PTR _p$3[ebp]
  000a2	33 c0		 xor	 eax, eax
  000a4	f3 ab		 rep stosd

; 540  : 		SecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));

  000a6	eb 64		 jmp	 SHORT $LN1@SecureWipe
$LN4@SecureWipe:

; 541  : 	else if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)

  000a8	33 c0		 xor	 eax, eax
  000aa	40		 inc	 eax
  000ab	74 4c		 je	 SHORT $LN6@SecureWipe

; 366  : 	if (sizeof(T) < 16)

  000ad	33 c0		 xor	 eax, eax
  000af	40		 inc	 eax
  000b0	74 09		 je	 SHORT $LN28@SecureWipe

; 367  : 		return 1;

  000b2	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR $T6[ebp], 1
  000b9	eb 07		 jmp	 SHORT $LN27@SecureWipe
$LN28@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  000bb	c7 45 ec 08 00
	00 00		 mov	 DWORD PTR $T6[ebp], 8
$LN27@SecureWipe:

; 366  : 	if (sizeof(T) < 16)

  000c2	33 c0		 xor	 eax, eax
  000c4	40		 inc	 eax
  000c5	74 09		 je	 SHORT $LN31@SecureWipe

; 367  : 		return 1;

  000c7	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR $T5[ebp], 1
  000ce	eb 07		 jmp	 SHORT $LN30@SecureWipe
$LN31@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  000d0	c7 45 e8 02 00
	00 00		 mov	 DWORD PTR $T5[ebp], 2
$LN30@SecureWipe:

; 541  : 	else if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)

  000d7	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  000da	33 d2		 xor	 edx, edx
  000dc	f7 75 e8	 div	 DWORD PTR $T5[ebp]
  000df	85 d2		 test	 edx, edx
  000e1	75 16		 jne	 SHORT $LN6@SecureWipe

; 500  : 	volatile word16 *p = buf;

  000e3	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000e6	89 45 dc	 mov	 DWORD PTR _p$2[ebp], eax

; 542  : 		SecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));

  000e9	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  000ec	c1 e1 02	 shl	 ecx, 2

; 504  : 	__stosw((word16 *)(size_t)p, 0, n);

  000ef	33 c0		 xor	 eax, eax
  000f1	8b 7d dc	 mov	 edi, DWORD PTR _p$2[ebp]
  000f4	66 f3 ab	 rep stosw

; 542  : 		SecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));

  000f7	eb 13		 jmp	 SHORT $LN1@SecureWipe
$LN6@SecureWipe:

; 490  : 	volatile byte *p = buf;

  000f9	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000fc	89 45 d8	 mov	 DWORD PTR _p$1[ebp], eax

; 543  : 	else
; 544  : 		SecureWipeBuffer((byte *)buf, n * sizeof(T));

  000ff	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  00102	c1 e1 03	 shl	 ecx, 3

; 494  : 	__stosb((byte *)(size_t)p, 0, n);

  00105	8b 7d d8	 mov	 edi, DWORD PTR _p$1[ebp]
  00108	32 c0		 xor	 al, al
  0010a	f3 aa		 rep stosb
$LN1@SecureWipe:

; 545  : }

  0010c	5f		 pop	 edi
  0010d	c9		 leave
  0010e	c3		 ret	 0
??$SecureWipeArray@_K@CryptoPP@@YAXPA_KI@Z ENDP		; CryptoPP::SecureWipeArray<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h
;	COMDAT ??$SecureWipeArray@I@CryptoPP@@YAXPAII@Z
_TEXT	SEGMENT
_p$1 = -32						; size = 4
_p$2 = -28						; size = 4
_p$3 = -24						; size = 4
_p$4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
$T7 = -8						; size = 4
$T8 = -4						; size = 4
_buf$ = 8						; size = 4
_n$ = 12						; size = 4
??$SecureWipeArray@I@CryptoPP@@YAXPAII@Z PROC		; CryptoPP::SecureWipeArray<unsigned int>, COMDAT

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	57		 push	 edi

; 537  : 	if (sizeof(T) % 8 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word64>() == 0)

  00007	33 c0		 xor	 eax, eax
  00009	74 18		 je	 SHORT $LN2@SecureWipe

; 510  : 	volatile word32 *p = buf;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  0000e	89 45 ec	 mov	 DWORD PTR _p$4[ebp], eax

; 538  : 		SecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));

  00011	6b 4d 0c 00	 imul	 ecx, DWORD PTR _n$[ebp], 0

; 528  : 	SecureWipeBuffer((word32 *)buf, 2*n);

  00015	d1 e1		 shl	 ecx, 1

; 514  : 	__stosd((unsigned long *)(size_t)p, 0, n);

  00017	8b 7d ec	 mov	 edi, DWORD PTR _p$4[ebp]
  0001a	33 c0		 xor	 eax, eax
  0001c	f3 ab		 rep stosd

; 538  : 		SecureWipeBuffer((word64 *)buf, n * (sizeof(T)/8));

  0001e	e9 b0 00 00 00	 jmp	 $LN1@SecureWipe
$LN2@SecureWipe:

; 539  : 	else if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	74 48		 je	 SHORT $LN4@SecureWipe

; 366  : 	if (sizeof(T) < 16)

  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
  0002b	74 09		 je	 SHORT $LN14@SecureWipe

; 367  : 		return 1;

  0002d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR $T8[ebp], 1
  00034	eb 07		 jmp	 SHORT $LN13@SecureWipe
$LN14@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  00036	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR $T8[ebp], 4
$LN13@SecureWipe:

; 366  : 	if (sizeof(T) < 16)

  0003d	33 c0		 xor	 eax, eax
  0003f	40		 inc	 eax
  00040	74 09		 je	 SHORT $LN17@SecureWipe

; 367  : 		return 1;

  00042	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR $T7[ebp], 1
  00049	eb 07		 jmp	 SHORT $LN16@SecureWipe
$LN17@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  0004b	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR $T7[ebp], 4
$LN16@SecureWipe:

; 539  : 	else if (sizeof(T) % 4 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word32>() == 0)

  00052	8b 45 fc	 mov	 eax, DWORD PTR $T8[ebp]
  00055	33 d2		 xor	 edx, edx
  00057	f7 75 f8	 div	 DWORD PTR $T7[ebp]
  0005a	85 d2		 test	 edx, edx
  0005c	75 12		 jne	 SHORT $LN4@SecureWipe

; 510  : 	volatile word32 *p = buf;

  0005e	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  00061	89 45 e8	 mov	 DWORD PTR _p$3[ebp], eax

; 511  : #ifdef __GNUC__
; 512  : 	asm volatile("rep stosl" : "+c"(n), "+D"(p) : "a"(0) : "memory");
; 513  : #else
; 514  : 	__stosd((unsigned long *)(size_t)p, 0, n);

  00064	8b 7d e8	 mov	 edi, DWORD PTR _p$3[ebp]
  00067	33 c0		 xor	 eax, eax
  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  0006c	f3 ab		 rep stosd

; 540  : 		SecureWipeBuffer((word32 *)buf, n * (sizeof(T)/4));

  0006e	eb 63		 jmp	 SHORT $LN1@SecureWipe
$LN4@SecureWipe:

; 541  : 	else if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)

  00070	33 c0		 xor	 eax, eax
  00072	40		 inc	 eax
  00073	74 4b		 je	 SHORT $LN6@SecureWipe

; 366  : 	if (sizeof(T) < 16)

  00075	33 c0		 xor	 eax, eax
  00077	40		 inc	 eax
  00078	74 09		 je	 SHORT $LN22@SecureWipe

; 367  : 		return 1;

  0007a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR $T6[ebp], 1
  00081	eb 07		 jmp	 SHORT $LN21@SecureWipe
$LN22@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  00083	c7 45 f4 04 00
	00 00		 mov	 DWORD PTR $T6[ebp], 4
$LN21@SecureWipe:

; 366  : 	if (sizeof(T) < 16)

  0008a	33 c0		 xor	 eax, eax
  0008c	40		 inc	 eax
  0008d	74 09		 je	 SHORT $LN25@SecureWipe

; 367  : 		return 1;

  0008f	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR $T5[ebp], 1
  00096	eb 07		 jmp	 SHORT $LN24@SecureWipe
$LN25@SecureWipe:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  00098	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR $T5[ebp], 2
$LN24@SecureWipe:

; 541  : 	else if (sizeof(T) % 2 == 0 && GetAlignmentOf<T>() % GetAlignmentOf<word16>() == 0)

  0009f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  000a2	33 d2		 xor	 edx, edx
  000a4	f7 75 f0	 div	 DWORD PTR $T5[ebp]
  000a7	85 d2		 test	 edx, edx
  000a9	75 15		 jne	 SHORT $LN6@SecureWipe

; 500  : 	volatile word16 *p = buf;

  000ab	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000ae	89 45 e4	 mov	 DWORD PTR _p$2[ebp], eax

; 542  : 		SecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));

  000b1	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  000b4	d1 e1		 shl	 ecx, 1

; 504  : 	__stosw((word16 *)(size_t)p, 0, n);

  000b6	33 c0		 xor	 eax, eax
  000b8	8b 7d e4	 mov	 edi, DWORD PTR _p$2[ebp]
  000bb	66 f3 ab	 rep stosw

; 542  : 		SecureWipeBuffer((word16 *)buf, n * (sizeof(T)/2));

  000be	eb 13		 jmp	 SHORT $LN1@SecureWipe
$LN6@SecureWipe:

; 490  : 	volatile byte *p = buf;

  000c0	8b 45 08	 mov	 eax, DWORD PTR _buf$[ebp]
  000c3	89 45 e0	 mov	 DWORD PTR _p$1[ebp], eax

; 543  : 	else
; 544  : 		SecureWipeBuffer((byte *)buf, n * sizeof(T));

  000c6	8b 4d 0c	 mov	 ecx, DWORD PTR _n$[ebp]
  000c9	c1 e1 02	 shl	 ecx, 2

; 494  : 	__stosb((byte *)(size_t)p, 0, n);

  000cc	8b 7d e0	 mov	 edi, DWORD PTR _p$1[ebp]
  000cf	32 c0		 xor	 al, al
  000d1	f3 aa		 rep stosb
$LN1@SecureWipe:

; 545  : }

  000d3	5f		 pop	 edi
  000d4	c9		 leave
  000d5	c3		 ret	 0
??$SecureWipeArray@I@CryptoPP@@YAXPAII@Z ENDP		; CryptoPP::SecureWipeArray<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
__Oldwidth$2 = -48					; size = 8
$T3 = -40						; size = 8
$T4 = -32						; size = 8
$T5 = -24						; size = 8
__$EHRec$ = -16						; size = 16
$T6 = 0							; size = 8
$T7 = 8							; size = 4
$T8 = 12						; size = 4
$T9 = 16						; size = 4
$T10 = 20						; size = 2
$T11 = 24						; size = 2
$T12 = 28						; size = 4
$T13 = 32						; size = 4
tv251 = 36						; size = 4
_this$ = 40						; size = 4
__Ok$ = 44						; size = 8
tv387 = 52						; size = 4
_this$ = 56						; size = 4
tv403 = 60						; size = 4
__Ctype_fac$14 = 64					; size = 4
tv362 = 68						; size = 4
$T15 = 72						; size = 4
_this$ = 76						; size = 4
_this$ = 80						; size = 4
$T16 = 86						; size = 2
tv253 = 88						; size = 2
tv259 = 90						; size = 2
__Size$17 = 92						; size = 4
__State$ = 96						; size = 4
tv365 = 101						; size = 1
$T18 = 102						; size = 1
$T19 = 103						; size = 1
__Meta$20 = 104						; size = 2
__Changed$ = 111					; size = 1
__Istr$ = 120						; size = 4
__Str$ = 124						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4670 :     basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 20	 sub	 esp, 32			; 00000020H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	83 65 48 00	 and	 DWORD PTR $T15[ebp], 0

; 4671 :     using _Myis   = basic_istream<_Elem, _Traits>;
; 4672 :     using _Ctype  = typename _Myis::_Ctype;
; 4673 :     using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
; 4674 :     using _Mysizt = typename _Mystr::size_type;
; 4675 : 
; 4676 :     typename _Myis::iostate _State = _Myis::goodbit;

  00035	83 65 60 00	 and	 DWORD PTR __State$[ebp], 0

; 4677 :     bool _Changed                  = false;

  00039	c6 45 6f 00	 mov	 BYTE PTR __Changed$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 103  :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

  0003d	ff 75 78	 push	 DWORD PTR __Istr$[ebp]
  00040	8d 4d 2c	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00043	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::_Sentry_base
  00048	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  0004c	6a 00		 push	 0
  0004e	8b 4d 2c	 mov	 ecx, DWORD PTR __Ok$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Ipfx
  00056	88 45 30	 mov	 BYTE PTR __Ok$[ebp+4], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4678 :     const typename _Myis::sentry _Ok(_Istr);

  00059	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 106  :             return _Ok;

  00060	8a 45 30	 mov	 al, BYTE PTR __Ok$[ebp+4]
  00063	88 45 67	 mov	 BYTE PTR $T19[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4680 :     if (_Ok) { // state okay, extract characters

  00066	0f b6 45 67	 movzx	 eax, BYTE PTR $T19[ebp]
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 14 02 00
	00		 je	 $LN5@operator

; 4681 :         const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(_Istr.getloc());

  00072	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  00075	8b 00		 mov	 eax, DWORD PTR [eax]
  00077	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0007a	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0007d	89 4d 28	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 373  :         return *_Ploc;

  00080	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00083	ff 70 30	 push	 DWORD PTR [eax+48]
  00086	8d 4d e8	 lea	 ecx, DWORD PTR $T5[ebp]
  00089	e8 00 00 00 00	 call	 ??0locale@std@@QAE@ABV01@@Z ; std::locale::locale
  0008e	8b 45 48	 mov	 eax, DWORD PTR $T15[ebp]
  00091	83 c8 01	 or	 eax, 1
  00094	89 45 48	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4681 :         const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(_Istr.getloc());

  00097	8d 45 e8	 lea	 eax, DWORD PTR $T5[ebp]
  0009a	89 45 24	 mov	 DWORD PTR tv251[ebp], eax
  0009d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  000a1	ff 75 24	 push	 DWORD PTR tv251[ebp]
  000a4	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  000a9	59		 pop	 ecx
  000aa	89 45 40	 mov	 DWORD PTR __Ctype_fac$14[ebp], eax
  000ad	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000b1	8d 4d e8	 lea	 ecx, DWORD PTR $T5[ebp]
  000b4	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 2231 :         if (_Mysize < _Off) {

  000b9	8b 45 7c	 mov	 eax, DWORD PTR __Str$[ebp]
  000bc	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000c0	73 05		 jae	 SHORT $LN40@operator

; 2232 :             _Xran();

  000c2	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
$LN40@operator:

; 3289 :         _Eos(_Off);

  000c7	6a 00		 push	 0
  000c9	8b 4d 7c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000cc	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos

; 4682 :         _Str.erase();
; 4683 : 
; 4684 :         _TRY_IO_BEGIN

  000d1	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  000d5	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  000d8	8b 00		 mov	 eax, DWORD PTR [eax]
  000da	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000dd	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000e0	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  000e4	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  000e8	89 55 00	 mov	 DWORD PTR $T6[ebp], edx
  000eb	89 45 04	 mov	 DWORD PTR $T6[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4686 :         if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {

  000ee	83 7d 04 00	 cmp	 DWORD PTR $T6[ebp+4], 0
  000f2	7c 4f		 jl	 SHORT $LN7@operator
  000f4	7f 06		 jg	 SHORT $LN265@operator
  000f6	83 7d 00 00	 cmp	 DWORD PTR $T6[ebp], 0
  000fa	76 47		 jbe	 SHORT $LN7@operator
$LN265@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  000fc	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  000ff	8b 00		 mov	 eax, DWORD PTR [eax]
  00101	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00104	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00107	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  0010b	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  0010f	89 55 e0	 mov	 DWORD PTR $T4[ebp], edx
  00112	89 45 e4	 mov	 DWORD PTR $T4[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4686 :         if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {

  00115	8b 4d 7c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00118	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  0011d	39 45 e0	 cmp	 DWORD PTR $T4[ebp], eax
  00120	73 21		 jae	 SHORT $LN7@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 363  :         return _Wide;

  00122	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  00125	8b 00		 mov	 eax, DWORD PTR [eax]
  00127	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0012a	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0012d	8b 54 01 20	 mov	 edx, DWORD PTR [ecx+eax+32]
  00131	8b 44 01 24	 mov	 eax, DWORD PTR [ecx+eax+36]
  00135	89 55 d8	 mov	 DWORD PTR $T3[ebp], edx
  00138	89 45 dc	 mov	 DWORD PTR $T3[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4687 :             _Size = static_cast<_Mysizt>(_Istr.width());

  0013b	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0013e	89 45 5c	 mov	 DWORD PTR __Size$17[ebp], eax

; 4688 :         } else {

  00141	eb 0b		 jmp	 SHORT $LN8@operator
$LN7@operator:

; 4689 :             _Size = _Str.max_size();

  00143	8b 4d 7c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00146	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  0014b	89 45 5c	 mov	 DWORD PTR __Size$17[ebp], eax
$LN8@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  0014e	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  00151	8b 00		 mov	 eax, DWORD PTR [eax]
  00153	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00156	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00159	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  0015d	89 45 20	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4692 :         typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00160	8b 4d 20	 mov	 ecx, DWORD PTR $T13[ebp]
  00163	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sgetc
  00168	66 89 45 5a	 mov	 WORD PTR tv259[ebp], ax
  0016c	66 8b 45 5a	 mov	 ax, WORD PTR tv259[ebp]
  00170	66 89 45 68	 mov	 WORD PTR __Meta$20[ebp], ax

; 4694 :         for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {

  00174	eb 2d		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00176	8b 45 5c	 mov	 eax, DWORD PTR __Size$17[ebp]
  00179	48		 dec	 eax
  0017a	89 45 5c	 mov	 DWORD PTR __Size$17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  0017d	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  00180	8b 00		 mov	 eax, DWORD PTR [eax]
  00182	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00185	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00188	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  0018c	89 45 1c	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4694 :         for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {

  0018f	8b 4d 1c	 mov	 ecx, DWORD PTR $T12[ebp]
  00192	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::snextc
  00197	66 89 45 58	 mov	 WORD PTR tv253[ebp], ax
  0019b	66 8b 45 58	 mov	 ax, WORD PTR tv253[ebp]
  0019f	66 89 45 68	 mov	 WORD PTR __Meta$20[ebp], ax
$LN4@operator:
  001a3	83 7d 5c 00	 cmp	 DWORD PTR __Size$17[ebp], 0
  001a7	0f 86 80 00 00
	00		 jbe	 $LN3@operator

; 309  :         return WEOF;

  001ad	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001b2	66 89 45 56	 mov	 WORD PTR $T16[ebp], ax

; 301  :         return _Left == _Right;

  001b6	0f b7 45 68	 movzx	 eax, WORD PTR __Meta$20[ebp]
  001ba	0f b7 4d 56	 movzx	 ecx, WORD PTR $T16[ebp]
  001be	3b c8		 cmp	 ecx, eax
  001c0	75 09		 jne	 SHORT $LN190@operator
  001c2	c7 45 44 01 00
	00 00		 mov	 DWORD PTR tv362[ebp], 1
  001c9	eb 04		 jmp	 SHORT $LN191@operator
$LN190@operator:
  001cb	83 65 44 00	 and	 DWORD PTR tv362[ebp], 0
$LN191@operator:
  001cf	8a 45 44	 mov	 al, BYTE PTR tv362[ebp]
  001d2	88 45 66	 mov	 BYTE PTR $T18[ebp], al

; 4695 :             if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  001d5	0f b6 45 66	 movzx	 eax, BYTE PTR $T18[ebp]
  001d9	85 c0		 test	 eax, eax
  001db	74 0d		 je	 SHORT $LN9@operator

; 4696 :                 _State |= _Myis::eofbit;

  001dd	8b 45 60	 mov	 eax, DWORD PTR __State$[ebp]
  001e0	83 c8 01	 or	 eax, 1
  001e3	89 45 60	 mov	 DWORD PTR __State$[ebp], eax

; 4697 :                 break;

  001e6	eb 45		 jmp	 SHORT $LN3@operator

; 4698 :             } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

  001e8	eb 3e		 jmp	 SHORT $LN10@operator
$LN9@operator:

; 293  :         return _Meta;

  001ea	66 8b 45 68	 mov	 ax, WORD PTR __Meta$20[ebp]
  001ee	66 89 45 18	 mov	 WORD PTR $T11[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2806 :         return do_is(_Maskval, _Ch);

  001f2	ff 75 18	 push	 DWORD PTR $T11[ebp]
  001f5	6a 48		 push	 72			; 00000048H
  001f7	8b 45 40	 mov	 eax, DWORD PTR __Ctype_fac$14[ebp]
  001fa	8b 00		 mov	 eax, DWORD PTR [eax]
  001fc	8b 4d 40	 mov	 ecx, DWORD PTR __Ctype_fac$14[ebp]
  001ff	ff 50 10	 call	 DWORD PTR [eax+16]
  00202	88 45 65	 mov	 BYTE PTR tv365[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4698 :             } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

  00205	0f b6 45 65	 movzx	 eax, BYTE PTR tv365[ebp]
  00209	85 c0		 test	 eax, eax
  0020b	74 04		 je	 SHORT $LN11@operator

; 4699 :                 break; // whitespace, quit

  0020d	eb 1e		 jmp	 SHORT $LN3@operator

; 4700 :             } else { // add character to string

  0020f	eb 17		 jmp	 SHORT $LN10@operator
$LN11@operator:

; 293  :         return _Meta;

  00211	66 8b 45 68	 mov	 ax, WORD PTR __Meta$20[ebp]
  00215	66 89 45 14	 mov	 WORD PTR $T10[ebp], ax

; 4701 :                 _Str.push_back(_Traits::to_char_type(_Meta));

  00219	ff 75 14	 push	 DWORD PTR $T10[ebp]
  0021c	8b 4d 7c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0021f	e8 00 00 00 00	 call	 ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back

; 4702 :                 _Changed = true;

  00224	c6 45 6f 01	 mov	 BYTE PTR __Changed$[ebp], 1
$LN10@operator:

; 4703 :             }
; 4704 :         }

  00228	e9 49 ff ff ff	 jmp	 $LN2@operator
$LN3@operator:
  0022d	eb 47		 jmp	 SHORT $LN15@operator
__catch$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$0:

; 4705 :         _CATCH_IO_(_Myis, _Istr)

  0022f	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  00232	8b 00		 mov	 eax, DWORD PTR [eax]
  00234	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00237	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0023a	89 4d 50	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  0023d	8b 45 50	 mov	 eax, DWORD PTR _this$[ebp]
  00240	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00243	89 45 10	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00246	8b 45 50	 mov	 eax, DWORD PTR _this$[ebp]
  00249	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0024d	74 06		 je	 SHORT $LN228@operator
  0024f	83 65 3c 00	 and	 DWORD PTR tv403[ebp], 0
  00253	eb 07		 jmp	 SHORT $LN229@operator
$LN228@operator:
  00255	c7 45 3c 04 00
	00 00		 mov	 DWORD PTR tv403[ebp], 4
$LN229@operator:
  0025c	6a 01		 push	 1

; 53   :         clear(rdstate() | _State, _Reraise);

  0025e	8b 45 10	 mov	 eax, DWORD PTR $T9[ebp]
  00261	83 c8 04	 or	 eax, 4

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00264	0b 45 3c	 or	 eax, DWORD PTR tv403[ebp]
  00267	50		 push	 eax
  00268	8b 4d 50	 mov	 ecx, DWORD PTR _this$[ebp]
  0026b	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4705 :         _CATCH_IO_(_Myis, _Istr)

  00270	b8 00 00 00 00	 mov	 eax, $LN20@operator
  00275	c3		 ret	 0
$LN15@operator:
  00276	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
  0027d	eb 07		 jmp	 SHORT $LN5@operator
$LN20@operator:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
  0027f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
$LN5@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4706 :     }
; 4707 : 
; 4708 :     _Istr.width(0);

  00286	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  00289	8b 00		 mov	 eax, DWORD PTR [eax]
  0028b	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0028e	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00291	89 4d 38	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 367  :         const streamsize _Oldwidth = _Wide;

  00294	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  00297	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0029a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0029d	89 4d d0	 mov	 DWORD PTR __Oldwidth$2[ebp], ecx
  002a0	89 45 d4	 mov	 DWORD PTR __Oldwidth$2[ebp+4], eax

; 368  :         _Wide                      = _Newwidth;

  002a3	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  002a6	33 c9		 xor	 ecx, ecx
  002a8	33 d2		 xor	 edx, edx
  002aa	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  002ad	89 50 24	 mov	 DWORD PTR [eax+36], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4709 :     if (!_Changed) {

  002b0	0f b6 45 6f	 movzx	 eax, BYTE PTR __Changed$[ebp]
  002b4	85 c0		 test	 eax, eax
  002b6	75 09		 jne	 SHORT $LN13@operator

; 4710 :         _State |= _Myis::failbit;

  002b8	8b 45 60	 mov	 eax, DWORD PTR __State$[ebp]
  002bb	83 c8 02	 or	 eax, 2
  002be	89 45 60	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 4711 :     }
; 4712 : 
; 4713 :     _Istr.setstate(_State);

  002c1	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  002c4	8b 00		 mov	 eax, DWORD PTR [eax]
  002c6	8b 4d 78	 mov	 ecx, DWORD PTR __Istr$[ebp]
  002c9	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  002cc	89 4d 4c	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  002cf	8b 45 4c	 mov	 eax, DWORD PTR _this$[ebp]
  002d2	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  002d5	89 45 0c	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  002d8	8b 45 4c	 mov	 eax, DWORD PTR _this$[ebp]
  002db	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  002df	74 06		 je	 SHORT $LN246@operator
  002e1	83 65 34 00	 and	 DWORD PTR tv387[ebp], 0
  002e5	eb 07		 jmp	 SHORT $LN247@operator
$LN246@operator:
  002e7	c7 45 34 04 00
	00 00		 mov	 DWORD PTR tv387[ebp], 4
$LN247@operator:
  002ee	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  002f0	8b 45 0c	 mov	 eax, DWORD PTR $T8[ebp]
  002f3	0b 45 60	 or	 eax, DWORD PTR __State$[ebp]

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  002f6	0b 45 34	 or	 eax, DWORD PTR tv387[ebp]
  002f9	50		 push	 eax
  002fa	8b 4d 4c	 mov	 ecx, DWORD PTR _this$[ebp]
  002fd	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4714 :     return _Istr;

  00302	8b 45 78	 mov	 eax, DWORD PTR __Istr$[ebp]
  00305	89 45 08	 mov	 DWORD PTR $T7[ebp], eax
  00308	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0030c	8d 4d 2c	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0030f	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
  00314	8b 45 08	 mov	 eax, DWORD PTR $T7[ebp]
$LN59@operator:

; 4715 : }

  00317	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0031a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00321	59		 pop	 ecx
  00322	5f		 pop	 edi
  00323	5e		 pop	 esi
  00324	5b		 pop	 ebx
  00325	83 c5 70	 add	 ebp, 112		; 00000070H
  00328	c9		 leave
  00329	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$4:
  00000	8d 4d 2c	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$2:
  00008	8d 4d 2c	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@XZ
__unwindfunclet$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z$3:
  00010	8d 4d e8	 lea	 ecx, DWORD PTR $T5[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z PROC ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 4719 :     basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4720 :     return _STD move(_Istr) >> _Str;

  0000a	ff 75 0c	 push	 DWORD PTR __Str$[ebp]
  0000d	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  00010	e8 00 00 00 00	 call	 ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@$$QAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx

; 4721 : }

  00017	c9		 leave
  00018	c3		 ret	 0
??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ENDP ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z
_TEXT	SEGMENT
__Al$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Raw_new$ = -40					; size = 4
__Old_ptr$3 = -36					; size = 4
__Old_capacity$ = -32					; size = 4
__New_capacity$ = -28					; size = 4
__New_size$ = -24					; size = 4
__New_ptr$ = -20					; size = 4
__Old_size$ = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f0	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f0	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f0	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e8	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 e0	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e8	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e4	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 ec	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e8	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 ec	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d e0 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 3a		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 dc	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 dc	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3830 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  000ac	8b 45 f0	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000af	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000b0	50		 push	 eax
  000b1	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b4	ff 75 d8	 push	 DWORD PTR __Raw_new$[ebp]
  000b7	e8 00 00 00 00	 call	 _memcpy
  000bc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000bf	8b 45 e0	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000c2	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c3	50		 push	 eax
  000c4	ff 75 dc	 push	 DWORD PTR __Old_ptr$3[ebp]
  000c7	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000cc	59		 pop	 ecx
  000cd	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000d1	8b 4d ec	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000d4	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  000d6	eb 21		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3830 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  000d8	8b 45 f0	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000db	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000dc	50		 push	 eax
  000dd	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000e0	ff 75 d8	 push	 DWORD PTR __Raw_new$[ebp]
  000e3	e8 00 00 00 00	 call	 _memcpy
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000eb	8d 45 ec	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000ee	50		 push	 eax
  000ef	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  000fc	c9		 leave
  000fd	c2 08 00	 ret	 8
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??$emplace@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@12@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@std@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<args_0>$ = 12						; size = 4
??$emplace@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@12@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@std@@@Z PROC ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::emplace<std::pair<unsigned long const ,CEterFileDict::Item> >, COMDAT
; _this$ = ecx

; 1094 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 249  :          {  return static_cast<T&&>(t);   }

  00009	8b 45 0c	 mov	 eax, DWORD PTR _<args_0>$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 c0 03	 add	 eax, 3
  00015	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00018	74 09		 je	 SHORT $LN10@emplace
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	40		 inc	 eax
  0001e	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00021	eb 04		 jmp	 SHORT $LN6@emplace
$LN10@emplace:
  00023	83 65 f8 00	 and	 DWORD PTR $T2[ebp], 0
$LN6@emplace:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1095 :         return iterator(table_.emplace_equiv(

  00027	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  0002a	ff 75 f8	 push	 DWORD PTR $T2[ebp]
  0002d	e8 00 00 00 00	 call	 ??$construct_node_from_args@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@U?$pair@$$CBKUItem@CEterFileDict@@@2@@func@detail@unordered@boost@@YAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@AAV?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@6@@Z ; boost::unordered::detail::func::construct_node_from_args<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > >,std::pair<unsigned long const ,CEterFileDict::Item> >
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
  00034	50		 push	 eax
  00035	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  00038	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_equiv
  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1096 :           boost::unordered::detail::func::construct_node_from_args(
; 1097 :             table_.node_alloc(), boost::forward<Args>(args)...)));
; 1098 :       }

  00043	c9		 leave
  00044	c2 08 00	 ret	 8
??$emplace@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@12@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@std@@@Z ENDP ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::emplace<std::pair<unsigned long const ,CEterFileDict::Item> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABQAUSEterPackIndex@@@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@1@QAU21@ABQAUSEterPackIndex@@@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABQAUSEterPackIndex@@@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@1@QAU21@ABQAUSEterPackIndex@@@Z PROC ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Emplace<SEterPackIndex * const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 55 55
	55 15		 mov	 DWORD PTR $T12[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABQAUSEterPackIndex@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@ABQAUSEterPackIndex@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > ><SEterPackIndex * const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABQAUSEterPackIndex@@@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@1@QAU21@ABQAUSEterPackIndex@@@Z ENDP ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Emplace<SEterPackIndex * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<SEterPackIndex *,void *>::_Free_non_head<std::allocator<std::_List_node<SEterPackIndex *,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ; std::_List_node<SEterPackIndex *,void *>::_Freenode0<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<SEterPackIndex *,void *>::_Free_non_head<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 28		 push	 40			; 00000028H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@ABV01@@Z
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7NotImplemented@CryptoPP@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::~InputRejected, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	c9		 leave
  00010	c3		 ret	 0
??1InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::~InputRejected
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected, COMDAT
; _this$ = ecx

; 85   : 		{InputRejected() : NotImplemented("BufferedTransformation: this object doesn't allow input") {}};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@JMMKBAHA@BufferedTransformation?3?5this?5ob@
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 169  : 	explicit NotImplemented(const std::string &s) : Exception(NOT_IMPLEMENTED, s) {}

  0003c	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  0003f	50		 push	 eax
  00040	6a 00		 push	 0
  00042	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::Exception::Exception
  0004a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7NotImplemented@CryptoPP@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h

; 85   : 		{InputRejected() : NotImplemented("BufferedTransformation: this object doesn't allow input") {}};

  00053	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00057	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h

; 85   : 		{InputRejected() : NotImplemented("BufferedTransformation: this object doesn't allow input") {}};

  0005f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@6B@
  00068	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00079	33 cd		 xor	 ecx, ebp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	c9		 leave
  00081	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected
; Function compile flags: /Odspy
;	COMDAT ??_GInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 28		 push	 40			; 00000028H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@ABV01@@Z
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7NotImplemented@CryptoPP@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@ABU012@@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::~InputRejected, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	c9		 leave
  00010	c3		 ret	 0
??1InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::~InputRejected
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected, COMDAT
; _this$ = ecx

; 85   : 		{InputRejected() : NotImplemented("BufferedTransformation: this object doesn't allow input") {}};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@JMMKBAHA@BufferedTransformation?3?5this?5ob@
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 169  : 	explicit NotImplemented(const std::string &s) : Exception(NOT_IMPLEMENTED, s) {}

  0003c	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  0003f	50		 push	 eax
  00040	6a 00		 push	 0
  00042	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::Exception::Exception
  0004a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7NotImplemented@CryptoPP@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h

; 85   : 		{InputRejected() : NotImplemented("BufferedTransformation: this object doesn't allow input") {}};

  00053	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00057	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h

; 85   : 		{InputRejected() : NotImplemented("BufferedTransformation: this object doesn't allow input") {}};

  0005f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@6B@
  00068	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00079	33 cd		 xor	 ecx, ebp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	c9		 leave
  00081	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -72						; size = 4
$T3 = -68						; size = 4
$T4 = -64						; size = 4
__Lock$5 = -60						; size = 4
__Old_val$6 = -56					; size = 4
$T7 = -52						; size = 4
$T8 = -48						; size = 4
_this$ = -44						; size = 4
__Ptr$ = -40						; size = 4
__Id$9 = -36						; size = 4
__Psave_guard$10 = -32					; size = 4
__Val$ = -28						; size = 4
__Pf$11 = -24						; size = 4
__Pfmod$12 = -20					; size = 4
__Psave$13 = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >, COMDAT

; 426  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	83 65 bc 00	 and	 DWORD PTR $T3[ebp], 0

; 427  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00029	6a 00		 push	 0
  0002b	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  0002e	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 428  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::codecvt<wchar_t,char,_Mbstatet> >::_Psave
  0003c	89 45 f0	 mov	 DWORD PTR __Psave$13[ebp], eax

; 429  : 
; 430  :     const size_t _Id         = _Facet::id;

  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$codecvt@_WDU_Mbstatet@@@std@@2V0locale@2@A ; std::codecvt<wchar_t,char,_Mbstatet>::id
  00044	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00049	89 45 dc	 mov	 DWORD PTR __Id$9[ebp], eax

; 431  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  0004c	ff 75 dc	 push	 DWORD PTR __Id$9[ebp]
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00057	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax

; 432  : 
; 433  :     if (!_Pf) {

  0005a	83 7d e8 00	 cmp	 DWORD PTR __Pf$11[ebp], 0
  0005e	0f 85 9f 00 00
	00		 jne	 $LN2@use_facet

; 434  :         if (_Psave) {

  00064	83 7d f0 00	 cmp	 DWORD PTR __Psave$13[ebp], 0
  00068	74 0b		 je	 SHORT $LN3@use_facet

; 435  :             _Pf = _Psave; // lazy facet already allocated

  0006a	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  0006d	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax
  00070	e9 8e 00 00 00	 jmp	 $LN2@use_facet
$LN3@use_facet:

; 436  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  00075	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  00078	8d 45 f0	 lea	 eax, DWORD PTR __Psave$13[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::codecvt<wchar_t,char,_Mbstatet>::_Getcat
  00081	59		 pop	 ecx
  00082	59		 pop	 ecx
  00083	83 f8 ff	 cmp	 eax, -1
  00086	75 07		 jne	 SHORT $LN5@use_facet

; 437  : #if _HAS_EXCEPTIONS
; 438  :             _Throw_bad_cast(); // lazy disallowed

  00088	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast

; 439  : #else // _HAS_EXCEPTIONS
; 440  :             _CSTD abort(); // lazy disallowed
; 441  : #endif // _HAS_EXCEPTIONS
; 442  :         } else { // queue up lazy facet for destruction

  0008d	eb 74		 jmp	 SHORT $LN2@use_facet
$LN5@use_facet:

; 443  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  0008f	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  00092	89 45 ec	 mov	 DWORD PTR __Pfmod$12[ebp], eax

; 444  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  00095	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$12[ebp]
  00098	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory

; 2590 :     explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

  0009b	8d 45 e0	 lea	 eax, DWORD PTR __Psave_guard$10[ebp]
  0009e	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  000a1	8d 45 d8	 lea	 eax, DWORD PTR __Ptr$[ebp]
  000a4	89 45 d0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000a7	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	8b 4d d0	 mov	 ecx, DWORD PTR $T8[ebp]
  000ad	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000af	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 444  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  000b1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 445  : 
; 446  : #if defined(_M_CEE)
; 447  :             _Facet_Register_m(_Pfmod);
; 448  : #else // defined(_M_CEE)
; 449  :             _Facet_Register(_Pfmod);

  000b5	ff 75 ec	 push	 DWORD PTR __Pfmod$12[ebp]
  000b8	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000bd	59		 pop	 ecx

; 450  : #endif // defined(_M_CEE)
; 451  : 
; 452  :             _Pfmod->_Incref();

  000be	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$12[ebp]
  000c1	8b 00		 mov	 eax, DWORD PTR [eax]
  000c3	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$12[ebp]
  000c6	ff 50 04	 call	 DWORD PTR [eax+4]

; 453  :             _Facetptr<_Facet>::_Psave = _Psave;

  000c9	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  000cc	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::codecvt<wchar_t,char,_Mbstatet> >::_Psave

; 454  :             _Pf                       = _Psave;

  000d1	8b 45 f0	 mov	 eax, DWORD PTR __Psave$13[ebp]
  000d4	89 45 e8	 mov	 DWORD PTR __Pf$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\memory

; 2676 :         return _STD exchange(_Mypair._Myval2, pointer());

  000d7	83 65 cc 00	 and	 DWORD PTR $T7[ebp], 0
  000db	8d 45 e0	 lea	 eax, DWORD PTR __Psave_guard$10[ebp]
  000de	89 45 e4	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  000e1	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000e4	8b 00		 mov	 eax, DWORD PTR [eax]
  000e6	89 45 c8	 mov	 DWORD PTR __Old_val$6[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  000e9	8b 45 e4	 mov	 eax, DWORD PTR __Val$[ebp]
  000ec	8b 4d cc	 mov	 ecx, DWORD PTR $T7[ebp]
  000ef	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  000f1	8b 45 c8	 mov	 eax, DWORD PTR __Old_val$6[ebp]
  000f4	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 457  :         }

  000f7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000fb	8d 4d e0	 lea	 ecx, DWORD PTR __Psave_guard$10[ebp]
  000fe	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN2@use_facet:

; 458  :     }
; 459  : 
; 460  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  00103	8b 45 e8	 mov	 eax, DWORD PTR __Pf$11[ebp]
  00106	89 45 c0	 mov	 DWORD PTR $T4[ebp], eax
  00109	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0010d	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00110	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00115	8b 45 c0	 mov	 eax, DWORD PTR $T4[ebp]
$LN7@use_facet:

; 461  :     _END_LOCK()
; 462  : } // end of use_facet body

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR __Lock$5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z$1:
  00008	8d 4d e0	 lea	 ecx, DWORD PTR __Psave_guard$10[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 18		 push	 24			; 00000018H
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 18		 push	 24			; 00000018H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 aa aa
	aa 0a		 mov	 DWORD PTR $T22[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000b7	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$2[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 aa aa
	aa 0a		 cmp	 DWORD PTR __Newcapacity$[ebp], 178956970 ; 0aaaaaaaH
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 18	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 24
  00104	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 10	 push	 DWORD PTR $T14[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]
  0011e	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00144	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00147	ff 75 04	 push	 DWORD PTR $T11[ebp]
  0014a	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  0014d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00152	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  00156	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00159	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015c	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015f	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00162	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00164	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00166	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00169	8b 00		 mov	 eax, DWORD PTR [eax]
  0016b	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016e	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00171	8b 00		 mov	 eax, DWORD PTR [eax]
  00173	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00176	33 c0		 xor	 eax, eax
  00178	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  0017b	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017e	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00181	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00184	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00187	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  0018a	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018d	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  00190	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00193	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00196	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00199	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  0019e	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  001a1	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a3	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a6	8b 00		 mov	 eax, DWORD PTR [eax]
  001a8	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001ab	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ae	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001b1	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b4	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b7	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001ba	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bd	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001c0	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c3	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  001c8	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001cb	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ce	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001d1	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d4	8b 00		 mov	 eax, DWORD PTR [eax]
  001d6	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d9	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001dc	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001df	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e2	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e5	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e8	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  001ec	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ef	8d 44 01 18	 lea	 eax, DWORD PTR [ecx+eax+24]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f3	50		 push	 eax
  001f4	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f7	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001fa	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  001ff	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00202	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00204	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00207	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  0020a	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020d	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00212	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00215	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00218	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0021b	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate

; 762  :         _RERAISE;

  00220	6a 00		 push	 0
  00222	6a 00		 push	 0
  00224	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00229	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022e	c3		 ret	 0
$LN7@Emplace_re:
  0022f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00233	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00235	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00239	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023c	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023f	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00242	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00245	e8 00 00 00 00	 call	 ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  0024a	6b 45 60 18	 imul	 eax, DWORD PTR __Whereoff$[ebp], 24
  0024e	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  00251	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00254	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0025b	59		 pop	 ecx
  0025c	5f		 pop	 edi
  0025d	5e		 pop	 esi
  0025e	5b		 pop	 ebx
  0025f	83 c5 70	 add	 ebp, 112		; 00000070H
  00262	c9		 leave
  00263	c2 08 00	 ret	 8
  00266	cc		 int	 3
  00267	cc		 int	 3
  00268	cc		 int	 3
  00269	cc		 int	 3
  0026a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	ff 75 e0	 push	 DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00057	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	83 c0 18	 add	 eax, 24			; 00000018H
  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00064	c9		 leave
  00065	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_back_with_unused_capacity<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@QAV21@$$QAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Emplace_reallocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00018	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0f		 je	 SHORT $LN2@scalar
  00025	68 c0 04 00 00	 push	 1216			; 000004c0H
  0002a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN2@scalar:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c9		 leave
  00038	c2 04 00	 ret	 4
??_G?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::~SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00018	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::~SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ
_TEXT	SEGMENT
_this$ = -32						; size = 4
tv85 = -28						; size = 4
$T2 = -24						; size = 4
tv83 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ PROC ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::Clone, COMDAT
; _this$ = ecx

; 289  : 	Clonable * Clone() const {return static_cast<SymmetricCipher *>(new SymmetricCipherFinal<BASE, INFO>(*this));}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	68 c0 04 00 00	 push	 1216			; 000004c0H
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	59		 pop	 ecx
  00033	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00036	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	83 7d f0 00	 cmp	 DWORD PTR $T3[ebp], 0
  0003e	74 3e		 je	 SHORT $LN3@Clone
  00040	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 e8 04	 sub	 eax, 4
  00046	50		 push	 eax
  00047	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  0004a	e8 00 00 00 00	 call	 ??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00052	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@
  00058	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0005b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@
  00062	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00065	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@
  0006c	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0006f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@
  00076	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00079	89 45 ec	 mov	 DWORD PTR tv83[ebp], eax
  0007c	eb 04		 jmp	 SHORT $LN4@Clone
$LN3@Clone:
  0007e	83 65 ec 00	 and	 DWORD PTR tv83[ebp], 0
$LN4@Clone:
  00082	8b 45 ec	 mov	 eax, DWORD PTR tv83[ebp]
  00085	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  00088	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	83 7d e8 00	 cmp	 DWORD PTR $T2[ebp], 0
  00090	74 0b		 je	 SHORT $LN5@Clone
  00092	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00095	83 c0 04	 add	 eax, 4
  00098	89 45 e4	 mov	 DWORD PTR tv85[ebp], eax
  0009b	eb 04		 jmp	 SHORT $LN6@Clone
$LN5@Clone:
  0009d	83 65 e4 00	 and	 DWORD PTR tv85[ebp], 0
$LN6@Clone:
  000a1	8b 45 e4	 mov	 eax, DWORD PTR tv85[ebp]
  000a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ae	59		 pop	 ecx
  000af	c9		 leave
  000b0	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0:
  00000	68 c0 04 00 00	 push	 1216			; 000004c0H
  00005	ff 75 f0	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEPAVClonable@2@XZ ENDP ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::Clone
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ??0?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@QAE@XZ PROC ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >, COMDAT
; _this$ = ecx

; 281  :  	SymmetricCipherFinal() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BSimpleKeyingInterface@1@@
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6BStreamTransformation@1@@
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ??_7?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c9		 leave
  0003a	c3		 ret	 0
??0?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\panama.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T1 = -8						; size = 4
tv75 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::AlgorithmName, COMDAT
; _this$ = ecx

; 28   : 	std::string AlgorithmName() const {return ALGORITHM_INFO::StaticAlgorithmName();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 65 f8 00	 and	 DWORD PTR $T1[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\panama.h

; 113  : 	static const char * StaticAlgorithmName() {return B::ToEnum() == BIG_ENDIAN_ORDER ? "Panama-BE" : "Panama-LE";}

  0000d	33 c0		 xor	 eax, eax
  0000f	83 f8 01	 cmp	 eax, 1
  00012	75 09		 jne	 SHORT $LN7@AlgorithmN
  00014	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], OFFSET ??_C@_09LKKJKGIK@Panama?9BE@
  0001b	eb 07		 jmp	 SHORT $LN5@AlgorithmN
$LN7@AlgorithmN:
  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], OFFSET ??_C@_09LADHILIA@Panama?9LE@
$LN5@AlgorithmN:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h

; 28   : 	std::string AlgorithmName() const {return ALGORITHM_INFO::StaticAlgorithmName();}

  00024	ff 75 fc	 push	 DWORD PTR tv75[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002f	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00032	83 c8 01	 or	 eax, 1
  00035	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00038	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003b	c9		 leave
  0003c	c2 04 00	 ret	 4
?AlgorithmName@?$AlgorithmImpl@V?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CryptoPP::AlgorithmImpl<CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::AlgorithmName
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\seckey.h
;	COMDAT ?IVSize@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IVSize@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ PROC ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::IVSize, COMDAT
; _this$ = ecx

; 139  : 	unsigned int IVSize() const {return INFO::IV_LENGTH;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 20		 push	 32			; 00000020H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?IVSize@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::IVSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\seckey.h
;	COMDAT ?IVRequirement@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AW4IV_Requirement@SimpleKeyingInterface@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IVRequirement@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AW4IV_Requirement@SimpleKeyingInterface@2@XZ PROC ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::IVRequirement, COMDAT
; _this$ = ecx

; 138  : 	SimpleKeyingInterface::IV_Requirement IVRequirement() const {return (SimpleKeyingInterface::IV_Requirement)INFO::IV_REQUIREMENT;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c3		 ret	 0
?IVRequirement@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBE?AW4IV_Requirement@SimpleKeyingInterface@2@XZ ENDP ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::IVRequirement
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\seckey.h
;	COMDAT ?GetValidKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?GetValidKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEII@Z PROC ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::GetValidKeyLength, COMDAT
; _this$ = ecx

; 137  : 	size_t GetValidKeyLength(size_t n) const {return INFO::StaticGetValidKeyLength(n);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 20		 push	 32			; 00000020H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c2 04 00	 ret	 4
?GetValidKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEII@Z ENDP ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::GetValidKeyLength
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\seckey.h
;	COMDAT ?DefaultKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DefaultKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ PROC ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::DefaultKeyLength, COMDAT
; _this$ = ecx

; 136  : 	size_t DefaultKeyLength() const {return INFO::DEFAULT_KEYLENGTH;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 20		 push	 32			; 00000020H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?DefaultKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::DefaultKeyLength
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\seckey.h
;	COMDAT ?MaxKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ PROC ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::MaxKeyLength, COMDAT
; _this$ = ecx

; 135  : 	size_t MaxKeyLength() const {return (size_t)INFO::MAX_KEYLENGTH;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 20		 push	 32			; 00000020H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?MaxKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::MaxKeyLength
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\seckey.h
;	COMDAT ?MinKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ PROC ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::MinKeyLength, COMDAT
; _this$ = ecx

; 134  : 	size_t MinKeyLength() const {return INFO::MIN_KEYLENGTH;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 20		 push	 32			; 00000020H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?MinKeyLength@?$SimpleKeyingInterfaceImpl@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::SimpleKeyingInterfaceImpl<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::MinKeyLength
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00018	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0f		 je	 SHORT $LN2@scalar
  00025	68 c0 04 00 00	 push	 1216			; 000004c0H
  0002a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN2@scalar:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c9		 leave
  00038	c2 04 00	 ret	 4
??_G?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00031	83 c0 0c	 add	 eax, 12			; 0000000cH
  00034	50		 push	 eax
  00035	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0003b	e8 00 00 00 00	 call	 ??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  00040	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00046	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  00049	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  0004c	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00053	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00056	83 c0 20	 add	 eax, 32			; 00000020H
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	83 c1 20	 add	 ecx, 32			; 00000020H
  00060	e8 00 00 00 00	 call	 ??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
  00065	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00068	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@
  0006e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@
  00078	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@
  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@
  0008c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00090	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	c9		 leave
  0009f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@UAE@XZ ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::~AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>
__unwindfunclet$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z$3:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1RandomNumberGenerator@CryptoPP@@UAE@XZ
__unwindfunclet$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z$0:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>
; Function compile flags: /Odspy
;	COMDAT ??1?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::~ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00018	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::~ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ PROC ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ
  0002e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 20	 add	 ecx, 32			; 00000020H
  00038	e8 00 00 00 00	 call	 ??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BSimpleKeyingInterface@1@@
  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6BStreamTransformation@1@@
  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], OFFSET ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@1@@
  0005a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], OFFSET ??_7?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@6B?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@1@@
  00064	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00068	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00075	59		 pop	 ecx
  00076	c9		 leave
  00077	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?AccessPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MAEAAUAdditiveCipherAbstractPolicy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AccessPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MAEAAUAdditiveCipherAbstractPolicy@2@XZ PROC ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::AccessPolicy, COMDAT
; _this$ = ecx

; 54   : 	POLICY_INTERFACE & AccessPolicy() {return *this;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 20	 add	 eax, 32			; 00000020H
  0000d	c9		 leave
  0000e	c3		 ret	 0
?AccessPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MAEAAUAdditiveCipherAbstractPolicy@2@XZ ENDP ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::AccessPolicy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?GetPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MBEABUAdditiveCipherAbstractPolicy@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MBEABUAdditiveCipherAbstractPolicy@2@XZ PROC ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::GetPolicy, COMDAT
; _this$ = ecx

; 53   : 	const POLICY_INTERFACE & GetPolicy() const {return *this;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 20	 add	 eax, 32			; 00000020H
  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetPolicy@?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@MBEABUAdditiveCipherAbstractPolicy@2@XZ ENDP ; CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>::GetPolicy
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 a0 04 00 00	 push	 1184			; 000004a0H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_G?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c0 08	 add	 eax, 8
  00032	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  00035	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00038	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
  0003b	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0003e	83 c0 08	 add	 eax, 8
  00041	50		 push	 eax
  00042	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >
  0004a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	05 70 04 00 00	 add	 eax, 1136		; 00000470H
  0005f	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
  00062	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00065	05 70 04 00 00	 add	 eax, 1136		; 00000470H
  0006a	50		 push	 eax
  0006b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >
  00073	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00077	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	c9		 leave
  00086	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UAE@XZ
__unwindfunclet$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::~PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	05 70 04 00 00	 add	 eax, 1136		; 00000470H
  0002f	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00032	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	ff 70 28	 push	 DWORD PTR [eax+40]
  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	ff 70 2c	 push	 DWORD PTR [eax+44]
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
  0004a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 08	 add	 ecx, 8
  00054	e8 00 00 00 00	 call	 ??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	c9		 leave
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::~PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c0 08	 add	 eax, 8
  00032	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  00035	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00038	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  0003b	68 14 01 00 00	 push	 276			; 00000114H
  00040	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >
  00048	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@6B@
  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	05 70 04 00 00	 add	 eax, 1136		; 00000470H
  0005d	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
  00060	6a 08		 push	 8
  00062	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >
  0006a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0006e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00074	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007b	59		 pop	 ecx
  0007c	c9		 leave
  0007d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UAE@XZ
__unwindfunclet$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\panama.h
;	COMDAT ?CipherIsRandomAccess@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CipherIsRandomAccess@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBE_NXZ PROC ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::CipherIsRandomAccess, COMDAT
; _this$ = ecx

; 125  : 	bool CipherIsRandomAccess() const {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c3		 ret	 0
?CipherIsRandomAccess@?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@MBE_NXZ ENDP ; CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::CipherIsRandomAccess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ PROC ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::~Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  0002d	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	ff b0 60 04 00
	00		 push	 DWORD PTR [eax+1120]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff b0 64 04 00
	00		 push	 DWORD PTR [eax+1124]
  00043	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1>::deallocate
  0004b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00052	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00059	59		 pop	 ecx
  0005a	c9		 leave
  0005b	c3		 ret	 0
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
  0005f	cc		 int	 3
  00060	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$Panama@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >::~Panama<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >
; Function compile flags: /Odspy
;	COMDAT ??__Fwhirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ
text$yd	SEGMENT
??__Fwhirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ PROC ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'whirlpool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?whirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VWhirlpool@CryptoPP@@A
  00008	e8 00 00 00 00	 call	 ??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fwhirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ ENDP ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'whirlpool''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ
text$yd	SEGMENT
??__Fripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ PROC ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'ripemd128'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VRIPEMD128@CryptoPP@@A
  00008	e8 00 00 00 00	 call	 ??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ ENDP ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'ripemd128''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fsha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ
text$yd	SEGMENT
??__Fsha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ PROC ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'sha1'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?sha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VSHA1@CryptoPP@@A
  00008	e8 00 00 00 00	 call	 ??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fsha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ ENDP ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'sha1''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Ftiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ
text$yd	SEGMENT
??__Ftiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ PROC ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'tiger'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?tiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VTiger@CryptoPP@@A
  00008	e8 00 00 00 00	 call	 ??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Ftiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ ENDP ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'tiger''
text$yd	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 18		 push	 24			; 00000018H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 18	 imul	 eax, DWORD PTR __Count$[ebp], 24
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 18	 imul	 eax, DWORD PTR __Newsize$[ebp], 24
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 18	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 24
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@II@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 18		 push	 24			; 00000018H
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 aa aa
	aa 0a		 mov	 DWORD PTR $T7[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@AAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 18	 imul	 eax, DWORD PTR __Count$[ebp], 24
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXQAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@V?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@2@@std@@YA?AV?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 8
__UDest$ = -60						; size = 8
__Dest$ = -52						; size = 8
$T2 = -44						; size = 4
__Last$ = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
__Ptr$5 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
__Ptr$8 = -16						; size = 4
__UFirst$ = -12						; size = 4
__ULast$ = -8						; size = 4
__First$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 8
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@V?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@2@@std@@YA?AV?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0V10@@Z PROC ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::ostream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t> > >, COMDAT

; 4424 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f0	 mov	 DWORD PTR __Ptr$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$8[ebp]
  0000f	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 ec	 mov	 eax, DWORD PTR $T7[ebp]
  00015	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4426 :     const auto _UFirst = _Get_unwrapped(_First);

  00018	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0001b	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 e4	 mov	 DWORD PTR __Ptr$5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$5[ebp]
  00027	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0002d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4427 :     const auto _ULast  = _Get_unwrapped(_Last);

  00030	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00033	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1557 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

  00036	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00039	2b 45 f4	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0003c	99		 cdq
  0003d	6a 18		 push	 24			; 00000018H
  0003f	59		 pop	 ecx
  00040	f7 f9		 idiv	 ecx
  00042	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 4428 :     const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  00045	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  00048	8b 4d 18	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  0004b	89 45 c4	 mov	 DWORD PTR __UDest$[ebp], eax
  0004e	89 4d c8	 mov	 DWORD PTR __UDest$[ebp+4], ecx

; 4429 :     _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));

  00051	8b 45 c4	 mov	 eax, DWORD PTR __UDest$[ebp]
  00054	8b 4d c8	 mov	 ecx, DWORD PTR __UDest$[ebp+4]
  00057	89 45 cc	 mov	 DWORD PTR __Dest$[ebp], eax
  0005a	89 4d d0	 mov	 DWORD PTR __Dest$[ebp+4], ecx
  0005d	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00060	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax
  00063	8b 45 f4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00066	89 45 fc	 mov	 DWORD PTR __First$[ebp], eax

; 4392 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  00069	eb 09		 jmp	 SHORT $LN28@copy
$LN30@copy:
  0006b	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  0006e	83 c0 18	 add	 eax, 24			; 00000018H
  00071	89 45 fc	 mov	 DWORD PTR __First$[ebp], eax
$LN28@copy:
  00074	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  00077	3b 45 d8	 cmp	 eax, DWORD PTR __Last$[ebp]
  0007a	74 0d		 je	 SHORT $LN27@copy

; 4393 :         *_Dest = *_First;

  0007c	ff 75 fc	 push	 DWORD PTR __First$[ebp]
  0007f	8d 4d cc	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00082	e8 00 00 00 00	 call	 ??4?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@std@@QAEAAV01@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ; std::ostream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t> >::operator=

; 4394 :     }

  00087	eb e2		 jmp	 SHORT $LN30@copy
$LN27@copy:

; 4395 : 
; 4396 :     return _Dest;

  00089	8b 45 cc	 mov	 eax, DWORD PTR __Dest$[ebp]
  0008c	8b 4d d0	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  0008f	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  00092	89 4d c0	 mov	 DWORD PTR $T1[ebp+4], ecx

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00095	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00098	8b 4d c0	 mov	 ecx, DWORD PTR $T1[ebp+4]
  0009b	89 45 14	 mov	 DWORD PTR __Dest$[ebp], eax
  0009e	89 4d 18	 mov	 DWORD PTR __Dest$[ebp+4], ecx

; 4430 :     return _Dest;

  000a1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000a7	8b 55 18	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  000aa	89 08		 mov	 DWORD PTR [eax], ecx
  000ac	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000af	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4431 : }

  000b2	c9		 leave
  000b3	c3		 ret	 0
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@V?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@2@@std@@YA?AV?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0V10@@Z ENDP ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::ostream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
$T1 = -52						; size = 1
$T2 = -48						; size = 4
$T3 = -44						; size = 4
__Ptr$4 = -40						; size = 4
__Last$ = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
__Ptr$7 = -24						; size = 4
__First$ = -20						; size = 4
__UFirst$8 = -16					; size = 4
__ULast$9 = -12						; size = 4
__Pred$ = -8						; size = 1
$T10 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0@Z PROC ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >, COMDAT

; 7575 : _CONSTEXPR20 void sort(const _RanIt _First, const _RanIt _Last) { // order [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H

; 7576 :     _STD sort(_First, _Last, less<>{});

  00006	33 c0		 xor	 eax, eax
  00008	88 45 ff	 mov	 BYTE PTR $T10[ebp], al
  0000b	8a 45 ff	 mov	 al, BYTE PTR $T10[ebp]
  0000e	88 45 f8	 mov	 BYTE PTR __Pred$[ebp], al
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00014	89 45 dc	 mov	 DWORD PTR __Last$[ebp], eax
  00017	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001d	8b 45 ec	 mov	 eax, DWORD PTR __First$[ebp]
  00020	89 45 e8	 mov	 DWORD PTR __Ptr$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00023	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$7[ebp]
  00026	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00029	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  0002c	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7569 :     const auto _UFirst = _Get_unwrapped(_First);

  0002f	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00032	89 45 f0	 mov	 DWORD PTR __UFirst$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00035	8b 45 dc	 mov	 eax, DWORD PTR __Last$[ebp]
  00038	89 45 d8	 mov	 DWORD PTR __Ptr$4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$4[ebp]
  0003e	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00041	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00044	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 7570 :     const auto _ULast  = _Get_unwrapped(_Last);

  00047	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0004a	89 45 f4	 mov	 DWORD PTR __ULast$9[ebp], eax

; 7571 :     _Sort_unchecked(_UFirst, _ULast, _ULast - _UFirst, _Pass_fn(_Pred));

  0004d	8a 45 f8	 mov	 al, BYTE PTR __Pred$[ebp]
  00050	88 45 cc	 mov	 BYTE PTR $T1[ebp], al
  00053	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  00056	8b 45 f4	 mov	 eax, DWORD PTR __ULast$9[ebp]
  00059	2b 45 f0	 sub	 eax, DWORD PTR __UFirst$8[ebp]
  0005c	99		 cdq
  0005d	6a 18		 push	 24			; 00000018H
  0005f	59		 pop	 ecx
  00060	f7 f9		 idiv	 ecx
  00062	50		 push	 eax
  00063	ff 75 f4	 push	 DWORD PTR __ULast$9[ebp]
  00066	ff 75 f0	 push	 DWORD PTR __UFirst$8[ebp]
  00069	e8 00 00 00 00	 call	 ??$_Sort_unchecked@PAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@U?$less@X@2@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@0HU?$less@X@0@@Z ; std::_Sort_unchecked<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > *,std::less<void> >
  0006e	83 c4 10	 add	 esp, 16			; 00000010H

; 7577 : }

  00071	c9		 leave
  00072	c3		 ret	 0
??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0@Z ENDP ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
;	COMDAT ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__Ok$2 = -44						; size = 8
$T3 = -36						; size = 4
tv152 = -32						; size = 4
_this$ = -28						; size = 4
__Rdbuf$ = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush, COMDAT
; _this$ = ecx

; 545  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00030	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00037	89 45 e8	 mov	 DWORD PTR __Rdbuf$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 547  :         if (_Rdbuf) { // buffer exists, flush it

  0003a	83 7d e8 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0003e	74 7a		 je	 SHORT $LN2@flush

; 548  :             const sentry _Ok(*this);

  00040	ff 75 ec	 push	 DWORD PTR _this$[ebp]
  00043	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  00046	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::sentry
  0004b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 125  :             return _Ok;

  0004f	8a 45 d8	 mov	 al, BYTE PTR __Ok$2[ebp+4]
  00052	88 45 f3	 mov	 BYTE PTR $T4[ebp], al

; 550  :             if (_Ok && _Rdbuf->pubsync() == -1) {

  00055	0f b6 45 f3	 movzx	 eax, BYTE PTR $T4[ebp]
  00059	85 c0		 test	 eax, eax
  0005b	74 51		 je	 SHORT $LN3@flush
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 123  :         return sync();

  0005d	8b 45 e8	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	8b 4d e8	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00065	ff 50 34	 call	 DWORD PTR [eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 550  :             if (_Ok && _Rdbuf->pubsync() == -1) {

  00068	83 f8 ff	 cmp	 eax, -1
  0006b	75 41		 jne	 SHORT $LN3@flush

; 551  :                 _Myios::setstate(ios_base::badbit); // sync failed

  0006d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 00		 mov	 eax, DWORD PTR [eax]
  00072	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00078	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  0007b	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00081	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00084	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00087	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0008b	74 06		 je	 SHORT $LN18@flush
  0008d	83 65 e0 00	 and	 DWORD PTR tv152[ebp], 0
  00091	eb 07		 jmp	 SHORT $LN19@flush
$LN18@flush:
  00093	c7 45 e0 04 00
	00 00		 mov	 DWORD PTR tv152[ebp], 4
$LN19@flush:
  0009a	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  0009c	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0009f	83 c8 04	 or	 eax, 4

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  000a2	0b 45 e0	 or	 eax, DWORD PTR tv152[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN3@flush:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 553  :         }

  000ae	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000b2	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  000b5	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
$LN2@flush:

; 554  :         return *this;

  000ba	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 555  :     }

  000bd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c7	59		 pop	 ecx
  000c8	c9		 leave
  000c9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAE@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T2 = -52						; size = 4
tv146 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
tv174 = -36						; size = 4
$T5 = -32						; size = 4
tv152 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx, COMDAT
; _this$ = ecx

; 155  :     void __CLR_OR_THIS_CALL _Osfx() { // perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 24	 sub	 esp, 36			; 00000024H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 156  :         _TRY_BEGIN

  0002f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  00033	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  00042	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax

; 295  :         return rdstate() == ios_base::goodbit;

  00045	83 7d d8 00	 cmp	 DWORD PTR $T4[ebp], 0
  00049	75 09		 jne	 SHORT $LN12@Osfx
  0004b	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv152[ebp], 1
  00052	eb 04		 jmp	 SHORT $LN10@Osfx
$LN12@Osfx:
  00054	83 65 e4 00	 and	 DWORD PTR tv152[ebp], 0
$LN10@Osfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 157  :         if (this->good() && this->flags() & ios_base::unitbuf) {

  00058	0f b6 45 e4	 movzx	 eax, BYTE PTR tv152[ebp]
  0005c	85 c0		 test	 eax, eax
  0005e	0f 84 81 00 00
	00		 je	 $LN3@Osfx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 326  :         return _Fmtfl;

  00064	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 00		 mov	 eax, DWORD PTR [eax]
  00069	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8b 44 01 14	 mov	 eax, DWORD PTR [ecx+eax+20]
  00073	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 157  :         if (this->good() && this->flags() & ios_base::unitbuf) {

  00076	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00079	83 e0 02	 and	 eax, 2
  0007c	74 67		 je	 SHORT $LN3@Osfx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  0007e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00086	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  0008d	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 123  :         return sync();

  00090	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00093	8b 00		 mov	 eax, DWORD PTR [eax]
  00095	8b 4d e0	 mov	 ecx, DWORD PTR $T5[ebp]
  00098	ff 50 34	 call	 DWORD PTR [eax+52]
  0009b	89 45 d0	 mov	 DWORD PTR tv146[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 158  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  0009e	83 7d d0 ff	 cmp	 DWORD PTR tv146[ebp], -1
  000a2	75 41		 jne	 SHORT $LN3@Osfx

; 159  :                 _Myios::setstate(ios_base::badbit);

  000a4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000af	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  000b2	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  000b8	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  000bb	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000be	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  000c2	74 06		 je	 SHORT $LN28@Osfx
  000c4	83 65 dc 00	 and	 DWORD PTR tv174[ebp], 0
  000c8	eb 07		 jmp	 SHORT $LN29@Osfx
$LN28@Osfx:
  000ca	c7 45 dc 04 00
	00 00		 mov	 DWORD PTR tv174[ebp], 4
$LN29@Osfx:
  000d1	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  000d3	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  000d6	83 c8 04	 or	 eax, 4

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  000d9	0b 45 dc	 or	 eax, DWORD PTR tv174[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN3@Osfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 159  :                 _Myios::setstate(ios_base::badbit);

  000e5	eb 06		 jmp	 SHORT $LN6@Osfx
__catch$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ$0:

; 160  :             }
; 161  :         }
; 162  :         _CATCH_ALL
; 163  :         _CATCH_END

  000e7	b8 00 00 00 00	 mov	 eax, $LN9@Osfx
  000ec	c3		 ret	 0
$LN6@Osfx:
  000ed	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000f1	eb 04		 jmp	 SHORT $LN1@Osfx
$LN9@Osfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
  000f3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
$LN1@Osfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ostream

; 164  :     }

  000f7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000fa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00101	59		 pop	 ecx
  00102	5f		 pop	 edi
  00103	5e		 pop	 esi
  00104	5b		 pop	 ebx
  00105	c9		 leave
  00106	c3		 ret	 0
  00107	cc		 int	 3
  00108	cc		 int	 3
  00109	cc		 int	 3
  0010a	cc		 int	 3
  0010b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Osfx
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
;	COMDAT ??4?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@std@@QAEAAV01@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??4?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@std@@QAEAAV01@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z PROC ; std::ostream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 318  :     ostream_iterator& operator=(const _Ty& _Val) { // insert value into output stream, followed by delimiter

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  :         *_Myostr << _Val;

  00007	ff 75 08	 push	 DWORD PTR __Val$[ebp]
  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	ff 70 04	 push	 DWORD PTR [eax+4]
  00010	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx

; 320  :         if (_Mydelim) {

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001d	74 12		 je	 SHORT $LN2@operator

; 321  :             *_Myostr << _Mydelim;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	ff 30		 push	 DWORD PTR [eax]
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	ff 70 04	 push	 DWORD PTR [eax+4]
  0002a	e8 00 00 00 00	 call	 ??$?6_WU?$char_traits@_W@std@@@std@@YAAAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AAV10@PB_W@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@operator:

; 322  :         }
; 323  : 
; 324  :         return *this;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 325  :     }

  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??4?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@std@@QAEAAV01@ABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@@Z ENDP ; std::ostream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z
_TEXT	SEGMENT
$T2 = -104						; size = 4
$T3 = -100						; size = 4
$T4 = -96						; size = 4
$T5 = -92						; size = 4
__UDest$ = -88						; size = 4
_this$ = -84						; size = 4
_this$ = -80						; size = 4
$T6 = -74						; size = 1
$T7 = -73						; size = 1
__UFirst$ = -72						; size = 28
__ULast$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 28
__Last$ = 40						; size = 28
__Dest$ = 68						; size = 4
??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z PROC ; std::copy<std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>,std::back_insert_iterator<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >, COMDAT

; 4424 : _CONSTEXPR20 _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest) { // copy [_First, _Last) to [_Dest, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0002f	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00032	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
  00035	8d 45 10	 lea	 eax, DWORD PTR __First$[ebp+4]
  00038	50		 push	 eax
  00039	8d 4d bc	 lea	 ecx, DWORD PTR __UFirst$[ebp+4]
  0003c	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 4425 :     _Adl_verify_range(_First, _Last);
; 4426 :     const auto _UFirst = _Get_unwrapped(_First);

  00041	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00045	8b 45 28	 mov	 eax, DWORD PTR __Last$[ebp]
  00048	89 45 d4	 mov	 DWORD PTR __ULast$[ebp], eax
  0004b	8d 45 2c	 lea	 eax, DWORD PTR __Last$[ebp+4]
  0004e	50		 push	 eax
  0004f	8d 4d d8	 lea	 ecx, DWORD PTR __ULast$[ebp+4]
  00052	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 4427 :     const auto _ULast  = _Get_unwrapped(_Last);

  00057	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1559 :         return _Distance_unknown{};

  0005b	33 c0		 xor	 eax, eax
  0005d	88 45 b7	 mov	 BYTE PTR $T7[ebp], al

; 4428 :     const auto _UDest  = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  00060	8a 45 b7	 mov	 al, BYTE PTR $T7[ebp]
  00063	88 45 b6	 mov	 BYTE PTR $T6[ebp], al
  00066	8b 45 44	 mov	 eax, DWORD PTR __Dest$[ebp]
  00069	89 45 a8	 mov	 DWORD PTR __UDest$[ebp], eax

; 4429 :     _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));

  0006c	ff 75 a8	 push	 DWORD PTR __UDest$[ebp]
  0006f	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00072	8b c4		 mov	 eax, esp
  00074	89 65 a0	 mov	 DWORD PTR $T4[ebp], esp
  00077	89 45 b0	 mov	 DWORD PTR _this$[ebp], eax
  0007a	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 4d d4	 mov	 ecx, DWORD PTR __ULast$[ebp]
  00080	89 08		 mov	 DWORD PTR [eax], ecx
  00082	8d 45 d8	 lea	 eax, DWORD PTR __ULast$[ebp+4]
  00085	50		 push	 eax
  00086	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	83 c1 04	 add	 ecx, 4
  0008c	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  00091	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00095	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00098	8b c4		 mov	 eax, esp
  0009a	89 65 9c	 mov	 DWORD PTR $T3[ebp], esp
  0009d	89 45 ac	 mov	 DWORD PTR _this$[ebp], eax
  000a0	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  000a6	89 08		 mov	 DWORD PTR [eax], ecx
  000a8	8d 45 bc	 lea	 eax, DWORD PTR __UFirst$[ebp+4]
  000ab	50		 push	 eax
  000ac	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000af	83 c1 04	 add	 ecx, 4
  000b2	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000b7	8d 45 98	 lea	 eax, DWORD PTR $T2[ebp]
  000ba	50		 push	 eax
  000bb	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000bf	e8 00 00 00 00	 call	 ??$_Copy_unchecked@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z ; std::_Copy_unchecked<std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>,std::back_insert_iterator<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
  000c4	83 c4 40	 add	 esp, 64			; 00000040H
  000c7	89 45 a4	 mov	 DWORD PTR $T5[ebp], eax

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  000ca	8b 45 a4	 mov	 eax, DWORD PTR $T5[ebp]
  000cd	8b 00		 mov	 eax, DWORD PTR [eax]
  000cf	89 45 44	 mov	 DWORD PTR __Dest$[ebp], eax

; 4430 :     return _Dest;

  000d2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000d5	8b 4d 44	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000d8	89 08		 mov	 DWORD PTR [eax], ecx
  000da	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000de	8d 4d d8	 lea	 ecx, DWORD PTR __ULast$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000e1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4430 :     return _Dest;

  000e6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ea	8d 4d bc	 lea	 ecx, DWORD PTR __UFirst$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000ed	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4430 :     return _Dest;

  000f2	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000f6	8d 4d 10	 lea	 ecx, DWORD PTR __First$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000f9	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4430 :     return _Dest;

  000fe	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00102	8d 4d 2c	 lea	 ecx, DWORD PTR __Last$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00105	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 4430 :     return _Dest;

  0010a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4431 : }

  0010d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00110	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00117	59		 pop	 ecx
  00118	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011b	33 cd		 xor	 ecx, ebp
  0011d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00122	c9		 leave
  00123	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$0:
  00000	8d 4d 28	 lea	 ecx, DWORD PTR __Last$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$1:
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$2:
  00010	8d 4d b8	 lea	 ecx, DWORD PTR __UFirst$[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$3:
  00018	8d 4d d4	 lea	 ecx, DWORD PTR __ULast$[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
__unwindfunclet$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z$4:
  00020	8b 4d a0	 mov	 ecx, DWORD PTR $T4[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
__ehhandler$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z:
  0002d	90		 npad	 1
  0002e	90		 npad	 1
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z ENDP ; std::copy<std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>,std::back_insert_iterator<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 18		 push	 24			; 00000018H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 18	 imul	 eax, DWORD PTR __Count$[ebp], 24
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@II@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 18		 push	 24			; 00000018H
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 18	 imul	 eax, DWORD PTR __Count$[ebp], 24
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 18	 imul	 eax, DWORD PTR __Newsize$[ebp], 24
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 18	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 24
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@II@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABEII@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 18		 push	 24			; 00000018H
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 aa aa
	aa 0a		 mov	 DWORD PTR $T7[ebp], 178956970 ; 0aaaaaaaH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@ABEII@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@YAXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@QAV10@AAV?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@0@Z ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z PROC ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 18	 imul	 eax, DWORD PTR __Count$[ebp], 24
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@QAEXQAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@I@Z ENDP ; std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ PROC ; std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>::~istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4

; 2801 :         _Tidy_deallocate();

  0000d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
  00012	c9		 leave
  00013	c3		 ret	 0
??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ ENDP ; std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>::~istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
;	COMDAT ?_Getval@?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
tv89 = -1						; size = 1
?_Getval@?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@AAEXXZ PROC ; std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>::_Getval, COMDAT
; _this$ = ecx

; 278  :     void _Getval() { // get a _Ty value if possible

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 280  :         if (!(*_Myistr >> _Myval)) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	50		 push	 eax
  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	ff 30		 push	 DWORD PTR [eax]
  00015	e8 00 00 00 00	 call	 ??$?5_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YAAAV?$basic_istream@_WU?$char_traits@_W@std@@@0@AAV10@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@@Z ; std::operator>><wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0001a	59		 pop	 ecx
  0001b	59		 pop	 ecx
  0001c	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  0001f	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00022	8b 00		 mov	 eax, DWORD PTR [eax]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  0002a	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  0002e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 303  :         return rdstate() & (ios_base::badbit | ios_base::failbit);

  00031	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00034	83 e0 06	 and	 eax, 6
  00037	74 06		 je	 SHORT $LN8@Getval
  00039	c6 45 ff 01	 mov	 BYTE PTR tv89[ebp], 1
  0003d	eb 04		 jmp	 SHORT $LN4@Getval
$LN8@Getval:
  0003f	c6 45 ff 00	 mov	 BYTE PTR tv89[ebp], 0
$LN4@Getval:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator

; 280  :         if (!(*_Myistr >> _Myval)) {

  00043	0f b6 45 ff	 movzx	 eax, BYTE PTR tv89[ebp]
  00047	85 c0		 test	 eax, eax
  00049	74 06		 je	 SHORT $LN1@Getval

; 281  :             _Myistr = nullptr;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 20 00	 and	 DWORD PTR [eax], 0
$LN1@Getval:

; 282  :         }
; 283  :     }

  00051	c9		 leave
  00052	c3		 ret	 0
?_Getval@?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@AAEXXZ ENDP ; std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>::_Getval
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
;	COMDAT ??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	83 c1 70	 add	 ecx, 112		; 00000070H
  0002d	e8 00 00 00 00	 call	 ??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >
  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 c0 70	 add	 eax, 112		; 00000070H
  00038	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 38   :     virtual __CLR_OR_THIS_CALL ~basic_ios() noexcept {}

  0003b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 451  :     virtual __CLR_OR_THIS_CALL ~ios_base() noexcept {

  00044	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 452  :         _Ios_base_dtor(this);

  00051	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00059	59		 pop	 ecx

; 453  :     }

  0005a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00068	59		 pop	 ecx
  00069	c9		 leave
  0006a	c3		 ret	 0
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
  0006e	cc		 int	 3
  0006f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Odspy
;	COMDAT ??_G?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 e9 70	 sub	 ecx, 112		; 00000070H
  0000d	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00012	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	74 13		 je	 SHORT $LN2@scalar
  0001a	68 b8 00 00 00	 push	 184			; 000000b8H
  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 e8 70	 sub	 eax, 112		; 00000070H
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 e8 70	 sub	 eax, 112		; 00000070H
  00033	c9		 leave
  00034	c2 04 00	 ret	 4
??_G?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 58		 push	 88			; 00000058H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
__Next$ = -8						; size = 4
_this$ = -4						; size = 4
?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Set_back, COMDAT
; _this$ = ecx

; 779  :     void _Set_back() { // set up putback area

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 181  :         return *_IGfirst;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 780  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 c0 3c	 add	 eax, 60			; 0000003cH
  0001a	39 45 f4	 cmp	 DWORD PTR $T2[ebp], eax
  0001d	74 2d		 je	 SHORT $LN2@Set_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 181  :         return *_IGfirst;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00025	8b 00		 mov	 eax, DWORD PTR [eax]
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 781  :             _Set_eback = _Mysb::eback();

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00030	89 48 50	 mov	 DWORD PTR [eax+80], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 197  :         return *_IGnext + *_IGcount;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00041	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00043	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 782  :             _Set_egptr = _Mysb::egptr();

  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	89 41 54	 mov	 DWORD PTR [ecx+84], eax
$LN2@Set_back:

; 784  :         _Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 c0 3c	 add	 eax, 60			; 0000003cH
  00052	89 45 f8	 mov	 DWORD PTR __Next$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 206  :         *_IGfirst = _First;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 784  :         _Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 3c	 add	 ecx, 60			; 0000003cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 206  :         *_IGfirst = _First;

  00061	89 08		 mov	 DWORD PTR [eax], ecx

; 207  :         *_IGnext  = _Next;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00069	8b 4d f8	 mov	 ecx, DWORD PTR __Next$[ebp]
  0006c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 784  :         _Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 c0 3e	 add	 eax, 62			; 0000003eH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  00074	2b 45 f8	 sub	 eax, DWORD PTR __Next$[ebp]
  00077	d1 f8		 sar	 eax, 1
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  0007f	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 785  :     }

  00081	c9		 leave
  00082	c3		 ret	 0
?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Last$ = -20						; size = 4
__First$ = -16						; size = 4
$T1 = -12						; size = 4
__Next$ = -8						; size = 4
_this$ = -4						; size = 4
?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back, COMDAT
; _this$ = ecx

; 773  :     void _Reset_back() { // restore buffer after putback

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 181  :         return *_IGfirst;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 774  :         if (_Mysb::eback() == &_Mychar) {

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 c0 3c	 add	 eax, 60			; 0000003cH
  0001a	39 45 f4	 cmp	 DWORD PTR $T1[ebp], eax
  0001d	75 41		 jne	 SHORT $LN1@Reset_back

; 775  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  00025	89 45 ec	 mov	 DWORD PTR __Last$[ebp], eax
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  0002e	89 45 f8	 mov	 DWORD PTR __Next$[ebp], eax
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00037	89 45 f0	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 206  :         *_IGfirst = _First;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR __First$[ebp]
  00043	89 08		 mov	 DWORD PTR [eax], ecx

; 207  :         *_IGnext  = _Next;

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Next$[ebp]
  0004e	89 08		 mov	 DWORD PTR [eax], ecx

; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  00050	8b 45 ec	 mov	 eax, DWORD PTR __Last$[ebp]
  00053	2b 45 f8	 sub	 eax, DWORD PTR __Next$[ebp]
  00056	d1 f8		 sar	 eax, 1
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  0005e	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Reset_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 777  :     }

  00060	c9		 leave
  00061	c3		 ret	 0
?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXABV?$codecvt@_WDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
__Newcvt$ = 8						; size = 4
?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXABV?$codecvt@_WDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Initcvt, COMDAT
; _this$ = ecx

; 756  :     void _Initcvt(const _Cvt& _Newcvt) { // initialize codecvt pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 632  :         return do_always_noconv();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Newcvt$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Newcvt$[ebp]
  00011	ff 50 0c	 call	 DWORD PTR [eax+12]
  00014	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 757  :         if (_Newcvt.always_noconv()) {

  00017	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  0001b	85 c0		 test	 eax, eax
  0001d	74 09		 je	 SHORT $LN2@Initcvt

; 758  :             _Pcvt = nullptr; // nothing to do

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 60 38 00	 and	 DWORD PTR [eax+56], 0

; 759  :         } else { // set up for nontrivial codecvt facet

  00026	eb 17		 jmp	 SHORT $LN1@Initcvt
$LN2@Initcvt:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00028	8b 45 08	 mov	 eax, DWORD PTR __Newcvt$[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 760  :             _Pcvt = _STD addressof(_Newcvt);

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00034	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 761  :             _Mysb::_Init(); // reset any buffering

  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init
$LN1@Initcvt:

; 762  :         }
; 763  :     }

  0003f	c9		 leave
  00040	c2 04 00	 ret	 4
?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXABV?$codecvt@_WDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ
_TEXT	SEGMENT
__Codecvt_temp_buf$ = -84				; size = 4
__Dest$ = -80						; size = 4
$T1 = -76						; size = 2
tv140 = -72						; size = 4
_this$ = -68						; size = 4
tv148 = -64						; size = 4
__Count$2 = -60						; size = 4
tv94 = -56						; size = 4
$T3 = -50						; size = 2
$T4 = -48						; size = 2
$T5 = -45						; size = 1
_this$ = -44						; size = 4
__Str$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite, COMDAT
; _this$ = ecx

; 720  :     bool _Endwrite() { // put shift to initial conversion state, as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 721  :         if (!_Pcvt || !_Wrotesome) {

  00013	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0001a	74 0b		 je	 SHORT $LN5@Endwrite
  0001c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	0f b6 40 3e	 movzx	 eax, BYTE PTR [eax+62]
  00023	85 c0		 test	 eax, eax
  00025	75 07		 jne	 SHORT $LN4@Endwrite
$LN5@Endwrite:

; 722  :             return true;

  00027	b0 01		 mov	 al, 1
  00029	e9 f5 00 00 00	 jmp	 $LN1@Endwrite
$LN4@Endwrite:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0002e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00033	66 89 45 b4	 mov	 WORD PTR $T1[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 726  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00037	ff 75 b4	 push	 DWORD PTR $T1[ebp]
  0003a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	ff 50 0c	 call	 DWORD PTR [eax+12]
  00045	66 89 45 ce	 mov	 WORD PTR $T3[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00049	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0004e	66 89 45 d0	 mov	 WORD PTR $T4[ebp], ax

; 301  :         return _Left == _Right;

  00052	0f b7 45 d0	 movzx	 eax, WORD PTR $T4[ebp]
  00056	0f b7 4d ce	 movzx	 ecx, WORD PTR $T3[ebp]
  0005a	3b c1		 cmp	 eax, ecx
  0005c	75 09		 jne	 SHORT $LN23@Endwrite
  0005e	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR tv148[ebp], 1
  00065	eb 04		 jmp	 SHORT $LN24@Endwrite
$LN23@Endwrite:
  00067	83 65 c0 00	 and	 DWORD PTR tv148[ebp], 0
$LN24@Endwrite:
  0006b	8a 45 c0	 mov	 al, BYTE PTR tv148[ebp]
  0006e	88 45 d3	 mov	 BYTE PTR $T5[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 726  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

  00071	0f b6 45 d3	 movzx	 eax, BYTE PTR $T5[ebp]
  00075	85 c0		 test	 eax, eax
  00077	74 07		 je	 SHORT $LN6@Endwrite

; 727  :             return false;

  00079	32 c0		 xor	 al, al
  0007b	e9 a3 00 00 00	 jmp	 $LN1@Endwrite
$LN6@Endwrite:

; 728  :         }
; 729  : 
; 730  :         constexpr size_t _Codecvt_temp_buf = 32;

  00080	c7 45 ac 20 00
	00 00		 mov	 DWORD PTR __Codecvt_temp_buf$[ebp], 32 ; 00000020H

; 733  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  00087	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0008d	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1947 :         return do_unshift(_State, _First2, _Last2, _Mid2);

  00090	8d 45 b0	 lea	 eax, DWORD PTR __Dest$[ebp]
  00093	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 733  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  00094	8d 45 f8	 lea	 eax, DWORD PTR __Str$[ebp+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1947 :         return do_unshift(_State, _First2, _Last2, _Mid2);

  00097	50		 push	 eax
  00098	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]
  0009b	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 733  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  0009c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	83 c0 40	 add	 eax, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1947 :         return do_unshift(_State, _First2, _Last2, _Mid2);

  000a2	50		 push	 eax
  000a3	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	ff 50 20	 call	 DWORD PTR [eax+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 733  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

  000ae	89 45 c8	 mov	 DWORD PTR tv94[ebp], eax
  000b1	83 7d c8 00	 cmp	 DWORD PTR tv94[ebp], 0
  000b5	74 0e		 je	 SHORT $LN7@Endwrite
  000b7	83 7d c8 01	 cmp	 DWORD PTR tv94[ebp], 1
  000bb	74 0f		 je	 SHORT $LN8@Endwrite
  000bd	83 7d c8 03	 cmp	 DWORD PTR tv94[ebp], 3
  000c1	74 53		 je	 SHORT $LN10@Endwrite
  000c3	eb 5c		 jmp	 SHORT $LN11@Endwrite
$LN7@Endwrite:

; 734  :         case codecvt_base::ok:
; 735  :             _Wrotesome = false; // homed successfully

  000c5	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	c6 40 3e 00	 mov	 BYTE PTR [eax+62], 0
$LN8@Endwrite:

; 736  : 
; 737  :         case codecvt_base::partial: // fall through
; 738  :         { // put any generated bytes
; 739  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

  000cc	8b 45 b0	 mov	 eax, DWORD PTR __Dest$[ebp]
  000cf	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  000d2	2b c1		 sub	 eax, ecx
  000d4	89 45 c4	 mov	 DWORD PTR __Count$2[ebp], eax

; 740  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  000d7	74 20		 je	 SHORT $LN9@Endwrite
  000d9	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	ff 70 4c	 push	 DWORD PTR [eax+76]
  000df	ff 75 c4	 push	 DWORD PTR __Count$2[ebp]
  000e2	6a 01		 push	 1
  000e4	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]
  000e7	50		 push	 eax
  000e8	e8 00 00 00 00	 call	 _fwrite
  000ed	83 c4 10	 add	 esp, 16			; 00000010H
  000f0	39 45 c4	 cmp	 DWORD PTR __Count$2[ebp], eax
  000f3	74 04		 je	 SHORT $LN9@Endwrite

; 741  :                 return false; // write failed

  000f5	32 c0		 xor	 al, al
  000f7	eb 2a		 jmp	 SHORT $LN1@Endwrite
$LN9@Endwrite:

; 742  :             }
; 743  : 
; 744  :             return !_Wrotesome;

  000f9	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	0f b6 40 3e	 movzx	 eax, BYTE PTR [eax+62]
  00100	85 c0		 test	 eax, eax
  00102	75 09		 jne	 SHORT $LN13@Endwrite
  00104	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv140[ebp], 1
  0010b	eb 04		 jmp	 SHORT $LN14@Endwrite
$LN13@Endwrite:
  0010d	83 65 b8 00	 and	 DWORD PTR tv140[ebp], 0
$LN14@Endwrite:
  00111	8a 45 b8	 mov	 al, BYTE PTR tv140[ebp]
  00114	eb 0d		 jmp	 SHORT $LN1@Endwrite
$LN10@Endwrite:

; 745  :         }
; 746  : 
; 747  :         case codecvt_base::noconv:
; 748  :             _Wrotesome = false; // homed successfully

  00116	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00119	c6 40 3e 00	 mov	 BYTE PTR [eax+62], 0

; 749  :             return true; // nothing else to do

  0011d	b0 01		 mov	 al, 1
  0011f	eb 02		 jmp	 SHORT $LN1@Endwrite
$LN11@Endwrite:

; 750  : 
; 751  :         default:
; 752  :             return false; // conversion failed

  00121	32 c0		 xor	 al, al
$LN1@Endwrite:

; 753  :         }
; 754  :     }

  00123	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00126	33 cd		 xor	 ecx, ebp
  00128	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012d	c9		 leave
  0012e	c3		 ret	 0
?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
__Nw$1 = -44						; size = 4
__Gc$ = -40						; size = 4
__Pn$ = -36						; size = 4
__Gn$ = -32						; size = 4
__Pf$ = -28						; size = 4
__Gf$ = -24						; size = 4
tv66 = -20						; size = 4
__Pb$2 = -16						; size = 4
__Pn$3 = -12						; size = 4
__Nr$4 = -8						; size = 4
_this$ = -4						; size = 4
__File$ = 8						; size = 4
__Which$ = 12						; size = 4
?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 693  :     void _Init(FILE* _File, _Initfl _Which) { // initialize to C stream _File after {new, open, close}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 694  :         using _State_type = typename _Traits::state_type;
; 695  : 
; 696  :         __PURE_APPDOMAIN_GLOBAL static _State_type _Stinit; // initial state
; 697  : 
; 698  :         _Closef    = _Which == _Openfl;

  00009	83 7d 0c 01	 cmp	 DWORD PTR __Which$[ebp], 1
  0000d	75 09		 jne	 SHORT $LN4@Init
  0000f	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00016	eb 04		 jmp	 SHORT $LN5@Init
$LN4@Init:
  00018	83 65 ec 00	 and	 DWORD PTR tv66[ebp], 0
$LN5@Init:
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8a 4d ec	 mov	 cl, BYTE PTR tv66[ebp]
  00022	88 48 48	 mov	 BYTE PTR [eax+72], cl

; 699  :         _Wrotesome = false;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c6 40 3e 00	 mov	 BYTE PTR [eax+62], 0

; 700  : 
; 701  :         _Mysb::_Init(); // initialize stream buffer base object

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init

; 702  : 
; 703  :         if (_File && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

  00034	83 7d 08 00	 cmp	 DWORD PTR __File$[ebp], 0
  00038	0f 84 81 00 00
	00		 je	 $LN2@Init
  0003e	33 c0		 xor	 eax, eax
  00040	74 7d		 je	 SHORT $LN2@Init

; 704  :             _Elem** _Pb = nullptr;

  00042	83 65 f0 00	 and	 DWORD PTR __Pb$2[ebp], 0

; 705  :             _Elem** _Pn = nullptr;

  00046	83 65 f4 00	 and	 DWORD PTR __Pn$3[ebp], 0

; 706  :             int* _Nr    = nullptr;

  0004a	83 65 f8 00	 and	 DWORD PTR __Nr$4[ebp], 0

; 707  : 
; 708  :             ::_get_stream_buffer_pointers(

  0004e	8d 45 f8	 lea	 eax, DWORD PTR __Nr$4[ebp]
  00051	50		 push	 eax
  00052	8d 45 f4	 lea	 eax, DWORD PTR __Pn$3[ebp]
  00055	50		 push	 eax
  00056	8d 45 f0	 lea	 eax, DWORD PTR __Pb$2[ebp]
  00059	50		 push	 eax
  0005a	ff 75 08	 push	 DWORD PTR __File$[ebp]
  0005d	e8 00 00 00 00	 call	 __get_stream_buffer_pointers
  00062	83 c4 10	 add	 esp, 16			; 00000010H

; 709  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 710  :             int* _Nw = _Nr;

  00065	8b 45 f8	 mov	 eax, DWORD PTR __Nr$4[ebp]
  00068	89 45 d4	 mov	 DWORD PTR __Nw$1[ebp], eax

; 711  : 
; 712  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);

  0006b	8b 45 f4	 mov	 eax, DWORD PTR __Pn$3[ebp]
  0006e	89 45 dc	 mov	 DWORD PTR __Pn$[ebp], eax
  00071	8b 45 f0	 mov	 eax, DWORD PTR __Pb$2[ebp]
  00074	89 45 e4	 mov	 DWORD PTR __Pf$[ebp], eax
  00077	8b 45 f8	 mov	 eax, DWORD PTR __Nr$4[ebp]
  0007a	89 45 d8	 mov	 DWORD PTR __Gc$[ebp], eax
  0007d	8b 45 f4	 mov	 eax, DWORD PTR __Pn$3[ebp]
  00080	89 45 e0	 mov	 DWORD PTR __Gn$[ebp], eax
  00083	8b 45 f0	 mov	 eax, DWORD PTR __Pb$2[ebp]
  00086	89 45 e8	 mov	 DWORD PTR __Gf$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 274  :         _IGfirst = _Gf;

  00089	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d e8	 mov	 ecx, DWORD PTR __Gf$[ebp]
  0008f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 275  :         _IPfirst = _Pf;

  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 4d e4	 mov	 ecx, DWORD PTR __Pf$[ebp]
  00098	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 276  :         _IGnext  = _Gn;

  0009b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 4d e0	 mov	 ecx, DWORD PTR __Gn$[ebp]
  000a1	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 277  :         _IPnext  = _Pn;

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8b 4d dc	 mov	 ecx, DWORD PTR __Pn$[ebp]
  000aa	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 278  :         _IGcount = _Gc;

  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 4d d8	 mov	 ecx, DWORD PTR __Gc$[ebp]
  000b3	89 48 2c	 mov	 DWORD PTR [eax+44], ecx

; 279  :         _IPcount = _Pc;

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d d4	 mov	 ecx, DWORD PTR __Nw$1[ebp]
  000bc	89 48 30	 mov	 DWORD PTR [eax+48], ecx
$LN2@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 715  :         _Myfile = _File;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 4d 08	 mov	 ecx, DWORD PTR __File$[ebp]
  000c5	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 716  :         _State  = _Stinit;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
  000d1	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A+4
  000d7	89 48 40	 mov	 DWORD PTR [eax+64], ecx
  000da	89 50 44	 mov	 DWORD PTR [eax+68], edx

; 717  :         _Pcvt   = nullptr; // pointer to codecvt facet

  000dd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	83 60 38 00	 and	 DWORD PTR [eax+56], 0

; 718  :     }

  000e4	c9		 leave
  000e5	c2 08 00	 ret	 8
?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Loc$ = 8						; size = 4
?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::imbue, COMDAT
; _this$ = ecx

; 688  :     virtual void __CLR_OR_THIS_CALL imbue(const locale& _Loc) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 689  :         // set locale to argument (capture nontrivial codecvt facet)
; 690  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

  00007	ff 75 08	 push	 DWORD PTR __Loc$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >
  0000f	59		 pop	 ecx
  00010	50		 push	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXABV?$codecvt@_WDU_Mbstatet@@@2@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Initcvt

; 691  :     }

  00019	c9		 leave
  0001a	c2 04 00	 ret	 4
?imbue@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::imbue
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
_TEXT	SEGMENT
$T1 = -20						; size = 2
tv88 = -16						; size = 4
_this$ = -12						; size = 4
$T2 = -6						; size = 2
$T3 = -4						; size = 2
$T4 = -1						; size = 1
?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::sync, COMDAT
; _this$ = ecx

; 680  :     virtual int __CLR_OR_THIS_CALL sync() override { // synchronize C stream with external file

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 681  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00010	74 5b		 je	 SHORT $LN3@sync
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00012	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00017	66 89 45 ec	 mov	 WORD PTR $T1[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 681  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  0001b	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	ff 50 0c	 call	 DWORD PTR [eax+12]
  00029	66 89 45 fa	 mov	 WORD PTR $T2[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0002d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00032	66 89 45 fc	 mov	 WORD PTR $T3[ebp], ax

; 301  :         return _Left == _Right;

  00036	0f b7 45 fc	 movzx	 eax, WORD PTR $T3[ebp]
  0003a	0f b7 4d fa	 movzx	 ecx, WORD PTR $T2[ebp]
  0003e	3b c1		 cmp	 eax, ecx
  00040	75 09		 jne	 SHORT $LN13@sync
  00042	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  00049	eb 04		 jmp	 SHORT $LN14@sync
$LN13@sync:
  0004b	83 65 f0 00	 and	 DWORD PTR tv88[ebp], 0
$LN14@sync:
  0004f	8a 45 f0	 mov	 al, BYTE PTR tv88[ebp]
  00052	88 45 ff	 mov	 BYTE PTR $T4[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 681  :         if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)) {

  00055	0f b6 45 ff	 movzx	 eax, BYTE PTR $T4[ebp]
  00059	85 c0		 test	 eax, eax
  0005b	75 10		 jne	 SHORT $LN3@sync
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00060	ff 70 4c	 push	 DWORD PTR [eax+76]
  00063	e8 00 00 00 00	 call	 _fflush
  00068	59		 pop	 ecx
  00069	85 c0		 test	 eax, eax
  0006b	7c 04		 jl	 SHORT $LN2@sync
$LN3@sync:

; 682  :             return 0;

  0006d	33 c0		 xor	 eax, eax
  0006f	eb 03		 jmp	 SHORT $LN1@sync
$LN2@sync:

; 683  :         }
; 684  : 
; 685  :         return -1;

  00071	83 c8 ff	 or	 eax, -1
$LN1@sync:

; 686  :     }

  00074	c9		 leave
  00075	c3		 ret	 0
?sync@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::sync
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z
_TEXT	SEGMENT
__Size$ = -12						; size = 4
__Mode$ = -8						; size = 4
_this$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Count$ = 12						; size = 8
?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::setbuf, COMDAT
; _this$ = ecx

; 661  :     virtual _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) override { // offer _Buffer to C stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 662  :         int _Mode;
; 663  :         if (!_Buffer && _Count == 0) {

  00009	83 7d 08 00	 cmp	 DWORD PTR __Buffer$[ebp], 0
  0000d	75 11		 jne	 SHORT $LN2@setbuf
  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00012	0b 45 10	 or	 eax, DWORD PTR __Count$[ebp+4]
  00015	75 09		 jne	 SHORT $LN2@setbuf

; 664  :             _Mode = _IONBF;

  00017	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR __Mode$[ebp], 4

; 665  :         } else {

  0001e	eb 04		 jmp	 SHORT $LN3@setbuf
$LN2@setbuf:

; 666  :             _Mode = _IOFBF;

  00020	83 65 f8 00	 and	 DWORD PTR __Mode$[ebp], 0
$LN3@setbuf:

; 667  :         }
; 668  : 
; 669  :         const size_t _Size = static_cast<size_t>(_Count) * sizeof(_Elem);

  00024	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00027	d1 e0		 shl	 eax, 1
  00029	89 45 f4	 mov	 DWORD PTR __Size$[ebp], eax

; 670  : 
; 671  :         if (!_Myfile || _CSTD setvbuf(_Myfile, reinterpret_cast<char*>(_Buffer), _Mode, _Size) != 0) {

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00033	74 1b		 je	 SHORT $LN5@setbuf
  00035	ff 75 f4	 push	 DWORD PTR __Size$[ebp]
  00038	ff 75 f8	 push	 DWORD PTR __Mode$[ebp]
  0003b	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	ff 70 4c	 push	 DWORD PTR [eax+76]
  00044	e8 00 00 00 00	 call	 _setvbuf
  00049	83 c4 10	 add	 esp, 16			; 00000010H
  0004c	85 c0		 test	 eax, eax
  0004e	74 04		 je	 SHORT $LN4@setbuf
$LN5@setbuf:

; 672  :             return nullptr; // failed

  00050	33 c0		 xor	 eax, eax
  00052	eb 13		 jmp	 SHORT $LN1@setbuf
$LN4@setbuf:

; 673  :         }
; 674  : 
; 675  :         // new buffer, reinitialize pointers
; 676  :         _Init(_Myfile, _Openfl);

  00054	6a 01		 push	 1
  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	ff 70 4c	 push	 DWORD PTR [eax+76]
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init

; 677  :         return this;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@setbuf:

; 678  :     }

  00067	c9		 leave
  00068	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@PA_W_J@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::setbuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
__State$ = -36						; size = 8
__Fileposition$ = -28					; size = 8
$T1 = -20						; size = 8
__Off$ = -12						; size = 8
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Pos$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 648  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd

; 70   :         return _Myoff + _Fpos;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Pos$[ebp]
  0000c	03 45 14	 add	 eax, DWORD PTR __Pos$[ebp+8]
  0000f	8b 4d 10	 mov	 ecx, DWORD PTR __Pos$[ebp+4]
  00012	13 4d 18	 adc	 ecx, DWORD PTR __Pos$[ebp+12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 650  :         off_type _Off = static_cast<off_type>(_Pos);

  00015	89 45 f4	 mov	 DWORD PTR __Off$[ebp], eax
  00018	89 4d f8	 mov	 DWORD PTR __Off$[ebp+4], ecx

; 651  : 
; 652  :         if (!_Myfile || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00022	74 24		 je	 SHORT $LN3@seekpos
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
  0002c	0f b6 c0	 movzx	 eax, al
  0002f	85 c0		 test	 eax, eax
  00031	74 15		 je	 SHORT $LN3@seekpos
  00033	8d 45 f4	 lea	 eax, DWORD PTR __Off$[ebp]
  00036	50		 push	 eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	ff 70 4c	 push	 DWORD PTR [eax+76]
  0003d	e8 00 00 00 00	 call	 _fsetpos
  00042	59		 pop	 ecx
  00043	59		 pop	 ecx
  00044	85 c0		 test	 eax, eax
  00046	74 2b		 je	 SHORT $LN2@seekpos
$LN3@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00048	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004b	83 c9 ff	 or	 ecx, -1
  0004e	83 08 ff	 or	 DWORD PTR [eax], -1
  00051	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00054	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00057	33 c9		 xor	 ecx, ecx
  00059	33 d2		 xor	 edx, edx
  0005b	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0005e	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00061	33 c0		 xor	 eax, eax
  00063	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00066	83 c1 10	 add	 ecx, 16			; 00000010H
  00069	89 01		 mov	 DWORD PTR [ecx], eax
  0006b	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 653  :             return pos_type(-1); // report failure

  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00071	eb 6b		 jmp	 SHORT $LN1@seekpos
$LN2@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd

; 60   :         return _Mystate;

  00073	8b 45 1c	 mov	 eax, DWORD PTR __Pos$[ebp+16]
  00076	8b 4d 20	 mov	 ecx, DWORD PTR __Pos$[ebp+20]
  00079	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
  0007c	89 4d f0	 mov	 DWORD PTR $T1[ebp+4], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 656  :         _State = _Pos.state();

  0007f	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00082	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp+4]
  00085	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00088	89 42 40	 mov	 DWORD PTR [edx+64], eax
  0008b	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 657  :         _Reset_back(); // revert from _Mychar buffer, discarding any putback

  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back

; 658  :         return pos_type(_State, _Off); // return new position

  00096	8b 45 f4	 mov	 eax, DWORD PTR __Off$[ebp]
  00099	8b 4d f8	 mov	 ecx, DWORD PTR __Off$[ebp+4]
  0009c	89 45 e4	 mov	 DWORD PTR __Fileposition$[ebp], eax
  0009f	89 4d e8	 mov	 DWORD PTR __Fileposition$[ebp+4], ecx
  000a2	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000a8	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  000ab	89 4d dc	 mov	 DWORD PTR __State$[ebp], ecx
  000ae	89 45 e0	 mov	 DWORD PTR __State$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  000b1	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000b4	8b 4d e4	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  000b7	8b 55 e8	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  000ba	89 08		 mov	 DWORD PTR [eax], ecx
  000bc	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000bf	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c2	33 c9		 xor	 ecx, ecx
  000c4	33 d2		 xor	 edx, edx
  000c6	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000c9	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000cc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000cf	8b 4d dc	 mov	 ecx, DWORD PTR __State$[ebp]
  000d2	8b 55 e0	 mov	 edx, DWORD PTR __State$[ebp+4]
  000d5	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000d8	89 50 14	 mov	 DWORD PTR [eax+20], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 658  :         return pos_type(_State, _Off); // return new position

  000db	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@seekpos:

; 659  :     }

  000de	c9		 leave
  000df	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
__Fileposition$ = -32					; size = 8
__State$ = -24						; size = 8
__Fileposition$ = -16					; size = 8
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 628  :         ios_base::openmode = ios_base::in | ios_base::out) override { // change position by _Off

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 633  :             && !_Pcvt) { // not converting

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 c0 3c	 add	 eax, 60			; 0000003cH
  0001a	39 45 f8	 cmp	 DWORD PTR $T1[ebp], eax
  0001d	75 21		 jne	 SHORT $LN2@seekoff
  0001f	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  00023	75 1b		 jne	 SHORT $LN2@seekoff
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0002c	75 12		 jne	 SHORT $LN2@seekoff

; 634  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00031	83 e8 02	 sub	 eax, 2
  00034	8b 4d 10	 mov	 ecx, DWORD PTR __Off$[ebp+4]
  00037	83 d9 00	 sbb	 ecx, 0
  0003a	89 45 0c	 mov	 DWORD PTR __Off$[ebp], eax
  0003d	89 4d 10	 mov	 DWORD PTR __Off$[ebp+4], ecx
$LN2@seekoff:

; 635  :         }
; 636  : 
; 637  :         if (!_Myfile || !_Endwrite()
; 638  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 639  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00047	74 4d		 je	 SHORT $LN4@seekoff
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
  00051	0f b6 c0	 movzx	 eax, al
  00054	85 c0		 test	 eax, eax
  00056	74 3e		 je	 SHORT $LN4@seekoff
  00058	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  0005b	0b 45 10	 or	 eax, DWORD PTR __Off$[ebp+4]
  0005e	75 06		 jne	 SHORT $LN6@seekoff
  00060	83 7d 14 01	 cmp	 DWORD PTR __Way$[ebp], 1
  00064	74 1b		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  00066	ff 75 14	 push	 DWORD PTR __Way$[ebp]
  00069	ff 75 10	 push	 DWORD PTR __Off$[ebp+4]
  0006c	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	ff 70 4c	 push	 DWORD PTR [eax+76]
  00075	e8 00 00 00 00	 call	 __fseeki64
  0007a	83 c4 10	 add	 esp, 16			; 00000010H
  0007d	85 c0		 test	 eax, eax
  0007f	75 15		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  00081	8d 45 e0	 lea	 eax, DWORD PTR __Fileposition$[ebp]
  00084	50		 push	 eax
  00085	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00088	ff 70 4c	 push	 DWORD PTR [eax+76]
  0008b	e8 00 00 00 00	 call	 _fgetpos
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
  00092	85 c0		 test	 eax, eax
  00094	74 2b		 je	 SHORT $LN3@seekoff
$LN4@seekoff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00096	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00099	83 c9 ff	 or	 ecx, -1
  0009c	83 08 ff	 or	 DWORD PTR [eax], -1
  0009f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000a2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000a5	33 c9		 xor	 ecx, ecx
  000a7	33 d2		 xor	 edx, edx
  000a9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000ac	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000af	33 c0		 xor	 eax, eax
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b4	83 c1 10	 add	 ecx, 16			; 00000010H
  000b7	89 01		 mov	 DWORD PTR [ecx], eax
  000b9	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 640  :             return pos_type(-1); // report failure

  000bc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000bf	eb 50		 jmp	 SHORT $LN1@seekoff
$LN3@seekoff:

; 641  :         }
; 642  : 
; 643  :         _Reset_back(); // revert from _Mychar buffer, discarding any putback

  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back

; 644  :         return pos_type(_State, _Fileposition); // return new position

  000c9	8b 45 e0	 mov	 eax, DWORD PTR __Fileposition$[ebp]
  000cc	8b 4d e4	 mov	 ecx, DWORD PTR __Fileposition$[ebp+4]
  000cf	89 45 f0	 mov	 DWORD PTR __Fileposition$[ebp], eax
  000d2	89 4d f4	 mov	 DWORD PTR __Fileposition$[ebp+4], ecx
  000d5	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  000db	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  000de	89 4d e8	 mov	 DWORD PTR __State$[ebp], ecx
  000e1	89 45 ec	 mov	 DWORD PTR __State$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd

; 57   :     fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) {}

  000e4	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000e7	8b 4d f0	 mov	 ecx, DWORD PTR __Fileposition$[ebp]
  000ea	8b 55 f4	 mov	 edx, DWORD PTR __Fileposition$[ebp+4]
  000ed	89 08		 mov	 DWORD PTR [eax], ecx
  000ef	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000f2	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000f5	33 c9		 xor	 ecx, ecx
  000f7	33 d2		 xor	 edx, edx
  000f9	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000fc	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  000ff	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00102	8b 4d e8	 mov	 ecx, DWORD PTR __State$[ebp]
  00105	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp+4]
  00108	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  0010b	89 50 14	 mov	 DWORD PTR [eax+20], edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 644  :         return pos_type(_State, _Fileposition); // return new position

  0010e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@seekoff:

; 645  :     }

  00111	c9		 leave
  00112	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?xsputn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsputn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::xsputn, COMDAT
; _this$ = ecx

; 596  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 597  :         // put _Count characters to stream
; 598  :         if _CONSTEXPR_IF (sizeof(_Elem) == 1) {
; 599  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing
; 600  :                 return _Mysb::xsputn(_Ptr, _Count);
; 601  :             }
; 602  : 
; 603  :             const streamsize _Start_count = _Count;
; 604  :             streamsize _Size              = _Mysb::_Pnavail();
; 605  :             if (0 < _Count && 0 < _Size) { // copy to write buffer
; 606  :                 if (_Count < _Size) {
; 607  :                     _Size = _Count;
; 608  :                 }
; 609  : 
; 610  :                 _Traits::copy(_Mysb::pptr(), _Ptr, static_cast<size_t>(_Size));
; 611  :                 _Ptr += _Size;
; 612  :                 _Count -= _Size;
; 613  :                 _Mysb::pbump(static_cast<int>(_Size));
; 614  :             }
; 615  : 
; 616  :             if (0 < _Count && _Myfile) { // open C stream, attempt write
; 617  :                 _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);
; 618  :             }
; 619  : 
; 620  :             return _Start_count - _Count;
; 621  :         } else { // non-chars always get element-by-element processing
; 622  :             return _Mysb::xsputn(_Ptr, _Count);

  00007	ff 75 10	 push	 DWORD PTR __Count$[ebp+4]
  0000a	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn

; 623  :         }
; 624  :     }

  00018	c9		 leave
  00019	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::xsputn
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?xsgetn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::xsgetn, COMDAT
; _this$ = ecx

; 548  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 549  :         // get _Count characters from stream
; 550  :         if _CONSTEXPR_IF (sizeof(_Elem) == 1) {
; 551  :             if (_Count <= 0) {
; 552  :                 return 0;
; 553  :             }
; 554  : 
; 555  :             if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing
; 556  :                 return _Mysb::xsgetn(_Ptr, _Count);
; 557  :             }
; 558  : 
; 559  :             // assuming this is OK because _Ptr + _Count must be valid
; 560  :             auto _Count_s           = static_cast<size_t>(_Count);
; 561  :             const auto _Start_count = _Count;
; 562  :             const auto _Available   = static_cast<size_t>(_Mysb::_Gnavail());
; 563  :             if (0 < _Available) { // copy from get area
; 564  :                 const auto _Read_size = (_STD min)(_Count_s, _Available);
; 565  :                 _Traits::copy(_Ptr, _Mysb::gptr(), _Read_size);
; 566  :                 _Ptr += _Read_size;
; 567  :                 _Count_s -= _Read_size;
; 568  :                 _Mysb::gbump(static_cast<int>(_Read_size));
; 569  :             }
; 570  : 
; 571  :             if (_Myfile) { // open C stream, attempt read
; 572  :                 _Reset_back(); // revert from _Mychar buffer
; 573  :                 // process in 4k - 1 chunks to avoid tripping over fread's clobber-the-end behavior when
; 574  :                 // doing \r\n -> \n translation
; 575  :                 constexpr size_t _Read_size = 4095; // _INTERNAL_BUFSIZ - 1
; 576  :                 while (_Read_size < _Count_s) {
; 577  :                     const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);
; 578  :                     _Ptr += _Actual_read;
; 579  :                     _Count_s -= _Actual_read;
; 580  :                     if (_Actual_read != _Read_size) {
; 581  :                         return static_cast<streamsize>(_Start_count - _Count_s);
; 582  :                     }
; 583  :                 }
; 584  : 
; 585  :                 if (0 < _Count_s) {
; 586  :                     _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);
; 587  :                 }
; 588  :             }
; 589  : 
; 590  :             return static_cast<streamsize>(_Start_count - _Count_s);
; 591  :         } else { // non-chars always get element-by-element processing
; 592  :             return _Mysb::xsgetn(_Ptr, _Count);

  00007	ff 75 10	 push	 DWORD PTR __Count$[ebp+4]
  0000a	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn

; 593  :         }
; 594  :     }

  00018	c9		 leave
  00019	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
__Count$ = -140						; size = 4
$T2 = -136						; size = 4
__Dest$3 = -132						; size = 4
__First1$ = -128					; size = 4
__Last1$ = -124						; size = 4
$T4 = -120						; size = 4
_this$ = -116						; size = 4
__File$ = -112						; size = 4
$T5 = -108						; size = 4
$T6 = -104						; size = 4
$T7 = -100						; size = 4
$T8 = -96						; size = 2
$T9 = -94						; size = 2
_this$ = -92						; size = 4
__Meta$10 = -88						; size = 4
__Src$11 = -84						; size = 4
tv169 = -80						; size = 4
$T12 = -76						; size = 2
$T13 = -74						; size = 2
$T14 = -72						; size = 2
$T15 = -70						; size = 2
__Ch$16 = -68						; size = 2
$T17 = -64						; size = 2
$T18 = -62						; size = 2
__Nleft$19 = -60					; size = 4
__Ch$20 = -56						; size = 2
__Meta$21 = -52						; size = 2
tv139 = -48						; size = 2
$T22 = -45						; size = 1
_this$ = -44						; size = 4
__Str$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::uflow, COMDAT
; _this$ = ecx

; 490  :     virtual int_type __CLR_OR_THIS_CALL uflow() override { // get an element from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  0002e	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 9c	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00039	83 7d 9c 00	 cmp	 DWORD PTR $T7[ebp], 0
  0003d	74 64		 je	 SHORT $LN9@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  0003f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 98	 mov	 DWORD PTR $T6[ebp], eax

; 197  :         return *_IGnext + *_IGcount;

  0004a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00050	8b 00		 mov	 eax, DWORD PTR [eax]
  00052	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00058	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0005a	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 491  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  0005d	39 45 98	 cmp	 DWORD PTR $T6[ebp], eax
  00060	73 41		 jae	 SHORT $LN9@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 221  :         --*_IGcount;

  00062	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	48		 dec	 eax
  0006b	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00071	89 01		 mov	 DWORD PTR [ecx], eax

; 222  :         return (*_IGnext)++;

  00073	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	89 45 94	 mov	 DWORD PTR $T5[ebp], eax
  0007e	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
  00086	40		 inc	 eax
  00087	40		 inc	 eax
  00088	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0008e	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00090	8b 45 94	 mov	 eax, DWORD PTR $T5[ebp]
  00093	66 8b 00	 mov	 ax, WORD PTR [eax]
  00096	66 89 45 c2	 mov	 WORD PTR $T18[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 492  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

  0009a	66 8b 45 c2	 mov	 ax, WORD PTR $T18[ebp]
  0009e	e9 48 02 00 00	 jmp	 $LN215@uflow
$LN9@uflow:

; 493  :         }
; 494  : 
; 495  :         if (!_Myfile) {

  000a3	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  000aa	75 12		 jne	 SHORT $LN10@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  000ac	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000b1	66 89 45 c0	 mov	 WORD PTR $T17[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 496  :             return _Traits::eof(); // no open C stream, fail

  000b5	66 8b 45 c0	 mov	 ax, WORD PTR $T17[ebp]
  000b9	e9 2d 02 00 00	 jmp	 $LN215@uflow
$LN10@uflow:

; 497  :         }
; 498  : 
; 499  :         _Reset_back(); // revert from _Mychar buffer

  000be	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back

; 500  :         if (!_Pcvt) { // no codecvt facet, just get it

  000c6	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  000cd	75 69		 jne	 SHORT $LN11@uflow

; 502  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  000cf	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000d2	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  000d5	89 45 90	 mov	 DWORD PTR __File$[ebp], eax

; 78   :     if ((_Meta = _CSTD fgetwc(_File)) == WEOF) {

  000d8	ff 75 90	 push	 DWORD PTR __File$[ebp]
  000db	e8 00 00 00 00	 call	 _fgetwc
  000e0	59		 pop	 ecx
  000e1	66 89 45 cc	 mov	 WORD PTR __Meta$21[ebp], ax
  000e5	0f b7 45 cc	 movzx	 eax, WORD PTR __Meta$21[ebp]
  000e9	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  000ee	75 08		 jne	 SHORT $LN43@uflow

; 79   :         return false;

  000f0	c6 45 d3 00	 mov	 BYTE PTR $T22[ebp], 0
  000f4	eb 0e		 jmp	 SHORT $LN42@uflow

; 80   :     } else { // got one, convert to wchar_t

  000f6	eb 0c		 jmp	 SHORT $LN42@uflow
$LN43@uflow:

; 81   :         _Wchar = static_cast<wchar_t>(_Meta);

  000f8	66 8b 45 cc	 mov	 ax, WORD PTR __Meta$21[ebp]
  000fc	66 89 45 bc	 mov	 WORD PTR __Ch$16[ebp], ax

; 82   :         return true;

  00100	c6 45 d3 01	 mov	 BYTE PTR $T22[ebp], 1
$LN42@uflow:

; 502  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  00104	0f b6 45 d3	 movzx	 eax, BYTE PTR $T22[ebp]
  00108	85 c0		 test	 eax, eax
  0010a	74 12		 je	 SHORT $LN18@uflow
  0010c	66 8b 45 a2	 mov	 ax, WORD PTR $T9[ebp]
  00110	66 89 45 d0	 mov	 WORD PTR tv139[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00114	66 8b 45 bc	 mov	 ax, WORD PTR __Ch$16[ebp]
  00118	66 89 45 d0	 mov	 WORD PTR tv139[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 502  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  0011c	eb 11		 jmp	 SHORT $LN19@uflow
$LN18@uflow:
  0011e	66 8b 45 a0	 mov	 ax, WORD PTR $T8[ebp]
  00122	66 89 45 d0	 mov	 WORD PTR tv139[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00126	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0012b	66 89 45 d0	 mov	 WORD PTR tv139[ebp], ax
$LN19@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 502  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

  0012f	66 8b 45 d0	 mov	 ax, WORD PTR tv139[ebp]
  00133	e9 b3 01 00 00	 jmp	 $LN215@uflow
$LN11@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00138	8d 45 d8	 lea	 eax, DWORD PTR __Str$[ebp]
  0013b	89 45 8c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0013e	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00146	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00149	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 506  :         string _Str;

  0014e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
$LN4@uflow:

; 507  : 
; 508  :         for (;;) { // get using codecvt facet
; 509  :             const char* _Src;
; 510  :             int _Meta = _CSTD fgetc(_Myfile);

  00152	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00155	ff 70 4c	 push	 DWORD PTR [eax+76]
  00158	e8 00 00 00 00	 call	 _fgetc
  0015d	59		 pop	 ecx
  0015e	89 45 a8	 mov	 DWORD PTR __Meta$10[ebp], eax

; 511  : 
; 512  :             if (_Meta == EOF) {

  00161	83 7d a8 ff	 cmp	 DWORD PTR __Meta$10[ebp], -1
  00165	75 1e		 jne	 SHORT $LN12@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00167	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0016c	66 89 45 ba	 mov	 WORD PTR $T15[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 513  :                 return _Traits::eof(); // partial char?

  00170	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00174	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00177	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 513  :                 return _Traits::eof(); // partial char?

  0017c	66 8b 45 ba	 mov	 ax, WORD PTR $T15[ebp]
  00180	e9 66 01 00 00	 jmp	 $LN215@uflow
$LN12@uflow:

; 514  :             }
; 515  : 
; 516  :             _Str.push_back(static_cast<char>(_Meta)); // append byte and convert

  00185	ff 75 a8	 push	 DWORD PTR __Meta$10[ebp]
  00188	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  0018b	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  00190	8b 45 e8	 mov	 eax, DWORD PTR __Str$[ebp+16]
  00193	89 45 88	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  00196	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00199	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  0019e	03 45 88	 add	 eax, DWORD PTR $T4[ebp]
  001a1	89 45 84	 mov	 DWORD PTR __Last1$[ebp], eax
  001a4	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  001a7	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  001ac	89 45 80	 mov	 DWORD PTR __First1$[ebp], eax
  001af	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  001b5	89 45 a4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1936 :         return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  001b8	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR __Dest$3[ebp]
  001be	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  001bf	8d 45 ca	 lea	 eax, DWORD PTR __Ch$20[ebp+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1936 :         return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  001c2	50		 push	 eax
  001c3	8d 45 c8	 lea	 eax, DWORD PTR __Ch$20[ebp]
  001c6	50		 push	 eax
  001c7	8d 45 ac	 lea	 eax, DWORD PTR __Src$11[ebp]
  001ca	50		 push	 eax
  001cb	ff 75 84	 push	 DWORD PTR __Last1$[ebp]
  001ce	ff 75 80	 push	 DWORD PTR __First1$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  001d1	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001d4	83 c0 40	 add	 eax, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1936 :         return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  001d7	50		 push	 eax
  001d8	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  001db	8b 00		 mov	 eax, DWORD PTR [eax]
  001dd	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	ff 50 18	 call	 DWORD PTR [eax+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 520  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

  001e3	89 45 b0	 mov	 DWORD PTR tv169[ebp], eax
  001e6	83 7d b0 00	 cmp	 DWORD PTR tv169[ebp], 0
  001ea	0f 8c cf 00 00
	00		 jl	 $LN16@uflow
  001f0	83 7d b0 01	 cmp	 DWORD PTR tv169[ebp], 1
  001f4	7e 0f		 jle	 SHORT $LN13@uflow
  001f6	83 7d b0 03	 cmp	 DWORD PTR tv169[ebp], 3
  001fa	0f 84 9d 00 00
	00		 je	 $LN15@uflow
  00200	e9 ba 00 00 00	 jmp	 $LN16@uflow
$LN13@uflow:

; 521  :                 _Dest)) { // test result of converting one element
; 522  :             case codecvt_base::partial:
; 523  :             case codecvt_base::ok:
; 524  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

  00205	8d 45 c8	 lea	 eax, DWORD PTR __Ch$20[ebp]
  00208	39 85 7c ff ff
	ff		 cmp	 DWORD PTR __Dest$3[ebp], eax
  0020e	74 5d		 je	 SHORT $LN14@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  00210	8b 45 e8	 mov	 eax, DWORD PTR __Str$[ebp+16]
  00213	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 525  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

  00219	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  0021c	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00221	03 85 78 ff ff
	ff		 add	 eax, DWORD PTR $T2[ebp]
  00227	2b 45 ac	 sub	 eax, DWORD PTR __Src$11[ebp]
  0022a	89 45 c4	 mov	 DWORD PTR __Nleft$19[ebp], eax
$LN7@uflow:

; 526  :                     while (0 < _Nleft) {

  0022d	83 7d c4 00	 cmp	 DWORD PTR __Nleft$19[ebp], 0
  00231	7e 20		 jle	 SHORT $LN8@uflow

; 527  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

  00233	8b 45 c4	 mov	 eax, DWORD PTR __Nleft$19[ebp]
  00236	48		 dec	 eax
  00237	89 45 c4	 mov	 DWORD PTR __Nleft$19[ebp], eax
  0023a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00240	8b 45 ac	 mov	 eax, DWORD PTR __Src$11[ebp]
  00243	03 45 c4	 add	 eax, DWORD PTR __Nleft$19[ebp]
  00246	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00249	50		 push	 eax
  0024a	e8 00 00 00 00	 call	 _ungetc
  0024f	59		 pop	 ecx
  00250	59		 pop	 ecx

; 528  :                     }

  00251	eb da		 jmp	 SHORT $LN7@uflow
$LN8@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00253	66 8b 45 c8	 mov	 ax, WORD PTR __Ch$20[ebp]
  00257	66 89 45 b8	 mov	 WORD PTR $T14[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 530  :                     return _Traits::to_int_type(_Ch);

  0025b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0025f	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00262	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 530  :                     return _Traits::to_int_type(_Ch);

  00267	66 8b 45 b8	 mov	 ax, WORD PTR $T14[ebp]
  0026b	eb 7e		 jmp	 SHORT $LN215@uflow
$LN14@uflow:

; 531  :                 }
; 532  : 
; 533  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

  0026d	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00270	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  00275	8b 4d ac	 mov	 ecx, DWORD PTR __Src$11[ebp]
  00278	2b c8		 sub	 ecx, eax
  0027a	89 8d 74 ff ff
	ff		 mov	 DWORD PTR __Count$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2231 :         if (_Mysize < _Off) {

  00280	83 7d e8 00	 cmp	 DWORD PTR __Str$[ebp+16], 0
  00284	73 05		 jae	 SHORT $LN187@uflow

; 2232 :             _Xran();

  00286	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
$LN187@uflow:

; 3308 :         return _Erase_noexcept(_Off, _Count);

  0028b	ff b5 74 ff ff
	ff		 push	 DWORD PTR __Count$[ebp]
  00291	6a 00		 push	 0
  00293	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00296	e8 00 00 00 00	 call	 ?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 534  :                 break;

  0029b	eb 3d		 jmp	 SHORT $LN5@uflow
$LN15@uflow:

; 538  :                 return static_cast<int_type>(_Str.front());

  0029d	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  002a0	e8 00 00 00 00	 call	 ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
  002a5	66 0f be 00	 movsx	 ax, BYTE PTR [eax]
  002a9	66 89 45 b6	 mov	 WORD PTR $T13[ebp], ax
  002ad	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002b1	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  002b4	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 538  :                 return static_cast<int_type>(_Str.front());

  002b9	66 8b 45 b6	 mov	 ax, WORD PTR $T13[ebp]
  002bd	eb 2c		 jmp	 SHORT $LN215@uflow
$LN16@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  002bf	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  002c4	66 89 45 b4	 mov	 WORD PTR $T12[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 541  :                 return _Traits::eof(); // conversion failed

  002c8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002cc	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  002cf	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 541  :                 return _Traits::eof(); // conversion failed

  002d4	66 8b 45 b4	 mov	 ax, WORD PTR $T12[ebp]
  002d8	eb 11		 jmp	 SHORT $LN215@uflow
$LN5@uflow:

; 542  :             }
; 543  :         }

  002da	e9 73 fe ff ff	 jmp	 $LN4@uflow

; 544  :     }

  002df	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002e3	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  002e6	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN215@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 544  :     }

  002eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002f5	59		 pop	 ecx
  002f6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f9	33 cd		 xor	 ecx, ebp
  002fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00300	c9		 leave
  00301	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Str$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?uflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::uflow
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
tv155 = -20						; size = 4
__Meta$ = -16						; size = 2
_this$ = -12						; size = 4
$T4 = -6						; size = 2
$T5 = -4						; size = 2
$T6 = -1						; size = 1
?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 478  :     virtual int_type __CLR_OR_THIS_CALL underflow() override { // get an element from stream, but don't point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00014	83 7d e8 00	 cmp	 DWORD PTR $T3[ebp], 0
  00018	74 40		 je	 SHORT $LN2@underflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  0001a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 197  :         return *_IGnext + *_IGcount;

  00025	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00033	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00035	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 480  :         if (_Mysb::gptr() && _Mysb::gptr() < _Mysb::egptr()) {

  00038	39 45 e4	 cmp	 DWORD PTR $T2[ebp], eax
  0003b	73 1d		 jae	 SHORT $LN2@underflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00048	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp]
  0004b	66 8b 00	 mov	 ax, WORD PTR [eax]
  0004e	66 89 45 fc	 mov	 WORD PTR $T5[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 481  :             return _Traits::to_int_type(*_Mysb::gptr()); // return buffered

  00052	66 8b 45 fc	 mov	 ax, WORD PTR $T5[ebp]
  00056	eb 5b		 jmp	 SHORT $LN1@underflow
  00058	eb 59		 jmp	 SHORT $LN1@underflow
$LN2@underflow:

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  0005a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 00		 mov	 eax, DWORD PTR [eax]
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	ff 50 1c	 call	 DWORD PTR [eax+28]
  00065	66 89 45 f0	 mov	 WORD PTR __Meta$[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00069	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0006e	66 89 45 fa	 mov	 WORD PTR $T4[ebp], ax

; 301  :         return _Left == _Right;

  00072	0f b7 45 fa	 movzx	 eax, WORD PTR $T4[ebp]
  00076	0f b7 4d f0	 movzx	 ecx, WORD PTR __Meta$[ebp]
  0007a	3b c1		 cmp	 eax, ecx
  0007c	75 09		 jne	 SHORT $LN23@underflow
  0007e	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv155[ebp], 1
  00085	eb 04		 jmp	 SHORT $LN24@underflow
$LN23@underflow:
  00087	83 65 ec 00	 and	 DWORD PTR tv155[ebp], 0
$LN24@underflow:
  0008b	8a 45 ec	 mov	 al, BYTE PTR tv155[ebp]
  0008e	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 482  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

  00091	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00095	85 c0		 test	 eax, eax
  00097	74 08		 je	 SHORT $LN4@underflow

; 483  :             return _Meta; // uflow failed, return EOF

  00099	66 8b 45 f0	 mov	 ax, WORD PTR __Meta$[ebp]
  0009d	eb 14		 jmp	 SHORT $LN1@underflow

; 484  :         } else { // get a char, don't point past it

  0009f	eb 12		 jmp	 SHORT $LN1@underflow
$LN4@underflow:

; 485  :             pbackfail(_Meta);

  000a1	ff 75 f0	 push	 DWORD PTR __Meta$[ebp]
  000a4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	ff 50 10	 call	 DWORD PTR [eax+16]

; 486  :             return _Meta;

  000af	66 8b 45 f0	 mov	 ax, WORD PTR __Meta$[ebp]
$LN1@underflow:

; 487  :         }
; 488  :     }

  000b3	c9		 leave
  000b4	c3		 ret	 0
?underflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 2
__File$ = -72						; size = 4
tv192 = -68						; size = 4
$T3 = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
tv206 = -48						; size = 4
tv203 = -44						; size = 4
tv184 = -40						; size = 4
tv181 = -36						; size = 4
_this$ = -32						; size = 4
$T7 = -28						; size = 2
$T8 = -26						; size = 2
$T9 = -24						; size = 2
$T10 = -22						; size = 2
$T11 = -20						; size = 2
$T12 = -18						; size = 2
$T13 = -16						; size = 2
$T14 = -14						; size = 2
$T15 = -12						; size = 2
$T16 = -10						; size = 2
tv201 = -8						; size = 2
tv200 = -6						; size = 2
$T17 = -3						; size = 1
$T18 = -2						; size = 1
$T19 = -1						; size = 1
__Meta$ = 8						; size = 2
?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 457  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  00009	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00014	83 7d cc 00	 cmp	 DWORD PTR $T6[ebp], 0
  00018	0f 84 27 01 00
	00		 je	 $LN2@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 181  :         return *_IGfirst;

  0001e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax

; 185  :         return *_IGnext;

  00029	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00034	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  00037	3b 45 c4	 cmp	 eax, DWORD PTR $T4[ebp]
  0003a	0f 83 05 01 00
	00		 jae	 $LN2@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00040	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00045	66 89 45 f6	 mov	 WORD PTR $T16[ebp], ax

; 301  :         return _Left == _Right;

  00049	0f b7 45 f6	 movzx	 eax, WORD PTR $T16[ebp]
  0004d	0f b7 4d 08	 movzx	 ecx, WORD PTR __Meta$[ebp]
  00051	3b c1		 cmp	 eax, ecx
  00053	75 09		 jne	 SHORT $LN24@pbackfail
  00055	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv181[ebp], 1
  0005c	eb 04		 jmp	 SHORT $LN25@pbackfail
$LN24@pbackfail:
  0005e	83 65 dc 00	 and	 DWORD PTR tv181[ebp], 0
$LN25@pbackfail:
  00062	8a 45 dc	 mov	 al, BYTE PTR tv181[ebp]
  00065	88 45 ff	 mov	 BYTE PTR $T19[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00068	0f b6 45 ff	 movzx	 eax, BYTE PTR $T19[ebp]
  0006c	85 c0		 test	 eax, eax
  0006e	75 4f		 jne	 SHORT $LN4@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  00070	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00076	8b 00		 mov	 eax, DWORD PTR [eax]
  00078	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0007b	6a 02		 push	 2
  0007d	58		 pop	 eax
  0007e	6b c0 ff	 imul	 eax, eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00081	8b 4d c0	 mov	 ecx, DWORD PTR $T3[ebp]
  00084	66 8b 04 01	 mov	 ax, WORD PTR [ecx+eax]
  00088	66 89 45 f4	 mov	 WORD PTR $T15[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0008c	66 8b 45 f4	 mov	 ax, WORD PTR $T15[ebp]
  00090	66 89 45 f2	 mov	 WORD PTR $T14[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 301  :         return _Left == _Right;

  00094	0f b7 45 f2	 movzx	 eax, WORD PTR $T14[ebp]
  00098	0f b7 4d 08	 movzx	 ecx, WORD PTR __Meta$[ebp]
  0009c	3b c1		 cmp	 eax, ecx
  0009e	75 09		 jne	 SHORT $LN34@pbackfail
  000a0	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv184[ebp], 1
  000a7	eb 04		 jmp	 SHORT $LN35@pbackfail
$LN34@pbackfail:
  000a9	83 65 d8 00	 and	 DWORD PTR tv184[ebp], 0
$LN35@pbackfail:
  000ad	8a 45 d8	 mov	 al, BYTE PTR tv184[ebp]
  000b0	88 45 fe	 mov	 BYTE PTR $T18[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 460  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

  000b3	0f b6 45 fe	 movzx	 eax, BYTE PTR $T18[ebp]
  000b7	85 c0		 test	 eax, eax
  000b9	0f 84 86 00 00
	00		 je	 $LN2@pbackfail
$LN4@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 216  :         ++*_IGcount;

  000bf	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  000c5	8b 00		 mov	 eax, DWORD PTR [eax]
  000c7	40		 inc	 eax
  000c8	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  000ce	89 01		 mov	 DWORD PTR [ecx], eax

; 217  :         return --*_IGnext;

  000d0	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000d6	8b 00		 mov	 eax, DWORD PTR [eax]
  000d8	48		 dec	 eax
  000d9	48		 dec	 eax
  000da	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  000dd	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000e3	8b 4d bc	 mov	 ecx, DWORD PTR tv192[ebp]
  000e6	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  000e8	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000ed	66 89 45 f0	 mov	 WORD PTR $T13[ebp], ax

; 305  :         return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());

  000f1	0f b7 45 08	 movzx	 eax, WORD PTR __Meta$[ebp]
  000f5	0f b7 4d f0	 movzx	 ecx, WORD PTR $T13[ebp]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	74 0a		 je	 SHORT $LN43@pbackfail
  000fd	66 8b 45 08	 mov	 ax, WORD PTR __Meta$[ebp]
  00101	66 89 45 f8	 mov	 WORD PTR tv201[ebp], ax
  00105	eb 28		 jmp	 SHORT $LN44@pbackfail
$LN43@pbackfail:

; 309  :         return WEOF;

  00107	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0010c	66 89 45 ee	 mov	 WORD PTR $T12[ebp], ax

; 305  :         return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());

  00110	0f b7 45 ee	 movzx	 eax, WORD PTR $T12[ebp]
  00114	85 c0		 test	 eax, eax
  00116	75 09		 jne	 SHORT $LN41@pbackfail
  00118	33 c0		 xor	 eax, eax
  0011a	40		 inc	 eax
  0011b	66 89 45 fa	 mov	 WORD PTR tv200[ebp], ax
  0011f	eb 06		 jmp	 SHORT $LN42@pbackfail
$LN41@pbackfail:
  00121	33 c0		 xor	 eax, eax
  00123	66 89 45 fa	 mov	 WORD PTR tv200[ebp], ax
$LN42@pbackfail:
  00127	66 8b 45 fa	 mov	 ax, WORD PTR tv200[ebp]
  0012b	66 89 45 f8	 mov	 WORD PTR tv201[ebp], ax
$LN44@pbackfail:
  0012f	66 8b 45 f8	 mov	 ax, WORD PTR tv201[ebp]
  00133	66 89 45 ec	 mov	 WORD PTR $T11[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 464  :             return _Traits::not_eof(_Meta);

  00137	66 8b 45 ec	 mov	 ax, WORD PTR $T11[ebp]
  0013b	e9 e9 00 00 00	 jmp	 $LN1@pbackfail
  00140	e9 e4 00 00 00	 jmp	 $LN1@pbackfail
$LN2@pbackfail:

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00145	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00148	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0014c	74 30		 je	 SHORT $LN7@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0014e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00153	66 89 45 ea	 mov	 WORD PTR $T10[ebp], ax

; 301  :         return _Left == _Right;

  00157	0f b7 45 ea	 movzx	 eax, WORD PTR $T10[ebp]
  0015b	0f b7 4d 08	 movzx	 ecx, WORD PTR __Meta$[ebp]
  0015f	3b c1		 cmp	 eax, ecx
  00161	75 09		 jne	 SHORT $LN57@pbackfail
  00163	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv203[ebp], 1
  0016a	eb 04		 jmp	 SHORT $LN58@pbackfail
$LN57@pbackfail:
  0016c	83 65 d4 00	 and	 DWORD PTR tv203[ebp], 0
$LN58@pbackfail:
  00170	8a 45 d4	 mov	 al, BYTE PTR tv203[ebp]
  00173	88 45 fd	 mov	 BYTE PTR $T17[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 465  :         } else if (!_Myfile || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00176	0f b6 45 fd	 movzx	 eax, BYTE PTR $T17[ebp]
  0017a	85 c0		 test	 eax, eax
  0017c	74 17		 je	 SHORT $LN5@pbackfail
$LN7@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0017e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00183	66 89 45 e8	 mov	 WORD PTR $T9[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 466  :             return _Traits::eof(); // no open C stream or EOF, fail

  00187	66 8b 45 e8	 mov	 ax, WORD PTR $T9[ebp]
  0018b	e9 99 00 00 00	 jmp	 $LN1@pbackfail
  00190	e9 94 00 00 00	 jmp	 $LN1@pbackfail
$LN5@pbackfail:

; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  00195	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00198	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0019c	75 45		 jne	 SHORT $LN8@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 293  :         return _Meta;

  0019e	66 8b 45 08	 mov	 ax, WORD PTR __Meta$[ebp]
  001a2	66 89 45 b4	 mov	 WORD PTR $T2[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  001a6	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001a9	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  001ac	89 45 b8	 mov	 DWORD PTR __File$[ebp], eax

; 145  :     return _CSTD ungetwc(_Wchar, _File) != WEOF;

  001af	ff 75 b8	 push	 DWORD PTR __File$[ebp]
  001b2	ff 75 b4	 push	 DWORD PTR $T2[ebp]
  001b5	e8 00 00 00 00	 call	 _ungetwc
  001ba	59		 pop	 ecx
  001bb	59		 pop	 ecx
  001bc	0f b7 c0	 movzx	 eax, ax
  001bf	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  001c4	74 09		 je	 SHORT $LN68@pbackfail
  001c6	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv206[ebp], 1
  001cd	eb 04		 jmp	 SHORT $LN66@pbackfail
$LN68@pbackfail:
  001cf	83 65 d0 00	 and	 DWORD PTR tv206[ebp], 0
$LN66@pbackfail:

; 467  :         } else if (!_Pcvt && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

  001d3	0f b6 45 d0	 movzx	 eax, BYTE PTR tv206[ebp]
  001d7	85 c0		 test	 eax, eax
  001d9	74 08		 je	 SHORT $LN8@pbackfail

; 468  :             return _Meta; // no facet and unget succeeded, return

  001db	66 8b 45 08	 mov	 ax, WORD PTR __Meta$[ebp]
  001df	eb 48		 jmp	 SHORT $LN1@pbackfail

; 469  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

  001e1	eb 46		 jmp	 SHORT $LN1@pbackfail
$LN8@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 185  :         return *_IGnext;

  001e3	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  001e9	8b 00		 mov	 eax, DWORD PTR [eax]
  001eb	89 45 b0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 469  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

  001ee	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  001f1	83 c0 3c	 add	 eax, 60			; 0000003cH
  001f4	39 45 b0	 cmp	 DWORD PTR $T1[ebp], eax
  001f7	74 23		 je	 SHORT $LN10@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 293  :         return _Meta;

  001f9	66 8b 45 08	 mov	 ax, WORD PTR __Meta$[ebp]
  001fd	66 89 45 e6	 mov	 WORD PTR $T8[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 470  :             _Mychar = _Traits::to_char_type(_Meta);

  00201	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00204	66 8b 4d e6	 mov	 cx, WORD PTR $T8[ebp]
  00208	66 89 48 3c	 mov	 WORD PTR [eax+60], cx

; 471  :             _Set_back(); // switch to _Mychar buffer

  0020c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0020f	e8 00 00 00 00	 call	 ?_Set_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Set_back

; 472  :             return _Meta;

  00214	66 8b 45 08	 mov	 ax, WORD PTR __Meta$[ebp]
  00218	eb 0f		 jmp	 SHORT $LN1@pbackfail

; 473  :         } else {

  0021a	eb 0d		 jmp	 SHORT $LN1@pbackfail
$LN10@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0021c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00221	66 89 45 e4	 mov	 WORD PTR $T7[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 474  :             return _Traits::eof(); // nowhere to put back

  00225	66 8b 45 e4	 mov	 ax, WORD PTR $T7[ebp]
$LN1@pbackfail:

; 475  :         }
; 476  :     }

  00229	c9		 leave
  0022a	c2 04 00	 ret	 4
?pbackfail@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
__Codecvt_temp_buf$ = -32				; size = 4
__Wchar$ = -28						; size = 2
__File$ = -24						; size = 4
__Src$ = -20						; size = 4
__Dest$ = -16						; size = 4
$T1 = -12						; size = 2
__File$ = -8						; size = 4
tv217 = -4						; size = 4
$T2 = 0							; size = 4
$T3 = 4							; size = 4
$T4 = 8							; size = 2
$T5 = 10						; size = 2
tv160 = 12						; size = 4
_this$ = 16						; size = 4
tv240 = 20						; size = 4
tv191 = 24						; size = 4
tv163 = 28						; size = 4
__Count$6 = 32						; size = 4
$T7 = 38						; size = 2
$T8 = 40						; size = 2
$T9 = 42						; size = 2
$T10 = 44						; size = 2
$T11 = 46						; size = 2
$T12 = 48						; size = 2
$T13 = 50						; size = 2
$T14 = 52						; size = 2
$T15 = 54						; size = 2
tv199 = 56						; size = 2
tv198 = 58						; size = 2
__Ch$ = 60						; size = 2
$T16 = 67						; size = 1
tv184 = 68						; size = 2
tv147 = 70						; size = 2
_this$ = 72						; size = 4
__Str$ = 76						; size = 32
__$ArrayPad$ = 112					; size = 4
__Meta$ = 124						; size = 2
?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 406  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) override { // put an element to stream

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d 48	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00018	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001d	66 89 45 36	 mov	 WORD PTR $T15[ebp], ax

; 301  :         return _Left == _Right;

  00021	0f b7 45 36	 movzx	 eax, WORD PTR $T15[ebp]
  00025	0f b7 4d 7c	 movzx	 ecx, WORD PTR __Meta$[ebp]
  00029	3b c1		 cmp	 eax, ecx
  0002b	75 09		 jne	 SHORT $LN23@overflow
  0002d	c7 45 18 01 00
	00 00		 mov	 DWORD PTR tv191[ebp], 1
  00034	eb 04		 jmp	 SHORT $LN24@overflow
$LN23@overflow:
  00036	83 65 18 00	 and	 DWORD PTR tv191[ebp], 0
$LN24@overflow:
  0003a	8a 45 18	 mov	 al, BYTE PTR tv191[ebp]
  0003d	88 45 43	 mov	 BYTE PTR $T16[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 407  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00040	0f b6 45 43	 movzx	 eax, BYTE PTR $T16[ebp]
  00044	85 c0		 test	 eax, eax
  00046	74 58		 je	 SHORT $LN4@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00048	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0004d	66 89 45 34	 mov	 WORD PTR $T14[ebp], ax

; 305  :         return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());

  00051	0f b7 45 7c	 movzx	 eax, WORD PTR __Meta$[ebp]
  00055	0f b7 4d 34	 movzx	 ecx, WORD PTR $T14[ebp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	74 0a		 je	 SHORT $LN30@overflow
  0005d	66 8b 45 7c	 mov	 ax, WORD PTR __Meta$[ebp]
  00061	66 89 45 38	 mov	 WORD PTR tv199[ebp], ax
  00065	eb 28		 jmp	 SHORT $LN31@overflow
$LN30@overflow:

; 309  :         return WEOF;

  00067	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0006c	66 89 45 32	 mov	 WORD PTR $T13[ebp], ax

; 305  :         return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());

  00070	0f b7 45 32	 movzx	 eax, WORD PTR $T13[ebp]
  00074	85 c0		 test	 eax, eax
  00076	75 09		 jne	 SHORT $LN28@overflow
  00078	33 c0		 xor	 eax, eax
  0007a	40		 inc	 eax
  0007b	66 89 45 3a	 mov	 WORD PTR tv198[ebp], ax
  0007f	eb 06		 jmp	 SHORT $LN29@overflow
$LN28@overflow:
  00081	33 c0		 xor	 eax, eax
  00083	66 89 45 3a	 mov	 WORD PTR tv198[ebp], ax
$LN29@overflow:
  00087	66 8b 45 3a	 mov	 ax, WORD PTR tv198[ebp]
  0008b	66 89 45 38	 mov	 WORD PTR tv199[ebp], ax
$LN31@overflow:
  0008f	66 8b 45 38	 mov	 ax, WORD PTR tv199[ebp]
  00093	66 89 45 30	 mov	 WORD PTR $T12[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 408  :             return _Traits::not_eof(_Meta); // EOF, return success code

  00097	66 8b 45 30	 mov	 ax, WORD PTR $T12[ebp]
  0009b	e9 34 02 00 00	 jmp	 $LN1@overflow
$LN4@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 193  :         return *_IPnext;

  000a0	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	89 45 04	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  000ab	83 7d 04 00	 cmp	 DWORD PTR $T3[ebp], 0
  000af	74 6c		 je	 SHORT $LN5@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 193  :         return *_IPnext;

  000b1	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000b7	8b 00		 mov	 eax, DWORD PTR [eax]
  000b9	89 45 00	 mov	 DWORD PTR $T2[ebp], eax

; 212  :         return *_IPnext + *_IPcount;

  000bc	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  000c2	8b 00		 mov	 eax, DWORD PTR [eax]
  000c4	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  000c7	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  000ca	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000cc	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 411  :         if (_Mysb::pptr() && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

  000cf	39 45 00	 cmp	 DWORD PTR $T2[ebp], eax
  000d2	73 49		 jae	 SHORT $LN5@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 293  :         return _Meta;

  000d4	66 8b 45 7c	 mov	 ax, WORD PTR __Meta$[ebp]
  000d8	66 89 45 2e	 mov	 WORD PTR $T11[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 253  :         --*_IPcount;

  000dc	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  000df	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  000e2	8b 00		 mov	 eax, DWORD PTR [eax]
  000e4	48		 dec	 eax
  000e5	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  000e8	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  000eb	89 01		 mov	 DWORD PTR [ecx], eax

; 254  :         return (*_IPnext)++;

  000ed	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000f3	8b 00		 mov	 eax, DWORD PTR [eax]
  000f5	89 45 fc	 mov	 DWORD PTR tv217[ebp], eax
  000f8	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  000fb	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000fe	8b 00		 mov	 eax, DWORD PTR [eax]
  00100	40		 inc	 eax
  00101	40		 inc	 eax
  00102	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00108	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 412  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  0010a	8b 45 fc	 mov	 eax, DWORD PTR tv217[ebp]
  0010d	66 8b 4d 2e	 mov	 cx, WORD PTR $T11[ebp]
  00111	66 89 08	 mov	 WORD PTR [eax], cx

; 413  :             return _Meta;

  00114	66 8b 45 7c	 mov	 ax, WORD PTR __Meta$[ebp]
  00118	e9 b7 01 00 00	 jmp	 $LN1@overflow
$LN5@overflow:

; 414  :         }
; 415  : 
; 416  :         if (!_Myfile) {

  0011d	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00120	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00124	75 12		 jne	 SHORT $LN6@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00126	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0012b	66 89 45 2c	 mov	 WORD PTR $T10[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 417  :             return _Traits::eof(); // no open C stream, fail

  0012f	66 8b 45 2c	 mov	 ax, WORD PTR $T10[ebp]
  00133	e9 9c 01 00 00	 jmp	 $LN1@overflow
$LN6@overflow:

; 418  :         }
; 419  : 
; 420  :         _Reset_back(); // revert from _Mychar buffer

  00138	8b 4d 48	 mov	 ecx, DWORD PTR _this$[ebp]
  0013b	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back

; 421  :         if (!_Pcvt) { // no codecvt facet, put as is

  00140	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00143	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00147	75 61		 jne	 SHORT $LN7@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 293  :         return _Meta;

  00149	66 8b 45 7c	 mov	 ax, WORD PTR __Meta$[ebp]
  0014d	66 89 45 f4	 mov	 WORD PTR $T1[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 422  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  00151	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00154	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00157	89 45 f8	 mov	 DWORD PTR __File$[ebp], eax

; 112  :     return _CSTD fputwc(_Wchar, _File) != WEOF;

  0015a	ff 75 f8	 push	 DWORD PTR __File$[ebp]
  0015d	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00160	e8 00 00 00 00	 call	 _fputwc
  00165	59		 pop	 ecx
  00166	59		 pop	 ecx
  00167	0f b7 c0	 movzx	 eax, ax
  0016a	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0016f	74 09		 je	 SHORT $LN65@overflow
  00171	c7 45 14 01 00
	00 00		 mov	 DWORD PTR tv240[ebp], 1
  00178	eb 04		 jmp	 SHORT $LN63@overflow
$LN65@overflow:
  0017a	83 65 14 00	 and	 DWORD PTR tv240[ebp], 0
$LN63@overflow:

; 422  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  0017e	0f b6 45 14	 movzx	 eax, BYTE PTR tv240[ebp]
  00182	85 c0		 test	 eax, eax
  00184	74 0a		 je	 SHORT $LN14@overflow
  00186	66 8b 45 7c	 mov	 ax, WORD PTR __Meta$[ebp]
  0018a	66 89 45 46	 mov	 WORD PTR tv147[ebp], ax
  0018e	eb 11		 jmp	 SHORT $LN15@overflow
$LN14@overflow:
  00190	66 8b 45 0a	 mov	 ax, WORD PTR $T5[ebp]
  00194	66 89 45 46	 mov	 WORD PTR tv147[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00198	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0019d	66 89 45 46	 mov	 WORD PTR tv147[ebp], ax
$LN15@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 422  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

  001a1	66 8b 45 46	 mov	 ax, WORD PTR tv147[ebp]
  001a5	e9 2a 01 00 00	 jmp	 $LN1@overflow
$LN7@overflow:

; 423  :         }
; 424  : 
; 425  :         // put using codecvt facet
; 426  :         constexpr size_t _Codecvt_temp_buf = 32;

  001aa	c7 45 e0 20 00
	00 00		 mov	 DWORD PTR __Codecvt_temp_buf$[ebp], 32 ; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 293  :         return _Meta;

  001b1	66 8b 45 7c	 mov	 ax, WORD PTR __Meta$[ebp]
  001b5	66 89 45 3c	 mov	 WORD PTR __Ch$[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

  001b9	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  001bc	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  001bf	89 45 10	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1942 :         return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  001c2	8d 45 f0	 lea	 eax, DWORD PTR __Dest$[ebp]
  001c5	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

  001c6	8d 45 6c	 lea	 eax, DWORD PTR __Str$[ebp+32]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1942 :         return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  001c9	50		 push	 eax
  001ca	8d 45 4c	 lea	 eax, DWORD PTR __Str$[ebp]
  001cd	50		 push	 eax
  001ce	8d 45 ec	 lea	 eax, DWORD PTR __Src$[ebp]
  001d1	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

  001d2	8d 45 3e	 lea	 eax, DWORD PTR __Ch$[ebp+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1942 :         return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  001d5	50		 push	 eax
  001d6	8d 45 3c	 lea	 eax, DWORD PTR __Ch$[ebp]
  001d9	50		 push	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

  001da	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  001dd	83 c0 40	 add	 eax, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1942 :         return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);

  001e0	50		 push	 eax
  001e1	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  001e4	8b 00		 mov	 eax, DWORD PTR [eax]
  001e6	8b 4d 10	 mov	 ecx, DWORD PTR _this$[ebp]
  001e9	ff 50 1c	 call	 DWORD PTR [eax+28]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 431  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

  001ec	89 45 1c	 mov	 DWORD PTR tv163[ebp], eax
  001ef	83 7d 1c 00	 cmp	 DWORD PTR tv163[ebp], 0
  001f3	0f 8c ce 00 00
	00		 jl	 $LN12@overflow
  001f9	83 7d 1c 01	 cmp	 DWORD PTR tv163[ebp], 1
  001fd	7e 0b		 jle	 SHORT $LN8@overflow
  001ff	83 7d 1c 03	 cmp	 DWORD PTR tv163[ebp], 3
  00203	74 64		 je	 SHORT $LN11@overflow
  00205	e9 bd 00 00 00	 jmp	 $LN12@overflow
$LN8@overflow:

; 432  :             _Dest)) { // test result of converting one element
; 433  :         case codecvt_base::partial:
; 434  :         case codecvt_base::ok: { // converted something, try to put it out
; 435  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

  0020a	8b 45 f0	 mov	 eax, DWORD PTR __Dest$[ebp]
  0020d	8d 4d 4c	 lea	 ecx, DWORD PTR __Str$[ebp]
  00210	2b c1		 sub	 eax, ecx
  00212	89 45 20	 mov	 DWORD PTR __Count$6[ebp], eax

; 436  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

  00215	74 2e		 je	 SHORT $LN9@overflow
  00217	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0021a	ff 70 4c	 push	 DWORD PTR [eax+76]
  0021d	ff 75 20	 push	 DWORD PTR __Count$6[ebp]
  00220	6a 01		 push	 1
  00222	8d 45 4c	 lea	 eax, DWORD PTR __Str$[ebp]
  00225	50		 push	 eax
  00226	e8 00 00 00 00	 call	 _fwrite
  0022b	83 c4 10	 add	 esp, 16			; 00000010H
  0022e	39 45 20	 cmp	 DWORD PTR __Count$6[ebp], eax
  00231	74 12		 je	 SHORT $LN9@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00233	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00238	66 89 45 2a	 mov	 WORD PTR $T9[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 437  :                 return _Traits::eof(); // write failed

  0023c	66 8b 45 2a	 mov	 ax, WORD PTR $T9[ebp]
  00240	e9 8f 00 00 00	 jmp	 $LN1@overflow
$LN9@overflow:

; 438  :             }
; 439  : 
; 440  :             _Wrotesome = true; // write succeeded

  00245	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  00248	c6 40 3e 01	 mov	 BYTE PTR [eax+62], 1

; 441  :             if (_Src != &_Ch) {

  0024c	8d 45 3c	 lea	 eax, DWORD PTR __Ch$[ebp]
  0024f	39 45 ec	 cmp	 DWORD PTR __Src$[ebp], eax
  00252	74 06		 je	 SHORT $LN10@overflow

; 442  :                 return _Meta; // converted whole element

  00254	66 8b 45 7c	 mov	 ax, WORD PTR __Meta$[ebp]
  00258	eb 7a		 jmp	 SHORT $LN1@overflow
$LN10@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0025a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0025f	66 89 45 28	 mov	 WORD PTR $T8[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 445  :             return _Traits::eof(); // conversion failed

  00263	66 8b 45 28	 mov	 ax, WORD PTR $T8[ebp]
  00267	eb 6b		 jmp	 SHORT $LN1@overflow
$LN11@overflow:

; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  00269	8b 45 48	 mov	 eax, DWORD PTR _this$[ebp]
  0026c	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  0026f	89 45 e8	 mov	 DWORD PTR __File$[ebp], eax
  00272	66 8b 45 3c	 mov	 ax, WORD PTR __Ch$[ebp]
  00276	66 89 45 e4	 mov	 WORD PTR __Wchar$[ebp], ax

; 112  :     return _CSTD fputwc(_Wchar, _File) != WEOF;

  0027a	ff 75 e8	 push	 DWORD PTR __File$[ebp]
  0027d	ff 75 e4	 push	 DWORD PTR __Wchar$[ebp]
  00280	e8 00 00 00 00	 call	 _fputwc
  00285	59		 pop	 ecx
  00286	59		 pop	 ecx
  00287	0f b7 c0	 movzx	 eax, ax
  0028a	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  0028f	74 09		 je	 SHORT $LN83@overflow
  00291	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR tv160[ebp], 1
  00298	eb 04		 jmp	 SHORT $LN81@overflow
$LN83@overflow:
  0029a	83 65 0c 00	 and	 DWORD PTR tv160[ebp], 0
$LN81@overflow:

; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  0029e	0f b6 45 0c	 movzx	 eax, BYTE PTR tv160[ebp]
  002a2	85 c0		 test	 eax, eax
  002a4	74 0a		 je	 SHORT $LN16@overflow
  002a6	66 8b 45 7c	 mov	 ax, WORD PTR __Meta$[ebp]
  002aa	66 89 45 44	 mov	 WORD PTR tv184[ebp], ax
  002ae	eb 11		 jmp	 SHORT $LN17@overflow
$LN16@overflow:
  002b0	66 8b 45 08	 mov	 ax, WORD PTR $T4[ebp]
  002b4	66 89 45 44	 mov	 WORD PTR tv184[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  002b8	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  002bd	66 89 45 44	 mov	 WORD PTR tv184[ebp], ax
$LN17@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 450  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

  002c1	66 8b 45 44	 mov	 ax, WORD PTR tv184[ebp]
  002c5	eb 0d		 jmp	 SHORT $LN1@overflow
$LN12@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  002c7	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  002cc	66 89 45 26	 mov	 WORD PTR $T7[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 453  :             return _Traits::eof(); // conversion failed

  002d0	66 8b 45 26	 mov	 ax, WORD PTR $T7[ebp]
$LN1@overflow:

; 454  :         }
; 455  :     }

  002d4	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002d7	33 cd		 xor	 ecx, ebp
  002d9	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002de	83 c5 74	 add	 ebp, 116		; 00000074H
  002e1	c9		 leave
  002e2	c2 04 00	 ret	 4
?overflow@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Unlock, COMDAT
; _this$ = ecx

; 399  :     virtual void __CLR_OR_THIS_CALL _Unlock() override { // unlock file instead of stream buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 400  :         if (_Myfile) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0000e	74 0c		 je	 SHORT $LN1@Unlock

; 401  :             _CSTD _unlock_file(_Myfile);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	ff 70 4c	 push	 DWORD PTR [eax+76]
  00016	e8 00 00 00 00	 call	 __unlock_file
  0001b	59		 pop	 ecx
$LN1@Unlock:

; 402  :         }
; 403  :     }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Unlock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Lock, COMDAT
; _this$ = ecx

; 393  :     virtual void __CLR_OR_THIS_CALL _Lock() override { // lock file instead of stream buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 394  :         if (_Myfile) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0000e	74 0c		 je	 SHORT $LN1@Lock

; 395  :             _CSTD _lock_file(_Myfile);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	ff 70 4c	 push	 DWORD PTR [eax+76]
  00016	e8 00 00 00 00	 call	 __lock_file
  0001b	59		 pop	 ecx
$LN1@Lock:

; 396  :         }
; 397  :     }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Lock@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Lock
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ
_TEXT	SEGMENT
__Ans$ = -8						; size = 4
_this$ = -4						; size = 4
?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close, COMDAT
; _this$ = ecx

; 374  :     basic_filebuf* close() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 375  :         basic_filebuf* _Ans;
; 376  :         if (_Myfile) { // put any homing sequence and close file

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  0000f	74 2f		 je	 SHORT $LN2@close

; 377  :             _Ans = this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR __Ans$[ebp], eax

; 378  :             if (!_Endwrite()) {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAE_NXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Endwrite
  0001f	0f b6 c0	 movzx	 eax, al
  00022	85 c0		 test	 eax, eax
  00024	75 04		 jne	 SHORT $LN4@close

; 379  :                 _Ans = nullptr;

  00026	83 65 f8 00	 and	 DWORD PTR __Ans$[ebp], 0
$LN4@close:

; 380  :             }
; 381  : 
; 382  :             if (_CSTD fclose(_Myfile) != 0) {

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00030	e8 00 00 00 00	 call	 _fclose
  00035	59		 pop	 ecx
  00036	85 c0		 test	 eax, eax
  00038	74 04		 je	 SHORT $LN5@close

; 383  :                 _Ans = nullptr;

  0003a	83 65 f8 00	 and	 DWORD PTR __Ans$[ebp], 0
$LN5@close:

; 384  :             }
; 385  :         } else {

  0003e	eb 04		 jmp	 SHORT $LN3@close
$LN2@close:

; 386  :             _Ans = nullptr;

  00040	83 65 f8 00	 and	 DWORD PTR __Ans$[ebp], 0
$LN3@close:

; 387  :         }
; 388  : 
; 389  :         _Init(nullptr, _Closefl);

  00044	6a 02		 push	 2
  00046	6a 00		 push	 0
  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init

; 390  :         return _Ans;

  00050	8b 45 f8	 mov	 eax, DWORD PTR __Ans$[ebp]

; 391  :     }

  00053	c9		 leave
  00054	c3		 ret	 0
?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z
_TEXT	SEGMENT
$T2 = -40						; size = 8
$T3 = -32						; size = 4
tv88 = -28						; size = 4
tv187 = -24						; size = 4
__File$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::open, COMDAT
; _this$ = ecx

; 275  :     basic_filebuf* open(const char* _Filename, ios_base::openmode _Mode, int _Prot = ios_base::_Default_open_prot) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	83 65 e0 00	 and	 DWORD PTR $T3[ebp], 0

; 276  :         // _Prot is an extension
; 277  :         if (_Myfile) {

  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00033	74 04		 je	 SHORT $LN2@open

; 278  :             return nullptr;

  00035	33 c0		 xor	 eax, eax
  00037	eb 65		 jmp	 SHORT $LN1@open
$LN2@open:

; 279  :         }
; 280  : 
; 281  :         const auto _File = _Fiopen(_Filename, _Mode, _Prot);

  00039	ff 75 10	 push	 DWORD PTR __Prot$[ebp]
  0003c	ff 75 0c	 push	 DWORD PTR __Mode$[ebp]
  0003f	ff 75 08	 push	 DWORD PTR __Filename$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Fiopen@std@@YAPAU_iobuf@@PBDHH@Z ; std::_Fiopen
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004a	89 45 ec	 mov	 DWORD PTR __File$[ebp], eax

; 282  :         if (!_File) {

  0004d	83 7d ec 00	 cmp	 DWORD PTR __File$[ebp], 0
  00051	75 04		 jne	 SHORT $LN3@open

; 283  :             return nullptr; // open failed

  00053	33 c0		 xor	 eax, eax
  00055	eb 47		 jmp	 SHORT $LN1@open
$LN3@open:

; 284  :         }
; 285  : 
; 286  :         _Init(_File, _Openfl);

  00057	6a 01		 push	 1
  00059	ff 75 ec	 push	 DWORD PTR __File$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init

; 287  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

  00064	8d 45 d8	 lea	 eax, DWORD PTR $T2[ebp]
  00067	50		 push	 eax
  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?getloc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QBE?AVlocale@2@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::getloc
  00070	89 45 e8	 mov	 DWORD PTR tv187[ebp], eax
  00073	8b 45 e8	 mov	 eax, DWORD PTR tv187[ebp]
  00076	89 45 e4	 mov	 DWORD PTR tv88[ebp], eax
  00079	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0007d	ff 75 e4	 push	 DWORD PTR tv88[ebp]
  00080	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@_WDU_Mbstatet@@@std@@@std@@YAABV?$codecvt@_WDU_Mbstatet@@@0@ABVlocale@0@@Z ; std::use_facet<std::codecvt<wchar_t,char,_Mbstatet> >
  00085	59		 pop	 ecx
  00086	50		 push	 eax
  00087	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Initcvt@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXABV?$codecvt@_WDU_Mbstatet@@@2@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Initcvt
  0008f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00093	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00096	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 288  :         return this; // open succeeded

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@open:

; 289  :     }

  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	c9		 leave
  000aa	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::open
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 170  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@

; 171  :         if (_Myfile) {

  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00036	74 08		 je	 SHORT $LN2@basic_file

; 172  :             _Reset_back(); // revert from _Mychar buffer

  00038	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@AAEXXZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Reset_back
$LN2@basic_file:

; 173  :         }
; 174  : 
; 175  :         if (_Closef) {

  00040	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	0f b6 40 48	 movzx	 eax, BYTE PTR [eax+72]
  00047	85 c0		 test	 eax, eax
  00049	74 08		 je	 SHORT $LN1@basic_file

; 176  :             close();

  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::close
$LN1@basic_file:

; 177  :         }
; 178  :     }

  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00065	59		 pop	 ecx
  00066	c9		 leave
  00067	c3		 ret	 0
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Odspy
;	COMDAT ??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 38		 push	 56			; 00000038H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue, COMDAT
; _this$ = ecx

; 377  :     virtual void __CLR_OR_THIS_CALL imbue(const locale&) {} // set locale to argument (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 04 00	 ret	 4
?imbue@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEXABVlocale@2@@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::imbue
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync, COMDAT
; _this$ = ecx

; 373  :     virtual int __CLR_OR_THIS_CALL sync() { // synchronize with external agent (do nothing)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 374  :         return 0;

  00007	33 c0		 xor	 eax, eax

; 375  :     }

  00009	c9		 leave
  0000a	c3		 ret	 0
?sync@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEHXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sync
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 8
?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf, COMDAT
; _this$ = ecx

; 368  :     virtual basic_streambuf* __CLR_OR_THIS_CALL setbuf(_Elem*, streamsize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 369  :         // offer buffer to external agent (do nothing)
; 370  :         return this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 371  :     }

  0000a	c9		 leave
  0000b	c2 0c 00	 ret	 12			; 0000000cH
?setbuf@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEPAV12@PA_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::setbuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 24
___formal$ = 36						; size = 4
?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos, COMDAT
; _this$ = ecx

; 363  :     virtual pos_type __CLR_OR_THIS_CALL seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	83 c9 ff	 or	 ecx, -1
  0000d	83 08 ff	 or	 DWORD PTR [eax], -1
  00010	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00016	33 c9		 xor	 ecx, ecx
  00018	33 d2		 xor	 edx, edx
  0001a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00020	33 c0		 xor	 eax, eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	83 c1 10	 add	 ecx, 16			; 00000010H
  00028	89 01		 mov	 DWORD PTR [ecx], eax
  0002a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 365  :         return streampos(-1);

  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 366  :     }

  00030	c9		 leave
  00031	c2 20 00	 ret	 32			; 00000020H
?seekpos@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekpos
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
___formal$ = 20						; size = 4
___formal$ = 24						; size = 4
?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff, COMDAT
; _this$ = ecx

; 358  :         off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iosfwd

; 55   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() {}

  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	83 c9 ff	 or	 ecx, -1
  0000d	83 08 ff	 or	 DWORD PTR [eax], -1
  00010	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00016	33 c9		 xor	 ecx, ecx
  00018	33 d2		 xor	 edx, edx
  0001a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0001d	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00020	33 c0		 xor	 eax, eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	83 c1 10	 add	 ecx, 16			; 00000010H
  00028	89 01		 mov	 DWORD PTR [ecx], eax
  0002a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 360  :         return streampos(-1);

  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 361  :     }

  00030	c9		 leave
  00031	c2 14 00	 ret	 20			; 00000014H
?seekoff@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::seekoff
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z
_TEXT	SEGMENT
__Start_count$ = -48					; size = 8
__Size$1 = -40						; size = 8
$T2 = -32						; size = 2
$T3 = -28						; size = 4
tv79 = -24						; size = 4
__Off$ = -20						; size = 4
tv135 = -16						; size = 4
_this$ = -12						; size = 4
$T4 = -6						; size = 2
$T5 = -4						; size = 2
$T6 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn, COMDAT
; _this$ = ecx

; 332  :     virtual streamsize __CLR_OR_THIS_CALL xsputn(const _Elem* _Ptr, streamsize _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 333  :         // put _Count characters to stream
; 334  :         const streamsize _Start_count = _Count;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  0000f	89 45 d0	 mov	 DWORD PTR __Start_count$[ebp], eax
  00012	89 4d d4	 mov	 DWORD PTR __Start_count$[ebp+4], ecx
$LN2@xsputn:

; 335  :         while (0 < _Count) {

  00015	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp+4], 0
  00019	0f 8c 4c 01 00
	00		 jl	 $LN3@xsputn
  0001f	7f 0a		 jg	 SHORT $LN32@xsputn
  00021	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00025	0f 86 40 01 00
	00		 jbe	 $LN3@xsputn
$LN32@xsputn:

; 258  :         return *_IPnext ? *_IPcount : 0;

  0002b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	74 0d		 je	 SHORT $LN12@xsputn
  00036	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 f0	 mov	 DWORD PTR tv135[ebp], eax
  00041	eb 04		 jmp	 SHORT $LN10@xsputn
$LN12@xsputn:
  00043	83 65 f0 00	 and	 DWORD PTR tv135[ebp], 0
$LN10@xsputn:
  00047	8b 45 f0	 mov	 eax, DWORD PTR tv135[ebp]
  0004a	99		 cdq

; 336  :             streamsize _Size = _Pnavail();

  0004b	89 45 d8	 mov	 DWORD PTR __Size$1[ebp], eax
  0004e	89 55 dc	 mov	 DWORD PTR __Size$1[ebp+4], edx

; 337  :             if (0 < _Size) { // copy to write buffer

  00051	83 7d dc 00	 cmp	 DWORD PTR __Size$1[ebp+4], 0
  00055	0f 8c a1 00 00
	00		 jl	 $LN4@xsputn
  0005b	7f 0a		 jg	 SHORT $LN33@xsputn
  0005d	83 7d d8 00	 cmp	 DWORD PTR __Size$1[ebp], 0
  00061	0f 86 95 00 00
	00		 jbe	 $LN4@xsputn
$LN33@xsputn:

; 338  :                 if (_Count < _Size) {

  00067	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0006a	3b 45 dc	 cmp	 eax, DWORD PTR __Size$1[ebp+4]
  0006d	7f 16		 jg	 SHORT $LN6@xsputn
  0006f	7c 08		 jl	 SHORT $LN34@xsputn
  00071	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00074	3b 45 d8	 cmp	 eax, DWORD PTR __Size$1[ebp]
  00077	73 0c		 jae	 SHORT $LN6@xsputn
$LN34@xsputn:

; 339  :                     _Size = _Count;

  00079	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0007c	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  0007f	89 45 d8	 mov	 DWORD PTR __Size$1[ebp], eax
  00082	89 4d dc	 mov	 DWORD PTR __Size$1[ebp+4], ecx
$LN6@xsputn:

; 193  :         return *_IPnext;

  00085	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0008b	8b 00		 mov	 eax, DWORD PTR [eax]
  0008d	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 340  :                 }
; 341  : 
; 342  :                 _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));

  00090	8b 45 d8	 mov	 eax, DWORD PTR __Size$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00093	d1 e0		 shl	 eax, 1
  00095	50		 push	 eax
  00096	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00099	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0009c	e8 00 00 00 00	 call	 _memcpy
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 343  :                 _Ptr += _Size;

  000a4	6a 00		 push	 0
  000a6	6a 02		 push	 2
  000a8	ff 75 dc	 push	 DWORD PTR __Size$1[ebp+4]
  000ab	ff 75 d8	 push	 DWORD PTR __Size$1[ebp]
  000ae	e8 00 00 00 00	 call	 __allmul
  000b3	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]
  000b6	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax

; 344  :                 _Count -= _Size;

  000b9	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000bc	2b 45 d8	 sub	 eax, DWORD PTR __Size$1[ebp]
  000bf	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  000c2	1b 4d dc	 sbb	 ecx, DWORD PTR __Size$1[ebp+4]
  000c5	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  000c8	89 4d 10	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 345  :                 pbump(static_cast<int>(_Size));

  000cb	8b 45 d8	 mov	 eax, DWORD PTR __Size$1[ebp]
  000ce	89 45 ec	 mov	 DWORD PTR __Off$[ebp], eax

; 235  :         *_IPcount -= _Off;

  000d1	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]
  000d9	2b 45 ec	 sub	 eax, DWORD PTR __Off$[ebp]
  000dc	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  000e2	89 01		 mov	 DWORD PTR [ecx], eax

; 236  :         *_IPnext += _Off;

  000e4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000ea	8b 00		 mov	 eax, DWORD PTR [eax]
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR __Off$[ebp]
  000ef	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  000f2	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  000f8	89 01		 mov	 DWORD PTR [ecx], eax

; 346  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  000fa	eb 6a		 jmp	 SHORT $LN5@xsputn
$LN4@xsputn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  000fc	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000ff	66 8b 00	 mov	 ax, WORD PTR [eax]
  00102	66 89 45 e0	 mov	 WORD PTR $T2[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 346  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  00106	ff 75 e0	 push	 DWORD PTR $T2[ebp]
  00109	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0010c	8b 00		 mov	 eax, DWORD PTR [eax]
  0010e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00111	ff 50 0c	 call	 DWORD PTR [eax+12]
  00114	66 89 45 fa	 mov	 WORD PTR $T4[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00118	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0011d	66 89 45 fc	 mov	 WORD PTR $T5[ebp], ax

; 301  :         return _Left == _Right;

  00121	0f b7 45 fc	 movzx	 eax, WORD PTR $T5[ebp]
  00125	0f b7 4d fa	 movzx	 ecx, WORD PTR $T4[ebp]
  00129	3b c1		 cmp	 eax, ecx
  0012b	75 09		 jne	 SHORT $LN29@xsputn
  0012d	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  00134	eb 04		 jmp	 SHORT $LN30@xsputn
$LN29@xsputn:
  00136	83 65 e8 00	 and	 DWORD PTR tv79[ebp], 0
$LN30@xsputn:
  0013a	8a 45 e8	 mov	 al, BYTE PTR tv79[ebp]
  0013d	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 346  :             } else if (_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr)))) {

  00140	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00144	85 c0		 test	 eax, eax
  00146	74 04		 je	 SHORT $LN7@xsputn

; 347  :                 break; // single character put failed, quit

  00148	eb 21		 jmp	 SHORT $LN3@xsputn

; 348  :             } else { // count character successfully put

  0014a	eb 1a		 jmp	 SHORT $LN5@xsputn
$LN7@xsputn:

; 349  :                 ++_Ptr;

  0014c	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0014f	40		 inc	 eax
  00150	40		 inc	 eax
  00151	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax

; 350  :                 --_Count;

  00154	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00157	83 e8 01	 sub	 eax, 1
  0015a	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  0015d	83 d9 00	 sbb	 ecx, 0
  00160	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  00163	89 4d 10	 mov	 DWORD PTR __Count$[ebp+4], ecx
$LN5@xsputn:

; 351  :             }
; 352  :         }

  00166	e9 aa fe ff ff	 jmp	 $LN2@xsputn
$LN3@xsputn:

; 353  : 
; 354  :         return _Start_count - _Count;

  0016b	8b 45 d0	 mov	 eax, DWORD PTR __Start_count$[ebp]
  0016e	2b 45 0c	 sub	 eax, DWORD PTR __Count$[ebp]
  00171	8b 55 d4	 mov	 edx, DWORD PTR __Start_count$[ebp+4]
  00174	1b 55 10	 sbb	 edx, DWORD PTR __Count$[ebp+4]

; 355  :     }

  00177	c9		 leave
  00178	c2 0c 00	 ret	 12			; 0000000cH
?xsputn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPB_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsputn
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z
_TEXT	SEGMENT
__Start_count$ = -48					; size = 8
__Size$1 = -40						; size = 8
$T2 = -32						; size = 4
tv148 = -28						; size = 4
__Off$ = -24						; size = 4
tv134 = -20						; size = 4
_this$ = -16						; size = 4
$T3 = -12						; size = 2
$T4 = -10						; size = 2
__Meta$5 = -8						; size = 2
$T6 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn, COMDAT
; _this$ = ecx

; 303  :     virtual streamsize __CLR_OR_THIS_CALL xsgetn(_Elem* _Ptr, streamsize _Count) { // get _Count characters from stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 304  :         const streamsize _Start_count = _Count;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  0000f	89 45 d0	 mov	 DWORD PTR __Start_count$[ebp], eax
  00012	89 4d d4	 mov	 DWORD PTR __Start_count$[ebp+4], ecx
$LN2@xsgetn:

; 305  : 
; 306  :         while (0 < _Count) {

  00015	83 7d 10 00	 cmp	 DWORD PTR __Count$[ebp+4], 0
  00019	0f 8c 4f 01 00
	00		 jl	 $LN3@xsgetn
  0001f	7f 0a		 jg	 SHORT $LN31@xsgetn
  00021	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00025	0f 86 43 01 00
	00		 jbe	 $LN3@xsgetn
$LN31@xsgetn:

; 231  :         return *_IGnext ? *_IGcount : 0;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00031	83 38 00	 cmp	 DWORD PTR [eax], 0
  00034	74 0d		 je	 SHORT $LN11@xsgetn
  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 ec	 mov	 DWORD PTR tv134[ebp], eax
  00041	eb 04		 jmp	 SHORT $LN9@xsgetn
$LN11@xsgetn:
  00043	83 65 ec 00	 and	 DWORD PTR tv134[ebp], 0
$LN9@xsgetn:
  00047	8b 45 ec	 mov	 eax, DWORD PTR tv134[ebp]
  0004a	99		 cdq

; 307  :             streamsize _Size = _Gnavail();

  0004b	89 45 d8	 mov	 DWORD PTR __Size$1[ebp], eax
  0004e	89 55 dc	 mov	 DWORD PTR __Size$1[ebp+4], edx

; 308  :             if (0 < _Size) { // copy from read buffer

  00051	83 7d dc 00	 cmp	 DWORD PTR __Size$1[ebp+4], 0
  00055	0f 8c a1 00 00
	00		 jl	 $LN4@xsgetn
  0005b	7f 0a		 jg	 SHORT $LN32@xsgetn
  0005d	83 7d d8 00	 cmp	 DWORD PTR __Size$1[ebp], 0
  00061	0f 86 95 00 00
	00		 jbe	 $LN4@xsgetn
$LN32@xsgetn:

; 309  :                 if (_Count < _Size) {

  00067	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0006a	3b 45 dc	 cmp	 eax, DWORD PTR __Size$1[ebp+4]
  0006d	7f 16		 jg	 SHORT $LN6@xsgetn
  0006f	7c 08		 jl	 SHORT $LN33@xsgetn
  00071	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00074	3b 45 d8	 cmp	 eax, DWORD PTR __Size$1[ebp]
  00077	73 0c		 jae	 SHORT $LN6@xsgetn
$LN33@xsgetn:

; 310  :                     _Size = _Count;

  00079	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0007c	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  0007f	89 45 d8	 mov	 DWORD PTR __Size$1[ebp], eax
  00082	89 4d dc	 mov	 DWORD PTR __Size$1[ebp+4], ecx
$LN6@xsgetn:

; 185  :         return *_IGnext;

  00085	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0008b	8b 00		 mov	 eax, DWORD PTR [eax]
  0008d	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax

; 311  :                 }
; 312  : 
; 313  :                 _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));

  00090	8b 45 d8	 mov	 eax, DWORD PTR __Size$1[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00093	d1 e0		 shl	 eax, 1
  00095	50		 push	 eax
  00096	ff 75 e0	 push	 DWORD PTR $T2[ebp]
  00099	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0009c	e8 00 00 00 00	 call	 _memcpy
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 314  :                 _Ptr += _Size;

  000a4	6a 00		 push	 0
  000a6	6a 02		 push	 2
  000a8	ff 75 dc	 push	 DWORD PTR __Size$1[ebp+4]
  000ab	ff 75 d8	 push	 DWORD PTR __Size$1[ebp]
  000ae	e8 00 00 00 00	 call	 __allmul
  000b3	03 45 08	 add	 eax, DWORD PTR __Ptr$[ebp]
  000b6	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax

; 315  :                 _Count -= _Size;

  000b9	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000bc	2b 45 d8	 sub	 eax, DWORD PTR __Size$1[ebp]
  000bf	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  000c2	1b 4d dc	 sbb	 ecx, DWORD PTR __Size$1[ebp+4]
  000c5	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  000c8	89 4d 10	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 316  :                 gbump(static_cast<int>(_Size));

  000cb	8b 45 d8	 mov	 eax, DWORD PTR __Size$1[ebp]
  000ce	89 45 e8	 mov	 DWORD PTR __Off$[ebp], eax

; 201  :         *_IGcount -= _Off;

  000d1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]
  000d9	2b 45 e8	 sub	 eax, DWORD PTR __Off$[ebp]
  000dc	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  000e2	89 01		 mov	 DWORD PTR [ecx], eax

; 202  :         *_IGnext += _Off;

  000e4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000ea	8b 00		 mov	 eax, DWORD PTR [eax]
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR __Off$[ebp]
  000ef	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  000f2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  000f8	89 01		 mov	 DWORD PTR [ecx], eax

; 317  :             } else {

  000fa	eb 6d		 jmp	 SHORT $LN5@xsgetn
$LN4@xsgetn:

; 318  :                 const int_type _Meta = uflow();

  000fc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ff	8b 00		 mov	 eax, DWORD PTR [eax]
  00101	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00104	ff 50 1c	 call	 DWORD PTR [eax+28]
  00107	66 89 45 f8	 mov	 WORD PTR __Meta$5[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0010b	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00110	66 89 45 f6	 mov	 WORD PTR $T4[ebp], ax

; 301  :         return _Left == _Right;

  00114	0f b7 45 f6	 movzx	 eax, WORD PTR $T4[ebp]
  00118	0f b7 4d f8	 movzx	 ecx, WORD PTR __Meta$5[ebp]
  0011c	3b c1		 cmp	 eax, ecx
  0011e	75 09		 jne	 SHORT $LN25@xsgetn
  00120	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv148[ebp], 1
  00127	eb 04		 jmp	 SHORT $LN26@xsgetn
$LN25@xsgetn:
  00129	83 65 e4 00	 and	 DWORD PTR tv148[ebp], 0
$LN26@xsgetn:
  0012d	8a 45 e4	 mov	 al, BYTE PTR tv148[ebp]
  00130	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 319  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

  00133	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00137	85 c0		 test	 eax, eax
  00139	74 02		 je	 SHORT $LN7@xsgetn

; 320  :                     break; // end of file, quit

  0013b	eb 31		 jmp	 SHORT $LN3@xsgetn
$LN7@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 293  :         return _Meta;

  0013d	66 8b 45 f8	 mov	 ax, WORD PTR __Meta$5[ebp]
  00141	66 89 45 f4	 mov	 WORD PTR $T3[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 324  :                 *_Ptr++ = _Traits::to_char_type(_Meta);

  00145	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00148	66 8b 4d f4	 mov	 cx, WORD PTR $T3[ebp]
  0014c	66 89 08	 mov	 WORD PTR [eax], cx
  0014f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00152	40		 inc	 eax
  00153	40		 inc	 eax
  00154	89 45 08	 mov	 DWORD PTR __Ptr$[ebp], eax

; 325  :                 --_Count;

  00157	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0015a	83 e8 01	 sub	 eax, 1
  0015d	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  00160	83 d9 00	 sbb	 ecx, 0
  00163	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
  00166	89 4d 10	 mov	 DWORD PTR __Count$[ebp+4], ecx
$LN5@xsgetn:

; 326  :             }
; 327  :         }

  00169	e9 a7 fe ff ff	 jmp	 $LN2@xsgetn
$LN3@xsgetn:

; 328  : 
; 329  :         return _Start_count - _Count;

  0016e	8b 45 d0	 mov	 eax, DWORD PTR __Start_count$[ebp]
  00171	2b 45 0c	 sub	 eax, DWORD PTR __Count$[ebp]
  00174	8b 55 d4	 mov	 edx, DWORD PTR __Start_count$[ebp+4]
  00177	1b 55 10	 sbb	 edx, DWORD PTR __Count$[ebp+4]

; 330  :     }

  0017a	c9		 leave
  0017b	c2 0c 00	 ret	 12			; 0000000cH
?xsgetn@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JPA_W_J@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
tv82 = -20						; size = 4
_this$ = -16						; size = 4
$T2 = -12						; size = 2
$T3 = -10						; size = 2
$T4 = -8						; size = 2
$T5 = -6						; size = 2
tv79 = -4						; size = 2
$T6 = -1						; size = 1
?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow, COMDAT
; _this$ = ecx

; 299  :     virtual int_type __CLR_OR_THIS_CALL uflow() { // get a character from stream, point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 300  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	ff 50 18	 call	 DWORD PTR [eax+24]
  00014	66 89 45 f8	 mov	 WORD PTR $T4[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00018	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0001d	66 89 45 fa	 mov	 WORD PTR $T5[ebp], ax

; 301  :         return _Left == _Right;

  00021	0f b7 45 fa	 movzx	 eax, WORD PTR $T5[ebp]
  00025	0f b7 4d f8	 movzx	 ecx, WORD PTR $T4[ebp]
  00029	3b c1		 cmp	 eax, ecx
  0002b	75 09		 jne	 SHORT $LN10@uflow
  0002d	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  00034	eb 04		 jmp	 SHORT $LN11@uflow
$LN10@uflow:
  00036	83 65 ec 00	 and	 DWORD PTR tv82[ebp], 0
$LN11@uflow:
  0003a	8a 45 ec	 mov	 al, BYTE PTR tv82[ebp]
  0003d	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 300  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());

  00040	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00044	85 c0		 test	 eax, eax
  00046	74 13		 je	 SHORT $LN3@uflow
  00048	66 8b 45 f6	 mov	 ax, WORD PTR $T3[ebp]
  0004c	66 89 45 fc	 mov	 WORD PTR tv79[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00050	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00055	66 89 45 fc	 mov	 WORD PTR tv79[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 300  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());

  00059	eb 40		 jmp	 SHORT $LN4@uflow
$LN3@uflow:

; 221  :         --*_IGcount;

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  00061	8b 00		 mov	 eax, DWORD PTR [eax]
  00063	48		 dec	 eax
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  0006a	89 01		 mov	 DWORD PTR [ecx], eax

; 222  :         return (*_IGnext)++;

  0006c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
  00077	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	40		 inc	 eax
  00080	40		 inc	 eax
  00081	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00087	89 01		 mov	 DWORD PTR [ecx], eax

; 300  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());

  00089	66 8b 45 f4	 mov	 ax, WORD PTR $T2[ebp]
  0008d	66 89 45 fc	 mov	 WORD PTR tv79[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00091	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00094	66 8b 00	 mov	 ax, WORD PTR [eax]
  00097	66 89 45 fc	 mov	 WORD PTR tv79[ebp], ax
$LN4@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 300  :         return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());

  0009b	66 8b 45 fc	 mov	 ax, WORD PTR tv79[ebp]

; 301  :     }

  0009f	c9		 leave
  000a0	c3		 ret	 0
?uflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::uflow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow, COMDAT
; _this$ = ecx

; 295  :     virtual int_type __CLR_OR_THIS_CALL underflow() { // get a character from stream, but don't point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00008	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000d	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 296  :         return _Traits::eof();

  00011	66 8b 45 fe	 mov	 ax, WORD PTR $T1[ebp]

; 297  :     }

  00015	c9		 leave
  00016	c3		 ret	 0
?underflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::underflow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc, COMDAT
; _this$ = ecx

; 291  :     virtual streamsize __CLR_OR_THIS_CALL showmanyc() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 292  :         return 0;

  00007	33 c0		 xor	 eax, eax
  00009	33 d2		 xor	 edx, edx

; 293  :     }

  0000b	c9		 leave
  0000c	c3		 ret	 0
?showmanyc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAE_JXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::showmanyc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
___formal$ = 8						; size = 2
?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail, COMDAT
; _this$ = ecx

; 286  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type = _Traits::eof()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00008	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000d	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 288  :         return _Traits::eof();

  00011	66 8b 45 fe	 mov	 ax, WORD PTR $T1[ebp]

; 289  :     }

  00015	c9		 leave
  00016	c2 04 00	 ret	 4
?pbackfail@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
___formal$ = 8						; size = 2
?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow, COMDAT
; _this$ = ecx

; 282  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type = _Traits::eof()) { // put a character to stream (always fail)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00008	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000d	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 283  :         return _Traits::eof();

  00011	66 8b 45 fe	 mov	 ax, WORD PTR $T1[ebp]

; 284  :     }

  00015	c9		 leave
  00016	c2 04 00	 ret	 4
?overflow@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@MAEGG@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::overflow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init, COMDAT
; _this$ = ecx

; 261  :     void __CLR_OR_THIS_CALL _Init() { // initialize buffer parameters for no buffers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  :         _IGfirst = &_Gfirst;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 263  :         _IPfirst = &_Pfirst;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 264  :         _IGnext  = &_Gnext;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	83 c0 14	 add	 eax, 20			; 00000014H
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 265  :         _IPnext  = &_Pnext;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 18	 add	 eax, 24			; 00000018H
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 266  :         _IGcount = &_Gcount;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 c0 24	 add	 eax, 36			; 00000024H
  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 267  :         _IPcount = &_Pcount;

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 28	 add	 eax, 40			; 00000028H
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 240  :         *_IPfirst = _First;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00055	83 20 00	 and	 DWORD PTR [eax], 0

; 241  :         *_IPnext  = _First;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0005e	83 20 00	 and	 DWORD PTR [eax], 0

; 242  :         *_IPcount = static_cast<int>(_Last - _First);

  00061	33 c0		 xor	 eax, eax
  00063	d1 f8		 sar	 eax, 1
  00065	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  0006b	89 01		 mov	 DWORD PTR [ecx], eax

; 206  :         *_IGfirst = _First;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00073	83 20 00	 and	 DWORD PTR [eax], 0

; 207  :         *_IGnext  = _Next;

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0007c	83 20 00	 and	 DWORD PTR [eax], 0

; 208  :         *_IGcount = static_cast<int>(_Last - _Next);

  0007f	33 c0		 xor	 eax, eax
  00081	d1 f8		 sar	 eax, 1
  00083	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00089	89 01		 mov	 DWORD PTR [ecx], eax

; 268  :         setp(nullptr, nullptr);
; 269  :         setg(nullptr, nullptr, nullptr);
; 270  :     }

  0008b	c9		 leave
  0008c	c3		 ret	 0
?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc, COMDAT
; _this$ = ecx

; 252  :     _Elem* __CLR_OR_THIS_CALL _Pninc() { // increment current position in write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 253  :         --*_IPcount;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	48		 dec	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 49 30	 mov	 ecx, DWORD PTR [ecx+48]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 254  :         return (*_IPnext)++;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	40		 inc	 eax
  0002d	40		 inc	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00034	89 01		 mov	 DWORD PTR [ecx], eax
  00036	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]

; 255  :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?_Gnpreinc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Gnpreinc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 225  :     _Elem* __CLR_OR_THIS_CALL _Gnpreinc() { // preincrement current position in read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  :         --*_IGcount;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	48		 dec	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 227  :         return ++(*_IGnext);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	40		 inc	 eax
  00022	40		 inc	 eax
  00023	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR tv72[ebp]
  0002f	89 08		 mov	 DWORD PTR [eax], ecx
  00031	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]

; 228  :     }

  00034	c9		 leave
  00035	c3		 ret	 0
?_Gnpreinc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnpreinc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc, COMDAT
; _this$ = ecx

; 220  :     _Elem* __CLR_OR_THIS_CALL _Gninc() { // increment current position in read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 221  :         --*_IGcount;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	48		 dec	 eax
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00017	89 01		 mov	 DWORD PTR [ecx], eax

; 222  :         return (*_IGnext)++;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	40		 inc	 eax
  0002d	40		 inc	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  00034	89 01		 mov	 DWORD PTR [ecx], eax
  00036	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]

; 223  :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock, COMDAT
; _this$ = ecx

; 177  :     virtual void __CLR_OR_THIS_CALL _Unlock() {} // clear the thread lock (overridden by basic_filebuf)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?_Unlock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock, COMDAT
; _this$ = ecx

; 175  :     virtual void __CLR_OR_THIS_CALL _Lock() {} // set the thread lock (overridden by basic_filebuf)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?_Lock@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAEXXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Lock
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z
_TEXT	SEGMENT
tv90 = -28						; size = 8
$T1 = -20						; size = 2
$T2 = -16						; size = 4
tv84 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 2
tv78 = -2						; size = 2
__Ch$ = 8						; size = 2
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc, COMDAT
; _this$ = ecx

; 166  :     int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 258  :         return *_IPnext ? *_IPcount : 0;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 0d		 je	 SHORT $LN7@sputc
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0001f	eb 04		 jmp	 SHORT $LN5@sputc
$LN7@sputc:
  00021	83 65 f4 00	 and	 DWORD PTR tv84[ebp], 0
$LN5@sputc:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv84[ebp]
  00028	99		 cdq

; 167  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00029	89 45 e4	 mov	 DWORD PTR tv90[ebp], eax
  0002c	89 55 e8	 mov	 DWORD PTR tv90[ebp+4], edx
  0002f	83 7d e8 00	 cmp	 DWORD PTR tv90[ebp+4], 0
  00033	7c 31		 jl	 SHORT $LN3@sputc
  00035	7f 06		 jg	 SHORT $LN17@sputc
  00037	83 7d e4 00	 cmp	 DWORD PTR tv90[ebp], 0
  0003b	76 29		 jbe	 SHORT $LN3@sputc
$LN17@sputc:
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Pninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Pninc
  00045	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00048	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0004b	66 8b 4d 08	 mov	 cx, WORD PTR __Ch$[ebp]
  0004f	66 89 08	 mov	 WORD PTR [eax], cx
  00052	66 8b 45 fc	 mov	 ax, WORD PTR $T3[ebp]
  00056	66 89 45 fe	 mov	 WORD PTR tv78[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  0005a	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005d	66 8b 00	 mov	 ax, WORD PTR [eax]
  00060	66 89 45 fe	 mov	 WORD PTR tv78[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 167  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00064	eb 1a		 jmp	 SHORT $LN4@sputc
$LN3@sputc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00066	66 8b 45 08	 mov	 ax, WORD PTR __Ch$[ebp]
  0006a	66 89 45 ec	 mov	 WORD PTR $T1[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 167  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  0006e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	ff 50 0c	 call	 DWORD PTR [eax+12]
  0007c	66 89 45 fe	 mov	 WORD PTR tv78[ebp], ax
$LN4@sputc:
  00080	66 8b 45 fe	 mov	 ax, WORD PTR tv78[ebp]

; 168  :     }

  00084	c9		 leave
  00085	c2 04 00	 ret	 4
?sputc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEG_W@Z ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sputc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
_TEXT	SEGMENT
tv131 = -40						; size = 8
__Ch$ = -32						; size = 4
tv91 = -28						; size = 4
tv89 = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -14						; size = 2
$T2 = -12						; size = 2
$T3 = -10						; size = 2
$T4 = -8						; size = 2
tv83 = -6						; size = 2
tv82 = -4						; size = 2
$T5 = -1						; size = 1
?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::snextc, COMDAT
; _this$ = ecx

; 139  :     int_type __CLR_OR_THIS_CALL snextc() { // point to next character and return it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :         return *_IGnext ? *_IGcount : 0;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 0d		 je	 SHORT $LN9@snextc
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 e8	 mov	 DWORD PTR tv89[ebp], eax
  0001f	eb 04		 jmp	 SHORT $LN7@snextc
$LN9@snextc:
  00021	83 65 e8 00	 and	 DWORD PTR tv89[ebp], 0
$LN7@snextc:
  00025	8b 45 e8	 mov	 eax, DWORD PTR tv89[ebp]
  00028	99		 cdq

; 140  :         return 1 < _Gnavail() ? _Traits::to_int_type(*_Gnpreinc())

  00029	89 45 d8	 mov	 DWORD PTR tv131[ebp], eax
  0002c	89 55 dc	 mov	 DWORD PTR tv131[ebp+4], edx
  0002f	83 7d dc 00	 cmp	 DWORD PTR tv131[ebp+4], 0
  00033	7c 27		 jl	 SHORT $LN5@snextc
  00035	7f 06		 jg	 SHORT $LN53@snextc
  00037	83 7d d8 01	 cmp	 DWORD PTR tv131[ebp], 1
  0003b	76 1f		 jbe	 SHORT $LN5@snextc
$LN53@snextc:
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Gnpreinc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gnpreinc
  00045	89 45 e0	 mov	 DWORD PTR __Ch$[ebp], eax
  00048	66 8b 45 f4	 mov	 ax, WORD PTR $T2[ebp]
  0004c	66 89 45 fa	 mov	 WORD PTR tv83[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00050	8b 45 e0	 mov	 eax, DWORD PTR __Ch$[ebp]
  00053	66 8b 00	 mov	 ax, WORD PTR [eax]
  00056	66 89 45 fa	 mov	 WORD PTR tv83[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 140  :         return 1 < _Gnavail() ? _Traits::to_int_type(*_Gnpreinc())

  0005a	eb 63		 jmp	 SHORT $LN6@snextc
$LN5@snextc:
  0005c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sbumpc
  00064	66 89 45 f6	 mov	 WORD PTR $T3[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  00068	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0006d	66 89 45 f8	 mov	 WORD PTR $T4[ebp], ax

; 301  :         return _Left == _Right;

  00071	0f b7 45 f8	 movzx	 eax, WORD PTR $T4[ebp]
  00075	0f b7 4d f6	 movzx	 ecx, WORD PTR $T3[ebp]
  00079	3b c1		 cmp	 eax, ecx
  0007b	75 09		 jne	 SHORT $LN34@snextc
  0007d	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00084	eb 04		 jmp	 SHORT $LN35@snextc
$LN34@snextc:
  00086	83 65 e4 00	 and	 DWORD PTR tv91[ebp], 0
$LN35@snextc:
  0008a	8a 45 e4	 mov	 al, BYTE PTR tv91[ebp]
  0008d	88 45 ff	 mov	 BYTE PTR $T5[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 140  :         return 1 < _Gnavail() ? _Traits::to_int_type(*_Gnpreinc())

  00090	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00094	85 c0		 test	 eax, eax
  00096	74 13		 je	 SHORT $LN3@snextc
  00098	66 8b 45 f2	 mov	 ax, WORD PTR $T1[ebp]
  0009c	66 89 45 fc	 mov	 WORD PTR tv82[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  000a0	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  000a5	66 89 45 fc	 mov	 WORD PTR tv82[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 140  :         return 1 < _Gnavail() ? _Traits::to_int_type(*_Gnpreinc())

  000a9	eb 0c		 jmp	 SHORT $LN4@snextc
$LN3@snextc:
  000ab	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sgetc
  000b3	66 89 45 fc	 mov	 WORD PTR tv82[ebp], ax
$LN4@snextc:
  000b7	66 8b 45 fc	 mov	 ax, WORD PTR tv82[ebp]
  000bb	66 89 45 fa	 mov	 WORD PTR tv83[ebp], ax
$LN6@snextc:
  000bf	66 8b 45 fa	 mov	 ax, WORD PTR tv83[ebp]

; 141  :                               : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof() : sgetc();
; 142  :     }

  000c3	c9		 leave
  000c4	c3		 ret	 0
?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::snextc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
_TEXT	SEGMENT
tv91 = -24						; size = 8
$T1 = -16						; size = 4
tv81 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 2
tv75 = -2						; size = 2
?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sgetc, COMDAT
; _this$ = ecx

; 130  :     int_type __CLR_OR_THIS_CALL sgetc() { // get a character and don't point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :         return *_IGnext ? *_IGcount : 0;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 0d		 je	 SHORT $LN7@sgetc
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
  0001f	eb 04		 jmp	 SHORT $LN5@sgetc
$LN7@sgetc:
  00021	83 65 f4 00	 and	 DWORD PTR tv81[ebp], 0
$LN5@sgetc:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv81[ebp]
  00028	99		 cdq

; 131  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00029	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  0002c	89 55 ec	 mov	 DWORD PTR tv91[ebp+4], edx
  0002f	83 7d ec 00	 cmp	 DWORD PTR tv91[ebp+4], 0
  00033	7c 27		 jl	 SHORT $LN3@sgetc
  00035	7f 06		 jg	 SHORT $LN14@sgetc
  00037	83 7d e8 00	 cmp	 DWORD PTR tv91[ebp], 0
  0003b	76 1f		 jbe	 SHORT $LN3@sgetc
$LN14@sgetc:

; 185  :         return *_IGnext;

  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]
  00045	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 131  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00048	66 8b 45 fc	 mov	 ax, WORD PTR $T2[ebp]
  0004c	66 89 45 fe	 mov	 WORD PTR tv75[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00050	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00053	66 8b 00	 mov	 ax, WORD PTR [eax]
  00056	66 89 45 fe	 mov	 WORD PTR tv75[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 131  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  0005a	eb 0f		 jmp	 SHORT $LN4@sgetc
$LN3@sgetc:
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	ff 50 18	 call	 DWORD PTR [eax+24]
  00067	66 89 45 fe	 mov	 WORD PTR tv75[ebp], ax
$LN4@sgetc:
  0006b	66 8b 45 fe	 mov	 ax, WORD PTR tv75[ebp]

; 132  :     }

  0006f	c9		 leave
  00070	c3		 ret	 0
?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sgetc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ
_TEXT	SEGMENT
tv86 = -24						; size = 8
__Ch$ = -16						; size = 4
tv81 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 2
tv75 = -2						; size = 2
?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sbumpc, COMDAT
; _this$ = ecx

; 126  :     int_type __CLR_OR_THIS_CALL sbumpc() { // get a character and point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 231  :         return *_IGnext ? *_IGcount : 0;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0000f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00012	74 0d		 je	 SHORT $LN7@sbumpc
  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
  0001f	eb 04		 jmp	 SHORT $LN5@sbumpc
$LN7@sbumpc:
  00021	83 65 f4 00	 and	 DWORD PTR tv81[ebp], 0
$LN5@sbumpc:
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv81[ebp]
  00028	99		 cdq

; 127  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00029	89 45 e8	 mov	 DWORD PTR tv86[ebp], eax
  0002c	89 55 ec	 mov	 DWORD PTR tv86[ebp+4], edx
  0002f	83 7d ec 00	 cmp	 DWORD PTR tv86[ebp+4], 0
  00033	7c 27		 jl	 SHORT $LN3@sbumpc
  00035	7f 06		 jg	 SHORT $LN14@sbumpc
  00037	83 7d e8 00	 cmp	 DWORD PTR tv86[ebp], 0
  0003b	76 1f		 jbe	 SHORT $LN3@sbumpc
$LN14@sbumpc:
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Gninc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEPA_WXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Gninc
  00045	89 45 f0	 mov	 DWORD PTR __Ch$[ebp], eax
  00048	66 8b 45 fc	 mov	 ax, WORD PTR $T1[ebp]
  0004c	66 89 45 fe	 mov	 WORD PTR tv75[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 297  :         return _Ch;

  00050	8b 45 f0	 mov	 eax, DWORD PTR __Ch$[ebp]
  00053	66 8b 00	 mov	 ax, WORD PTR [eax]
  00056	66 89 45 fe	 mov	 WORD PTR tv75[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 127  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  0005a	eb 0f		 jmp	 SHORT $LN4@sbumpc
$LN3@sbumpc:
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	ff 50 1c	 call	 DWORD PTR [eax+28]
  00067	66 89 45 fe	 mov	 WORD PTR tv75[ebp], ax
$LN4@sbumpc:
  0006b	66 8b 45 fe	 mov	 ax, WORD PTR tv75[ebp]

; 128  :     }

  0006f	c9		 leave
  00070	c3		 ret	 0
?sbumpc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sbumpc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ?getloc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
__Right$ = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QBE?AVlocale@2@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::getloc, COMDAT
; _this$ = ecx

; 113  :     locale __CLR_OR_THIS_CALL getloc() const { // get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 65 fc 00	 and	 DWORD PTR $T1[ebp], 0

; 114  :         return *_Plocale;

  0000d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00013	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 268  :         _Ptr->_Incref();

  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00028	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 114  :         return *_Plocale;

  00033	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00036	83 c8 01	 or	 eax, 1
  00039	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0003c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 115  :     }

  0003f	c9		 leave
  00040	c2 04 00	 ret	 4
?getloc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QBE?AVlocale@2@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::getloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
tv70 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 69   :     virtual __CLR_OR_THIS_CALL ~basic_streambuf() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@

; 70   :         delete _Plocale;

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00018	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  0001b	83 7d fc 00	 cmp	 DWORD PTR $T2[ebp], 0
  0001f	74 2a		 je	 SHORT $LN3@basic_stre
  00021	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00024	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  0002a	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0002f	33 c0		 xor	 eax, eax
  00031	40		 inc	 eax
  00032	83 e0 01	 and	 eax, 1
  00035	74 0c		 je	 SHORT $LN6@basic_stre
  00037	6a 08		 push	 8
  00039	ff 75 fc	 push	 DWORD PTR $T2[ebp]
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx
$LN6@basic_stre:
  00043	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  00049	eb 04		 jmp	 SHORT $LN2@basic_stre
$LN3@basic_stre:
  0004b	83 65 f4 00	 and	 DWORD PTR tv70[ebp], 0
$LN2@basic_stre:

; 71   :     }

  0004f	c9		 leave
  00050	c3		 ret	 0
??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf
;	COMDAT ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
_TEXT	SEGMENT
tv74 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ PROC ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 25   :     __CLR_OR_THIS_CALL basic_streambuf() : _Plocale(new locale) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@6B@
  00031	6a 08		 push	 8
  00033	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00038	59		 pop	 ecx
  00039	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  0003c	83 7d ec 00	 cmp	 DWORD PTR $T2[ebp], 0
  00040	74 1e		 je	 SHORT $LN3@basic_stre
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 271  :     locale() noexcept : _Ptr(_Init(true)) {}

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00046	6a 01		 push	 1
  00048	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  0004d	59		 pop	 ecx
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00051	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00054	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\streambuf

; 25   :     __CLR_OR_THIS_CALL basic_streambuf() : _Plocale(new locale) {

  00058	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  0005b	89 45 e8	 mov	 DWORD PTR tv74[ebp], eax
  0005e	eb 04		 jmp	 SHORT $LN4@basic_stre
$LN3@basic_stre:
  00060	83 65 e8 00	 and	 DWORD PTR tv74[ebp], 0
$LN4@basic_stre:
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d e8	 mov	 ecx, DWORD PTR tv74[ebp]
  0006a	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 26   :         _Init();

  0006d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Init@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAEXXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::_Init

; 27   :     }

  00075	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00082	59		 pop	 ecx
  00083	c9		 leave
  00084	c3		 ret	 0
  00085	cc		 int	 3
  00086	cc		 int	 3
  00087	cc		 int	 3
  00088	cc		 int	 3
  00089	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ENDP ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 944  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 90	 mov	 eax, DWORD PTR [eax-112]
  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 44 01 90 00
	00 00 00	 mov	 DWORD PTR [ecx+eax-112], OFFSET ??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 90	 mov	 eax, DWORD PTR [eax-112]
  00022	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00025	83 e8 70	 sub	 eax, 112		; 00000070H
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 49 90	 mov	 ecx, DWORD PTR [ecx-112]
  0002e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	89 44 0a 8c	 mov	 DWORD PTR [edx+ecx-116], eax
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	83 e9 60	 sub	 ecx, 96			; 00000060H
  0003e	e8 00 00 00 00	 call	 ??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >
  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 e8 58	 sub	 eax, 88			; 00000058H
  00049	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 72   :     virtual __CLR_OR_THIS_CALL ~basic_istream() noexcept {}

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 40 e8	 mov	 eax, DWORD PTR [eax-24]
  00052	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	c7 44 01 e8 00
	00 00 00	 mov	 DWORD PTR [ecx+eax-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 40 e8	 mov	 eax, DWORD PTR [eax-24]
  00066	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00069	83 e8 18	 sub	 eax, 24			; 00000018H
  0006c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8b 49 e8	 mov	 ecx, DWORD PTR [ecx-24]
  00072	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00075	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00078	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 944  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept {}

  0007c	c9		 leave
  0007d	c3		 ret	 0
??1?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::~basic_ifstream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream
;	COMDAT ??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z
_TEXT	SEGMENT
$T2 = -44						; size = 4
$T3 = -40						; size = 4
tv155 = -36						; size = 4
$T4 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Filename$ = 8						; size = 4
__Mode$ = 12						; size = 4
__Prot$ = 16						; size = 4
_$initVBases$ = 20					; size = 4
??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z PROC ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::basic_ifstream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 806  :     explicit basic_ifstream(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	83 65 e0 00	 and	 DWORD PTR $T4[ebp], 0

; 808  :         : _Mybase(_STD addressof(_Filebuffer)) {

  0002c	83 7d 14 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00030	74 31		 je	 SHORT $LN2@basic_ifst
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_8?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@7B@
  0003b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 70	 add	 eax, 112		; 00000070H
  00041	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 460  :     __CLR_OR_THIS_CALL ios_base() {}

  00044	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 161  :     __CLR_OR_THIS_CALL basic_ios() {}

  0004d	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 808  :         : _Mybase(_STD addressof(_Filebuffer)) {

  00056	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005a	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0005d	83 c8 01	 or	 eax, 1
  00060	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
$LN2@basic_ifst:
  00063	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00066	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00069	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 808  :         : _Mybase(_STD addressof(_Filebuffer)) {

  0006c	6a 00		 push	 0
  0006e	6a 00		 push	 0
  00070	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >
  0007b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 00		 mov	 eax, DWORD PTR [eax]
  00087	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], OFFSET ??_7?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@6B@
  00094	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0009c	83 e8 70	 sub	 eax, 112		; 00000070H
  0009f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a4	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000a7	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000aa	89 44 0a fc	 mov	 DWORD PTR [edx+ecx-4], eax
  000ae	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	83 c0 10	 add	 eax, 16			; 00000010H
  000b4	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 162  :     basic_filebuf() : _Mysb() {

  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ??0?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@IAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
  000bf	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@6B@

; 163  :         _Init(nullptr, _Newfl);

  000cc	6a 00		 push	 0
  000ce	6a 00		 push	 0
  000d0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@IAEXPAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::_Init

; 808  :         : _Mybase(_STD addressof(_Filebuffer)) {

  000d8	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 809  :         // _Prot is an extension
; 810  :         if (!_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot)) {

  000dc	ff 75 10	 push	 DWORD PTR __Prot$[ebp]
  000df	8b 45 0c	 mov	 eax, DWORD PTR __Mode$[ebp]
  000e2	83 c8 01	 or	 eax, 1
  000e5	50		 push	 eax
  000e6	ff 75 08	 push	 DWORD PTR __Filename$[ebp]
  000e9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	83 c1 10	 add	 ecx, 16			; 00000010H
  000ef	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@QAEPAV12@PBDHH@Z ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::open
  000f4	85 c0		 test	 eax, eax
  000f6	75 41		 jne	 SHORT $LN1@basic_ifst

; 811  :             _Myios::setstate(ios_base::failbit);

  000f8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fb	8b 00		 mov	 eax, DWORD PTR [eax]
  000fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00103	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  00106	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00109	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0010c	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0010f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00112	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00116	74 06		 je	 SHORT $LN93@basic_ifst
  00118	83 65 dc 00	 and	 DWORD PTR tv155[ebp], 0
  0011c	eb 07		 jmp	 SHORT $LN94@basic_ifst
$LN93@basic_ifst:
  0011e	c7 45 dc 04 00
	00 00		 mov	 DWORD PTR tv155[ebp], 4
$LN94@basic_ifst:
  00125	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  00127	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  0012a	83 c8 02	 or	 eax, 2

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0012d	0b 45 dc	 or	 eax, DWORD PTR tv155[ebp]
  00130	50		 push	 eax
  00131	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00134	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN1@basic_ifst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\fstream

; 813  :     }

  00139	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0013d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00140	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00143	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014a	59		 pop	 ecx
  0014b	c9		 leave
  0014c	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z$0:
  00000	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN6@basic_ifst
  0000c	83 65 e0 fe	 and	 DWORD PTR $T4[ebp], -2	; fffffffeH
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 70	 add	 ecx, 112		; 00000070H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN6@basic_ifst:
  0001b	c3		 ret	 0
__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z$1:
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 18	 add	 ecx, 24			; 00000018H
  00022	e9 00 00 00 00	 jmp	 ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z$5:
  00027	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::~basic_streambuf<wchar_t,std::char_traits<wchar_t> >
__unwindfunclet$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z$2:
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 10	 add	 ecx, 16			; 00000010H
  00035	e9 00 00 00 00	 jmp	 ??1?$basic_filebuf@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >::~basic_filebuf<wchar_t,std::char_traits<wchar_t> >
  0003a	cc		 int	 3
  0003b	cc		 int	 3
  0003c	cc		 int	 3
  0003d	cc		 int	 3
  0003e	cc		 int	 3
__ehhandler$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z:
  0003f	90		 npad	 1
  00040	90		 npad	 1
  00041	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00045	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00048	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0004b	33 c8		 xor	 ecx, eax
  0004d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00052	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z
  00057	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z ENDP ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::basic_ifstream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
;	COMDAT ??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 18	 add	 eax, 24			; 00000018H
  0002e	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 72   :     virtual __CLR_OR_THIS_CALL ~basic_istream() noexcept {}

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 e8	 mov	 eax, DWORD PTR [eax-24]
  00037	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	c7 44 01 e8 00
	00 00 00	 mov	 DWORD PTR [ecx+eax-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00045	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 40 e8	 mov	 eax, DWORD PTR [eax-24]
  0004b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004e	83 e8 18	 sub	 eax, 24			; 00000018H
  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	8b 49 e8	 mov	 ecx, DWORD PTR [ecx-24]
  00057	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0005a	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0005d	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax
  00061	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 c0 18	 add	 eax, 24			; 00000018H
  00067	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 38   :     virtual __CLR_OR_THIS_CALL ~basic_ios() noexcept {}

  0006a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 451  :     virtual __CLR_OR_THIS_CALL ~ios_base() noexcept {

  00073	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00077	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 452  :         _Ios_base_dtor(this);

  00080	ff 75 ec	 push	 DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00088	59		 pop	 ecx

; 453  :     }

  00089	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	c9		 leave
  00099	c3		 ret	 0
  0009a	cc		 int	 3
  0009b	cc		 int	 3
  0009c	cc		 int	 3
  0009d	cc		 int	 3
  0009e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`vbase destructor'
; Function compile flags: /Odspy
;	COMDAT ??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 e9 18	 sub	 ecx, 24			; 00000018H
  0000d	e8 00 00 00 00	 call	 ??_D?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  00012	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	74 10		 je	 SHORT $LN2@scalar
  0001a	6a 60		 push	 96			; 00000060H
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 e8 18	 sub	 eax, 24			; 00000018H
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
$LN2@scalar:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 e8 18	 sub	 eax, 24			; 00000018H
  00030	c9		 leave
  00031	c2 04 00	 ret	 4
??_G?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
;	COMDAT ?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
$T2 = -136						; size = 8
$T3 = -128						; size = 4
$T4 = -124						; size = 4
$T5 = -120						; size = 4
$T6 = -116						; size = 4
$T7 = -112						; size = 2
$T8 = -108						; size = 4
$T9 = -104						; size = 4
tv243 = -100						; size = 4
tv240 = -96						; size = 4
$T10 = -92						; size = 4
$T11 = -88						; size = 4
$T12 = -84						; size = 4
tv216 = -80						; size = 4
tv377 = -76						; size = 4
tv145 = -72						; size = 4
__Ctype_fac$13 = -68					; size = 4
tv343 = -64						; size = 4
__Tied$ = -60						; size = 4
tv267 = -56						; size = 4
tv248 = -52						; size = 4
_this$ = -48						; size = 4
_this$ = -44						; size = 4
_this$ = -40						; size = 4
$T14 = -34						; size = 2
tv397 = -32						; size = 2
tv229 = -30						; size = 2
__Meta$15 = -28						; size = 2
tv396 = -23						; size = 1
$T16 = -22						; size = 1
__Eof$ = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Ipfx, COMDAT
; _this$ = ecx

; 116  :     bool __CLR_OR_THIS_CALL _Ipfx(bool _Noskip = false) { // test stream state and skip whitespace as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 78	 sub	 esp, 120		; 00000078H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0002f	83 65 80 00	 and	 DWORD PTR $T3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  00033	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  00042	89 45 ac	 mov	 DWORD PTR $T12[ebp], eax

; 295  :         return rdstate() == ios_base::goodbit;

  00045	83 7d ac 00	 cmp	 DWORD PTR $T12[ebp], 0
  00049	75 09		 jne	 SHORT $LN21@Ipfx
  0004b	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv248[ebp], 1
  00052	eb 04		 jmp	 SHORT $LN19@Ipfx
$LN21@Ipfx:
  00054	83 65 cc 00	 and	 DWORD PTR tv248[ebp], 0
$LN19@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 117  :         if (!this->good()) {

  00058	0f b6 45 cc	 movzx	 eax, BYTE PTR tv248[ebp]
  0005c	85 c0		 test	 eax, eax
  0005e	75 48		 jne	 SHORT $LN5@Ipfx

; 118  :             _Myios::setstate(ios_base::failbit);

  00060	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0006b	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  0006e	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00074	89 45 a8	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00077	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0007e	74 06		 je	 SHORT $LN31@Ipfx
  00080	83 65 c8 00	 and	 DWORD PTR tv267[ebp], 0
  00084	eb 07		 jmp	 SHORT $LN32@Ipfx
$LN31@Ipfx:
  00086	c7 45 c8 04 00
	00 00		 mov	 DWORD PTR tv267[ebp], 4
$LN32@Ipfx:
  0008d	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  0008f	8b 45 a8	 mov	 eax, DWORD PTR $T11[ebp]
  00092	83 c8 02	 or	 eax, 2

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00095	0b 45 c8	 or	 eax, DWORD PTR tv267[ebp]
  00098	50		 push	 eax
  00099	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 119  :             return false;

  000a1	32 c0		 xor	 al, al
  000a3	e9 08 02 00 00	 jmp	 $LN1@Ipfx
$LN5@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 70   :         return _Tiestr;

  000a8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 00		 mov	 eax, DWORD PTR [eax]
  000ad	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	8b 44 01 3c	 mov	 eax, DWORD PTR [ecx+eax+60]
  000b7	89 45 c4	 mov	 DWORD PTR __Tied$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 124  :         if (_Tied) {

  000ba	83 7d c4 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  000be	74 08		 je	 SHORT $LN6@Ipfx

; 125  :             _Tied->flush();

  000c0	8b 4d c4	 mov	 ecx, DWORD PTR __Tied$[ebp]
  000c3	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::flush
$LN6@Ipfx:

; 126  :         }
; 127  : 
; 128  :         bool _Eof = false;

  000c8	c6 45 eb 00	 mov	 BYTE PTR __Eof$[ebp], 0

; 129  :         if (!_Noskip && this->flags() & ios_base::skipws) { // skip whitespace

  000cc	0f b6 45 08	 movzx	 eax, BYTE PTR __Noskip$[ebp]
  000d0	85 c0		 test	 eax, eax
  000d2	0f 85 67 01 00
	00		 jne	 $LN7@Ipfx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 326  :         return _Fmtfl;

  000d8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000db	8b 00		 mov	 eax, DWORD PTR [eax]
  000dd	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	8b 44 01 14	 mov	 eax, DWORD PTR [ecx+eax+20]
  000e7	89 45 a4	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 129  :         if (!_Noskip && this->flags() & ios_base::skipws) { // skip whitespace

  000ea	8b 45 a4	 mov	 eax, DWORD PTR $T10[ebp]
  000ed	83 e0 01	 and	 eax, 1
  000f0	0f 84 49 01 00
	00		 je	 $LN7@Ipfx

; 130  :             const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(this->getloc());

  000f6	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000fc	50		 push	 eax
  000fd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00100	8b 00		 mov	 eax, DWORD PTR [eax]
  00102	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00108	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0010d	89 45 a0	 mov	 DWORD PTR tv240[ebp], eax
  00110	8b 45 a0	 mov	 eax, DWORD PTR tv240[ebp]
  00113	89 45 9c	 mov	 DWORD PTR tv243[ebp], eax
  00116	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
  0011a	ff 75 9c	 push	 DWORD PTR tv243[ebp]
  0011d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  00122	59		 pop	 ecx
  00123	89 45 bc	 mov	 DWORD PTR __Ctype_fac$13[ebp], eax
  00126	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0012a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00130	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale

; 131  : 
; 132  :             _TRY_IO_BEGIN

  00135	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  0013c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0013f	8b 00		 mov	 eax, DWORD PTR [eax]
  00141	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00144	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00147	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  0014b	89 45 98	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 133  :             int_type _Meta = _Myios::rdbuf()->sgetc();

  0014e	8b 4d 98	 mov	 ecx, DWORD PTR $T9[ebp]
  00151	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::sgetc
  00156	66 89 45 e2	 mov	 WORD PTR tv229[ebp], ax
  0015a	66 8b 45 e2	 mov	 ax, WORD PTR tv229[ebp]
  0015e	66 89 45 e4	 mov	 WORD PTR __Meta$15[ebp], ax

; 135  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  00162	eb 26		 jmp	 SHORT $LN4@Ipfx
$LN2@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 80   :         return _Mystrbuf;

  00164	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00167	8b 00		 mov	 eax, DWORD PTR [eax]
  00169	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0016c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016f	8b 44 01 38	 mov	 eax, DWORD PTR [ecx+eax+56]
  00173	89 45 94	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 135  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  00176	8b 4d 94	 mov	 ecx, DWORD PTR $T8[ebp]
  00179	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@_WU?$char_traits@_W@std@@@std@@QAEGXZ ; std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >::snextc
  0017e	66 89 45 e0	 mov	 WORD PTR tv397[ebp], ax
  00182	66 8b 45 e0	 mov	 ax, WORD PTR tv397[ebp]
  00186	66 89 45 e4	 mov	 WORD PTR __Meta$15[ebp], ax
$LN4@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 309  :         return WEOF;

  0018a	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0018f	66 89 45 de	 mov	 WORD PTR $T14[ebp], ax

; 301  :         return _Left == _Right;

  00193	0f b7 45 e4	 movzx	 eax, WORD PTR __Meta$15[ebp]
  00197	0f b7 4d de	 movzx	 ecx, WORD PTR $T14[ebp]
  0019b	3b c8		 cmp	 ecx, eax
  0019d	75 09		 jne	 SHORT $LN149@Ipfx
  0019f	c7 45 c0 01 00
	00 00		 mov	 DWORD PTR tv343[ebp], 1
  001a6	eb 04		 jmp	 SHORT $LN150@Ipfx
$LN149@Ipfx:
  001a8	83 65 c0 00	 and	 DWORD PTR tv343[ebp], 0
$LN150@Ipfx:
  001ac	8a 45 c0	 mov	 al, BYTE PTR tv343[ebp]
  001af	88 45 ea	 mov	 BYTE PTR $T16[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 136  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  001b2	0f b6 45 ea	 movzx	 eax, BYTE PTR $T16[ebp]
  001b6	85 c0		 test	 eax, eax
  001b8	74 08		 je	 SHORT $LN9@Ipfx

; 137  :                     _Eof = true;

  001ba	c6 45 eb 01	 mov	 BYTE PTR __Eof$[ebp], 1

; 138  :                     break;

  001be	eb 2c		 jmp	 SHORT $LN3@Ipfx

; 139  :                 } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

  001c0	eb 25		 jmp	 SHORT $LN10@Ipfx
$LN9@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 293  :         return _Meta;

  001c2	66 8b 45 e4	 mov	 ax, WORD PTR __Meta$15[ebp]
  001c6	66 89 45 90	 mov	 WORD PTR $T7[ebp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2806 :         return do_is(_Maskval, _Ch);

  001ca	ff 75 90	 push	 DWORD PTR $T7[ebp]
  001cd	6a 48		 push	 72			; 00000048H
  001cf	8b 45 bc	 mov	 eax, DWORD PTR __Ctype_fac$13[ebp]
  001d2	8b 00		 mov	 eax, DWORD PTR [eax]
  001d4	8b 4d bc	 mov	 ecx, DWORD PTR __Ctype_fac$13[ebp]
  001d7	ff 50 10	 call	 DWORD PTR [eax+16]
  001da	88 45 e9	 mov	 BYTE PTR tv396[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 139  :                 } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

  001dd	0f b6 45 e9	 movzx	 eax, BYTE PTR tv396[ebp]
  001e1	85 c0		 test	 eax, eax
  001e3	75 02		 jne	 SHORT $LN10@Ipfx

; 140  :                     break; // not whitespace, quit

  001e5	eb 05		 jmp	 SHORT $LN3@Ipfx
$LN10@Ipfx:

; 141  :                 }
; 142  :             }

  001e7	e9 78 ff ff ff	 jmp	 $LN2@Ipfx
$LN3@Ipfx:
  001ec	eb 47		 jmp	 SHORT $LN14@Ipfx
__catch$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z$0:

; 143  :             _CATCH_IO_END

  001ee	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001f1	8b 00		 mov	 eax, DWORD PTR [eax]
  001f3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001f6	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  001f9	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  001fc	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001ff	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00202	89 45 8c	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00205	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00208	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0020c	74 06		 je	 SHORT $LN163@Ipfx
  0020e	83 65 b8 00	 and	 DWORD PTR tv145[ebp], 0
  00212	eb 07		 jmp	 SHORT $LN164@Ipfx
$LN163@Ipfx:
  00214	c7 45 b8 04 00
	00 00		 mov	 DWORD PTR tv145[ebp], 4
$LN164@Ipfx:
  0021b	6a 01		 push	 1

; 53   :         clear(rdstate() | _State, _Reraise);

  0021d	8b 45 8c	 mov	 eax, DWORD PTR $T6[ebp]
  00220	83 c8 04	 or	 eax, 4

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00223	0b 45 b8	 or	 eax, DWORD PTR tv145[ebp]
  00226	50		 push	 eax
  00227	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 143  :             _CATCH_IO_END

  0022f	b8 00 00 00 00	 mov	 eax, $LN18@Ipfx
  00234	c3		 ret	 0
$LN14@Ipfx:
  00235	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00239	eb 04		 jmp	 SHORT $LN7@Ipfx
$LN18@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
  0023b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
$LN7@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 144  :         }
; 145  : 
; 146  :         if (_Eof) {

  0023f	0f b6 45 eb	 movzx	 eax, BYTE PTR __Eof$[ebp]
  00243	85 c0		 test	 eax, eax
  00245	74 41		 je	 SHORT $LN12@Ipfx

; 147  :             _Myios::setstate(ios_base::eofbit | ios_base::failbit);

  00247	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0024a	8b 00		 mov	 eax, DWORD PTR [eax]
  0024c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0024f	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00252	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  00255	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00258	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0025b	89 45 88	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0025e	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00261	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00265	74 06		 je	 SHORT $LN179@Ipfx
  00267	83 65 b4 00	 and	 DWORD PTR tv377[ebp], 0
  0026b	eb 07		 jmp	 SHORT $LN180@Ipfx
$LN179@Ipfx:
  0026d	c7 45 b4 04 00
	00 00		 mov	 DWORD PTR tv377[ebp], 4
$LN180@Ipfx:
  00274	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  00276	8b 45 88	 mov	 eax, DWORD PTR $T5[ebp]
  00279	83 c8 03	 or	 eax, 3

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  0027c	0b 45 b4	 or	 eax, DWORD PTR tv377[ebp]
  0027f	50		 push	 eax
  00280	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00283	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN12@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  00288	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0028b	8b 00		 mov	 eax, DWORD PTR [eax]
  0028d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00290	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00293	8b 44 01 0c	 mov	 eax, DWORD PTR [ecx+eax+12]
  00297	89 45 84	 mov	 DWORD PTR $T4[ebp], eax

; 295  :         return rdstate() == ios_base::goodbit;

  0029a	83 7d 84 00	 cmp	 DWORD PTR $T4[ebp], 0
  0029e	75 09		 jne	 SHORT $LN191@Ipfx
  002a0	c7 45 b0 01 00
	00 00		 mov	 DWORD PTR tv216[ebp], 1
  002a7	eb 04		 jmp	 SHORT $LN189@Ipfx
$LN191@Ipfx:
  002a9	83 65 b0 00	 and	 DWORD PTR tv216[ebp], 0
$LN189@Ipfx:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 150  :         return this->good();

  002ad	8a 45 b0	 mov	 al, BYTE PTR tv216[ebp]
$LN1@Ipfx:

; 151  :     }

  002b0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002b3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ba	59		 pop	 ecx
  002bb	5f		 pop	 edi
  002bc	5e		 pop	 esi
  002bd	5b		 pop	 ebx
  002be	c9		 leave
  002bf	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z$2:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Ipfx
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
;	COMDAT ??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 72   :     virtual __CLR_OR_THIS_CALL ~basic_istream() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 e8	 mov	 eax, DWORD PTR [eax-24]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 44 01 e8 00
	00 00 00	 mov	 DWORD PTR [ecx+eax-24], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 e8	 mov	 eax, DWORD PTR [eax-24]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	83 e8 18	 sub	 eax, 24			; 00000018H
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	8b 49 e8	 mov	 ecx, DWORD PTR [ecx-24]
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00033	89 44 0a e4	 mov	 DWORD PTR [edx+ecx-28], eax
  00037	c9		 leave
  00038	c3		 ret	 0
??1?$basic_istream@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::~basic_istream<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream
;	COMDAT ??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
_$initVBases$ = 16					; size = 4
??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z PROC ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 41   :     explicit __CLR_OR_THIS_CALL basic_istream(_Mysb* _Strbuf, bool _Isstd = false)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	83 65 e8 00	 and	 DWORD PTR $T2[ebp], 0

; 43   :         : _Chcount(0) {

  0002c	83 7d 10 00	 cmp	 DWORD PTR _$initVBases$[ebp], 0
  00030	74 31		 je	 SHORT $LN2@basic_istr
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_8?$basic_istream@_WU?$char_traits@_W@std@@@std@@7B@
  0003b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 18	 add	 eax, 24			; 00000018H
  00041	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 460  :     __CLR_OR_THIS_CALL ios_base() {}

  00044	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 161  :     __CLR_OR_THIS_CALL basic_ios() {}

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\istream

; 43   :         : _Chcount(0) {

  00056	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0005d	83 c8 01	 or	 eax, 1
  00060	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
$LN2@basic_istr:
  00063	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 00		 mov	 eax, DWORD PTR [eax]
  00068	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0006b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	c7 04 01 00 00
	00 00		 mov	 DWORD PTR [ecx+eax], OFFSET ??_7?$basic_istream@_WU?$char_traits@_W@std@@@std@@6B@
  00075	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0007d	83 e8 18	 sub	 eax, 24			; 00000018H
  00080	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00085	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00088	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0008b	89 44 0a fc	 mov	 DWORD PTR [edx+ecx-4], eax
  0008f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	33 c9		 xor	 ecx, ecx
  00094	33 d2		 xor	 edx, edx
  00096	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00099	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 44   :         _Myios::init(_Strbuf, _Isstd);

  0009c	ff 75 0c	 push	 DWORD PTR __Isstd$[ebp]
  0009f	ff 75 08	 push	 DWORD PTR __Strbuf$[ebp]
  000a2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	8b 00		 mov	 eax, DWORD PTR [eax]
  000a7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000ad	e8 00 00 00 00	 call	 ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init

; 45   :     }

  000b2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000b6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c3	59		 pop	 ecx
  000c4	c9		 leave
  000c5	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z$0:
  00000	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00003	83 e0 01	 and	 eax, 1
  00006	0f 84 0f 00 00
	00		 je	 $LN5@basic_istr
  0000c	83 65 e8 fe	 and	 DWORD PTR $T2[ebp], -2	; fffffffeH
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 18	 add	 ecx, 24			; 00000018H
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
$LN5@basic_istr:
  0001b	c3		 ret	 0
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
__ehhandler$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z:
  00021	90		 npad	 1
  00022	90		 npad	 1
  00023	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00027	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002a	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_istream@_WU?$char_traits@_W@std@@@std@@QAE@PAV?$basic_streambuf@_WU?$char_traits@_W@std@@@1@_N@Z ENDP ; std::basic_istream<wchar_t,std::char_traits<wchar_t> >::basic_istream<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
;	COMDAT ??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 38   :     virtual __CLR_OR_THIS_CALL ~basic_ios() noexcept {}

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 451  :     virtual __CLR_OR_THIS_CALL ~ios_base() noexcept {

  0002f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 452  :         _Ios_base_dtor(this);

  0003c	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00044	59		 pop	 ecx

; 453  :     }

  00045	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00049	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0004c	83 e0 01	 and	 eax, 1
  0004f	74 0c		 je	 SHORT $LN2@scalar
  00051	6a 48		 push	 72			; 00000048H
  00053	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005b	59		 pop	 ecx
  0005c	59		 pop	 ecx
$LN2@scalar:
  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00063	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006a	59		 pop	 ecx
  0006b	c9		 leave
  0006c	c2 04 00	 ret	 4
  0006f	cc		 int	 3
  00070	cc		 int	 3
  00071	cc		 int	 3
  00072	cc		 int	 3
  00073	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_G?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAEPAXI@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::`scalar deleting destructor'
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
;	COMDAT ?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
tv178 = -8						; size = 4
_this$ = -4						; size = 4
__Strbuf$ = 8						; size = 4
__Isstd$ = 12						; size = 1
?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init, COMDAT
; _this$ = ecx

; 146  :         bool _Isstd                             = false) { // initialize with stream buffer pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0

; 147  :         _Init(); // initialize ios_base

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Init@ios_base@std@@IAEXXZ ; std::ios_base::_Init

; 148  :         _Mystrbuf = _Strbuf;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Strbuf$[ebp]
  0001b	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 149  :         _Tiestr   = nullptr;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 60 3c 00	 and	 DWORD PTR [eax+60], 0

; 150  :         _Fillch   = widen(' ');

  00025	6a 20		 push	 32			; 00000020H
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	66 89 41 40	 mov	 WORD PTR [ecx+64], ax

; 151  : 
; 152  :         if (!_Mystrbuf) {

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0003d	75 33		 jne	 SHORT $LN2@init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 276  :         return _Mystate;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00045	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0004f	74 06		 je	 SHORT $LN46@init
  00051	83 65 f8 00	 and	 DWORD PTR tv178[ebp], 0
  00055	eb 07		 jmp	 SHORT $LN47@init
$LN46@init:
  00057	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR tv178[ebp], 4
$LN47@init:
  0005e	6a 00		 push	 0

; 53   :         clear(rdstate() | _State, _Reraise);

  00060	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00063	83 c8 04	 or	 eax, 4

; 42   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);

  00066	0b 45 f8	 or	 eax, DWORD PTR tv178[ebp]
  00069	50		 push	 eax
  0006a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
$LN2@init:

; 153  :             setstate(badbit);
; 154  :         }
; 155  : 
; 156  :         if (_Isstd) {

  00072	0f b6 45 0c	 movzx	 eax, BYTE PTR __Isstd$[ebp]
  00076	85 c0		 test	 eax, eax
  00078	74 09		 je	 SHORT $LN1@init

; 157  :             _Addstd(this); // special handling for standard streams

  0007a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?_Addstd@ios_base@std@@SAXPAV12@@Z ; std::ios_base::_Addstd
  00082	59		 pop	 ecx
$LN1@init:

; 158  :         }
; 159  :     }

  00083	c9		 leave
  00084	c2 08 00	 ret	 8
?init@?$basic_ios@_WU?$char_traits@_W@std@@@std@@IAEXPAV?$basic_streambuf@_WU?$char_traits@_W@std@@@2@_N@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
;	COMDAT ?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
_TEXT	SEGMENT
$T2 = -44						; size = 8
$T3 = -36						; size = 4
tv79 = -32						; size = 4
tv152 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -14						; size = 2
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen, COMDAT
; _this$ = ecx

; 114  :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	83 65 dc 00	 and	 DWORD PTR $T3[ebp], 0

; 115  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

  0002c	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  0002f	50		 push	 eax
  00030	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00038	89 45 e4	 mov	 DWORD PTR tv152[ebp], eax
  0003b	8b 45 e4	 mov	 eax, DWORD PTR tv152[ebp]
  0003e	89 45 e0	 mov	 DWORD PTR tv79[ebp], eax
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	ff 75 e0	 push	 DWORD PTR tv79[ebp]
  00048	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@_W@std@@@std@@YAABV?$ctype@_W@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<wchar_t> >
  0004d	59		 pop	 ecx
  0004e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2843 :         return do_widen(_Byte);

  00051	ff 75 08	 push	 DWORD PTR __Byte$[ebp]
  00054	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	ff 50 30	 call	 DWORD PTR [eax+48]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 115  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

  0005f	66 89 45 f2	 mov	 WORD PTR $T4[ebp], ax
  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  0006a	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0006f	66 8b 45 f2	 mov	 ax, WORD PTR $T4[ebp]

; 116  :     }

  00073	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00076	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007d	59		 pop	 ecx
  0007e	c9		 leave
  0007f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z$0:
  00000	8d 4d d4	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@_WU?$char_traits@_W@std@@@std@@QBE_WD@Z ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::widen
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios
;	COMDAT ??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ PROC ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 38   :     virtual __CLR_OR_THIS_CALL ~basic_ios() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 451  :     virtual __CLR_OR_THIS_CALL ~ios_base() noexcept {

  0002f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 452  :         _Ios_base_dtor(this);

  0003c	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  00044	59		 pop	 ecx

; 453  :     }

  00045	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\ios

; 38   :     virtual __CLR_OR_THIS_CALL ~basic_ios() noexcept {}

  00049	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00053	59		 pop	 ecx
  00054	c9		 leave
  00055	c3		 ret	 0
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
  00059	cc		 int	 3
  0005a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$basic_ios@_WU?$char_traits@_W@std@@@std@@UAE@XZ ENDP ; std::basic_ios<wchar_t,std::char_traits<wchar_t> >::~basic_ios<wchar_t,std::char_traits<wchar_t> >
; Function compile flags: /Odspy
;	COMDAT ??__Fs_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV1@XZ@YAXXZ
text$yd	SEGMENT
??__Fs_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV1@XZ@YAXXZ PROC ; `CMakePackLog::GetSingleton'::`2'::`dynamic atexit destructor for 's_kMakePackLog'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4V2@A
  00008	e8 00 00 00 00	 call	 ??1CMakePackLog@@QAE@XZ	; CMakePackLog::~CMakePackLog
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fs_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV1@XZ@YAXXZ ENDP ; `CMakePackLog::GetSingleton'::`2'::`dynamic atexit destructor for 's_kMakePackLog''
text$yd	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
;	COMDAT ??_Gios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gios_base@std@@UAEPAXI@Z PROC			; std::ios_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??_Gios_base@std@@UAEPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 451  :     virtual __CLR_OR_THIS_CALL ~ios_base() noexcept {

  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ios_base@std@@6B@

; 452  :         _Ios_base_dtor(this);

  00033	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Ios_base_dtor@ios_base@std@@CAXPAV12@@Z ; std::ios_base::_Ios_base_dtor
  0003b	59		 pop	 ecx

; 453  :     }

  0003c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00040	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00043	83 e0 01	 and	 eax, 1
  00046	74 0c		 je	 SHORT $LN2@scalar
  00048	6a 38		 push	 56			; 00000038H
  0004a	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00052	59		 pop	 ecx
  00053	59		 pop	 ecx
$LN2@scalar:
  00054	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	c9		 leave
  00063	c2 04 00	 ret	 4
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Gios_base@std@@UAEPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??_Gios_base@std@@UAEPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??_Gios_base@std@@UAEPAXI@Z ENDP			; std::ios_base::`scalar deleting destructor'
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
;	COMDAT ?_Init@ios_base@std@@IAEXXZ
_TEXT	SEGMENT
tv83 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Init@ios_base@std@@IAEXXZ PROC			; std::ios_base::_Init, COMDAT
; _this$ = ecx

; 462  :     void __CLR_OR_THIS_CALL _Init() { // initialize a new ios_base

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@ios_base@std@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 463  :         _Ploc   = nullptr;

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 60 30 00	 and	 DWORD PTR [eax+48], 0

; 464  :         _Stdstr = 0;

  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 465  :         _Except = goodbit;

  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 466  :         _Fmtfl  = skipws | dec;

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 40 14 01 02
	00 00		 mov	 DWORD PTR [eax+20], 513	; 00000201H

; 467  :         _Prec   = 6;

  00047	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	33 c9		 xor	 ecx, ecx
  0004c	c7 40 18 06 00
	00 00		 mov	 DWORD PTR [eax+24], 6
  00053	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 468  :         _Wide   = 0;

  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	33 c9		 xor	 ecx, ecx
  0005b	33 d2		 xor	 edx, edx
  0005d	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00060	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 469  :         _Arr    = nullptr;

  00063	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00066	83 60 28 00	 and	 DWORD PTR [eax+40], 0

; 470  :         _Calls  = nullptr;

  0006a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	83 60 2c 00	 and	 DWORD PTR [eax+44], 0

; 266  :         clear(_State, false);

  00071	6a 00		 push	 0
  00073	6a 00		 push	 0
  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 472  :         _Ploc = new locale;

  0007d	6a 08		 push	 8
  0007f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00084	59		 pop	 ecx
  00085	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00088	83 7d ec 00	 cmp	 DWORD PTR $T2[ebp], 0
  0008c	74 1e		 je	 SHORT $LN3@Init
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 271  :     locale() noexcept : _Ptr(_Init(true)) {}

  0008e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00092	6a 01		 push	 1
  00094	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  00099	59		 pop	 ecx
  0009a	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  0009d	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000a0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 472  :         _Ploc = new locale;

  000a4	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  000a7	89 45 e8	 mov	 DWORD PTR tv83[ebp], eax
  000aa	eb 04		 jmp	 SHORT $LN4@Init
$LN3@Init:
  000ac	83 65 e8 00	 and	 DWORD PTR tv83[ebp], 0
$LN4@Init:
  000b0	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b3	8b 4d e8	 mov	 ecx, DWORD PTR tv83[ebp]
  000b6	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 473  :     }

  000b9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000bc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c3	59		 pop	 ecx
  000c4	c9		 leave
  000c5	c3		 ret	 0
  000c6	cc		 int	 3
  000c7	cc		 int	 3
  000c8	cc		 int	 3
  000c9	cc		 int	 3
  000ca	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Init@ios_base@std@@IAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@ios_base@std@@IAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@ios_base@std@@IAEXXZ ENDP			; std::ios_base::_Init
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
__Right$ = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 372  :     _NODISCARD locale __CLR_OR_THIS_CALL getloc() const { // get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 65 fc 00	 and	 DWORD PTR $T1[ebp], 0

; 373  :         return *_Ploc;

  0000d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00013	89 45 f4	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	8b 4d f4	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 268  :         _Ptr->_Incref();

  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00028	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	ff 50 04	 call	 DWORD PTR [eax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 373  :         return *_Ploc;

  00033	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00036	83 c8 01	 or	 eax, 1
  00039	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0003c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 374  :     }

  0003f	c9		 leave
  00040	c2 04 00	 ret	 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -40						; size = 20
$T2 = -20						; size = 8
_this$ = -12						; size = 4
__Msg$3 = -8						; size = 4
__Filtered$ = -4					; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 243  :     void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 244  :         _State &= _Statmask;

  00009	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  0000c	83 e0 17	 and	 eax, 23			; 00000017H
  0000f	89 45 08	 mov	 DWORD PTR __State$[ebp], eax

; 245  :         _Mystate             = _State;

  00012	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __State$[ebp]
  00018	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 246  :         const auto _Filtered = _State & _Except;

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __State$[ebp]
  00021	23 48 10	 and	 ecx, DWORD PTR [eax+16]
  00024	89 4d fc	 mov	 DWORD PTR __Filtered$[ebp], ecx

; 247  :         if (_Filtered) {

  00027	74 61		 je	 SHORT $LN8@clear

; 248  :             if (_Reraise) {

  00029	0f b6 45 0c	 movzx	 eax, BYTE PTR __Reraise$[ebp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 09		 je	 SHORT $LN3@clear

; 249  :                 _RERAISE;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@clear:

; 250  :             }
; 251  : 
; 252  :             const char* _Msg;
; 253  :             if (_Filtered & ios_base::badbit) {

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Filtered$[ebp]
  0003d	83 e0 04	 and	 eax, 4
  00040	74 09		 je	 SHORT $LN4@clear

; 254  :                 _Msg = "ios_base::badbit set";

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00049	eb 18		 jmp	 SHORT $LN5@clear
$LN4@clear:

; 255  :             } else if (_Filtered & ios_base::failbit) {

  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Filtered$[ebp]
  0004e	83 e0 02	 and	 eax, 2
  00051	74 09		 je	 SHORT $LN6@clear

; 256  :                 _Msg = "ios_base::failbit set";

  00053	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@

; 257  :             } else {

  0005a	eb 07		 jmp	 SHORT $LN5@clear
$LN6@clear:

; 258  :                 _Msg = "ios_base::eofbit set";

  0005c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
$LN5@clear:

; 259  :             }
; 260  : 
; 261  :             _THROW(failure(_Msg));

  00063	6a 01		 push	 1
  00065	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx
  00070	50		 push	 eax
  00071	ff 75 f8	 push	 DWORD PTR __Msg$3[ebp]
  00074	8d 4d d8	 lea	 ecx, DWORD PTR $T1[ebp]
  00077	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  0007c	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00081	8d 45 d8	 lea	 eax, DWORD PTR $T1[ebp]
  00084	50		 push	 eax
  00085	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN8@clear:

; 262  :         }
; 263  :     }

  0008a	c9		 leave
  0008b	c2 08 00	 ret	 8
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 14		 push	 20			; 00000014H
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_System_error@std@@6B@
  00024	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00033	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7system_error@std@@6B@
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7failure@ios_base@std@@6B@
  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	c9		 leave
  0004c	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
$T2 = -56						; size = 4
__Errcode$ = -52					; size = 8
_this$ = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 204  :         explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	83 65 c8 00	 and	 DWORD PTR $T2[ebp], 0

; 205  :             : system_error(_Errcode, _Message) {} // construct with message

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	89 4d cc	 mov	 DWORD PTR __Errcode$[ebp], ecx
  0003a	89 45 d0	 mov	 DWORD PTR __Errcode$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error

; 410  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

  0003d	ff 75 08	 push	 DWORD PTR __Message$[ebp]
  00040	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00043	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00048	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004c	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  0004f	50		 push	 eax
  00050	ff 75 d0	 push	 DWORD PTR __Errcode$[ebp+4]
  00053	ff 75 cc	 push	 DWORD PTR __Errcode$[ebp]
  00056	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  0005e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00062	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00065	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error

; 410  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

  0006a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7system_error@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xiosbase

; 205  :             : system_error(_Errcode, _Message) {} // construct with message

  00073	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00076	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7failure@ios_base@std@@6B@
  0007c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00082	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00089	59		 pop	 ecx
  0008a	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008d	33 cd		 xor	 ecx, ebp
  0008f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00094	c9		 leave
  00095	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z$1:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
; Function compile flags: /Odspy
;	COMDAT ??_G?$ctype@_W@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ctype@_W@std@@MAEPAXI@Z PROC			; std::ctype<wchar_t>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$ctype@_W@std@@MAE@XZ ; std::ctype<wchar_t>::~ctype<wchar_t>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 44		 push	 68			; 00000044H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$ctype@_W@std@@MAEPAXI@Z ENDP			; std::ctype<wchar_t>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dflt$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z PROC	; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 2984 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2985 :         _Adl_verify_range(_First, _Last);
; 2986 :         for (; _First != _Last; ++_First, ++_Dest) {

  00007	eb 0f		 jmp	 SHORT $LN4@do_narrow
$LN2@do_narrow:
  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	40		 inc	 eax
  0000d	40		 inc	 eax
  0000e	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
  00011	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp]
  00014	40		 inc	 eax
  00015	89 45 14	 mov	 DWORD PTR __Dest$[ebp], eax
$LN4@do_narrow:
  00018	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001b	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001e	74 19		 je	 SHORT $LN3@do_narrow

; 2987 :             *_Dest = _Donarrow(*_First, _Dflt);

  00020	ff 75 10	 push	 DWORD PTR __Dflt$[ebp]
  00023	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00026	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00029	50		 push	 eax
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Donarrow@?$ctype@_W@std@@IBED_WD@Z ; std::ctype<wchar_t>::_Donarrow
  00032	8b 4d 14	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	88 01		 mov	 BYTE PTR [ecx], al

; 2988 :         }

  00037	eb d0		 jmp	 SHORT $LN2@do_narrow
$LN3@do_narrow:

; 2989 : 
; 2990 :         return _First;

  00039	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2991 :     }

  0003c	c9		 leave
  0003d	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@_W@std@@MBEPB_WPB_W0DPAD@Z ENDP	; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_narrow@?$ctype@_W@std@@MBED_WD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?do_narrow@?$ctype@_W@std@@MBED_WD@Z PROC		; std::ctype<wchar_t>::do_narrow, COMDAT
; _this$ = ecx

; 2979 :     virtual char __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char _Dflt) const { // narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2980 :         return _Donarrow(_Ch, _Dflt);

  00007	ff 75 0c	 push	 DWORD PTR __Dflt$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Donarrow@?$ctype@_W@std@@IBED_WD@Z ; std::ctype<wchar_t>::_Donarrow

; 2981 :     }

  00015	c9		 leave
  00016	c2 08 00	 ret	 8
?do_narrow@?$ctype@_W@std@@MBED_WD@Z ENDP		; std::ctype<wchar_t>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Donarrow@?$ctype@_W@std@@IBED_WD@Z
_TEXT	SEGMENT
__Mbst$ = -28						; size = 8
_this$ = -20						; size = 4
tv76 = -13						; size = 1
__Buf$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__Ch$ = 8						; size = 2
__Dflt$ = 12						; size = 1
?_Donarrow@?$ctype@_W@std@@IBED_WD@Z PROC		; std::ctype<wchar_t>::_Donarrow, COMDAT
; _this$ = ecx

; 2973 :     char __CLR_OR_THIS_CALL _Donarrow(_Elem _Ch, char _Dflt) const { // narrow element to char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2974 :         char _Buf[MB_LEN_MAX];
; 2975 :         mbstate_t _Mbst = {};

  00013	33 c0		 xor	 eax, eax
  00015	89 45 e4	 mov	 DWORD PTR __Mbst$[ebp], eax
  00018	89 45 e8	 mov	 DWORD PTR __Mbst$[ebp+4], eax

; 2976 :         return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];

  0001b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 18	 add	 eax, 24			; 00000018H
  00021	50		 push	 eax
  00022	8d 45 e4	 lea	 eax, DWORD PTR __Mbst$[ebp]
  00025	50		 push	 eax
  00026	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00029	8d 45 f4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 __Wcrtomb
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	83 f8 01	 cmp	 eax, 1
  00038	74 08		 je	 SHORT $LN3@Donarrow
  0003a	8a 45 0c	 mov	 al, BYTE PTR __Dflt$[ebp]
  0003d	88 45 f3	 mov	 BYTE PTR tv76[ebp], al
  00040	eb 0d		 jmp	 SHORT $LN4@Donarrow
$LN3@Donarrow:
  00042	33 c0		 xor	 eax, eax
  00044	40		 inc	 eax
  00045	6b c0 00	 imul	 eax, eax, 0
  00048	8a 44 05 f4	 mov	 al, BYTE PTR __Buf$[ebp+eax]
  0004c	88 45 f3	 mov	 BYTE PTR tv76[ebp], al
$LN4@Donarrow:
  0004f	8a 45 f3	 mov	 al, BYTE PTR tv76[ebp]

; 2977 :     }

  00052	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00055	33 cd		 xor	 ecx, ebp
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	c9		 leave
  0005d	c2 08 00	 ret	 8
?_Donarrow@?$ctype@_W@std@@IBED_WD@Z ENDP		; std::ctype<wchar_t>::_Donarrow
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z PROC		; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 2964 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2965 :         _Adl_verify_range(_First, _Last);
; 2966 :         for (; _First != _Last; ++_First, ++_Dest) {

  00007	eb 0f		 jmp	 SHORT $LN4@do_widen
$LN2@do_widen:
  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	40		 inc	 eax
  0000d	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
  00010	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00013	40		 inc	 eax
  00014	40		 inc	 eax
  00015	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
$LN4@do_widen:
  00018	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001b	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001e	74 17		 je	 SHORT $LN3@do_widen

; 2967 :             *_Dest = _Dowiden(*_First);

  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Dowiden@?$ctype@_W@std@@IBE_WD@Z ; std::ctype<wchar_t>::_Dowiden
  0002f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00032	66 89 01	 mov	 WORD PTR [ecx], ax

; 2968 :         }

  00035	eb d2		 jmp	 SHORT $LN2@do_widen
$LN3@do_widen:

; 2969 : 
; 2970 :         return _First;

  00037	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2971 :     }

  0003a	c9		 leave
  0003b	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@_W@std@@MBEPBDPBD0PA_W@Z ENDP		; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_widen@?$ctype@_W@std@@MBE_WD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?do_widen@?$ctype@_W@std@@MBE_WD@Z PROC			; std::ctype<wchar_t>::do_widen, COMDAT
; _this$ = ecx

; 2959 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2960 :         return _Dowiden(_Byte);

  00007	ff 75 08	 push	 DWORD PTR __Byte$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?_Dowiden@?$ctype@_W@std@@IBE_WD@Z ; std::ctype<wchar_t>::_Dowiden

; 2961 :     }

  00012	c9		 leave
  00013	c2 04 00	 ret	 4
?do_widen@?$ctype@_W@std@@MBE_WD@Z ENDP			; std::ctype<wchar_t>::do_widen
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Dowiden@?$ctype@_W@std@@IBE_WD@Z
_TEXT	SEGMENT
__Mbst$ = -20						; size = 8
_this$ = -12						; size = 4
__Wc$ = -8						; size = 2
tv75 = -2						; size = 2
__Byte$ = 8						; size = 1
?_Dowiden@?$ctype@_W@std@@IBE_WD@Z PROC			; std::ctype<wchar_t>::_Dowiden, COMDAT
; _this$ = ecx

; 2953 :     _Elem __CLR_OR_THIS_CALL _Dowiden(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2954 :         mbstate_t _Mbst = {};

  00009	33 c0		 xor	 eax, eax
  0000b	89 45 ec	 mov	 DWORD PTR __Mbst$[ebp], eax
  0000e	89 45 f0	 mov	 DWORD PTR __Mbst$[ebp+4], eax

; 2955 :         wchar_t _Wc;
; 2956 :         return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(WEOF) : _Wc;

  00011	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 c0 18	 add	 eax, 24			; 00000018H
  00017	50		 push	 eax
  00018	8d 45 ec	 lea	 eax, DWORD PTR __Mbst$[ebp]
  0001b	50		 push	 eax
  0001c	6a 01		 push	 1
  0001e	8d 45 08	 lea	 eax, DWORD PTR __Byte$[ebp]
  00021	50		 push	 eax
  00022	8d 45 f8	 lea	 eax, DWORD PTR __Wc$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 __Mbrtowc
  0002b	83 c4 14	 add	 esp, 20			; 00000014H
  0002e	85 c0		 test	 eax, eax
  00030	7d 0b		 jge	 SHORT $LN3@Dowiden
  00032	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00037	66 89 45 fe	 mov	 WORD PTR tv75[ebp], ax
  0003b	eb 08		 jmp	 SHORT $LN4@Dowiden
$LN3@Dowiden:
  0003d	66 8b 45 f8	 mov	 ax, WORD PTR __Wc$[ebp]
  00041	66 89 45 fe	 mov	 WORD PTR tv75[ebp], ax
$LN4@Dowiden:
  00045	66 8b 45 fe	 mov	 ax, WORD PTR tv75[ebp]

; 2957 :     }

  00049	c9		 leave
  0004a	c2 04 00	 ret	 4
?_Dowiden@?$ctype@_W@std@@IBE_WD@Z ENDP			; std::ctype<wchar_t>::_Dowiden
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 2944 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2945 :         _Adl_verify_range(_First, _Last);
; 2946 :         for (; _First != _Last; ++_First) {

  00007	eb 08		 jmp	 SHORT $LN4@do_toupper
$LN2@do_toupper:
  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	40		 inc	 eax
  0000d	40		 inc	 eax
  0000e	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@do_toupper:
  00011	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00017	74 1d		 je	 SHORT $LN3@do_toupper

; 2947 :             *_First = _Towupper(*_First, &_Ctype);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Towupper
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00031	66 89 01	 mov	 WORD PTR [ecx], ax

; 2948 :         }

  00034	eb d3		 jmp	 SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2949 : 
; 2950 :         return _First;

  00036	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2951 :     }

  00039	c9		 leave
  0003a	c2 08 00	 ret	 8
?do_toupper@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_toupper@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 2
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_toupper, COMDAT
; _this$ = ecx

; 2939 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2940 :         return _Towupper(_Ch, &_Ctype);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00011	e8 00 00 00 00	 call	 __Towupper
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 2941 :     }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?do_toupper@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z PROC	; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 2930 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2931 :         _Adl_verify_range(_First, _Last);
; 2932 :         for (; _First != _Last; ++_First) {

  00007	eb 08		 jmp	 SHORT $LN4@do_tolower
$LN2@do_tolower:
  00009	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000c	40		 inc	 eax
  0000d	40		 inc	 eax
  0000e	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@do_tolower:
  00011	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00017	74 1d		 je	 SHORT $LN3@do_tolower

; 2933 :             *_First = _Towlower(*_First, &_Ctype);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00023	0f b7 00	 movzx	 eax, WORD PTR [eax]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 __Towlower
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00031	66 89 01	 mov	 WORD PTR [ecx], ax

; 2934 :         }

  00034	eb d3		 jmp	 SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2935 : 
; 2936 :         return _First;

  00036	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2937 :     }

  00039	c9		 leave
  0003a	c2 08 00	 ret	 8
?do_tolower@?$ctype@_W@std@@MBEPB_WPA_WPB_W@Z ENDP	; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_tolower@?$ctype@_W@std@@MBE_W_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 2
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z PROC		; std::ctype<wchar_t>::do_tolower, COMDAT
; _this$ = ecx

; 2925 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2926 :         return _Towlower(_Ch, &_Ctype);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00011	e8 00 00 00 00	 call	 __Towlower
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 2927 :     }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?do_tolower@?$ctype@_W@std@@MBE_W_W@Z ENDP		; std::ctype<wchar_t>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Ch$ = -8						; size = 2
_this$ = -4						; size = 4
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_not, COMDAT
; _this$ = ecx

; 2916 :         const _Elem* _Last) const { // find first in [_First, _Last) not fitting mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@do_scan_no:

; 2917 :         _Adl_verify_range(_First, _Last);
; 2918 :         while (_First != _Last && is(_Maskval, *_First)) {

  00008	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000e	74 2c		 je	 SHORT $LN3@do_scan_no
  00010	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00013	66 8b 00	 mov	 ax, WORD PTR [eax]
  00016	66 89 45 f8	 mov	 WORD PTR __Ch$[ebp], ax

; 2806 :         return do_is(_Maskval, _Ch);

  0001a	ff 75 f8	 push	 DWORD PTR __Ch$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	ff 50 10	 call	 DWORD PTR [eax+16]

; 2917 :         _Adl_verify_range(_First, _Last);
; 2918 :         while (_First != _Last && is(_Maskval, *_First)) {

  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	74 0a		 je	 SHORT $LN3@do_scan_no

; 2919 :             ++_First;

  00032	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00035	40		 inc	 eax
  00036	40		 inc	 eax
  00037	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax

; 2920 :         }

  0003a	eb cc		 jmp	 SHORT $LN2@do_scan_no
$LN3@do_scan_no:

; 2921 : 
; 2922 :         return _First;

  0003c	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 2923 :     }

  0003f	c9		 leave
  00040	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_not@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_not
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z
_TEXT	SEGMENT
__Ch$ = -8						; size = 2
_this$ = -4						; size = 4
__Maskval$ = 8						; size = 2
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z PROC	; std::ctype<wchar_t>::do_scan_is, COMDAT
; _this$ = ecx

; 2906 :         const _Elem* _Last) const { // find first in [_First, _Last) that fits mask classification

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@do_scan_is:

; 2907 :         _Adl_verify_range(_First, _Last);
; 2908 :         while (_First != _Last && !is(_Maskval, *_First)) {

  00008	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  0000e	74 2c		 je	 SHORT $LN3@do_scan_is
  00010	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00013	66 8b 00	 mov	 ax, WORD PTR [eax]
  00016	66 89 45 f8	 mov	 WORD PTR __Ch$[ebp], ax

; 2806 :         return do_is(_Maskval, _Ch);

  0001a	ff 75 f8	 push	 DWORD PTR __Ch$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Maskval$[ebp]
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	ff 50 10	 call	 DWORD PTR [eax+16]

; 2907 :         _Adl_verify_range(_First, _Last);
; 2908 :         while (_First != _Last && !is(_Maskval, *_First)) {

  0002b	0f b6 c0	 movzx	 eax, al
  0002e	85 c0		 test	 eax, eax
  00030	75 0a		 jne	 SHORT $LN3@do_scan_is

; 2909 :             ++_First;

  00032	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00035	40		 inc	 eax
  00036	40		 inc	 eax
  00037	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax

; 2910 :         }

  0003a	eb cc		 jmp	 SHORT $LN2@do_scan_is
$LN3@do_scan_is:

; 2911 : 
; 2912 :         return _First;

  0003c	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]

; 2913 :     }

  0003f	c9		 leave
  00040	c2 0c 00	 ret	 12			; 0000000cH
?do_scan_is@?$ctype@_W@std@@MBEPB_WFPB_W0@Z ENDP	; std::ctype<wchar_t>::do_scan_is
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z PROC		; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2900 :         mask* _Dest) const { // get mask sequence for elements in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2901 :         _Adl_verify_range(_First, _Last);
; 2902 :         return _CSTD _Getwctypes(_First, _Last, _Dest, &_Ctype);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	ff 75 10	 push	 DWORD PTR __Dest$[ebp]
  00011	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  00014	ff 75 08	 push	 DWORD PTR __First$[ebp]
  00017	e8 00 00 00 00	 call	 __Getwctypes
  0001c	83 c4 10	 add	 esp, 16			; 00000010H

; 2903 :     }

  0001f	c9		 leave
  00020	c2 0c 00	 ret	 12			; 0000000cH
?do_is@?$ctype@_W@std@@MBEPB_WPB_W0PAF@Z ENDP		; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_is@?$ctype@_W@std@@MBE_NF_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv72 = -4						; size = 4
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 2
?do_is@?$ctype@_W@std@@MBE_NF_W@Z PROC			; std::ctype<wchar_t>::do_is, COMDAT
; _this$ = ecx

; 2895 :         mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2896 :         return (_CSTD _Getwctype(_Ch, &_Ctype) & _Maskval) != 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 c0 08	 add	 eax, 8
  0000e	50		 push	 eax
  0000f	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00012	e8 00 00 00 00	 call	 __Getwctype
  00017	59		 pop	 ecx
  00018	59		 pop	 ecx
  00019	98		 cwde
  0001a	0f bf 4d 08	 movsx	 ecx, WORD PTR __Maskval$[ebp]
  0001e	23 c1		 and	 eax, ecx
  00020	74 09		 je	 SHORT $LN3@do_is
  00022	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00029	eb 04		 jmp	 SHORT $LN4@do_is
$LN3@do_is:
  0002b	83 65 fc 00	 and	 DWORD PTR tv72[ebp], 0
$LN4@do_is:
  0002f	8a 45 fc	 mov	 al, BYTE PTR tv72[ebp]

; 2897 :     }

  00032	c9		 leave
  00033	c2 08 00	 ret	 8
?do_is@?$ctype@_W@std@@MBE_NF_W@Z ENDP			; std::ctype<wchar_t>::do_is
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??1?$ctype@_W@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ctype@_W@std@@MAE@XZ PROC				; std::ctype<wchar_t>::~ctype<wchar_t>, COMDAT
; _this$ = ecx

; 2881 :     virtual __CLR_OR_THIS_CALL ~ctype() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$ctype@_W@std@@6B@

; 2882 :         if (_Ctype._Delfl) {

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00017	74 0c		 je	 SHORT $LN2@ctype

; 2883 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	ff 70 0c	 push	 DWORD PTR [eax+12]
  0001f	e8 00 00 00 00	 call	 _free
  00024	59		 pop	 ecx
$LN2@ctype:

; 2884 :         }
; 2885 : 
; 2886 :         _CSTD free(_Ctype._LocaleName);

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	ff 70 14	 push	 DWORD PTR [eax+20]
  0002b	e8 00 00 00 00	 call	 _free
  00030	59		 pop	 ecx

; 2368 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2887 :     }

  0004c	c9		 leave
  0004d	c3		 ret	 0
??1?$ctype@_W@std@@MAE@XZ ENDP				; std::ctype<wchar_t>::~ctype<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -172						; size = 44
$T3 = -128						; size = 52
$T4 = -76						; size = 16
$T5 = -60						; size = 16
$T6 = -44						; size = 16
tv128 = -28						; size = 4
$T7 = -24						; size = 4
$T8 = -20						; size = 4
tv89 = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv142 = 0						; size = 4
tv137 = 4						; size = 4
_this$ = 8						; size = 4
$T9 = 12						; size = 4
$T10 = 16						; size = 4
$T11 = 20						; size = 44
$T12 = 64						; size = 44
__$ArrayPad$ = 108					; size = 4
__Ppf$ = 120						; size = 4
__Ploc$ = 124						; size = 4
?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<wchar_t>::_Getcat, COMDAT

; 2872 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 6c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	50		 push	 eax
  00029	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00032	83 65 0c 00	 and	 DWORD PTR $T9[ebp], 0

; 2873 :         if (_Ppf && !*_Ppf) {

  00036	83 7d 78 00	 cmp	 DWORD PTR __Ppf$[ebp], 0
  0003a	0f 84 38 01 00
	00		 je	 $LN2@Getcat
  00040	8b 45 78	 mov	 eax, DWORD PTR __Ppf$[ebp]
  00043	83 38 00	 cmp	 DWORD PTR [eax], 0
  00046	0f 85 2c 01 00
	00		 jne	 $LN2@Getcat

; 2874 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  0004c	6a 44		 push	 68			; 00000044H
  0004e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00053	59		 pop	 ecx
  00054	89 45 10	 mov	 DWORD PTR $T10[ebp], eax
  00057	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005b	83 7d 10 00	 cmp	 DWORD PTR $T10[ebp], 0
  0005f	0f 84 e9 00 00
	00		 je	 $LN4@Getcat

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00065	8b 45 7c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00068	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0006c	74 35		 je	 SHORT $LN12@Getcat
  0006e	8b 45 7c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00071	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00074	83 c0 18	 add	 eax, 24			; 00000018H
  00077	89 45 08	 mov	 DWORD PTR _this$[ebp], eax
  0007a	8b 45 e8	 mov	 eax, DWORD PTR $T7[ebp]
  0007d	89 45 04	 mov	 DWORD PTR tv137[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo

; 109  :         return _Myptr ? _Myptr : &_Nul;

  00080	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00083	83 38 00	 cmp	 DWORD PTR [eax], 0
  00086	74 0a		 je	 SHORT $LN16@Getcat
  00088	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0008b	8b 00		 mov	 eax, DWORD PTR [eax]
  0008d	89 45 00	 mov	 DWORD PTR tv142[ebp], eax
  00090	eb 09		 jmp	 SHORT $LN17@Getcat
$LN16@Getcat:
  00092	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 c0 04	 add	 eax, 4
  00098	89 45 00	 mov	 DWORD PTR tv142[ebp], eax
$LN17@Getcat:
  0009b	8b 45 00	 mov	 eax, DWORD PTR tv142[ebp]
  0009e	89 45 04	 mov	 DWORD PTR tv137[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  000a1	eb 07		 jmp	 SHORT $LN10@Getcat
$LN12@Getcat:
  000a3	c7 45 04 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN10@Getcat:

; 2874 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  000aa	ff 75 04	 push	 DWORD PTR tv137[ebp]
  000ad	8d 4d 80	 lea	 ecx, DWORD PTR $T3[ebp]
  000b0	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  000b5	89 45 e4	 mov	 DWORD PTR tv128[ebp], eax
  000b8	8b 45 0c	 mov	 eax, DWORD PTR $T9[ebp]
  000bb	83 c8 01	 or	 eax, 1
  000be	89 45 0c	 mov	 DWORD PTR $T9[ebp], eax
  000c1	8b 45 10	 mov	 eax, DWORD PTR $T10[ebp]
  000c4	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@

; 153  :         {}

  000ca	8b 45 10	 mov	 eax, DWORD PTR $T10[ebp]
  000cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 152  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  000d3	8b 45 10	 mov	 eax, DWORD PTR $T10[ebp]
  000d6	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 2366 :     __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) : locale::facet(_Refs) {}

  000da	8b 45 10	 mov	 eax, DWORD PTR $T10[ebp]
  000dd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 2868 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

  000e3	8b 45 10	 mov	 eax, DWORD PTR $T10[ebp]
  000e6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$ctype@_W@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo

; 199  :         return ::_Getctype();

  000ec	8d 45 b4	 lea	 eax, DWORD PTR $T4[ebp]
  000ef	50		 push	 eax
  000f0	e8 00 00 00 00	 call	 __Getctype
  000f5	59		 pop	 ecx
  000f6	8b f0		 mov	 esi, eax
  000f8	8d 7d d4	 lea	 edi, DWORD PTR $T6[ebp]
  000fb	a5		 movsd
  000fc	a5		 movsd
  000fd	a5		 movsd
  000fe	a5		 movsd
  000ff	8d 75 d4	 lea	 esi, DWORD PTR $T6[ebp]
  00102	8d 7d c4	 lea	 edi, DWORD PTR $T5[ebp]
  00105	a5		 movsd
  00106	a5		 movsd
  00107	a5		 movsd
  00108	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2890 :         _Ctype = _Lobj._Getctype();

  00109	8b 7d 10	 mov	 edi, DWORD PTR $T10[ebp]
  0010c	83 c7 08	 add	 edi, 8
  0010f	8d 75 c4	 lea	 esi, DWORD PTR $T5[ebp]
  00112	a5		 movsd
  00113	a5		 movsd
  00114	a5		 movsd
  00115	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo

; 203  :         return ::_Getcvt();

  00116	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 __Getcvt
  00122	59		 pop	 ecx
  00123	6a 0b		 push	 11			; 0000000bH
  00125	59		 pop	 ecx
  00126	8b f0		 mov	 esi, eax
  00128	8d 7d 40	 lea	 edi, DWORD PTR $T12[ebp]
  0012b	f3 a5		 rep movsd
  0012d	6a 0b		 push	 11			; 0000000bH
  0012f	59		 pop	 ecx
  00130	8d 75 40	 lea	 esi, DWORD PTR $T12[ebp]
  00133	8d 7d 14	 lea	 edi, DWORD PTR $T11[ebp]
  00136	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2891 :         _Cvt   = _Lobj._Getcvt();

  00138	8b 7d 10	 mov	 edi, DWORD PTR $T10[ebp]
  0013b	83 c7 18	 add	 edi, 24			; 00000018H
  0013e	6a 0b		 push	 11			; 0000000bH
  00140	59		 pop	 ecx
  00141	8d 75 14	 lea	 esi, DWORD PTR $T11[ebp]
  00144	f3 a5		 rep movsd

; 2874 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));

  00146	8b 45 10	 mov	 eax, DWORD PTR $T10[ebp]
  00149	89 45 f0	 mov	 DWORD PTR tv89[ebp], eax
  0014c	eb 04		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  0014e	83 65 f0 00	 and	 DWORD PTR tv89[ebp], 0
$LN5@Getcat:
  00152	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00155	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
  00158	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0015c	8b 45 78	 mov	 eax, DWORD PTR __Ppf$[ebp]
  0015f	8b 4d ec	 mov	 ecx, DWORD PTR $T8[ebp]
  00162	89 08		 mov	 DWORD PTR [eax], ecx
  00164	8b 45 0c	 mov	 eax, DWORD PTR $T9[ebp]
  00167	83 e0 01	 and	 eax, 1
  0016a	74 0c		 je	 SHORT $LN2@Getcat
  0016c	83 65 0c fe	 and	 DWORD PTR $T9[ebp], -2	; fffffffeH
  00170	8d 4d 80	 lea	 ecx, DWORD PTR $T3[ebp]
  00173	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 2875 :         }
; 2876 : 
; 2877 :         return _X_CTYPE;

  00178	6a 02		 push	 2
  0017a	58		 pop	 eax

; 2878 :     }

  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00185	59		 pop	 ecx
  00186	5f		 pop	 edi
  00187	5e		 pop	 esi
  00188	8b 4d 6c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018b	33 cd		 xor	 ecx, ebp
  0018d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00192	83 c5 70	 add	 ebp, 112		; 00000070H
  00195	c9		 leave
  00196	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 44		 push	 68			; 00000044H
  00002	ff 75 10	 push	 DWORD PTR $T10[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 8a 54 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-172]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a 78	 mov	 ecx, DWORD PTR [edx+120]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@_W@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<wchar_t>::_Getcat
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2368 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00022	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00025	83 e0 01	 and	 eax, 1
  00028	74 0c		 je	 SHORT $LN2@scalar
  0002a	6a 08		 push	 8
  0002c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx
$LN2@scalar:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c9		 leave
  0003a	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_G?$codecvt@_WDU_Mbstatet@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$codecvt@_WDU_Mbstatet@@@std@@MAEPAXI@Z PROC	; std::codecvt<wchar_t,char,_Mbstatet>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1978 :     virtual __CLR_OR_THIS_CALL ~codecvt() noexcept {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$codecvt@_WDU_Mbstatet@@@std@@6B@

; 644  :     __CLR_OR_THIS_CALL ~codecvt_base() noexcept {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7codecvt_base@std@@6B@

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  0002b	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002e	83 e0 01	 and	 eax, 1
  00031	74 0c		 je	 SHORT $LN2@scalar
  00033	6a 34		 push	 52			; 00000034H
  00035	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003d	59		 pop	 ecx
  0003e	59		 pop	 ecx
$LN2@scalar:
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c9		 leave
  00043	c2 04 00	 ret	 4
??_G?$codecvt@_WDU_Mbstatet@@@std@@MAEPAXI@Z ENDP	; std::codecvt<wchar_t,char,_Mbstatet>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_encoding@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?do_encoding@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ PROC	; std::codecvt<wchar_t,char,_Mbstatet>::do_encoding, COMDAT
; _this$ = ecx

; 2114 :     virtual int __CLR_OR_THIS_CALL do_encoding() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2115 :         // return length of code sequence (from codecvt)
; 2116 :         return _Cvt._Mbcurmax == 1; // 0 => varying length, 1 => fixed length

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  0000f	75 09		 jne	 SHORT $LN3@do_encodin
  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00018	eb 04		 jmp	 SHORT $LN4@do_encodin
$LN3@do_encodin:
  0001a	83 65 fc 00	 and	 DWORD PTR tv67[ebp], 0
$LN4@do_encodin:
  0001e	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]

; 2117 :     }

  00021	c9		 leave
  00022	c3		 ret	 0
?do_encoding@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ ENDP	; std::codecvt<wchar_t,char,_Mbstatet>::do_encoding
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_max_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_max_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ PROC ; std::codecvt<wchar_t,char,_Mbstatet>::do_max_length, COMDAT
; _this$ = ecx

; 2109 :     virtual int __CLR_OR_THIS_CALL do_max_length() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2110 :         // return maximum length required for a conversion (from codecvt)
; 2111 :         return static_cast<int>(_Cvt._Mbcurmax);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2112 :     }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?do_max_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHXZ ENDP ; std::codecvt<wchar_t,char,_Mbstatet>::do_max_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_always_noconv@?$codecvt@_WDU_Mbstatet@@@std@@MBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_always_noconv@?$codecvt@_WDU_Mbstatet@@@std@@MBE_NXZ PROC ; std::codecvt<wchar_t,char,_Mbstatet>::do_always_noconv, COMDAT
; _this$ = ecx

; 2104 :     virtual bool __CLR_OR_THIS_CALL do_always_noconv() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2105 :         // return true if conversions never change input
; 2106 :         return false;

  00007	32 c0		 xor	 al, al

; 2107 :     }

  00009	c9		 leave
  0000a	c3		 ret	 0
?do_always_noconv@?$codecvt@_WDU_Mbstatet@@@std@@MBE_NXZ ENDP ; std::codecvt<wchar_t,char,_Mbstatet>::do_always_noconv
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
__Old_first1$ = -28					; size = 4
_this$ = -24						; size = 4
tv65 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
__Bytes$5 = -8						; size = 4
__Ch$6 = -4						; size = 2
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Count$ = 20						; size = 4
?do_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z PROC ; std::codecvt<wchar_t,char,_Mbstatet>::do_length, COMDAT
; _this$ = ecx

; 2080 :         mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2081 :         // return p - _First1, for the largest value p in [_First1, _Last1] such that [_First1, p) successfully
; 2082 :         // converts to at most _Count wide characters
; 2083 :         _Adl_verify_range(_First1, _Last1);
; 2084 :         const auto _Old_first1 = _First1;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __First1$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Old_first1$[ebp], eax

; 2085 : 
; 2086 :         for (; _Count > 0u && _First1 != _Last1; --_Count) {

  0000f	eb 07		 jmp	 SHORT $LN4@do_length
$LN2@do_length:
  00011	8b 45 14	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	48		 dec	 eax
  00015	89 45 14	 mov	 DWORD PTR __Count$[ebp], eax
$LN4@do_length:
  00018	83 7d 14 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001c	76 4b		 jbe	 SHORT $LN3@do_length
  0001e	8b 45 0c	 mov	 eax, DWORD PTR __First1$[ebp]
  00021	3b 45 10	 cmp	 eax, DWORD PTR __Last1$[ebp]
  00024	74 43		 je	 SHORT $LN3@do_length

; 2087 :             wchar_t _Ch;
; 2088 :             int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);

  00026	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c0 08	 add	 eax, 8
  0002c	50		 push	 eax
  0002d	ff 75 08	 push	 DWORD PTR __State$[ebp]
  00030	8b 45 10	 mov	 eax, DWORD PTR __Last1$[ebp]
  00033	2b 45 0c	 sub	 eax, DWORD PTR __First1$[ebp]
  00036	50		 push	 eax
  00037	ff 75 0c	 push	 DWORD PTR __First1$[ebp]
  0003a	8d 45 fc	 lea	 eax, DWORD PTR __Ch$6[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 __Mbrtowc
  00043	83 c4 14	 add	 esp, 20			; 00000014H
  00046	89 45 f8	 mov	 DWORD PTR __Bytes$5[ebp], eax

; 2089 :             if (_Bytes < 0) { // partial or failed conversion

  00049	83 7d f8 00	 cmp	 DWORD PTR __Bytes$5[ebp], 0
  0004d	7d 02		 jge	 SHORT $LN5@do_length

; 2090 :                 break;

  0004f	eb 18		 jmp	 SHORT $LN3@do_length
$LN5@do_length:

; 2091 :             }
; 2092 : 
; 2093 :             if (_Bytes == 0) { // converted NULL character, TRANSITION, VSO-654347

  00051	83 7d f8 00	 cmp	 DWORD PTR __Bytes$5[ebp], 0
  00055	75 07		 jne	 SHORT $LN6@do_length

; 2094 :                 _Bytes = 1;

  00057	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR __Bytes$5[ebp], 1
$LN6@do_length:

; 2095 :             }
; 2096 : 
; 2097 :             // converted _Bytes bytes to a wide character
; 2098 :             _First1 += _Bytes;

  0005e	8b 45 0c	 mov	 eax, DWORD PTR __First1$[ebp]
  00061	03 45 f8	 add	 eax, DWORD PTR __Bytes$5[ebp]
  00064	89 45 0c	 mov	 DWORD PTR __First1$[ebp], eax

; 2099 :         }

  00067	eb a8		 jmp	 SHORT $LN2@do_length
$LN3@do_length:

; 2101 :         return static_cast<int>((_STD min)(_First1 - _Old_first1, ptrdiff_t{INT_MAX}));

  00069	c7 45 f4 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
  00070	8b 45 0c	 mov	 eax, DWORD PTR __First1$[ebp]
  00073	2b 45 e4	 sub	 eax, DWORD PTR __Old_first1$[ebp]
  00076	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00079	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  0007c	3b 45 f0	 cmp	 eax, DWORD PTR $T3[ebp]
  0007f	7d 08		 jge	 SHORT $LN12@do_length
  00081	8d 45 f4	 lea	 eax, DWORD PTR $T4[ebp]
  00084	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00087	eb 06		 jmp	 SHORT $LN13@do_length
$LN12@do_length:
  00089	8d 45 f0	 lea	 eax, DWORD PTR $T3[ebp]
  0008c	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
$LN13@do_length:
  0008f	8b 45 ec	 mov	 eax, DWORD PTR tv65[ebp]
  00092	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00095	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00098	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 2101 :         return static_cast<int>((_STD min)(_First1 - _Old_first1, ptrdiff_t{INT_MAX}));

  0009b	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0009e	8b 00		 mov	 eax, DWORD PTR [eax]

; 2102 :     }

  000a0	c9		 leave
  000a1	c2 10 00	 ret	 16			; 00000010H
?do_length@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1I@Z ENDP ; std::codecvt<wchar_t,char,_Mbstatet>::do_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_unshift@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z
_TEXT	SEGMENT
__Stsave$ = -32						; size = 8
_this$ = -24						; size = 4
__Ans$ = -20						; size = 4
__Bytes$ = -16						; size = 4
__Buf$ = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__State$ = 8						; size = 4
__First2$ = 12						; size = 4
__Last2$ = 16						; size = 4
__Mid2$ = 20						; size = 4
?do_unshift@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z PROC ; std::codecvt<wchar_t,char,_Mbstatet>::do_unshift, COMDAT
; _this$ = ecx

; 2058 :     virtual result __CLR_OR_THIS_CALL do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2059 :         // generate bytes to return to default shift state
; 2060 :         _Adl_verify_range(_First2, _Last2);
; 2061 :         _Mid2       = _First2;

  00013	8b 45 14	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 2062 :         result _Ans = ok;

  0001b	83 65 ec 00	 and	 DWORD PTR __Ans$[ebp], 0

; 2063 :         int _Bytes;
; 2064 :         char _Buf[MB_LEN_MAX];
; 2065 :         mbstate_t _Stsave = _State;

  0001f	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00027	89 4d e0	 mov	 DWORD PTR __Stsave$[ebp], ecx
  0002a	89 45 e4	 mov	 DWORD PTR __Stsave$[ebp+4], eax

; 2066 : 
; 2067 :         if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0) {

  0002d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 08	 add	 eax, 8
  00033	50		 push	 eax
  00034	ff 75 08	 push	 DWORD PTR __State$[ebp]
  00037	6a 00		 push	 0
  00039	8d 45 f4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 __Wcrtomb
  00042	83 c4 10	 add	 esp, 16			; 00000010H
  00045	89 45 f0	 mov	 DWORD PTR __Bytes$[ebp], eax
  00048	83 7d f0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0004c	7f 09		 jg	 SHORT $LN2@do_unshift

; 2068 :             _Ans = error; // locale-specific wcrtomb failed

  0004e	c7 45 ec 02 00
	00 00		 mov	 DWORD PTR __Ans$[ebp], 2
  00055	eb 52		 jmp	 SHORT $LN3@do_unshift
$LN2@do_unshift:

; 2069 :         } else if (_Last2 - _Mid2 < --_Bytes) { // converted too many, roll back and return

  00057	8b 45 f0	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0005a	48		 dec	 eax
  0005b	89 45 f0	 mov	 DWORD PTR __Bytes$[ebp], eax
  0005e	8b 45 14	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00061	8b 4d 10	 mov	 ecx, DWORD PTR __Last2$[ebp]
  00064	2b 08		 sub	 ecx, DWORD PTR [eax]
  00066	3b 4d f0	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  00069	7d 17		 jge	 SHORT $LN4@do_unshift

; 2070 :             _State = _Stsave;

  0006b	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  0006e	8b 4d e0	 mov	 ecx, DWORD PTR __Stsave$[ebp]
  00071	8b 55 e4	 mov	 edx, DWORD PTR __Stsave$[ebp+4]
  00074	89 08		 mov	 DWORD PTR [eax], ecx
  00076	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2071 :             _Ans   = partial;

  00079	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR __Ans$[ebp], 1
  00080	eb 27		 jmp	 SHORT $LN3@do_unshift
$LN4@do_unshift:

; 2072 :         } else if (0 < _Bytes) { // copy converted bytes from buffer

  00082	83 7d f0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00086	7e 21		 jle	 SHORT $LN3@do_unshift

; 2073 :             _CSTD memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));

  00088	ff 75 f0	 push	 DWORD PTR __Bytes$[ebp]
  0008b	8d 45 f4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0008e	50		 push	 eax
  0008f	8b 45 14	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00092	ff 30		 push	 DWORD PTR [eax]
  00094	e8 00 00 00 00	 call	 _memcpy
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2074 :             _Mid2 += _Bytes;

  0009c	8b 45 14	 mov	 eax, DWORD PTR __Mid2$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	03 45 f0	 add	 eax, DWORD PTR __Bytes$[ebp]
  000a4	8b 4d 14	 mov	 ecx, DWORD PTR __Mid2$[ebp]
  000a7	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@do_unshift:

; 2075 :         }
; 2076 :         return _Ans;

  000a9	8b 45 ec	 mov	 eax, DWORD PTR __Ans$[ebp]

; 2077 :     }

  000ac	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000af	33 cd		 xor	 ecx, ebp
  000b1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b6	c9		 leave
  000b7	c2 10 00	 ret	 16			; 00000010H
?do_unshift@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PAD1AAPAD@Z ENDP ; std::codecvt<wchar_t,char,_Mbstatet>::do_unshift
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_out@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PB_W1AAPB_WPAD3AAPAD@Z
_TEXT	SEGMENT
__Stsave$1 = -32					; size = 8
tv131 = -24						; size = 4
_this$ = -20						; size = 4
__Bytes$ = -16						; size = 4
__Buf$2 = -12						; size = 5
__$ArrayPad$ = -4					; size = 4
__State$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_out@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PB_W1AAPB_WPAD3AAPAD@Z PROC ; std::codecvt<wchar_t,char,_Mbstatet>::do_out, COMDAT
; _this$ = ecx

; 2022 :         const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2023 :         // convert [_First1, _Last1) to bytes [_First2, _Last2)
; 2024 :         _Adl_verify_range(_First1, _Last1);
; 2025 :         _Adl_verify_range(_First2, _Last2);
; 2026 :         _Mid1 = _First1;

  00013	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00016	8b 4d 0c	 mov	 ecx, DWORD PTR __First1$[ebp]
  00019	89 08		 mov	 DWORD PTR [eax], ecx

; 2027 :         _Mid2 = _First2;

  0001b	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  0001e	8b 4d 18	 mov	 ecx, DWORD PTR __First2$[ebp]
  00021	89 08		 mov	 DWORD PTR [eax], ecx
$LN2@do_out:

; 2028 :         int _Bytes;
; 2029 : 
; 2030 :         while (_Mid1 != _Last1 && _Mid2 != _Last2) {

  00023	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	3b 45 10	 cmp	 eax, DWORD PTR __Last1$[ebp]
  0002b	0f 84 fa 00 00
	00		 je	 $LN3@do_out
  00031	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	3b 45 1c	 cmp	 eax, DWORD PTR __Last2$[ebp]
  00039	0f 84 ec 00 00
	00		 je	 $LN3@do_out

; 2031 :             if (MB_LEN_MAX <= _Last2 - _Mid2) {

  0003f	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00042	8b 4d 1c	 mov	 ecx, DWORD PTR __Last2$[ebp]
  00045	2b 08		 sub	 ecx, DWORD PTR [eax]
  00047	83 f9 05	 cmp	 ecx, 5
  0004a	7c 51		 jl	 SHORT $LN4@do_out

; 2032 :                 if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0) {

  0004c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	83 c0 08	 add	 eax, 8
  00052	50		 push	 eax
  00053	ff 75 08	 push	 DWORD PTR __State$[ebp]
  00056	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	0f b7 00	 movzx	 eax, WORD PTR [eax]
  0005e	50		 push	 eax
  0005f	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00062	ff 30		 push	 DWORD PTR [eax]
  00064	e8 00 00 00 00	 call	 __Wcrtomb
  00069	83 c4 10	 add	 esp, 16			; 00000010H
  0006c	89 45 f0	 mov	 DWORD PTR __Bytes$[ebp], eax
  0006f	83 7d f0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00073	7d 0a		 jge	 SHORT $LN6@do_out

; 2033 :                     return error; // locale-specific wcrtomb failed

  00075	6a 02		 push	 2
  00077	58		 pop	 eax
  00078	e9 c8 00 00 00	 jmp	 $LN1@do_out

; 2034 :                 } else {

  0007d	eb 19		 jmp	 SHORT $LN7@do_out
$LN6@do_out:

; 2035 :                     ++_Mid1;

  0007f	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00082	8b 00		 mov	 eax, DWORD PTR [eax]
  00084	40		 inc	 eax
  00085	40		 inc	 eax
  00086	8b 4d 14	 mov	 ecx, DWORD PTR __Mid1$[ebp]
  00089	89 01		 mov	 DWORD PTR [ecx], eax

; 2036 :                     _Mid2 += _Bytes;

  0008b	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]
  00090	03 45 f0	 add	 eax, DWORD PTR __Bytes$[ebp]
  00093	8b 4d 20	 mov	 ecx, DWORD PTR __Mid2$[ebp]
  00096	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@do_out:

; 2037 :                 }
; 2038 :             } else { // destination too small, convert into buffer

  00098	e9 89 00 00 00	 jmp	 $LN5@do_out
$LN4@do_out:

; 2039 :                 char _Buf[MB_LEN_MAX];
; 2040 :                 mbstate_t _Stsave = _State;

  0009d	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  000a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a5	89 4d e0	 mov	 DWORD PTR __Stsave$1[ebp], ecx
  000a8	89 45 e4	 mov	 DWORD PTR __Stsave$1[ebp+4], eax

; 2041 : 
; 2042 :                 if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0) {

  000ab	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	83 c0 08	 add	 eax, 8
  000b1	50		 push	 eax
  000b2	ff 75 08	 push	 DWORD PTR __State$[ebp]
  000b5	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000bd	50		 push	 eax
  000be	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 __Wcrtomb
  000c7	83 c4 10	 add	 esp, 16			; 00000010H
  000ca	89 45 f0	 mov	 DWORD PTR __Bytes$[ebp], eax
  000cd	83 7d f0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  000d1	7d 07		 jge	 SHORT $LN8@do_out

; 2043 :                     return error; // locale-specific wcrtomb failed

  000d3	6a 02		 push	 2
  000d5	58		 pop	 eax
  000d6	eb 6d		 jmp	 SHORT $LN1@do_out
  000d8	eb 4c		 jmp	 SHORT $LN5@do_out
$LN8@do_out:

; 2044 :                 } else if (_Last2 - _Mid2 < _Bytes) { // converted too many, roll back and return previous

  000da	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  000dd	8b 4d 1c	 mov	 ecx, DWORD PTR __Last2$[ebp]
  000e0	2b 08		 sub	 ecx, DWORD PTR [eax]
  000e2	3b 4d f0	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  000e5	7d 12		 jge	 SHORT $LN10@do_out

; 2045 :                     _State = _Stsave;

  000e7	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  000ea	8b 4d e0	 mov	 ecx, DWORD PTR __Stsave$1[ebp]
  000ed	8b 55 e4	 mov	 edx, DWORD PTR __Stsave$1[ebp+4]
  000f0	89 08		 mov	 DWORD PTR [eax], ecx
  000f2	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 2046 :                     break;

  000f5	eb 34		 jmp	 SHORT $LN3@do_out

; 2047 :                 } else { // copy converted bytes from buffer

  000f7	eb 2d		 jmp	 SHORT $LN5@do_out
$LN10@do_out:

; 2048 :                     _CSTD memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));

  000f9	ff 75 f0	 push	 DWORD PTR __Bytes$[ebp]
  000fc	8d 45 f4	 lea	 eax, DWORD PTR __Buf$2[ebp]
  000ff	50		 push	 eax
  00100	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00103	ff 30		 push	 DWORD PTR [eax]
  00105	e8 00 00 00 00	 call	 _memcpy
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2049 :                     ++_Mid1;

  0010d	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00110	8b 00		 mov	 eax, DWORD PTR [eax]
  00112	40		 inc	 eax
  00113	40		 inc	 eax
  00114	8b 4d 14	 mov	 ecx, DWORD PTR __Mid1$[ebp]
  00117	89 01		 mov	 DWORD PTR [ecx], eax

; 2050 :                     _Mid2 += _Bytes;

  00119	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  0011c	8b 00		 mov	 eax, DWORD PTR [eax]
  0011e	03 45 f0	 add	 eax, DWORD PTR __Bytes$[ebp]
  00121	8b 4d 20	 mov	 ecx, DWORD PTR __Mid2$[ebp]
  00124	89 01		 mov	 DWORD PTR [ecx], eax
$LN5@do_out:

; 2051 :                 }
; 2052 :             }
; 2053 :         }

  00126	e9 f8 fe ff ff	 jmp	 $LN2@do_out
$LN3@do_out:

; 2054 : 
; 2055 :         return _Mid1 == _Last1 ? ok : partial;

  0012b	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  0012e	8b 00		 mov	 eax, DWORD PTR [eax]
  00130	3b 45 10	 cmp	 eax, DWORD PTR __Last1$[ebp]
  00133	75 06		 jne	 SHORT $LN13@do_out
  00135	83 65 e8 00	 and	 DWORD PTR tv131[ebp], 0
  00139	eb 07		 jmp	 SHORT $LN14@do_out
$LN13@do_out:
  0013b	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
$LN14@do_out:
  00142	8b 45 e8	 mov	 eax, DWORD PTR tv131[ebp]
$LN1@do_out:

; 2056 :     }

  00145	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00148	33 cd		 xor	 ecx, ebp
  0014a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0014f	c9		 leave
  00150	c2 1c 00	 ret	 28			; 0000001cH
?do_out@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PB_W1AAPB_WPAD3AAPAD@Z ENDP ; std::codecvt<wchar_t,char,_Mbstatet>::do_out
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_in@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPA_W3AAPA_W@Z
_TEXT	SEGMENT
__Mystate$ = -20					; size = 8
_this$ = -12						; size = 4
__Bytes$1 = -8						; size = 4
tv81 = -4						; size = 4
___formal$ = 8						; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__Mid1$ = 20						; size = 4
__First2$ = 24						; size = 4
__Last2$ = 28						; size = 4
__Mid2$ = 32						; size = 4
?do_in@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPA_W3AAPA_W@Z PROC ; std::codecvt<wchar_t,char,_Mbstatet>::do_in, COMDAT
; _this$ = ecx

; 1985 :         wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1986 :         // convert bytes [_First1, _Last1) to [_First2, _Last2)
; 1987 :         mbstate_t _Mystate{};

  00009	33 c0		 xor	 eax, eax
  0000b	89 45 ec	 mov	 DWORD PTR __Mystate$[ebp], eax
  0000e	89 45 f0	 mov	 DWORD PTR __Mystate$[ebp+4], eax

; 1988 :         _Adl_verify_range(_First1, _Last1);
; 1989 :         _Adl_verify_range(_First2, _Last2);
; 1990 :         _Mid1 = _First1;

  00011	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR __First1$[ebp]
  00017	89 08		 mov	 DWORD PTR [eax], ecx

; 1991 :         _Mid2 = _First2;

  00019	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  0001c	8b 4d 18	 mov	 ecx, DWORD PTR __First2$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx
$LN4@do_in:

; 1992 :         for (;;) {
; 1993 :             if (_Mid1 == _Last1) {

  00021	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	3b 45 10	 cmp	 eax, DWORD PTR __Last1$[ebp]
  00029	75 07		 jne	 SHORT $LN7@do_in

; 1994 :                 return ok;

  0002b	33 c0		 xor	 eax, eax
  0002d	e9 81 00 00 00	 jmp	 $LN1@do_in
$LN7@do_in:

; 1995 :             }
; 1996 : 
; 1997 :             if (_Mid2 == _Last2) {

  00032	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  00035	8b 00		 mov	 eax, DWORD PTR [eax]
  00037	3b 45 1c	 cmp	 eax, DWORD PTR __Last2$[ebp]
  0003a	75 05		 jne	 SHORT $LN8@do_in

; 1998 :                 return partial;

  0003c	33 c0		 xor	 eax, eax
  0003e	40		 inc	 eax
  0003f	eb 72		 jmp	 SHORT $LN1@do_in
$LN8@do_in:

; 1999 :             }
; 2000 : 
; 2001 :             int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);

  00041	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 c0 08	 add	 eax, 8
  00047	50		 push	 eax
  00048	8d 45 ec	 lea	 eax, DWORD PTR __Mystate$[ebp]
  0004b	50		 push	 eax
  0004c	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  0004f	8b 4d 10	 mov	 ecx, DWORD PTR __Last1$[ebp]
  00052	2b 08		 sub	 ecx, DWORD PTR [eax]
  00054	51		 push	 ecx
  00055	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 __Mbrtowc
  00064	83 c4 14	 add	 esp, 20			; 00000014H
  00067	89 45 f8	 mov	 DWORD PTR __Bytes$1[ebp], eax

; 2002 :             switch (_Bytes) {

  0006a	8b 45 f8	 mov	 eax, DWORD PTR __Bytes$1[ebp]
  0006d	89 45 fc	 mov	 DWORD PTR tv81[ebp], eax
  00070	83 7d fc fe	 cmp	 DWORD PTR tv81[ebp], -2	; fffffffeH
  00074	74 0e		 je	 SHORT $LN9@do_in
  00076	83 7d fc ff	 cmp	 DWORD PTR tv81[ebp], -1
  0007a	74 0d		 je	 SHORT $LN10@do_in
  0007c	83 7d fc 00	 cmp	 DWORD PTR tv81[ebp], 0
  00080	74 0c		 je	 SHORT $LN11@do_in
  00082	eb 11		 jmp	 SHORT $LN12@do_in
$LN9@do_in:

; 2003 :             case -2: // partial conversion
; 2004 :                 return partial;

  00084	33 c0		 xor	 eax, eax
  00086	40		 inc	 eax
  00087	eb 2a		 jmp	 SHORT $LN1@do_in
$LN10@do_in:

; 2005 : 
; 2006 :             case -1: // failed conversion
; 2007 :                 return error;

  00089	6a 02		 push	 2
  0008b	58		 pop	 eax
  0008c	eb 25		 jmp	 SHORT $LN1@do_in
$LN11@do_in:

; 2008 : 
; 2009 :             case 0: // converted NULL character, TRANSITION, VSO-654347
; 2010 :                 _Bytes = 1;

  0008e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR __Bytes$1[ebp], 1
$LN12@do_in:

; 2011 :                 // [[fallthrough]];
; 2012 : 
; 2013 :             default: // converted some other character
; 2014 :                 _Mid1 += _Bytes;

  00095	8b 45 14	 mov	 eax, DWORD PTR __Mid1$[ebp]
  00098	8b 00		 mov	 eax, DWORD PTR [eax]
  0009a	03 45 f8	 add	 eax, DWORD PTR __Bytes$1[ebp]
  0009d	8b 4d 14	 mov	 ecx, DWORD PTR __Mid1$[ebp]
  000a0	89 01		 mov	 DWORD PTR [ecx], eax

; 2015 :                 ++_Mid2;

  000a2	8b 45 20	 mov	 eax, DWORD PTR __Mid2$[ebp]
  000a5	8b 00		 mov	 eax, DWORD PTR [eax]
  000a7	40		 inc	 eax
  000a8	40		 inc	 eax
  000a9	8b 4d 20	 mov	 ecx, DWORD PTR __Mid2$[ebp]
  000ac	89 01		 mov	 DWORD PTR [ecx], eax

; 2016 :                 break;
; 2017 :             }
; 2018 :         }

  000ae	e9 6e ff ff ff	 jmp	 $LN4@do_in
$LN1@do_in:

; 2019 :     }

  000b3	c9		 leave
  000b4	c2 1c 00	 ret	 28			; 0000001cH
?do_in@?$codecvt@_WDU_Mbstatet@@@std@@MBEHAAU_Mbstatet@@PBD1AAPBDPA_W3AAPA_W@Z ENDP ; std::codecvt<wchar_t,char,_Mbstatet>::do_in
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -124						; size = 44
$T3 = -80						; size = 52
tv128 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
tv89 = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv142 = 0						; size = 4
tv137 = 4						; size = 4
_this$ = 8						; size = 4
$T6 = 12						; size = 4
$T7 = 16						; size = 4
$T8 = 20						; size = 44
$T9 = 64						; size = 44
__$ArrayPad$ = 108					; size = 4
__Ppf$ = 120						; size = 4
__Ploc$ = 124						; size = 4
?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::codecvt<wchar_t,char,_Mbstatet>::_Getcat, COMDAT

; 1968 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 70	 sub	 esp, 112		; 00000070H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 6c	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	56		 push	 esi
  00024	57		 push	 edi
  00025	50		 push	 eax
  00026	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00029	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002f	83 65 0c 00	 and	 DWORD PTR $T6[ebp], 0

; 1969 :         // return locale category mask and construct standard facet
; 1970 :         if (_Ppf && !*_Ppf) {

  00033	83 7d 78 00	 cmp	 DWORD PTR __Ppf$[ebp], 0
  00037	0f 84 0b 01 00
	00		 je	 $LN2@Getcat
  0003d	8b 45 78	 mov	 eax, DWORD PTR __Ppf$[ebp]
  00040	83 38 00	 cmp	 DWORD PTR [eax], 0
  00043	0f 85 ff 00 00
	00		 jne	 $LN2@Getcat

; 1971 :             *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));

  00049	6a 34		 push	 52			; 00000034H
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00050	59		 pop	 ecx
  00051	89 45 10	 mov	 DWORD PTR $T7[ebp], eax
  00054	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00058	83 7d 10 00	 cmp	 DWORD PTR $T7[ebp], 0
  0005c	0f 84 bc 00 00
	00		 je	 $LN4@Getcat

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00062	8b 45 7c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  00065	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00069	74 35		 je	 SHORT $LN12@Getcat
  0006b	8b 45 7c	 mov	 eax, DWORD PTR __Ploc$[ebp]
  0006e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00071	83 c0 18	 add	 eax, 24			; 00000018H
  00074	89 45 08	 mov	 DWORD PTR _this$[ebp], eax
  00077	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  0007a	89 45 04	 mov	 DWORD PTR tv137[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo

; 109  :         return _Myptr ? _Myptr : &_Nul;

  0007d	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00080	83 38 00	 cmp	 DWORD PTR [eax], 0
  00083	74 0a		 je	 SHORT $LN16@Getcat
  00085	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 00		 mov	 eax, DWORD PTR [eax]
  0008a	89 45 00	 mov	 DWORD PTR tv142[ebp], eax
  0008d	eb 09		 jmp	 SHORT $LN17@Getcat
$LN16@Getcat:
  0008f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00092	83 c0 04	 add	 eax, 4
  00095	89 45 00	 mov	 DWORD PTR tv142[ebp], eax
$LN17@Getcat:
  00098	8b 45 00	 mov	 eax, DWORD PTR tv142[ebp]
  0009b	89 45 04	 mov	 DWORD PTR tv137[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 370  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  0009e	eb 07		 jmp	 SHORT $LN10@Getcat
$LN12@Getcat:
  000a0	c7 45 04 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN10@Getcat:

; 1971 :             *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));

  000a7	ff 75 04	 push	 DWORD PTR tv137[ebp]
  000aa	8d 4d b0	 lea	 ecx, DWORD PTR $T3[ebp]
  000ad	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  000b2	89 45 e4	 mov	 DWORD PTR tv128[ebp], eax
  000b5	8b 45 0c	 mov	 eax, DWORD PTR $T6[ebp]
  000b8	83 c8 01	 or	 eax, 1
  000bb	89 45 0c	 mov	 DWORD PTR $T6[ebp], eax
  000be	8b 45 10	 mov	 eax, DWORD PTR $T7[ebp]
  000c1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@

; 153  :         {}

  000c7	8b 45 10	 mov	 eax, DWORD PTR $T7[ebp]
  000ca	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 152  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  000d0	8b 45 10	 mov	 eax, DWORD PTR $T7[ebp]
  000d3	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 628  :     __CLR_OR_THIS_CALL codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) {}

  000d7	8b 45 10	 mov	 eax, DWORD PTR $T7[ebp]
  000da	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7codecvt_base@std@@6B@

; 1964 :     explicit __CLR_OR_THIS_CALL codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs) {

  000e0	8b 45 10	 mov	 eax, DWORD PTR $T7[ebp]
  000e3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$codecvt@_WDU_Mbstatet@@@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo

; 203  :         return ::_Getcvt();

  000e9	8d 45 84	 lea	 eax, DWORD PTR $T2[ebp]
  000ec	50		 push	 eax
  000ed	e8 00 00 00 00	 call	 __Getcvt
  000f2	59		 pop	 ecx
  000f3	6a 0b		 push	 11			; 0000000bH
  000f5	59		 pop	 ecx
  000f6	8b f0		 mov	 esi, eax
  000f8	8d 7d 40	 lea	 edi, DWORD PTR $T9[ebp]
  000fb	f3 a5		 rep movsd
  000fd	6a 0b		 push	 11			; 0000000bH
  000ff	59		 pop	 ecx
  00100	8d 75 40	 lea	 esi, DWORD PTR $T9[ebp]
  00103	8d 7d 14	 lea	 edi, DWORD PTR $T8[ebp]
  00106	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 1981 :         _Cvt = _Lobj._Getcvt();

  00108	8b 7d 10	 mov	 edi, DWORD PTR $T7[ebp]
  0010b	83 c7 08	 add	 edi, 8
  0010e	6a 0b		 push	 11			; 0000000bH
  00110	59		 pop	 ecx
  00111	8d 75 14	 lea	 esi, DWORD PTR $T8[ebp]
  00114	f3 a5		 rep movsd

; 1971 :             *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));

  00116	8b 45 10	 mov	 eax, DWORD PTR $T7[ebp]
  00119	89 45 f0	 mov	 DWORD PTR tv89[ebp], eax
  0011c	eb 04		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  0011e	83 65 f0 00	 and	 DWORD PTR tv89[ebp], 0
$LN5@Getcat:
  00122	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00125	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
  00128	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0012c	8b 45 78	 mov	 eax, DWORD PTR __Ppf$[ebp]
  0012f	8b 4d ec	 mov	 ecx, DWORD PTR $T5[ebp]
  00132	89 08		 mov	 DWORD PTR [eax], ecx
  00134	8b 45 0c	 mov	 eax, DWORD PTR $T6[ebp]
  00137	83 e0 01	 and	 eax, 1
  0013a	74 0c		 je	 SHORT $LN2@Getcat
  0013c	83 65 0c fe	 and	 DWORD PTR $T6[ebp], -2	; fffffffeH
  00140	8d 4d b0	 lea	 ecx, DWORD PTR $T3[ebp]
  00143	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN2@Getcat:

; 1972 :         }
; 1973 : 
; 1974 :         return _X_CTYPE;

  00148	6a 02		 push	 2
  0014a	58		 pop	 eax

; 1975 :     }

  0014b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00155	59		 pop	 ecx
  00156	5f		 pop	 edi
  00157	5e		 pop	 esi
  00158	8b 4d 6c	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015b	33 cd		 xor	 ecx, ebp
  0015d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00162	83 c5 70	 add	 ebp, 112		; 00000070H
  00165	c9		 leave
  00166	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 34		 push	 52			; 00000034H
  00002	ff 75 10	 push	 DWORD PTR $T7[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a 84	 mov	 ecx, DWORD PTR [edx-124]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	8b 4a 78	 mov	 ecx, DWORD PTR [edx+120]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00034	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$codecvt@_WDU_Mbstatet@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::codecvt<wchar_t,char,_Mbstatet>::_Getcat
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_Gcodecvt_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gcodecvt_base@std@@UAEPAXI@Z PROC			; std::codecvt_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 644  :     __CLR_OR_THIS_CALL ~codecvt_base() noexcept {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7codecvt_base@std@@6B@

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00022	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00025	83 e0 01	 and	 eax, 1
  00028	74 0c		 je	 SHORT $LN2@scalar
  0002a	6a 08		 push	 8
  0002c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx
$LN2@scalar:
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c9		 leave
  0003a	c2 04 00	 ret	 4
??_Gcodecvt_base@std@@UAEPAXI@Z ENDP			; std::codecvt_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_encoding@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_encoding@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_encoding, COMDAT
; _this$ = ecx

; 657  :     virtual int __CLR_OR_THIS_CALL do_encoding() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 658  :         return 1; // -1 ==> state dependent, 0 ==> varying length

  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax

; 659  :     }

  0000a	c9		 leave
  0000b	c3		 ret	 0
?do_encoding@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_encoding
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_max_length@codecvt_base@std@@MBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_max_length@codecvt_base@std@@MBEHXZ PROC		; std::codecvt_base::do_max_length, COMDAT
; _this$ = ecx

; 652  :     virtual int __CLR_OR_THIS_CALL do_max_length() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 653  :         // return maximum length required for a conversion (from codecvt)
; 654  :         return 1;

  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax

; 655  :     }

  0000a	c9		 leave
  0000b	c3		 ret	 0
?do_max_length@codecvt_base@std@@MBEHXZ ENDP		; std::codecvt_base::do_max_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?do_always_noconv@codecvt_base@std@@MBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_always_noconv@codecvt_base@std@@MBE_NXZ PROC	; std::codecvt_base::do_always_noconv, COMDAT
; _this$ = ecx

; 647  :     virtual bool __CLR_OR_THIS_CALL do_always_noconv() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 648  :         // return true if conversions never change input (from codecvt)
; 649  :         return false;

  00007	32 c0		 xor	 al, al

; 650  :     }

  00009	c9		 leave
  0000a	c3		 ret	 0
?do_always_noconv@codecvt_base@std@@MBE_NXZ ENDP	; std::codecvt_base::do_always_noconv
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Ptr0$ = -16						; size = 4
__Facptr$ = -12						; size = 4
tv71 = -8						; size = 4
_this$ = -4						; size = 4
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 373  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 374  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  00012	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00015	73 14		 jae	 SHORT $LN6@Getfacet
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  00023	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00026	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  00029	eb 04		 jmp	 SHORT $LN7@Getfacet
$LN6@Getfacet:
  0002b	83 65 f8 00	 and	 DWORD PTR tv71[ebp], 0
$LN7@Getfacet:
  0002f	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
  00032	89 45 f4	 mov	 DWORD PTR __Facptr$[ebp], eax

; 375  :         if (_Facptr || !_Ptr->_Xparent) {

  00035	83 7d f4 00	 cmp	 DWORD PTR __Facptr$[ebp], 0
  00039	75 0e		 jne	 SHORT $LN3@Getfacet
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00041	0f b6 40 14	 movzx	 eax, BYTE PTR [eax+20]
  00045	85 c0		 test	 eax, eax
  00047	75 05		 jne	 SHORT $LN2@Getfacet
$LN3@Getfacet:

; 376  :             return _Facptr; // found facet or not transparent

  00049	8b 45 f4	 mov	 eax, DWORD PTR __Facptr$[ebp]
  0004c	eb 23		 jmp	 SHORT $LN1@Getfacet
$LN2@Getfacet:

; 377  :         }
; 378  : 
; 379  :         // look in current locale
; 380  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  0004e	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00053	89 45 f0	 mov	 DWORD PTR __Ptr0$[ebp], eax

; 381  :         if (_Id < _Ptr0->_Facetcount) {

  00056	8b 45 f0	 mov	 eax, DWORD PTR __Ptr0$[ebp]
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0005c	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  0005f	73 0e		 jae	 SHORT $LN4@Getfacet

; 382  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  00061	8b 45 f0	 mov	 eax, DWORD PTR __Ptr0$[ebp]
  00064	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0006a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0006d	eb 02		 jmp	 SHORT $LN1@Getfacet
$LN4@Getfacet:

; 383  :         }
; 384  : 
; 385  :         return nullptr; // no entry in current locale

  0006f	33 c0		 xor	 eax, eax
$LN1@Getfacet:

; 386  :     }

  00071	c9		 leave
  00072	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
tv84 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 350  :     ~locale() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 351  :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 2f		 je	 SHORT $LN3@locale

; 352  :             delete _Ptr->_Decref();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00020	ff 50 08	 call	 DWORD PTR [eax+8]
  00023	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00026	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  0002a	74 11		 je	 SHORT $LN4@locale
  0002c	6a 01		 push	 1
  0002e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00036	ff 10		 call	 DWORD PTR [eax]
  00038	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0003b	eb 04		 jmp	 SHORT $LN3@locale
$LN4@locale:
  0003d	83 65 f4 00	 and	 DWORD PTR tv84[ebp], 0
$LN3@locale:

; 353  :         }
; 354  :     }

  00041	c9		 leave
  00042	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 267  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00010	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 268  :         _Ptr->_Incref();

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00021	ff 50 04	 call	 DWORD PTR [eax+4]

; 269  :     }

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale

; 155  :         virtual __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00019	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	74 0c		 je	 SHORT $LN2@scalar
  00021	6a 08		 push	 8
  00023	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c9		 leave
  00031	c2 04 00	 ret	 4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 139  :         virtual _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :             if (_MT_DECR(_Myrefs) == 0) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 05		 jne	 SHORT $LN2@Decref

; 141  :                 return this;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	eb 02		 jmp	 SHORT $LN3@Decref
$LN2@Decref:

; 142  :             }
; 143  : 
; 144  :             return nullptr;

  0001c	33 c0		 xor	 eax, eax
$LN3@Decref:

; 145  :         }

  0001e	c9		 leave
  0001f	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 135  :         virtual void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 136  :             _MT_INCR(_Myrefs);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	f0 ff 00	 lock	  inc	 DWORD PTR [eax]

; 137  :         }

  00010	c9		 leave
  00011	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -8						; size = 4
_this$ = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 104  :         __CLR_OR_THIS_CALL operator size_t() { // get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 105  :             if (_Id == 0) { // still zero, allocate stamp

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000e	75 30		 jne	 SHORT $LN2@operator

; 106  :                 _BEGIN_LOCK(_LOCK_LOCALE)

  00010	6a 00		 push	 0
  00012	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00015	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 107  :                 if (_Id == 0) {

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00020	75 16		 jne	 SHORT $LN3@operator

; 108  :                     _Id = static_cast<size_t>(++_Id_cnt);

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00027	40		 inc	 eax
  00028	a3 00 00 00 00	 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, eax ; std::locale::id::_Id_cnt
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00036	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@operator:

; 109  :                 }
; 110  :                 _END_LOCK()

  00038	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  0003b	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN2@operator:

; 111  :             }
; 112  :             return _Id;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 00		 mov	 eax, DWORD PTR [eax]

; 113  :         }

  00045	c9		 leave
  00046	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  :         if (_Myptr) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0b		 je	 SHORT $LN4@Yarn

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	e8 00 00 00 00	 call	 _free
  00019	59		 pop	 ecx
$LN4@Yarn:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 20 00	 and	 DWORD PTR [eax], 0

; 101  :         _Tidy();
; 102  :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 122  :         if (_Myptr) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0b		 je	 SHORT $LN4@Yarn

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	e8 00 00 00 00	 call	 _free
  00019	59		 pop	 ecx
$LN4@Yarn:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 20 00	 and	 DWORD PTR [eax], 0

; 101  :         _Tidy();
; 102  :     }

  00020	c9		 leave
  00021	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 178  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 179  :         _Locinfo_dtor(this);

  00028	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
  00030	59		 pop	 ecx

; 180  :     }

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 c0 2c	 add	 eax, 44			; 0000002cH
  00037	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00040	74 0b		 je	 SHORT $LN7@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	ff 30		 push	 DWORD PTR [eax]
  00047	e8 00 00 00 00	 call	 _free
  0004c	59		 pop	 ecx
$LN7@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0004d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00050	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  00053	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	83 c0 24	 add	 eax, 36			; 00000024H
  00059	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  0005c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00062	74 0b		 je	 SHORT $LN14@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  00064	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	ff 30		 push	 DWORD PTR [eax]
  00069	e8 00 00 00 00	 call	 _free
  0006e	59		 pop	 ecx
$LN14@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  0006f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  00075	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 c0 1c	 add	 eax, 28			; 0000001cH
  0007b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  0007e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00081	83 38 00	 cmp	 DWORD PTR [eax], 0
  00084	74 0b		 je	 SHORT $LN21@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  00086	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00089	ff 30		 push	 DWORD PTR [eax]
  0008b	e8 00 00 00 00	 call	 _free
  00090	59		 pop	 ecx
$LN21@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  00091	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  00097	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	83 c0 14	 add	 eax, 20			; 00000014H
  0009d	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  000a0	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a6	74 0b		 je	 SHORT $LN28@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  000a8	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	ff 30		 push	 DWORD PTR [eax]
  000ad	e8 00 00 00 00	 call	 _free
  000b2	59		 pop	 ecx
$LN28@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  000b3	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  000b9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	83 c0 0c	 add	 eax, 12			; 0000000cH
  000bf	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  000c2	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	83 38 00	 cmp	 DWORD PTR [eax], 0
  000c8	74 0b		 je	 SHORT $LN35@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  000ca	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	ff 30		 push	 DWORD PTR [eax]
  000cf	e8 00 00 00 00	 call	 _free
  000d4	59		 pop	 ecx
$LN35@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  000d5	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  000db	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000de	83 c0 04	 add	 eax, 4
  000e1	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax

; 122  :         if (_Myptr) {

  000e4	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ea	74 0b		 je	 SHORT $LN42@Locinfo

; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);

  000ec	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	ff 30		 push	 DWORD PTR [eax]
  000f1	e8 00 00 00 00	 call	 _free
  000f6	59		 pop	 ecx
$LN42@Locinfo:

; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;

  000f7	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	83 20 00	 and	 DWORD PTR [eax], 0

; 180  :     }

  000fd	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00100	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00105	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00108	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010f	59		 pop	 ecx
  00110	c9		 leave
  00111	c3		 ret	 0
  00112	cc		 int	 3
  00113	cc		 int	 3
  00114	cc		 int	 3
  00115	cc		 int	 3
  00116	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 155  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 60   : 
; 61   :     __CLR_OR_THIS_CALL _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0) {
; 62   :         *this = _Right;
; 63   :     }
; 64   : 
; 65   :     __CLR_OR_THIS_CALL _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0) {
; 66   :         *this = _Right;
; 67   :     }
; 68   : 
; 69   :     _Yarn& __CLR_OR_THIS_CALL operator=(const _Yarn& _Right) noexcept {
; 70   :         return *this = _Right._Myptr;
; 71   :     }
; 72   : 
; 73   :     _Yarn& __CLR_OR_THIS_CALL operator=(const _Elem* _Right) noexcept {
; 74   :         if (_Myptr != _Right) { // new value, discard old and copy new
; 75   :             _Tidy();
; 76   : 
; 77   :             if (_Right) { // new is not empty, copy it
; 78   :                 const _Elem* _Ptr = _Right;
; 79   :                 while (*_Ptr != _Elem{}) {
; 80   :                     ++_Ptr;
; 81   :                 }
; 82   : 
; 83   :                 const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);
; 84   : 
; 85   : #ifdef _DEBUG
; 86   :                 _Myptr = static_cast<_Elem*>(_malloc_dbg(_Count, _CRT_BLOCK, __FILE__, __LINE__));
; 87   : #else // _DEBUG
; 88   :                 _Myptr = static_cast<_Elem*>(_CSTD malloc(_Count));
; 89   : #endif // _DEBUG
; 90   : 
; 91   :                 if (_Myptr) {
; 92   :                     _CSTD memcpy(_Myptr, _Right, _Count);
; 93   :                 }
; 94   :             }
; 95   :         }
; 96   : 
; 97   :         return *this;
; 98   :     }
; 99   : 
; 100  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {
; 101  :         _Tidy();
; 102  :     }
; 103  : 
; 104  :     _NODISCARD bool __CLR_OR_THIS_CALL empty() const noexcept {
; 105  :         return _Myptr == nullptr;
; 106  :     }
; 107  : 
; 108  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {
; 109  :         return _Myptr ? _Myptr : &_Nul;
; 110  :     }
; 111  : 
; 112  :     _NODISCARD bool __CLR_OR_THIS_CALL _Empty() const noexcept {
; 113  :         return _Myptr == nullptr;
; 114  :     }
; 115  : 
; 116  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL _C_str() const noexcept {
; 117  :         return _Myptr ? _Myptr : &_Nul;
; 118  :     }
; 119  : 
; 120  : private:
; 121  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {
; 122  :         if (_Myptr) {
; 123  : #ifdef _DEBUG
; 124  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 125  : #else // _DEBUG
; 126  :             _CSTD free(_Myptr);
; 127  : #endif // _DEBUG
; 128  :         }
; 129  : 
; 130  :         _Myptr = nullptr;
; 131  :     }
; 132  : 
; 133  :     _Elem* _Myptr; // pointer to allocated string
; 134  :     _Elem _Nul; // nul terminator for unallocated string
; 135  : };
; 136  : 
; 137  : // CLASS _Locinfo
; 138  : class _CRTIMP2_PURE_IMPORT _Locinfo { // summary of all stuff specific to a locale used by standard facets
; 139  : public:
; 140  :     using _Collvec  = ::_Collvec;
; 141  :     using _Ctypevec = ::_Ctypevec;
; 142  :     using _Cvtvec   = ::_Cvtvec;
; 143  :     using _Timevec  = _STD _Timevec;
; 144  : 
; 145  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, const char*);
; 146  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_ctor(_Locinfo*, int, const char*);
; 147  :     static void __CLRCALL_PURE_OR_CDECL _Locinfo_dtor(_Locinfo*);
; 148  :     static _Locinfo& __CLRCALL_PURE_OR_CDECL _Locinfo_Addcats(_Locinfo*, int, const char*);
; 149  : 
; 150  :     __CLR_OR_THIS_CALL _Locinfo(const char* _Pch = "C")
; 151  : #ifndef _M_CEE
; 152  :         : _Lock(_LOCK_LOCALE)

  00028	6a 00		 push	 0
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00032	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 155  :     {

  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	83 c0 04	 add	 eax, 4
  0003c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  0003f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 20 00	 and	 DWORD PTR [eax], 0
  00045	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00048	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 155  :     {

  0004c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 c0 0c	 add	 eax, 12			; 0000000cH
  00056	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00059	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 20 00	 and	 DWORD PTR [eax], 0
  0005f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 155  :     {

  00066	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0006a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	83 c0 14	 add	 eax, 20			; 00000014H
  00070	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00073	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00076	83 20 00	 and	 DWORD PTR [eax], 0
  00079	33 c0		 xor	 eax, eax
  0007b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 155  :     {

  00082	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 c0 1c	 add	 eax, 28			; 0000001cH
  0008c	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	83 20 00	 and	 DWORD PTR [eax], 0
  00095	33 c0		 xor	 eax, eax
  00097	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	66 89 41 04	 mov	 WORD PTR [ecx+4], ax

; 155  :     {

  0009e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000a2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a5	83 c0 24	 add	 eax, 36			; 00000024H
  000a8	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  000ab	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	83 20 00	 and	 DWORD PTR [eax], 0
  000b1	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 155  :     {

  000b8	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000bc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	83 c0 2c	 add	 eax, 44			; 0000002cH
  000c2	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax

; 59   :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  000c5	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000c8	83 20 00	 and	 DWORD PTR [eax], 0
  000cb	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 155  :     {

  000d2	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 156  :         if (_Pch) {

  000d6	83 7d 08 00	 cmp	 DWORD PTR __Pch$[ebp], 0
  000da	74 0f		 je	 SHORT $LN2@Locinfo

; 157  :             _Locinfo_ctor(this, _Pch);

  000dc	ff 75 08	 push	 DWORD PTR __Pch$[ebp]
  000df	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  000e2	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  000e7	59		 pop	 ecx
  000e8	59		 pop	 ecx

; 158  :             return;

  000e9	eb 0a		 jmp	 SHORT $LN1@Locinfo
$LN2@Locinfo:

; 159  :         }
; 160  : 
; 161  :         _Xruntime_error("bad locale name");

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
  000f0	e8 00 00 00 00	 call	 ?_Xruntime_error@std@@YAXPBD@Z ; std::_Xruntime_error
$LN1@Locinfo:

; 162  :     }

  000f5	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000f9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@Locinfo:
  000fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ff	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00106	59		 pop	 ecx
  00107	c9		 leave
  00108	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  0004f	90		 npad	 1
  00050	90		 npad	 1
  00051	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00055	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00058	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0005b	33 c8		 xor	 ecx, eax
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xfacet
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 0c		 je	 SHORT $LN2@scalar
  00018	6a 04		 push	 4
  0001a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
$LN2@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_n$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv140 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_t$ = 8							; size = 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >, COMDAT
; _this$ = ecx

; 248  : 	SecBlock(const SecBlock<T, A> &t)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 166  : 	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 40 21 00	 mov	 BYTE PTR [eax+33], 0

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0001c	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  0001f	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00028	89 45 e8	 mov	 DWORD PTR _n$[ebp], eax
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 183  : 		if (n <= S && !m_allocated)

  00031	83 7d e8 08	 cmp	 DWORD PTR _n$[ebp], 8
  00035	77 3a		 ja	 SHORT $LN13@SecBlock
  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	0f b6 40 21	 movzx	 eax, BYTE PTR [eax+33]
  0003e	85 c0		 test	 eax, eax
  00040	75 2f		 jne	 SHORT $LN13@SecBlock

; 184  : 		{
; 185  : 			m_allocated = true;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c6 40 21 01	 mov	 BYTE PTR [eax+33], 1

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  00049	33 c0		 xor	 eax, eax
  0004b	74 14		 je	 SHORT $LN11@SecBlock
  0004d	33 c0		 xor	 eax, eax
  0004f	2b 45 f8	 sub	 eax, DWORD PTR _this$[ebp]
  00052	33 d2		 xor	 edx, edx
  00054	6a 10		 push	 16			; 00000010H
  00056	59		 pop	 ecx
  00057	f7 f1		 div	 ecx
  00059	03 55 f8	 add	 edx, DWORD PTR _this$[ebp]
  0005c	89 55 f4	 mov	 DWORD PTR tv140[ebp], edx
  0005f	eb 06		 jmp	 SHORT $LN9@SecBlock
$LN11@SecBlock:
  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	89 45 f4	 mov	 DWORD PTR tv140[ebp], eax
$LN9@SecBlock:

; 186  : 			return GetAlignedArray();

  00067	8b 45 f4	 mov	 eax, DWORD PTR tv140[ebp]
  0006a	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0006d	eb 06		 jmp	 SHORT $LN5@SecBlock

; 187  : 		}

  0006f	eb 04		 jmp	 SHORT $LN5@SecBlock
$LN13@SecBlock:

; 188  : 		else
; 189  : 			return m_fallbackAllocator.allocate(n, hint);

  00071	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
$LN5@SecBlock:

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007b	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00084	c1 e0 02	 shl	 eax, 2
  00087	50		 push	 eax
  00088	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  0008b	ff 70 2c	 push	 DWORD PTR [eax+44]
  0008e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00094	c1 e0 02	 shl	 eax, 2
  00097	50		 push	 eax
  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	ff 70 2c	 push	 DWORD PTR [eax+44]
  0009e	e8 00 00 00 00	 call	 _memcpy_s
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	c9		 leave
  000aa	c2 04 00	 ret	 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv128 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z PROC ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >, COMDAT
; _this$ = ecx

; 246  : 	explicit SecBlock(size_type size=0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 166  : 	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 40 21 00	 mov	 BYTE PTR [eax+33], 0

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0001c	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 183  : 		if (n <= S && !m_allocated)

  00025	83 7d 08 08	 cmp	 DWORD PTR _size$[ebp], 8
  00029	77 3a		 ja	 SHORT $LN13@SecBlock
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 40 21	 movzx	 eax, BYTE PTR [eax+33]
  00032	85 c0		 test	 eax, eax
  00034	75 2f		 jne	 SHORT $LN13@SecBlock

; 184  : 		{
; 185  : 			m_allocated = true;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c6 40 21 01	 mov	 BYTE PTR [eax+33], 1

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  0003d	33 c0		 xor	 eax, eax
  0003f	74 14		 je	 SHORT $LN11@SecBlock
  00041	33 c0		 xor	 eax, eax
  00043	2b 45 fc	 sub	 eax, DWORD PTR _this$[ebp]
  00046	33 d2		 xor	 edx, edx
  00048	6a 10		 push	 16			; 00000010H
  0004a	59		 pop	 ecx
  0004b	f7 f1		 div	 ecx
  0004d	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  00050	89 55 f4	 mov	 DWORD PTR tv128[ebp], edx
  00053	eb 06		 jmp	 SHORT $LN9@SecBlock
$LN11@SecBlock:
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	89 45 f4	 mov	 DWORD PTR tv128[ebp], eax
$LN9@SecBlock:

; 186  : 			return GetAlignedArray();

  0005b	8b 45 f4	 mov	 eax, DWORD PTR tv128[ebp]
  0005e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00061	eb 06		 jmp	 SHORT $LN5@SecBlock

; 187  : 		}

  00063	eb 04		 jmp	 SHORT $LN5@SecBlock
$LN13@SecBlock:

; 188  : 		else
; 189  : 			return m_fallbackAllocator.allocate(n, hint);

  00065	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
$LN5@SecBlock:

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0006f	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  00072	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ENDP ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ?deallocate@?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?deallocate@?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z PROC ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0>::deallocate, COMDAT
; _this$ = ecx

; 193  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  00008	33 c0		 xor	 eax, eax
  0000a	74 14		 je	 SHORT $LN7@deallocate
  0000c	33 c0		 xor	 eax, eax
  0000e	2b 45 fc	 sub	 eax, DWORD PTR _this$[ebp]
  00011	33 d2		 xor	 edx, edx
  00013	6a 10		 push	 16			; 00000010H
  00015	59		 pop	 ecx
  00016	f7 f1		 div	 ecx
  00018	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  0001b	89 55 f8	 mov	 DWORD PTR tv81[ebp], edx
  0001e	eb 06		 jmp	 SHORT $LN5@deallocate
$LN7@deallocate:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR tv81[ebp], eax
$LN5@deallocate:

; 194  : 		if (p == GetAlignedArray())

  00026	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00029	3b 45 f8	 cmp	 eax, DWORD PTR tv81[ebp]
  0002c	75 14		 jne	 SHORT $LN1@deallocate

; 195  : 		{
; 196  : 			assert(n <= S);
; 197  : 			assert(m_allocated);
; 198  : 			m_allocated = false;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c6 40 21 00	 mov	 BYTE PTR [eax+33], 0

; 199  : 			SecureWipeArray((pointer)p, n);

  00035	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  00038	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0003b	e8 00 00 00 00	 call	 ??$SecureWipeArray@I@CryptoPP@@YAXPAII@Z ; CryptoPP::SecureWipeArray<unsigned int>
  00040	59		 pop	 ecx
  00041	59		 pop	 ecx
$LN1@deallocate:

; 200  : 		}
; 201  : 		else
; 202  : 			m_fallbackAllocator.deallocate(p, n);
; 203  : 	}

  00042	c9		 leave
  00043	c2 08 00	 ret	 8
?deallocate@?$FixedSizeAllocatorWithCleanup@I$07V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ENDP ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,8,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::~AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::~AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?CanOperateKeystream@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanOperateKeystream@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBE_NXZ PROC ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::CanOperateKeystream, COMDAT
; _this$ = ecx

; 94   : 	bool CanOperateKeystream() const {return true;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	c9		 leave
  0000a	c3		 ret	 0
?CanOperateKeystream@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBE_NXZ ENDP ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::CanOperateKeystream
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?GetIterationsToBuffer@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIterationsToBuffer@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ PROC ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::GetIterationsToBuffer, COMDAT
; _this$ = ecx

; 93   : 	unsigned int GetIterationsToBuffer() const {return X;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?GetIterationsToBuffer@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::GetIterationsToBuffer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?GetBytesPerIteration@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBytesPerIteration@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ PROC ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::GetBytesPerIteration, COMDAT
; _this$ = ecx

; 92   : 	unsigned int GetBytesPerIteration() const {return BYTES_PER_ITERATION;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 20		 push	 32			; 00000020H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?GetBytesPerIteration@?$AdditiveCipherConcretePolicy@I$07$00UAdditiveCipherAbstractPolicy@CryptoPP@@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::AdditiveCipherConcretePolicy<unsigned int,8,1,CryptoPP::AdditiveCipherAbstractPolicy>::GetBytesPerIteration
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_n$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv140 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_t$ = 8							; size = 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >, COMDAT
; _this$ = ecx

; 248  : 	SecBlock(const SecBlock<T, A> &t)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 166  : 	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 80 59 04 00
	00 00		 mov	 BYTE PTR [eax+1113], 0

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0001f	8b 89 60 04 00
	00		 mov	 ecx, DWORD PTR [ecx+1120]
  00025	89 88 60 04 00
	00		 mov	 DWORD PTR [eax+1120], ecx
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 80 60 04 00
	00		 mov	 eax, DWORD PTR [eax+1120]
  00034	89 45 e8	 mov	 DWORD PTR _n$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 183  : 		if (n <= S && !m_allocated)

  0003d	81 7d e8 14 01
	00 00		 cmp	 DWORD PTR _n$[ebp], 276	; 00000114H
  00044	77 41		 ja	 SHORT $LN13@SecBlock
  00046	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00049	0f b6 80 59 04
	00 00		 movzx	 eax, BYTE PTR [eax+1113]
  00050	85 c0		 test	 eax, eax
  00052	75 33		 jne	 SHORT $LN13@SecBlock

; 184  : 		{
; 185  : 			m_allocated = true;

  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	c6 80 59 04 00
	00 01		 mov	 BYTE PTR [eax+1113], 1

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  0005e	33 c0		 xor	 eax, eax
  00060	40		 inc	 eax
  00061	74 14		 je	 SHORT $LN11@SecBlock
  00063	33 c0		 xor	 eax, eax
  00065	2b 45 f8	 sub	 eax, DWORD PTR _this$[ebp]
  00068	33 d2		 xor	 edx, edx
  0006a	6a 10		 push	 16			; 00000010H
  0006c	59		 pop	 ecx
  0006d	f7 f1		 div	 ecx
  0006f	03 55 f8	 add	 edx, DWORD PTR _this$[ebp]
  00072	89 55 f4	 mov	 DWORD PTR tv140[ebp], edx
  00075	eb 06		 jmp	 SHORT $LN9@SecBlock
$LN11@SecBlock:
  00077	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	89 45 f4	 mov	 DWORD PTR tv140[ebp], eax
$LN9@SecBlock:

; 186  : 			return GetAlignedArray();

  0007d	8b 45 f4	 mov	 eax, DWORD PTR tv140[ebp]
  00080	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00083	eb 06		 jmp	 SHORT $LN5@SecBlock

; 187  : 		}

  00085	eb 04		 jmp	 SHORT $LN5@SecBlock
$LN13@SecBlock:

; 188  : 		else
; 189  : 			return m_fallbackAllocator.allocate(n, hint);

  00087	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
$LN5@SecBlock:

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00091	89 88 64 04 00
	00		 mov	 DWORD PTR [eax+1124], ecx
  00097	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	8b 80 60 04 00
	00		 mov	 eax, DWORD PTR [eax+1120]
  000a0	c1 e0 02	 shl	 eax, 2
  000a3	50		 push	 eax
  000a4	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  000a7	ff b0 64 04 00
	00		 push	 DWORD PTR [eax+1124]
  000ad	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b0	8b 80 60 04 00
	00		 mov	 eax, DWORD PTR [eax+1120]
  000b6	c1 e0 02	 shl	 eax, 2
  000b9	50		 push	 eax
  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	ff b0 64 04 00
	00		 push	 DWORD PTR [eax+1124]
  000c3	e8 00 00 00 00	 call	 _memcpy_s
  000c8	83 c4 10	 add	 esp, 16			; 00000010H
  000cb	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	c9		 leave
  000cf	c2 04 00	 ret	 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv128 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@I@Z PROC ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >, COMDAT
; _this$ = ecx

; 246  : 	explicit SecBlock(size_type size=0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 166  : 	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 80 59 04 00
	00 00		 mov	 BYTE PTR [eax+1113], 0

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00019	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0001f	89 88 60 04 00
	00		 mov	 DWORD PTR [eax+1120], ecx
  00025	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 183  : 		if (n <= S && !m_allocated)

  0002b	81 7d 08 14 01
	00 00		 cmp	 DWORD PTR _size$[ebp], 276 ; 00000114H
  00032	77 41		 ja	 SHORT $LN13@SecBlock
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	0f b6 80 59 04
	00 00		 movzx	 eax, BYTE PTR [eax+1113]
  0003e	85 c0		 test	 eax, eax
  00040	75 33		 jne	 SHORT $LN13@SecBlock

; 184  : 		{
; 185  : 			m_allocated = true;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c6 80 59 04 00
	00 01		 mov	 BYTE PTR [eax+1113], 1

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  0004c	33 c0		 xor	 eax, eax
  0004e	40		 inc	 eax
  0004f	74 14		 je	 SHORT $LN11@SecBlock
  00051	33 c0		 xor	 eax, eax
  00053	2b 45 fc	 sub	 eax, DWORD PTR _this$[ebp]
  00056	33 d2		 xor	 edx, edx
  00058	6a 10		 push	 16			; 00000010H
  0005a	59		 pop	 ecx
  0005b	f7 f1		 div	 ecx
  0005d	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  00060	89 55 f4	 mov	 DWORD PTR tv128[ebp], edx
  00063	eb 06		 jmp	 SHORT $LN9@SecBlock
$LN11@SecBlock:
  00065	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00068	89 45 f4	 mov	 DWORD PTR tv128[ebp], eax
$LN9@SecBlock:

; 186  : 			return GetAlignedArray();

  0006b	8b 45 f4	 mov	 eax, DWORD PTR tv128[ebp]
  0006e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00071	eb 06		 jmp	 SHORT $LN5@SecBlock

; 187  : 		}

  00073	eb 04		 jmp	 SHORT $LN5@SecBlock
$LN13@SecBlock:

; 188  : 		else
; 189  : 			return m_fallbackAllocator.allocate(n, hint);

  00075	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
$LN5@SecBlock:

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00079	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007f	89 88 64 04 00
	00		 mov	 DWORD PTR [eax+1124], ecx
  00085	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00088	c9		 leave
  00089	c2 04 00	 ret	 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@@CryptoPP@@QAE@I@Z ENDP ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@QAEXPAXI@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@QAEXPAXI@Z PROC ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1>::deallocate, COMDAT
; _this$ = ecx

; 193  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  00008	33 c0		 xor	 eax, eax
  0000a	40		 inc	 eax
  0000b	74 14		 je	 SHORT $LN7@deallocate
  0000d	33 c0		 xor	 eax, eax
  0000f	2b 45 fc	 sub	 eax, DWORD PTR _this$[ebp]
  00012	33 d2		 xor	 edx, edx
  00014	6a 10		 push	 16			; 00000010H
  00016	59		 pop	 ecx
  00017	f7 f1		 div	 ecx
  00019	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  0001c	89 55 f8	 mov	 DWORD PTR tv81[ebp], edx
  0001f	eb 06		 jmp	 SHORT $LN5@deallocate
$LN7@deallocate:
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR tv81[ebp], eax
$LN5@deallocate:

; 194  : 		if (p == GetAlignedArray())

  00027	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  0002a	3b 45 f8	 cmp	 eax, DWORD PTR tv81[ebp]
  0002d	75 17		 jne	 SHORT $LN1@deallocate

; 195  : 		{
; 196  : 			assert(n <= S);
; 197  : 			assert(m_allocated);
; 198  : 			m_allocated = false;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c6 80 59 04 00
	00 00		 mov	 BYTE PTR [eax+1113], 0

; 199  : 			SecureWipeArray((pointer)p, n);

  00039	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  0003c	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0003f	e8 00 00 00 00	 call	 ??$SecureWipeArray@I@CryptoPP@@YAXPAII@Z ; CryptoPP::SecureWipeArray<unsigned int>
  00044	59		 pop	 ecx
  00045	59		 pop	 ecx
$LN1@deallocate:

; 200  : 		}
; 201  : 		else
; 202  : 			m_fallbackAllocator.deallocate(p, n);
; 203  : 	}

  00046	c9		 leave
  00047	c2 08 00	 ret	 8
?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BBE@V?$NullAllocator@I@CryptoPP@@$00@CryptoPP@@QAEXPAXI@Z ENDP ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,276,CryptoPP::NullAllocator<unsigned int>,1>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GWhirlpool@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GWhirlpool@CryptoPP@@UAEPAXI@Z PROC			; CryptoPP::Whirlpool::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 b8 00 00 00	 push	 184			; 000000b8H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GWhirlpool@CryptoPP@@UAEPAXI@Z ENDP			; CryptoPP::Whirlpool::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::~IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 68	 add	 eax, 104		; 00000068H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	ff 70 48	 push	 DWORD PTR [eax+72]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0>::deallocate
  00048	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	c9		 leave
  00060	c3		 ret	 0
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::~IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::StateBuf, COMDAT
; _this$ = ecx

; 92   : 	T_HashWordType* StateBuf() {return this->m_state;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 92   : 	T_HashWordType* StateBuf() {return this->m_state;}

  00014	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::StateBuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::Init, COMDAT
; _this$ = ecx

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00014	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00017	e8 00 00 00 00	 call	 ?InitState@Whirlpool@CryptoPP@@SAXPA_K@Z ; CryptoPP::Whirlpool::InitState
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::Init
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_data$ = 8						; size = 4
?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::HashEndianCorrectedBlock, COMDAT
; _this$ = ecx

; 89   : 	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 89   : 	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}

  00014	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00017	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0001a	e8 00 00 00 00	 call	 ?Transform@Whirlpool@CryptoPP@@SAXPA_KPB_K@Z ; CryptoPP::Whirlpool::Transform
  0001f	59		 pop	 ecx
  00020	59		 pop	 ecx
  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::HashEndianCorrectedBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>, COMDAT
; _this$ = ecx

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 68	 add	 eax, 104		; 00000068H
  0003a	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  0003d	6a 08		 push	 8
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00054	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00057	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  0005a	e8 00 00 00 00	 call	 ?InitState@Whirlpool@CryptoPP@@SAXPA_K@Z ; CryptoPP::Whirlpool::InitState
  0005f	59		 pop	 ecx

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	c9		 leave
  00073	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UAE@XZ
__unwindfunclet$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 68	 add	 ecx, 104		; 00000068H
  0000e	e9 00 00 00 00	 jmp	 ??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::DigestSize, COMDAT
; _this$ = ecx

; 85   : 	unsigned int DigestSize() const {return DIGESTSIZE;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 40		 push	 64			; 00000040H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::DigestSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::~ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::~ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
_TEXT	SEGMENT
$T2 = -32						; size = 4
_this$3 = -28						; size = 4
tv83 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ PROC ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::Clone, COMDAT
; _this$ = ecx

; 19   : 	Clonable * Clone() const {return new DERIVED(*static_cast<const DERIVED *>(this));}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	68 b8 00 00 00	 push	 184			; 000000b8H
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	59		 pop	 ecx
  00033	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00036	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	83 7d f0 00	 cmp	 DWORD PTR $T4[ebp], 0
  0003e	74 3c		 je	 SHORT $LN3@Clone
  00040	ff 75 ec	 push	 DWORD PTR _this$[ebp]
  00043	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00046	e8 00 00 00 00	 call	 ??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00052	83 c0 68	 add	 eax, 104		; 00000068H
  00055	89 45 e4	 mov	 DWORD PTR _this$3[ebp], eax
  00058	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 c0 68	 add	 eax, 104		; 00000068H
  0005e	50		 push	 eax
  0005f	8b 4d e4	 mov	 ecx, DWORD PTR _this$3[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
  00067	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0006b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Whirlpool@CryptoPP@@6B@
  00074	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00077	89 45 e8	 mov	 DWORD PTR tv83[ebp], eax
  0007a	eb 04		 jmp	 SHORT $LN4@Clone
$LN3@Clone:
  0007c	83 65 e8 00	 and	 DWORD PTR tv83[ebp], 0
$LN4@Clone:
  00080	8b 45 e8	 mov	 eax, DWORD PTR tv83[ebp]
  00083	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00086	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	c9		 leave
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0:
  00000	68 b8 00 00 00	 push	 184			; 000000b8H
  00005	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
__unwindfunclet$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UAE@XZ
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@?$ClonableImpl@VWhirlpool@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ ENDP ; CryptoPP::ClonableImpl<CryptoPP::Whirlpool,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool> >::Clone
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::AlgorithmName, COMDAT
; _this$ = ecx

; 28   : 	std::string AlgorithmName() const {return ALGORITHM_INFO::StaticAlgorithmName();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	83 65 fc 00	 and	 DWORD PTR $T1[ebp], 0
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_09HLDHDDJL@Whirlpool@
  00011	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	83 c8 01	 or	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	c9		 leave
  00026	c2 04 00	 ret	 4
?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VWhirlpool@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::Whirlpool>::AlgorithmName
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00030	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00033	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00036	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00039	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00042	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00045	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00048	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0004b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c0 18	 add	 eax, 24			; 00000018H
  00055	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  00058	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0005b	83 c0 18	 add	 eax, 24			; 00000018H
  0005e	50		 push	 eax
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
  00067	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0006b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00078	59		 pop	 ecx
  00079	c9		 leave
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 18	 add	 eax, 24			; 00000018H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	ff 70 48	 push	 DWORD PTR [eax+72]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0>::deallocate
  00048	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	c9		 leave
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	6a 01		 push	 1
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 26   : 	IteratedHashBase() : m_countLo(0), m_countHi(0) {}

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	33 c9		 xor	 ecx, ecx
  00036	33 d2		 xor	 edx, edx
  00038	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0003b	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0003e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00041	33 c9		 xor	 ecx, ecx
  00043	33 d2		 xor	 edx, edx
  00045	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00048	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0004b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c0 18	 add	 eax, 24			; 00000018H
  00055	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  00058	6a 08		 push	 8
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
  00062	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	c9		 leave
  00075	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::DataBuf, COMDAT
; _this$ = ecx

; 74   : 	T_HashWordType* DataBuf() {return this->m_data;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  0000e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 74   : 	T_HashWordType* DataBuf() {return this->m_data;}

  00011	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00014	c9		 leave
  00015	c3		 ret	 0
?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::DataBuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::GetByteOrder, COMDAT
; _this$ = ecx

; 66   : 	ByteOrder GetByteOrder() const {return T_Endianness::ToEnum();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::GetByteOrder
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::BlockSize, COMDAT
; _this$ = ecx

; 64   : 	unsigned int BlockSize() const {return T_BlockSize;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 40		 push	 64			; 00000040H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::BlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GRIPEMD128@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GRIPEMD128@CryptoPP@@UAEPAXI@Z PROC			; CryptoPP::RIPEMD128::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 b0 00 00 00	 push	 176			; 000000b0H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GRIPEMD128@CryptoPP@@UAEPAXI@Z ENDP			; CryptoPP::RIPEMD128::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::~IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 60	 add	 eax, 96			; 00000060H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	ff 70 48	 push	 DWORD PTR [eax+72]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
  00048	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	c9		 leave
  00060	c3		 ret	 0
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::~IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEPAIXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEPAIXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::StateBuf, COMDAT
; _this$ = ecx

; 92   : 	T_HashWordType* StateBuf() {return this->m_state;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 92   : 	T_HashWordType* StateBuf() {return this->m_state;}

  00014	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEPAIXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::StateBuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::Init, COMDAT
; _this$ = ecx

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00014	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00017	e8 00 00 00 00	 call	 ?InitState@RIPEMD128@CryptoPP@@SAXPAI@Z ; CryptoPP::RIPEMD128::InitState
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::Init
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_data$ = 8						; size = 4
?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::HashEndianCorrectedBlock, COMDAT
; _this$ = ecx

; 89   : 	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 89   : 	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}

  00014	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00017	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0001a	e8 00 00 00 00	 call	 ?Transform@RIPEMD128@CryptoPP@@SAXPAIPBI@Z ; CryptoPP::RIPEMD128::Transform
  0001f	59		 pop	 ecx
  00020	59		 pop	 ecx
  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::HashEndianCorrectedBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>, COMDAT
; _this$ = ecx

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 60	 add	 eax, 96			; 00000060H
  0003a	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  0003d	6a 10		 push	 16			; 00000010H
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00054	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00057	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  0005a	e8 00 00 00 00	 call	 ?InitState@RIPEMD128@CryptoPP@@SAXPAI@Z ; CryptoPP::RIPEMD128::InitState
  0005f	59		 pop	 ecx

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	c9		 leave
  00073	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UAE@XZ
__unwindfunclet$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 60	 add	 ecx, 96			; 00000060H
  0000e	e9 00 00 00 00	 jmp	 ??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::DigestSize, COMDAT
; _this$ = ecx

; 85   : 	unsigned int DigestSize() const {return DIGESTSIZE;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 10		 push	 16			; 00000010H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::DigestSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::~ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::~ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
_TEXT	SEGMENT
$T2 = -32						; size = 4
_this$3 = -28						; size = 4
tv83 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ PROC ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::Clone, COMDAT
; _this$ = ecx

; 19   : 	Clonable * Clone() const {return new DERIVED(*static_cast<const DERIVED *>(this));}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	68 b0 00 00 00	 push	 176			; 000000b0H
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	59		 pop	 ecx
  00033	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00036	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	83 7d f0 00	 cmp	 DWORD PTR $T4[ebp], 0
  0003e	74 3c		 je	 SHORT $LN3@Clone
  00040	ff 75 ec	 push	 DWORD PTR _this$[ebp]
  00043	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00046	e8 00 00 00 00	 call	 ??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00052	83 c0 60	 add	 eax, 96			; 00000060H
  00055	89 45 e4	 mov	 DWORD PTR _this$3[ebp], eax
  00058	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 c0 60	 add	 eax, 96			; 00000060H
  0005e	50		 push	 eax
  0005f	8b 4d e4	 mov	 ecx, DWORD PTR _this$3[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
  00067	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0006b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7RIPEMD128@CryptoPP@@6B@
  00074	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00077	89 45 e8	 mov	 DWORD PTR tv83[ebp], eax
  0007a	eb 04		 jmp	 SHORT $LN4@Clone
$LN3@Clone:
  0007c	83 65 e8 00	 and	 DWORD PTR tv83[ebp], 0
$LN4@Clone:
  00080	8b 45 e8	 mov	 eax, DWORD PTR tv83[ebp]
  00083	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00086	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	c9		 leave
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0:
  00000	68 b0 00 00 00	 push	 176			; 000000b0H
  00005	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
__unwindfunclet$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UAE@XZ
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@?$ClonableImpl@VRIPEMD128@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ ENDP ; CryptoPP::ClonableImpl<CryptoPP::RIPEMD128,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128> >::Clone
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::AlgorithmName, COMDAT
; _this$ = ecx

; 28   : 	std::string AlgorithmName() const {return ALGORITHM_INFO::StaticAlgorithmName();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	83 65 fc 00	 and	 DWORD PTR $T1[ebp], 0
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DFIJCONE@RIPEMD?9128@
  00011	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	83 c8 01	 or	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	c9		 leave
  00026	c2 04 00	 ret	 4
?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VRIPEMD128@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::RIPEMD128>::AlgorithmName
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00039	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0003c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0003f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 10	 add	 eax, 16			; 00000010H
  00049	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  0004c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0004f	83 c0 10	 add	 eax, 16			; 00000010H
  00052	50		 push	 eax
  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
  0005b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	c9		 leave
  0006e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 10	 add	 eax, 16			; 00000010H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	ff 70 48	 push	 DWORD PTR [eax+72]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
  00048	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	c9		 leave
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	6a 01		 push	 1
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 26   : 	IteratedHashBase() : m_countLo(0), m_countHi(0) {}

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0003f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 10	 add	 eax, 16			; 00000010H
  00049	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  0004c	6a 10		 push	 16			; 00000010H
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
  00056	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0005a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	c9		 leave
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::DataBuf, COMDAT
; _this$ = ecx

; 74   : 	T_HashWordType* DataBuf() {return this->m_data;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  0000e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 74   : 	T_HashWordType* DataBuf() {return this->m_data;}

  00011	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00014	c9		 leave
  00015	c3		 ret	 0
?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::DataBuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::GetByteOrder, COMDAT
; _this$ = ecx

; 66   : 	ByteOrder GetByteOrder() const {return T_Endianness::ToEnum();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c3		 ret	 0
?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::GetByteOrder
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::BlockSize, COMDAT
; _this$ = ecx

; 64   : 	unsigned int BlockSize() const {return T_BlockSize;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 40		 push	 64			; 00000040H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::BlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GSHA1@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSHA1@CryptoPP@@UAEPAXI@Z PROC			; CryptoPP::SHA1::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 b0 00 00 00	 push	 176			; 000000b0H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GSHA1@CryptoPP@@UAEPAXI@Z ENDP			; CryptoPP::SHA1::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::~IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 60	 add	 eax, 96			; 00000060H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	ff 70 48	 push	 DWORD PTR [eax+72]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
  00048	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	c9		 leave
  00060	c3		 ret	 0
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::~IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ PROC ; CryptoPP::FixedSizeAlignedSecBlock<unsigned int,16,0>::~FixedSizeAlignedSecBlock<unsigned int,16,0>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	ff 70 48	 push	 DWORD PTR [eax+72]
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	ff 70 4c	 push	 DWORD PTR [eax+76]
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
  0003e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00045	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004c	59		 pop	 ecx
  0004d	c9		 leave
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
  00052	cc		 int	 3
  00053	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::FixedSizeAlignedSecBlock<unsigned int,16,0>::~FixedSizeAlignedSecBlock<unsigned int,16,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEPAIXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEPAIXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::StateBuf, COMDAT
; _this$ = ecx

; 92   : 	T_HashWordType* StateBuf() {return this->m_state;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 92   : 	T_HashWordType* StateBuf() {return this->m_state;}

  00014	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
?StateBuf@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEPAIXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::StateBuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::Init, COMDAT
; _this$ = ecx

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00014	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00017	e8 00 00 00 00	 call	 ?InitState@SHA1@CryptoPP@@SAXPAI@Z ; CryptoPP::SHA1::InitState
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
?Init@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::Init
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_data$ = 8						; size = 4
?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::HashEndianCorrectedBlock, COMDAT
; _this$ = ecx

; 89   : 	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 89   : 	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}

  00014	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00017	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0001a	e8 00 00 00 00	 call	 ?Transform@SHA1@CryptoPP@@SAXPAIPBI@Z ; CryptoPP::SHA1::Transform
  0001f	59		 pop	 ecx
  00020	59		 pop	 ecx
  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@MAEXPBI@Z ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::HashEndianCorrectedBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>, COMDAT
; _this$ = ecx

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 60	 add	 eax, 96			; 00000060H
  0003a	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  0003d	6a 10		 push	 16			; 00000010H
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00054	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00057	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  0005a	e8 00 00 00 00	 call	 ?InitState@SHA1@CryptoPP@@SAXPAI@Z ; CryptoPP::SHA1::InitState
  0005f	59		 pop	 ecx

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	c9		 leave
  00073	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UAE@XZ
__unwindfunclet$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 60	 add	 ecx, 96			; 00000060H
  0000e	e9 00 00 00 00	 jmp	 ??1?$FixedSizeAlignedSecBlock@I$0BA@$0A@@CryptoPP@@QAE@XZ
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::DigestSize, COMDAT
; _this$ = ecx

; 85   : 	unsigned int DigestSize() const {return DIGESTSIZE;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 14		 push	 20			; 00000014H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?DigestSize@?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::DigestSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::~ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::~ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
_TEXT	SEGMENT
$T2 = -32						; size = 4
_this$3 = -28						; size = 4
tv83 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ PROC ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::Clone, COMDAT
; _this$ = ecx

; 19   : 	Clonable * Clone() const {return new DERIVED(*static_cast<const DERIVED *>(this));}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	68 b0 00 00 00	 push	 176			; 000000b0H
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	59		 pop	 ecx
  00033	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00036	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	83 7d f0 00	 cmp	 DWORD PTR $T4[ebp], 0
  0003e	74 3c		 je	 SHORT $LN3@Clone
  00040	ff 75 ec	 push	 DWORD PTR _this$[ebp]
  00043	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00046	e8 00 00 00 00	 call	 ??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00052	83 c0 60	 add	 eax, 96			; 00000060H
  00055	89 45 e4	 mov	 DWORD PTR _this$3[ebp], eax
  00058	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 c0 60	 add	 eax, 96			; 00000060H
  0005e	50		 push	 eax
  0005f	8b 4d e4	 mov	 ecx, DWORD PTR _this$3[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
  00067	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0006b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SHA1@CryptoPP@@6B@
  00074	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00077	89 45 e8	 mov	 DWORD PTR tv83[ebp], eax
  0007a	eb 04		 jmp	 SHORT $LN4@Clone
$LN3@Clone:
  0007c	83 65 e8 00	 and	 DWORD PTR tv83[ebp], 0
$LN4@Clone:
  00080	8b 45 e8	 mov	 eax, DWORD PTR tv83[ebp]
  00083	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00086	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	c9		 leave
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0:
  00000	68 b0 00 00 00	 push	 176			; 000000b0H
  00005	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
__unwindfunclet$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UAE@XZ
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@?$ClonableImpl@VSHA1@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ ENDP ; CryptoPP::ClonableImpl<CryptoPP::SHA1,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1> >::Clone
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::AlgorithmName, COMDAT
; _this$ = ecx

; 28   : 	std::string AlgorithmName() const {return ALGORITHM_INFO::StaticAlgorithmName();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	83 65 fc 00	 and	 DWORD PTR $T1[ebp], 0
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_05HJMENKNE@SHA?91@
  00011	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	83 c8 01	 or	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	c9		 leave
  00026	c2 04 00	 ret	 4
?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VSHA1@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>,CryptoPP::SHA1>::AlgorithmName
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00030	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00039	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0003c	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0003f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 10	 add	 eax, 16			; 00000010H
  00049	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  0004c	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0004f	83 c0 10	 add	 eax, 16			; 00000010H
  00052	50		 push	 eax
  00053	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
  0005b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	c9		 leave
  0006e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 10	 add	 eax, 16			; 00000010H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	ff 70 48	 push	 DWORD PTR [eax+72]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
  00048	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	c9		 leave
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	6a 01		 push	 1
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 26   : 	IteratedHashBase() : m_countLo(0), m_countHi(0) {}

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0003f	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00043	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00046	83 c0 10	 add	 eax, 16			; 00000010H
  00049	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  0004c	6a 10		 push	 16			; 00000010H
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
  00056	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0005a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00060	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00067	59		 pop	 ecx
  00068	c9		 leave
  00069	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_n$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv140 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_t$ = 8							; size = 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >, COMDAT
; _this$ = ecx

; 248  : 	SecBlock(const SecBlock<T, A> &t)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 166  : 	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 40 41 00	 mov	 BYTE PTR [eax+65], 0

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0001c	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  0001f	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00028	89 45 e8	 mov	 DWORD PTR _n$[ebp], eax
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 183  : 		if (n <= S && !m_allocated)

  00031	83 7d e8 10	 cmp	 DWORD PTR _n$[ebp], 16	; 00000010H
  00035	77 3a		 ja	 SHORT $LN13@SecBlock
  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	0f b6 40 41	 movzx	 eax, BYTE PTR [eax+65]
  0003e	85 c0		 test	 eax, eax
  00040	75 2f		 jne	 SHORT $LN13@SecBlock

; 184  : 		{
; 185  : 			m_allocated = true;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c6 40 41 01	 mov	 BYTE PTR [eax+65], 1

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  00049	33 c0		 xor	 eax, eax
  0004b	74 14		 je	 SHORT $LN11@SecBlock
  0004d	33 c0		 xor	 eax, eax
  0004f	2b 45 f8	 sub	 eax, DWORD PTR _this$[ebp]
  00052	33 d2		 xor	 edx, edx
  00054	6a 10		 push	 16			; 00000010H
  00056	59		 pop	 ecx
  00057	f7 f1		 div	 ecx
  00059	03 55 f8	 add	 edx, DWORD PTR _this$[ebp]
  0005c	89 55 f4	 mov	 DWORD PTR tv140[ebp], edx
  0005f	eb 06		 jmp	 SHORT $LN9@SecBlock
$LN11@SecBlock:
  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	89 45 f4	 mov	 DWORD PTR tv140[ebp], eax
$LN9@SecBlock:

; 186  : 			return GetAlignedArray();

  00067	8b 45 f4	 mov	 eax, DWORD PTR tv140[ebp]
  0006a	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0006d	eb 06		 jmp	 SHORT $LN5@SecBlock

; 187  : 		}

  0006f	eb 04		 jmp	 SHORT $LN5@SecBlock
$LN13@SecBlock:

; 188  : 		else
; 189  : 			return m_fallbackAllocator.allocate(n, hint);

  00071	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
$LN5@SecBlock:

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007b	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00084	c1 e0 02	 shl	 eax, 2
  00087	50		 push	 eax
  00088	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  0008b	ff 70 4c	 push	 DWORD PTR [eax+76]
  0008e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00094	c1 e0 02	 shl	 eax, 2
  00097	50		 push	 eax
  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	ff 70 4c	 push	 DWORD PTR [eax+76]
  0009e	e8 00 00 00 00	 call	 _memcpy_s
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	c9		 leave
  000aa	c2 04 00	 ret	 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv128 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z PROC ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >, COMDAT
; _this$ = ecx

; 246  : 	explicit SecBlock(size_type size=0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 166  : 	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 40 41 00	 mov	 BYTE PTR [eax+65], 0

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0001c	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 183  : 		if (n <= S && !m_allocated)

  00025	83 7d 08 10	 cmp	 DWORD PTR _size$[ebp], 16 ; 00000010H
  00029	77 3a		 ja	 SHORT $LN13@SecBlock
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 40 41	 movzx	 eax, BYTE PTR [eax+65]
  00032	85 c0		 test	 eax, eax
  00034	75 2f		 jne	 SHORT $LN13@SecBlock

; 184  : 		{
; 185  : 			m_allocated = true;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c6 40 41 01	 mov	 BYTE PTR [eax+65], 1

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  0003d	33 c0		 xor	 eax, eax
  0003f	74 14		 je	 SHORT $LN11@SecBlock
  00041	33 c0		 xor	 eax, eax
  00043	2b 45 fc	 sub	 eax, DWORD PTR _this$[ebp]
  00046	33 d2		 xor	 edx, edx
  00048	6a 10		 push	 16			; 00000010H
  0004a	59		 pop	 ecx
  0004b	f7 f1		 div	 ecx
  0004d	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  00050	89 55 f4	 mov	 DWORD PTR tv128[ebp], edx
  00053	eb 06		 jmp	 SHORT $LN9@SecBlock
$LN11@SecBlock:
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	89 45 f4	 mov	 DWORD PTR tv128[ebp], eax
$LN9@SecBlock:

; 186  : 			return GetAlignedArray();

  0005b	8b 45 f4	 mov	 eax, DWORD PTR tv128[ebp]
  0005e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00061	eb 06		 jmp	 SHORT $LN5@SecBlock

; 187  : 		}

  00063	eb 04		 jmp	 SHORT $LN5@SecBlock
$LN13@SecBlock:

; 188  : 		else
; 189  : 			return m_fallbackAllocator.allocate(n, hint);

  00065	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
$LN5@SecBlock:

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0006f	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  00072	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
??0?$SecBlock@IV?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ENDP ; CryptoPP::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >::SecBlock<unsigned int,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z PROC ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0>::deallocate, COMDAT
; _this$ = ecx

; 193  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  00008	33 c0		 xor	 eax, eax
  0000a	74 14		 je	 SHORT $LN7@deallocate
  0000c	33 c0		 xor	 eax, eax
  0000e	2b 45 fc	 sub	 eax, DWORD PTR _this$[ebp]
  00011	33 d2		 xor	 edx, edx
  00013	6a 10		 push	 16			; 00000010H
  00015	59		 pop	 ecx
  00016	f7 f1		 div	 ecx
  00018	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  0001b	89 55 f8	 mov	 DWORD PTR tv81[ebp], edx
  0001e	eb 06		 jmp	 SHORT $LN5@deallocate
$LN7@deallocate:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR tv81[ebp], eax
$LN5@deallocate:

; 194  : 		if (p == GetAlignedArray())

  00026	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00029	3b 45 f8	 cmp	 eax, DWORD PTR tv81[ebp]
  0002c	75 14		 jne	 SHORT $LN1@deallocate

; 195  : 		{
; 196  : 			assert(n <= S);
; 197  : 			assert(m_allocated);
; 198  : 			m_allocated = false;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c6 40 41 00	 mov	 BYTE PTR [eax+65], 0

; 199  : 			SecureWipeArray((pointer)p, n);

  00035	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  00038	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0003b	e8 00 00 00 00	 call	 ??$SecureWipeArray@I@CryptoPP@@YAXPAII@Z ; CryptoPP::SecureWipeArray<unsigned int>
  00040	59		 pop	 ecx
  00041	59		 pop	 ecx
$LN1@deallocate:

; 200  : 		}
; 201  : 		else
; 202  : 			m_fallbackAllocator.deallocate(p, n);
; 203  : 	}

  00042	c9		 leave
  00043	c2 08 00	 ret	 8
?deallocate@?$FixedSizeAllocatorWithCleanup@I$0BA@V?$NullAllocator@I@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ENDP ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned int,16,CryptoPP::NullAllocator<unsigned int>,0>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::DataBuf, COMDAT
; _this$ = ecx

; 74   : 	T_HashWordType* DataBuf() {return this->m_data;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  0000e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 74   : 	T_HashWordType* DataBuf() {return this->m_data;}

  00011	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00014	c9		 leave
  00015	c3		 ret	 0
?DataBuf@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPAIXZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::DataBuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::GetByteOrder, COMDAT
; _this$ = ecx

; 66   : 	ByteOrder GetByteOrder() const {return T_Endianness::ToEnum();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?GetByteOrder@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::GetByteOrder
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::BlockSize, COMDAT
; _this$ = ecx

; 64   : 	unsigned int BlockSize() const {return T_BlockSize;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 40		 push	 64			; 00000040H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?BlockSize@?$IteratedHash@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHash<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,CryptoPP::HashTransformation>::BlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GTiger@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTiger@CryptoPP@@UAEPAXI@Z PROC			; CryptoPP::Tiger::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 b8 00 00 00	 push	 184			; 000000b8H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GTiger@CryptoPP@@UAEPAXI@Z ENDP			; CryptoPP::Tiger::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::~IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 68	 add	 eax, 104		; 00000068H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	ff 70 48	 push	 DWORD PTR [eax+72]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0>::deallocate
  00048	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  00054	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00057	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005e	59		 pop	 ecx
  0005f	c9		 leave
  00060	c3		 ret	 0
  00061	cc		 int	 3
  00062	cc		 int	 3
  00063	cc		 int	 3
  00064	cc		 int	 3
  00065	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::~IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ PROC ; CryptoPP::FixedSizeAlignedSecBlock<unsigned __int64,8,0>::~FixedSizeAlignedSecBlock<unsigned __int64,8,0>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	ff 70 48	 push	 DWORD PTR [eax+72]
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	ff 70 4c	 push	 DWORD PTR [eax+76]
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0>::deallocate
  0003e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00042	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00045	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004c	59		 pop	 ecx
  0004d	c9		 leave
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
  00052	cc		 int	 3
  00053	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::FixedSizeAlignedSecBlock<unsigned __int64,8,0>::~FixedSizeAlignedSecBlock<unsigned __int64,8,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::StateBuf, COMDAT
; _this$ = ecx

; 92   : 	T_HashWordType* StateBuf() {return this->m_state;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 92   : 	T_HashWordType* StateBuf() {return this->m_state;}

  00014	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00017	c9		 leave
  00018	c3		 ret	 0
?StateBuf@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEPA_KXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::StateBuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::Init, COMDAT
; _this$ = ecx

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00014	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00017	e8 00 00 00 00	 call	 ?InitState@Tiger@CryptoPP@@SAXPA_K@Z ; CryptoPP::Tiger::InitState
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
?Init@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::Init
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_data$ = 8						; size = 4
?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::HashEndianCorrectedBlock, COMDAT
; _this$ = ecx

; 89   : 	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 89   : 	void HashEndianCorrectedBlock(const T_HashWordType *data) {T_Transform::Transform(this->m_state, data);}

  00014	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00017	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0001a	e8 00 00 00 00	 call	 ?Transform@Tiger@CryptoPP@@SAXPA_KPB_K@Z ; CryptoPP::Tiger::Transform
  0001f	59		 pop	 ecx
  00020	59		 pop	 ecx
  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?HashEndianCorrectedBlock@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@MAEXPB_K@Z ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::HashEndianCorrectedBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>, COMDAT
; _this$ = ecx

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 68	 add	 eax, 104		; 00000068H
  0003a	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  0003d	6a 08		 push	 8
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00047	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00054	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 90   : 	void Init() {T_Transform::InitState(this->m_state);}

  00057	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  0005a	e8 00 00 00 00	 call	 ?InitState@Tiger@CryptoPP@@SAXPA_K@Z ; CryptoPP::Tiger::InitState
  0005f	59		 pop	 ecx

; 88   : 	IteratedHashWithStaticTransform() {this->Init();}

  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	c9		 leave
  00073	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UAE@XZ
__unwindfunclet$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 68	 add	 ecx, 104		; 00000068H
  0000e	e9 00 00 00 00	 jmp	 ??1?$FixedSizeAlignedSecBlock@_K$07$0A@@CryptoPP@@QAE@XZ
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::DigestSize, COMDAT
; _this$ = ecx

; 85   : 	unsigned int DigestSize() const {return DIGESTSIZE;};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 18		 push	 24			; 00000018H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?DigestSize@?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::DigestSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::~ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::~ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
_TEXT	SEGMENT
$T2 = -32						; size = 4
_this$3 = -28						; size = 4
tv83 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ PROC ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::Clone, COMDAT
; _this$ = ecx

; 19   : 	Clonable * Clone() const {return new DERIVED(*static_cast<const DERIVED *>(this));}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	68 b8 00 00 00	 push	 184			; 000000b8H
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	59		 pop	 ecx
  00033	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00036	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	83 7d f0 00	 cmp	 DWORD PTR $T4[ebp], 0
  0003e	74 3c		 je	 SHORT $LN3@Clone
  00040	ff 75 ec	 push	 DWORD PTR _this$[ebp]
  00043	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00046	e8 00 00 00 00	 call	 ??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  0004b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0004f	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00052	83 c0 68	 add	 eax, 104		; 00000068H
  00055	89 45 e4	 mov	 DWORD PTR _this$3[ebp], eax
  00058	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	83 c0 68	 add	 eax, 104		; 00000068H
  0005e	50		 push	 eax
  0005f	8b 4d e4	 mov	 ecx, DWORD PTR _this$3[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
  00067	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0006b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Tiger@CryptoPP@@6B@
  00074	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00077	89 45 e8	 mov	 DWORD PTR tv83[ebp], eax
  0007a	eb 04		 jmp	 SHORT $LN4@Clone
$LN3@Clone:
  0007c	83 65 e8 00	 and	 DWORD PTR tv83[ebp], 0
$LN4@Clone:
  00080	8b 45 e8	 mov	 eax, DWORD PTR tv83[ebp]
  00083	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00086	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008a	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  0008d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00090	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00097	59		 pop	 ecx
  00098	c9		 leave
  00099	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$0:
  00000	68 b8 00 00 00	 push	 184			; 000000b8H
  00005	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
__unwindfunclet$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ$2:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UAE@XZ
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@?$ClonableImpl@VTiger@CryptoPP@@V?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@2@@CryptoPP@@UBEPAVClonable@2@XZ ENDP ; CryptoPP::ClonableImpl<CryptoPP::Tiger,CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger> >::Clone
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::AlgorithmName, COMDAT
; _this$ = ecx

; 28   : 	std::string AlgorithmName() const {return ALGORITHM_INFO::StaticAlgorithmName();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	83 65 fc 00	 and	 DWORD PTR $T1[ebp], 0
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_05LIOENMIE@Tiger@
  00011	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	83 c8 01	 or	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	c9		 leave
  00026	c2 04 00	 ret	 4
?AlgorithmName@?$AlgorithmImpl@V?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@VTiger@2@@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CryptoPP::AlgorithmImpl<CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>,CryptoPP::Tiger>::AlgorithmName
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00030	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00033	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00036	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00039	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0003f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00042	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00045	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00048	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0004b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c0 18	 add	 eax, 24			; 00000018H
  00055	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
  00058	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0005b	83 c0 18	 add	 eax, 24			; 00000018H
  0005e	50		 push	 eax
  0005f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
  00067	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0006b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00078	59		 pop	 ecx
  00079	c9		 leave
  0007a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00027	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 18	 add	 eax, 24			; 00000018H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	ff 70 48	 push	 DWORD PTR [eax+72]
  0003a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff 70 4c	 push	 DWORD PTR [eax+76]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0>::deallocate
  00048	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00056	59		 pop	 ecx
  00057	c9		 leave
  00058	c3		 ret	 0
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::~IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	6a 01		 push	 1
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 26   : 	IteratedHashBase() : m_countLo(0), m_countHi(0) {}

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	33 c9		 xor	 ecx, ecx
  00036	33 d2		 xor	 edx, edx
  00038	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0003b	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  0003e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00041	33 c9		 xor	 ecx, ecx
  00043	33 d2		 xor	 edx, edx
  00045	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00048	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0004b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c0 18	 add	 eax, 24			; 00000018H
  00055	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 425  : 	explicit FixedSizeSecBlock() : SecBlock<T, A>(S) {}

  00058	6a 08		 push	 8
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
  00062	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	c9		 leave
  00075	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_n$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv140 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_t$ = 8							; size = 4
??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >, COMDAT
; _this$ = ecx

; 248  : 	SecBlock(const SecBlock<T, A> &t)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 166  : 	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 40 41 00	 mov	 BYTE PTR [eax+65], 0

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0001c	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  0001f	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00028	89 45 e8	 mov	 DWORD PTR _n$[ebp], eax
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 183  : 		if (n <= S && !m_allocated)

  00031	83 7d e8 08	 cmp	 DWORD PTR _n$[ebp], 8
  00035	77 3a		 ja	 SHORT $LN13@SecBlock
  00037	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	0f b6 40 41	 movzx	 eax, BYTE PTR [eax+65]
  0003e	85 c0		 test	 eax, eax
  00040	75 2f		 jne	 SHORT $LN13@SecBlock

; 184  : 		{
; 185  : 			m_allocated = true;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c6 40 41 01	 mov	 BYTE PTR [eax+65], 1

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  00049	33 c0		 xor	 eax, eax
  0004b	74 14		 je	 SHORT $LN11@SecBlock
  0004d	33 c0		 xor	 eax, eax
  0004f	2b 45 f8	 sub	 eax, DWORD PTR _this$[ebp]
  00052	33 d2		 xor	 edx, edx
  00054	6a 10		 push	 16			; 00000010H
  00056	59		 pop	 ecx
  00057	f7 f1		 div	 ecx
  00059	03 55 f8	 add	 edx, DWORD PTR _this$[ebp]
  0005c	89 55 f4	 mov	 DWORD PTR tv140[ebp], edx
  0005f	eb 06		 jmp	 SHORT $LN9@SecBlock
$LN11@SecBlock:
  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	89 45 f4	 mov	 DWORD PTR tv140[ebp], eax
$LN9@SecBlock:

; 186  : 			return GetAlignedArray();

  00067	8b 45 f4	 mov	 eax, DWORD PTR tv140[ebp]
  0006a	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0006d	eb 06		 jmp	 SHORT $LN5@SecBlock

; 187  : 		}

  0006f	eb 04		 jmp	 SHORT $LN5@SecBlock
$LN13@SecBlock:

; 188  : 		else
; 189  : 			return m_fallbackAllocator.allocate(n, hint);

  00071	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
$LN5@SecBlock:

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0007b	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00084	c1 e0 03	 shl	 eax, 3
  00087	50		 push	 eax
  00088	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  0008b	ff 70 4c	 push	 DWORD PTR [eax+76]
  0008e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  00094	c1 e0 03	 shl	 eax, 3
  00097	50		 push	 eax
  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	ff 70 4c	 push	 DWORD PTR [eax+76]
  0009e	e8 00 00 00 00	 call	 _memcpy_s
  000a3	83 c4 10	 add	 esp, 16			; 00000010H
  000a6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	c9		 leave
  000aa	c2 04 00	 ret	 4
??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T1 = -16						; size = 4
tv128 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z PROC ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >, COMDAT
; _this$ = ecx

; 246  : 	explicit SecBlock(size_type size=0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 166  : 	FixedSizeAllocatorWithCleanup() : m_allocated(false) {}

  0000f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 40 41 00	 mov	 BYTE PTR [eax+65], 0

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0001c	89 48 48	 mov	 DWORD PTR [eax+72], ecx
  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 183  : 		if (n <= S && !m_allocated)

  00025	83 7d 08 08	 cmp	 DWORD PTR _size$[ebp], 8
  00029	77 3a		 ja	 SHORT $LN13@SecBlock
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	0f b6 40 41	 movzx	 eax, BYTE PTR [eax+65]
  00032	85 c0		 test	 eax, eax
  00034	75 2f		 jne	 SHORT $LN13@SecBlock

; 184  : 		{
; 185  : 			m_allocated = true;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c6 40 41 01	 mov	 BYTE PTR [eax+65], 1

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  0003d	33 c0		 xor	 eax, eax
  0003f	74 14		 je	 SHORT $LN11@SecBlock
  00041	33 c0		 xor	 eax, eax
  00043	2b 45 fc	 sub	 eax, DWORD PTR _this$[ebp]
  00046	33 d2		 xor	 edx, edx
  00048	6a 10		 push	 16			; 00000010H
  0004a	59		 pop	 ecx
  0004b	f7 f1		 div	 ecx
  0004d	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  00050	89 55 f4	 mov	 DWORD PTR tv128[ebp], edx
  00053	eb 06		 jmp	 SHORT $LN9@SecBlock
$LN11@SecBlock:
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	89 45 f4	 mov	 DWORD PTR tv128[ebp], eax
$LN9@SecBlock:

; 186  : 			return GetAlignedArray();

  0005b	8b 45 f4	 mov	 eax, DWORD PTR tv128[ebp]
  0005e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00061	eb 06		 jmp	 SHORT $LN5@SecBlock

; 187  : 		}

  00063	eb 04		 jmp	 SHORT $LN5@SecBlock
$LN13@SecBlock:

; 188  : 		else
; 189  : 			return m_fallbackAllocator.allocate(n, hint);

  00065	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
$LN5@SecBlock:

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0006f	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  00072	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
??0?$SecBlock@_KV?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ENDP ; CryptoPP::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >::SecBlock<unsigned __int64,CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
_this$ = -4						; size = 4
_p$ = 8							; size = 4
_n$ = 12						; size = 4
?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z PROC ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0>::deallocate, COMDAT
; _this$ = ecx

; 193  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 229  : 	T* GetAlignedArray() {return (CRYPTOPP_BOOL_ALIGN16_ENABLED && T_Align16) ? (T*)(((byte *)m_array) + (0-(size_t)m_array)%16) : m_array;}

  00008	33 c0		 xor	 eax, eax
  0000a	74 14		 je	 SHORT $LN7@deallocate
  0000c	33 c0		 xor	 eax, eax
  0000e	2b 45 fc	 sub	 eax, DWORD PTR _this$[ebp]
  00011	33 d2		 xor	 edx, edx
  00013	6a 10		 push	 16			; 00000010H
  00015	59		 pop	 ecx
  00016	f7 f1		 div	 ecx
  00018	03 55 fc	 add	 edx, DWORD PTR _this$[ebp]
  0001b	89 55 f8	 mov	 DWORD PTR tv81[ebp], edx
  0001e	eb 06		 jmp	 SHORT $LN5@deallocate
$LN7@deallocate:
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 f8	 mov	 DWORD PTR tv81[ebp], eax
$LN5@deallocate:

; 194  : 		if (p == GetAlignedArray())

  00026	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00029	3b 45 f8	 cmp	 eax, DWORD PTR tv81[ebp]
  0002c	75 14		 jne	 SHORT $LN1@deallocate

; 195  : 		{
; 196  : 			assert(n <= S);
; 197  : 			assert(m_allocated);
; 198  : 			m_allocated = false;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c6 40 41 00	 mov	 BYTE PTR [eax+65], 0

; 199  : 			SecureWipeArray((pointer)p, n);

  00035	ff 75 0c	 push	 DWORD PTR _n$[ebp]
  00038	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0003b	e8 00 00 00 00	 call	 ??$SecureWipeArray@_K@CryptoPP@@YAXPA_KI@Z ; CryptoPP::SecureWipeArray<unsigned __int64>
  00040	59		 pop	 ecx
  00041	59		 pop	 ecx
$LN1@deallocate:

; 200  : 		}
; 201  : 		else
; 202  : 			m_fallbackAllocator.deallocate(p, n);
; 203  : 	}

  00042	c9		 leave
  00043	c2 08 00	 ret	 8
?deallocate@?$FixedSizeAllocatorWithCleanup@_K$07V?$NullAllocator@_K@CryptoPP@@$0A@@CryptoPP@@QAEXPAXI@Z ENDP ; CryptoPP::FixedSizeAllocatorWithCleanup<unsigned __int64,8,CryptoPP::NullAllocator<unsigned __int64>,0>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::DataBuf, COMDAT
; _this$ = ecx

; 74   : 	T_HashWordType* DataBuf() {return this->m_data;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 275  : 		{return m_ptr;}

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  0000e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 74   : 	T_HashWordType* DataBuf() {return this->m_data;}

  00011	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00014	c9		 leave
  00015	c3		 ret	 0
?DataBuf@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@MAEPA_KXZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::DataBuf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::GetByteOrder, COMDAT
; _this$ = ecx

; 66   : 	ByteOrder GetByteOrder() const {return T_Endianness::ToEnum();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c3		 ret	 0
?GetByteOrder@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBE?AW4ByteOrder@2@XZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::GetByteOrder
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::BlockSize, COMDAT
; _this$ = ecx

; 64   : 	unsigned int BlockSize() const {return T_BlockSize;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 40		 push	 64			; 00000040H
  00009	58		 pop	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?BlockSize@?$IteratedHash@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@VHashTransformation@2@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHash<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,CryptoPP::HashTransformation>::BlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::~IteratedHashBase<unsigned int,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::~IteratedHashBase<unsigned int,CryptoPP::HashTransformation>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?OptimalDataAlignment@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
?OptimalDataAlignment@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::OptimalDataAlignment, COMDAT
; _this$ = ecx

; 28   : 	unsigned int OptimalDataAlignment() const {return GetAlignmentOf<T>();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h

; 366  : 	if (sizeof(T) < 16)

  00008	33 c0		 xor	 eax, eax
  0000a	40		 inc	 eax
  0000b	74 09		 je	 SHORT $LN4@OptimalDat

; 367  : 		return 1;

  0000d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00014	eb 07		 jmp	 SHORT $LN3@OptimalDat
$LN4@OptimalDat:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  00016	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR $T1[ebp], 4
$LN3@OptimalDat:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 28   : 	unsigned int OptimalDataAlignment() const {return GetAlignmentOf<T>();}

  0001d	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00020	c9		 leave
  00021	c3		 ret	 0
?OptimalDataAlignment@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::OptimalDataAlignment
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?OptimalBlockSize@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OptimalBlockSize@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::OptimalBlockSize, COMDAT
; _this$ = ecx

; 27   : 	unsigned int OptimalBlockSize() const {return this->BlockSize();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 20	 call	 DWORD PTR [eax+32]
  00012	c9		 leave
  00013	c3		 ret	 0
?OptimalBlockSize@?$IteratedHashBase@IVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHashBase<unsigned int,CryptoPP::HashTransformation>::OptimalBlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::~IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::~IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?OptimalDataAlignment@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
?OptimalDataAlignment@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::OptimalDataAlignment, COMDAT
; _this$ = ecx

; 28   : 	unsigned int OptimalDataAlignment() const {return GetAlignmentOf<T>();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h

; 366  : 	if (sizeof(T) < 16)

  00008	33 c0		 xor	 eax, eax
  0000a	40		 inc	 eax
  0000b	74 09		 je	 SHORT $LN4@OptimalDat

; 367  : 		return 1;

  0000d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR $T1[ebp], 1
  00014	eb 07		 jmp	 SHORT $LN3@OptimalDat
$LN4@OptimalDat:

; 368  : #endif
; 369  : 
; 370  : #if (_MSC_VER >= 1300)
; 371  : 	return __alignof(T);

  00016	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR $T1[ebp], 8
$LN3@OptimalDat:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h

; 28   : 	unsigned int OptimalDataAlignment() const {return GetAlignmentOf<T>();}

  0001d	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00020	c9		 leave
  00021	c3		 ret	 0
?OptimalDataAlignment@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::OptimalDataAlignment
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\iterhash.h
;	COMDAT ?OptimalBlockSize@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OptimalBlockSize@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ PROC ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::OptimalBlockSize, COMDAT
; _this$ = ecx

; 27   : 	unsigned int OptimalBlockSize() const {return this->BlockSize();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 20	 call	 DWORD PTR [eax+32]
  00012	c9		 leave
  00013	c3		 ret	 0
?OptimalBlockSize@?$IteratedHashBase@_KVHashTransformation@CryptoPP@@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::IteratedHashBase<unsigned __int64,CryptoPP::HashTransformation>::OptimalBlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::~AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  00012	c9		 leave
  00013	c3		 ret	 0
??1?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::~AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c0 04	 add	 eax, 4
  00032	89 45 ec	 mov	 DWORD PTR _this$2[ebp], eax
  00035	6a 01		 push	 1
  00037	8b 4d ec	 mov	 ecx, DWORD PTR _this$2[ebp]
  0003a	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
  0003f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00043	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 08	 add	 eax, 8
  00050	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
  00053	6a 01		 push	 1
  00055	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
  0005d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00061	6a 00		 push	 0
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00069	e8 00 00 00 00	 call	 ??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0006e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00072	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	c9		 leave
  00081	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ$4:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SimpleKeyingInterface@CryptoPP@@UAE@XZ ; CryptoPP::SimpleKeyingInterface::~SimpleKeyingInterface
__unwindfunclet$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@UAE@XZ ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::~AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>
__unwindfunclet$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ$1:
  00010	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 08	 add	 ecx, 8
  00016	e9 00 00 00 00	 jmp	 ??1RandomNumberGenerator@CryptoPP@@UAE@XZ
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ
  00038	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?IsRandomAccess@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?IsRandomAccess@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsRandomAccess, COMDAT
; _this$ = ecx

; 145  : 	bool IsRandomAccess() const {return this->GetPolicy().CipherIsRandomAccess();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 e9 04	 sub	 ecx, 4
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00014	ff 50 3c	 call	 DWORD PTR [eax+60]
  00017	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00022	ff 50 28	 call	 DWORD PTR [eax+40]
  00025	c9		 leave
  00026	c3		 ret	 0
?IsRandomAccess@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ ENDP ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsRandomAccess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?IsForwardTransformation@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsForwardTransformation@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsForwardTransformation, COMDAT
; _this$ = ecx

; 144  : 	bool IsForwardTransformation() const {return true;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	c9		 leave
  0000a	c3		 ret	 0
?IsForwardTransformation@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ ENDP ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsForwardTransformation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?IsSelfInverting@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSelfInverting@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsSelfInverting, COMDAT
; _this$ = ecx

; 143  : 	bool IsSelfInverting() const {return true;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	c9		 leave
  0000a	c3		 ret	 0
?IsSelfInverting@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBE_NXZ ENDP ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::IsSelfInverting
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?OptimalDataAlignment@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?OptimalDataAlignment@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::OptimalDataAlignment, COMDAT
; _this$ = ecx

; 142  : 	unsigned int OptimalDataAlignment() const {return this->GetPolicy().GetAlignment();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 e9 04	 sub	 ecx, 4
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00014	ff 50 3c	 call	 DWORD PTR [eax+60]
  00017	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00022	ff 50 04	 call	 DWORD PTR [eax+4]
  00025	c9		 leave
  00026	c3		 ret	 0
?OptimalDataAlignment@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::OptimalDataAlignment
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?OptimalBlockSize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?OptimalBlockSize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ PROC ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::OptimalBlockSize, COMDAT
; _this$ = ecx

; 140  : 	unsigned int OptimalBlockSize() const {return this->GetPolicy().GetOptimalBlockSize();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 e9 04	 sub	 ecx, 4
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 fc	 mov	 eax, DWORD PTR [eax-4]
  00014	ff 50 3c	 call	 DWORD PTR [eax+60]
  00017	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  0001a	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]
  0001d	8b 00		 mov	 eax, DWORD PTR [eax]
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00022	ff 50 0c	 call	 DWORD PTR [eax+12]
  00025	c9		 leave
  00026	c3		 ret	 0
?OptimalBlockSize@?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@CryptoPP@@UBEIXZ ENDP ; CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >::OptimalBlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ??1?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@UAE@XZ PROC ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::~AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>, COMDAT
; _this$ = ecx

; 42   : 	virtual ~AbstractPolicyHolder() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>::~AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T2 = -80						; size = 40
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_iterationCount$ = 8					; size = 8
?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z PROC ; CryptoPP::AdditiveCipherAbstractPolicy::SeekToIteration, COMDAT
; _this$ = ecx

; 80   : 	virtual void SeekToIteration(lword iterationCount) {assert(!CipherIsRandomAccess()); throw NotImplemented("StreamTransformation: this object doesn't support random access");}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0EA@BPAJPOGP@StreamTransformation?3?5this?5obje@
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  0003f	50		 push	 eax
  00040	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	e8 00 00 00 00	 call	 ??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::NotImplemented::NotImplemented
  00048	68 00 00 00 00	 push	 OFFSET __TI3?AVNotImplemented@CryptoPP@@
  0004d	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 __CxxThrowException@8
  00056	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0005a	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN2@SeekToIter:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h

; 80   : 	virtual void SeekToIteration(lword iterationCount) {assert(!CipherIsRandomAccess()); throw NotImplemented("StreamTransformation: this object doesn't support random access");}

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	c9		 leave
  00078	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SeekToIteration@AdditiveCipherAbstractPolicy@CryptoPP@@UAEX_K@Z ENDP ; CryptoPP::AdditiveCipherAbstractPolicy::SeekToIteration
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?WriteKeystream@AdditiveCipherAbstractPolicy@CryptoPP@@UAEXPAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_keystream$ = 8						; size = 4
_iterationCount$ = 12					; size = 4
?WriteKeystream@AdditiveCipherAbstractPolicy@CryptoPP@@UAEXPAEI@Z PROC ; CryptoPP::AdditiveCipherAbstractPolicy::WriteKeystream, COMDAT
; _this$ = ecx

; 74   : 		{OperateKeystream(KeystreamOperation(INPUT_NULL | (KeystreamOperationFlags)IsAlignedOn(keystream, GetAlignment())), keystream, NULL, iterationCount);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 0c	 push	 DWORD PTR _iterationCount$[ebp]
  0000a	6a 00		 push	 0
  0000c	ff 75 08	 push	 DWORD PTR _keystream$[ebp]
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	ff 50 04	 call	 DWORD PTR [eax+4]
  0001a	50		 push	 eax
  0001b	ff 75 08	 push	 DWORD PTR _keystream$[ebp]
  0001e	e8 00 00 00 00	 call	 ?IsAlignedOn@CryptoPP@@YA_NPBXI@Z ; CryptoPP::IsAlignedOn
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	0f b6 c0	 movzx	 eax, al
  00028	83 c8 04	 or	 eax, 4
  0002b	50		 push	 eax
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	ff 50 1c	 call	 DWORD PTR [eax+28]
  00037	c9		 leave
  00038	c2 08 00	 ret	 8
?WriteKeystream@AdditiveCipherAbstractPolicy@CryptoPP@@UAEXPAEI@Z ENDP ; CryptoPP::AdditiveCipherAbstractPolicy::WriteKeystream
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\strciphr.h
;	COMDAT ?GetOptimalBlockSize@AdditiveCipherAbstractPolicy@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOptimalBlockSize@AdditiveCipherAbstractPolicy@CryptoPP@@UBEIXZ PROC ; CryptoPP::AdditiveCipherAbstractPolicy::GetOptimalBlockSize, COMDAT
; _this$ = ecx

; 71   : 	virtual unsigned int GetOptimalBlockSize() const {return GetBytesPerIteration();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 08	 call	 DWORD PTR [eax+8]
  00012	c9		 leave
  00013	c3		 ret	 0
?GetOptimalBlockSize@AdditiveCipherAbstractPolicy@CryptoPP@@UBEIXZ ENDP ; CryptoPP::AdditiveCipherAbstractPolicy::GetOptimalBlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_string$ = 8						; size = 4
_deepCopy$ = 12						; size = 1
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 25   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	6a 00		 push	 0
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 ??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  00034	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  00038	8b 45 08	 mov	 eax, DWORD PTR _string$[ebp]
  0003b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0003e	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 27   : 		Assign((const byte *)string.data(), string.size(), deepCopy);

  00041	ff 75 0c	 push	 DWORD PTR _deepCopy$[ebp]
  00044	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00047	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  0004a	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  0004f	50		 push	 eax
  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?Assign@ConstByteArrayParameter@CryptoPP@@QAEXPBEI_N@Z ; CryptoPP::ConstByteArrayParameter::Assign

; 28   : 	}

  00058	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0005c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	c9		 leave
  0006b	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Odspy
;	COMDAT ??_GStringSource@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GStringSource@CryptoPP@@UAEPAXI@Z PROC		; CryptoPP::StringSource::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
  00012	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	74 0c		 je	 SHORT $LN2@scalar
  0001a	6a 38		 push	 56			; 00000038H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GStringSource@CryptoPP@@UAEPAXI@Z ENDP		; CryptoPP::StringSource::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z
_TEXT	SEGMENT
$T2 = -68						; size = 24
$T3 = -44						; size = 12
$T4 = -32						; size = 4
tv132 = -28						; size = 4
tv144 = -24						; size = 4
tv69 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_string$ = 8						; size = 4
_pumpAll$ = 12						; size = 1
_attachment$ = 16					; size = 4
??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z PROC ; CryptoPP::StringSource::StringSource, COMDAT
; _this$ = ecx

; 792  : 	StringSource(const std::string &string, bool pumpAll, BufferedTransformation *attachment = NULL)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 793  : 		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}

  00028	ff 75 10	 push	 DWORD PTR _attachment$[ebp]
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SourceTemplate<CryptoPP::StringStore>
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7StringSource@CryptoPP@@6BAlgorithm@1@@
  00040	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7StringSource@CryptoPP@@6BWaitable@1@@
  0004a	6a 00		 push	 0
  0004c	ff 75 08	 push	 DWORD PTR _string$[ebp]
  0004f	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  00052	e8 00 00 00 00	 call	 ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@ConstByteArrayParameter@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00057	89 45 ec	 mov	 DWORD PTR tv69[ebp], eax
  0005a	8b 45 ec	 mov	 eax, DWORD PTR tv69[ebp]
  0005d	89 45 e8	 mov	 DWORD PTR tv144[ebp], eax
  00060	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00064	6a 01		 push	 1
  00066	ff 75 e8	 push	 DWORD PTR tv144[ebp]
  00069	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JMHEFFAI@InputBuffer@
  0006e	8d 45 d4	 lea	 eax, DWORD PTR $T3[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z ; CryptoPP::MakeParameters<CryptoPP::ConstByteArrayParameter>
  00077	83 c4 10	 add	 esp, 16			; 00000010H
  0007a	89 45 e4	 mov	 DWORD PTR tv132[ebp], eax
  0007d	8b 45 e4	 mov	 eax, DWORD PTR tv132[ebp]
  00080	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
  00083	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 747  : 		IsolatedInitialize(parameters);

  00087	ff 75 e0	 push	 DWORD PTR $T4[ebp]
  0008a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	8b 00		 mov	 eax, DWORD PTR [eax]
  0008f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	ff 50 1c	 call	 DWORD PTR [eax+28]

; 748  : 		if (pumpAll)

  00095	0f b6 45 0c	 movzx	 eax, BYTE PTR _pumpAll$[ebp]
  00099	85 c0		 test	 eax, eax
  0009b	74 10		 je	 SHORT $LN105@StringSour

; 738  : 		{PumpAll2();}

  0009d	6a 01		 push	 1
  0009f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	ff 90 c4 00 00
	00		 call	 DWORD PTR [eax+196]
$LN105@StringSour:

; 793  : 		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}

  000ad	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000b1	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp+4]
  000b4	e8 00 00 00 00	 call	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
  000b9	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000bd	8d 4d c8	 lea	 ecx, DWORD PTR $T2[ebp+12]
  000c0	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  000c5	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000c9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cf	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d6	59		 pop	 ecx
  000d7	c9		 leave
  000d8	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAE@XZ
__unwindfunclet$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z$1:
  00008	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1ConstByteArrayParameter@CryptoPP@@QAE@XZ
__unwindfunclet$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z$2:
  00010	8d 4d d4	 lea	 ecx, DWORD PTR $T3[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1AlgorithmParameters@CryptoPP@@UAE@XZ
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z ENDP ; CryptoPP::StringSource::StringSource
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 24
$T3 = -40						; size = 12
$T4 = -28						; size = 4
tv170 = -24						; size = 4
tv145 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_string$ = 8						; size = 4
_length$ = 12						; size = 4
_pumpAll$ = 16						; size = 1
_attachment$ = 20					; size = 4
??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z PROC ; CryptoPP::StringSource::StringSource, COMDAT
; _this$ = ecx

; 789  : 	StringSource(const byte *string, size_t length, bool pumpAll, BufferedTransformation *attachment = NULL)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 790  : 		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string, length)));}

  00028	ff 75 14	 push	 DWORD PTR _attachment$[ebp]
  0002b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SourceTemplate<CryptoPP::StringStore>
  00033	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00037	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7StringSource@CryptoPP@@6BAlgorithm@1@@
  00040	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7StringSource@CryptoPP@@6BWaitable@1@@
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 20   : 	ConstByteArrayParameter(const byte *data, size_t size, bool deepCopy = false)

  0004a	6a 00		 push	 0
  0004c	8d 4d cc	 lea	 ecx, DWORD PTR $T2[ebp+12]
  0004f	e8 00 00 00 00	 call	 ??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  00054	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 21   : 	{
; 22   : 		Assign(data, size, deepCopy);

  00058	6a 00		 push	 0
  0005a	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  0005d	ff 75 08	 push	 DWORD PTR _string$[ebp]
  00060	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00063	e8 00 00 00 00	 call	 ?Assign@ConstByteArrayParameter@CryptoPP@@QAEXPBEI_N@Z ; CryptoPP::ConstByteArrayParameter::Assign

; 23   : 	}

  00068	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 790  : 		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string, length)));}

  0006c	8d 45 c0	 lea	 eax, DWORD PTR $T2[ebp]
  0006f	89 45 ec	 mov	 DWORD PTR tv145[ebp], eax
  00072	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00076	6a 01		 push	 1
  00078	ff 75 ec	 push	 DWORD PTR tv145[ebp]
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JMHEFFAI@InputBuffer@
  00080	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z ; CryptoPP::MakeParameters<CryptoPP::ConstByteArrayParameter>
  00089	83 c4 10	 add	 esp, 16			; 00000010H
  0008c	89 45 e8	 mov	 DWORD PTR tv170[ebp], eax
  0008f	8b 45 e8	 mov	 eax, DWORD PTR tv170[ebp]
  00092	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
  00095	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 747  : 		IsolatedInitialize(parameters);

  00099	ff 75 e4	 push	 DWORD PTR $T4[ebp]
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	ff 50 1c	 call	 DWORD PTR [eax+28]

; 748  : 		if (pumpAll)

  000a7	0f b6 45 10	 movzx	 eax, BYTE PTR _pumpAll$[ebp]
  000ab	85 c0		 test	 eax, eax
  000ad	74 10		 je	 SHORT $LN87@StringSour

; 738  : 		{PumpAll2();}

  000af	6a 01		 push	 1
  000b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
  000b6	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	ff 90 c4 00 00
	00		 call	 DWORD PTR [eax+196]
$LN87@StringSour:

; 790  : 		: SourceTemplate<StringStore>(attachment) {SourceInitialize(pumpAll, MakeParameters("InputBuffer", ConstByteArrayParameter(string, length)));}

  000bf	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000c3	8d 4d dc	 lea	 ecx, DWORD PTR $T3[ebp+4]
  000c6	e8 00 00 00 00	 call	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
  000cb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000cf	8d 4d cc	 lea	 ecx, DWORD PTR $T2[ebp+12]
  000d2	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  000d7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000db	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000de	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e8	59		 pop	 ecx
  000e9	c9		 leave
  000ea	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAE@XZ
__unwindfunclet$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z$14:
  00008	8d 4d cc	 lea	 ecx, DWORD PTR $T2[ebp+12]
  0000b	e9 00 00 00 00	 jmp	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
__unwindfunclet$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z$1:
  00010	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1ConstByteArrayParameter@CryptoPP@@QAE@XZ
__unwindfunclet$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z$2:
  00018	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1AlgorithmParameters@CryptoPP@@UAE@XZ
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
  00023	cc		 int	 3
  00024	cc		 int	 3
__ehhandler$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z:
  00025	90		 npad	 1
  00026	90		 npad	 1
  00027	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002e	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z ENDP ; CryptoPP::StringSource::StringSource
; Function compile flags: /Odspy
;	COMDAT ??_G?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
  00012	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00015	83 e0 01	 and	 eax, 1
  00018	74 0c		 je	 SHORT $LN2@scalar
  0001a	6a 38		 push	 56			; 00000038H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_G?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::~SourceTemplate<CryptoPP::StringStore>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
  00012	c9		 leave
  00013	c3		 ret	 0
??1?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::~SourceTemplate<CryptoPP::StringStore>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?GetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBEHXZ PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::GetAutoSignalPropagation, COMDAT
; _this$ = ecx

; 773  : 		{return m_store.GetAutoSignalPropagation();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00013	ff 50 38	 call	 DWORD PTR [eax+56]
  00016	c9		 leave
  00017	c3		 ret	 0
?GetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBEHXZ ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::GetAutoSignalPropagation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?SetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_propagation$ = 8					; size = 4
?SetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXH@Z PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SetAutoSignalPropagation, COMDAT
; _this$ = ecx

; 771  : 		{m_store.SetAutoSignalPropagation(propagation);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR _propagation$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	83 c1 18	 add	 ecx, 24			; 00000018H
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00016	ff 50 34	 call	 DWORD PTR [eax+52]
  00019	c9		 leave
  0001a	c2 04 00	 ret	 4
?SetAutoSignalPropagation@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXH@Z ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SetAutoSignalPropagation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?SourceExhausted@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBE_NXZ
_TEXT	SEGMENT
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?SourceExhausted@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBE_NXZ PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SourceExhausted, COMDAT
; _this$ = ecx

; 769  : 		{return !m_store.AnyRetrievable() && !m_store.AnyMessages();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 18	 add	 ecx, 24			; 00000018H
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00014	ff 50 40	 call	 DWORD PTR [eax+64]
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 1f		 jne	 SHORT $LN3@SourceExha
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 18	 add	 ecx, 24			; 00000018H
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0002a	ff 50 60	 call	 DWORD PTR [eax+96]
  0002d	0f b6 c0	 movzx	 eax, al
  00030	85 c0		 test	 eax, eax
  00032	75 09		 jne	 SHORT $LN3@SourceExha
  00034	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv88[ebp], 1
  0003b	eb 04		 jmp	 SHORT $LN4@SourceExha
$LN3@SourceExha:
  0003d	83 65 f8 00	 and	 DWORD PTR tv88[ebp], 0
$LN4@SourceExha:
  00041	8a 45 f8	 mov	 al, BYTE PTR tv88[ebp]
  00044	c9		 leave
  00045	c3		 ret	 0
?SourceExhausted@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UBE_NXZ ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SourceExhausted
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?PumpAll2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEI_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_blocking$ = 8						; size = 1
?PumpAll2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEI_N@Z PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::PumpAll2, COMDAT
; _this$ = ecx

; 767  : 		{return m_store.TransferAllTo2(*AttachedTransformation(), DEFAULT_CHANNEL, blocking);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR _blocking$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CryptoPP::DEFAULT_CHANNEL
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 18	 add	 ecx, 24			; 00000018H
  00024	e8 00 00 00 00	 call	 ?TransferAllTo2@BufferedTransformation@CryptoPP@@QAEIAAV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CryptoPP::BufferedTransformation::TransferAllTo2
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
?PumpAll2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEI_N@Z ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::PumpAll2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?PumpMessages2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAAI_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_messageCount$ = 8					; size = 4
_blocking$ = 12						; size = 1
?PumpMessages2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAAI_N@Z PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::PumpMessages2, COMDAT
; _this$ = ecx

; 765  : 		{return m_store.TransferMessagesTo2(*AttachedTransformation(), messageCount, DEFAULT_CHANNEL, blocking);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 0c	 push	 DWORD PTR _blocking$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CryptoPP::DEFAULT_CHANNEL
  0000f	ff 75 08	 push	 DWORD PTR _messageCount$[ebp]
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 18	 add	 ecx, 24			; 00000018H
  00027	e8 00 00 00 00	 call	 ?TransferMessagesTo2@BufferedTransformation@CryptoPP@@QAEIAAV12@AAIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; CryptoPP::BufferedTransformation::TransferMessagesTo2
  0002c	c9		 leave
  0002d	c2 08 00	 ret	 8
?PumpMessages2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAAI_N@Z ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::PumpMessages2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?Pump2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAA_K_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_byteCount$ = 8						; size = 4
_blocking$ = 12						; size = 1
?Pump2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAA_K_N@Z PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::Pump2, COMDAT
; _this$ = ecx

; 763  : 		{return m_store.TransferTo2(*AttachedTransformation(), byteCount, DEFAULT_CHANNEL, blocking);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 0c	 push	 DWORD PTR _blocking$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CryptoPP::DEFAULT_CHANNEL
  0000f	ff 75 08	 push	 DWORD PTR _byteCount$[ebp]
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 00		 mov	 eax, DWORD PTR [eax]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]
  00020	50		 push	 eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 18	 add	 ecx, 24			; 00000018H
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0002d	ff 50 7c	 call	 DWORD PTR [eax+124]
  00030	c9		 leave
  00031	c2 08 00	 ret	 8
?Pump2@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEIAA_K_N@Z ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::Pump2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?IsolatedInitialize@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_parameters$ = 8					; size = 4
?IsolatedInitialize@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::IsolatedInitialize, COMDAT
; _this$ = ecx

; 761  : 		{m_store.IsolatedInitialize(parameters);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR _parameters$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	83 c1 18	 add	 ecx, 24			; 00000018H
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00016	ff 50 1c	 call	 DWORD PTR [eax+28]
  00019	c9		 leave
  0001a	c2 04 00	 ret	 4
?IsolatedInitialize@?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::IsolatedInitialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_attachment$ = 8					; size = 4
??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z PROC ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SourceTemplate<CryptoPP::StringStore>, COMDAT
; _this$ = ecx

; 758  : 	SourceTemplate<T>(BufferedTransformation *attachment)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	6a 00		 push	 0
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0Filter@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z ; CryptoPP::Filter::Filter

; 730  : 	Source(BufferedTransformation *attachment = NULL)

  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 731  : 		{Source::Detach(attachment);}

  00034	ff 75 08	 push	 DWORD PTR _attachment$[ebp]
  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?Detach@Filter@CryptoPP@@UAEXPAVBufferedTransformation@2@@Z ; CryptoPP::Filter::Detach

; 759  : 		: Source(attachment) {}

  0003f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  00046	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00049	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BAlgorithm@1@@
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@6BWaitable@1@@
  00059	6a 00		 push	 0
  0005b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 18	 add	 ecx, 24			; 00000018H
  00061	e8 00 00 00 00	 call	 ??0StringStore@CryptoPP@@QAE@PBD@Z ; CryptoPP::StringStore::StringStore
  00066	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0006a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00070	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00077	59		 pop	 ecx
  00078	c9		 leave
  00079	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z$2:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ
__unwindfunclet$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z$0:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1Source@CryptoPP@@UAE@XZ
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$SourceTemplate@VStringStore@CryptoPP@@@CryptoPP@@QAE@PAVBufferedTransformation@1@@Z ENDP ; CryptoPP::SourceTemplate<CryptoPP::StringStore>::SourceTemplate<CryptoPP::StringStore>
; Function compile flags: /Odspy
;	COMDAT ??1Source@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Source@CryptoPP@@UAE@XZ PROC				; CryptoPP::Source::~Source, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
  00012	c9		 leave
  00013	c3		 ret	 0
??1Source@CryptoPP@@UAE@XZ ENDP				; CryptoPP::Source::~Source
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::~InputRejecting<CryptoPP::Filter>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
  00012	c9		 leave
  00013	c3		 ret	 0
??1?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE@XZ ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::~InputRejecting<CryptoPP::Filter>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?ChannelMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
?ChannelMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::ChannelMessageSeriesEnd, COMDAT
; _this$ = ecx

; 95   : 	bool ChannelMessageSeriesEnd(const std::string &, int, bool) {throw InputRejected();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00016	e8 00 00 00 00	 call	 ??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected
  0001b	68 00 00 00 00	 push	 OFFSET __TI4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
  00020	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@ChannelMes:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	c9		 leave
  00034	c2 0c 00	 ret	 12			; 0000000cH
?ChannelMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::ChannelMessageSeriesEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?ChannelPut2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_channel$ = 8						; size = 4
_begin$ = 12						; size = 4
_length$ = 16						; size = 4
_messageEnd$ = 20					; size = 4
_blocking$ = 24						; size = 1
?ChannelPut2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::ChannelPut2, COMDAT
; _this$ = ecx

; 94   : 		{throw InputRejected();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00016	e8 00 00 00 00	 call	 ??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected
  0001b	68 00 00 00 00	 push	 OFFSET __TI4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
  00020	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@ChannelPut:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	c9		 leave
  00034	c2 14 00	 ret	 20			; 00000014H
?ChannelPut2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::ChannelPut2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?IsolatedMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 1
?IsolatedMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N@Z PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::IsolatedMessageSeriesEnd, COMDAT
; _this$ = ecx

; 91   : 	bool IsolatedMessageSeriesEnd(bool) {throw InputRejected();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00016	e8 00 00 00 00	 call	 ??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected
  0001b	68 00 00 00 00	 push	 OFFSET __TI4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
  00020	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@IsolatedMe:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	c9		 leave
  00034	c2 04 00	 ret	 4
?IsolatedMessageSeriesEnd@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::IsolatedMessageSeriesEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?IsolatedFlush@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
?IsolatedFlush@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N0@Z PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::IsolatedFlush, COMDAT
; _this$ = ecx

; 90   : 	bool IsolatedFlush(bool, bool) {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c2 08 00	 ret	 8
?IsolatedFlush@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAE_N_N0@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::IsolatedFlush
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?Put2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_begin$ = 8						; size = 4
_length$ = 12						; size = 4
_messageEnd$ = 16					; size = 4
_blocking$ = 20						; size = 1
?Put2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z PROC ; CryptoPP::InputRejecting<CryptoPP::Filter>::Put2, COMDAT
; _this$ = ecx

; 89   : 		{throw InputRejected();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00016	e8 00 00 00 00	 call	 ??0InputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::Filter>::InputRejected::InputRejected
  0001b	68 00 00 00 00	 push	 OFFSET __TI4?AUInputRejected@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@
  00020	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Put2:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	c9		 leave
  00034	c2 10 00	 ret	 16			; 00000010H
?Put2@?$InputRejecting@VFilter@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::Filter>::Put2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z
_TEXT	SEGMENT
$T2 = -36						; size = 12
tv78 = -24						; size = 4
tv65 = -20						; size = 4
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_name$ = 12						; size = 4
_value$ = 16						; size = 4
_throwIfNotUsed$ = 20					; size = 1
??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z PROC ; CryptoPP::MakeParameters<CryptoPP::ConstByteArrayParameter>, COMDAT

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0

; 388  : 	return AlgorithmParameters()(name, value, throwIfNotUsed);

  00029	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  0002c	e8 00 00 00 00	 call	 ??0AlgorithmParameters@CryptoPP@@QAE@XZ ; CryptoPP::AlgorithmParameters::AlgorithmParameters
  00031	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00034	8b 45 ec	 mov	 eax, DWORD PTR tv65[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  0003a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	ff 75 14	 push	 DWORD PTR _throwIfNotUsed$[ebp]
  00041	ff 75 10	 push	 DWORD PTR _value$[ebp]
  00044	ff 75 0c	 push	 DWORD PTR _name$[ebp]
  00047	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  0004a	e8 00 00 00 00	 call	 ??$?RVConstByteArrayParameter@CryptoPP@@@AlgorithmParameters@CryptoPP@@QAEAAV01@PBDABVConstByteArrayParameter@1@_N@Z ; CryptoPP::AlgorithmParameters::operator()<CryptoPP::ConstByteArrayParameter>
  0004f	50		 push	 eax
  00050	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00053	e8 00 00 00 00	 call	 ??0AlgorithmParameters@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::AlgorithmParameters::AlgorithmParameters
  00058	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0005b	83 c8 01	 or	 eax, 1
  0005e	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  00061	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00065	8d 4d e0	 lea	 ecx, DWORD PTR $T2[ebp+4]
  00068	e8 00 00 00 00	 call	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 389  : }

  00070	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00073	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007a	59		 pop	 ecx
  0007b	c9		 leave
  0007c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1AlgorithmParameters@CryptoPP@@UAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z ENDP ; CryptoPP::MakeParameters<CryptoPP::ConstByteArrayParameter>
; Function compile flags: /Odspy
;	COMDAT ??_GStringStore@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GStringStore@CryptoPP@@UAEPAXI@Z PROC		; CryptoPP::StringStore::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000a	83 e0 01	 and	 eax, 1
  0000d	74 0c		 je	 SHORT $LN2@scalar
  0000f	6a 20		 push	 32			; 00000020H
  00011	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx
$LN2@scalar:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??_GStringStore@CryptoPP@@UAEPAXI@Z ENDP		; CryptoPP::StringStore::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ??0StringStore@CryptoPP@@QAE@PBD@Z
_TEXT	SEGMENT
$T2 = -68						; size = 24
$T3 = -44						; size = 12
tv140 = -32						; size = 4
tv185 = -28						; size = 4
tv138 = -24						; size = 4
tv192 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_string$ = 8						; size = 4
??0StringStore@CryptoPP@@QAE@PBD@Z PROC			; CryptoPP::StringStore::StringStore, COMDAT
; _this$ = ecx

; 669  : 	StringStore(const char *string = NULL)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0StringStore@CryptoPP@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 777  : 	BufferedTransformation() : Algorithm(false) {}

  00028	6a 00		 push	 0
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h

; 155  : 	AutoSignaling(int propagation=-1) : m_autoSignalPropagation(propagation) {}

  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 48 0c ff	 or	 DWORD PTR [eax+12], -1

; 170  : 	Store() : m_messageEnd(false) {}

  00039	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 669  : 	StringStore(const char *string = NULL)

  00040	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7StringStore@CryptoPP@@6BAlgorithm@1@@
  0004d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7StringStore@CryptoPP@@6BWaitable@1@@

; 670  : 		{StoreInitialize(MakeParameters("InputBuffer", ConstByteArrayParameter(string)));}

  00057	6a 00		 push	 0
  00059	ff 75 08	 push	 DWORD PTR _string$[ebp]
  0005c	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0005f	e8 00 00 00 00	 call	 ??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z ; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter
  00064	89 45 ec	 mov	 DWORD PTR tv192[ebp], eax
  00067	8b 45 ec	 mov	 eax, DWORD PTR tv192[ebp]
  0006a	89 45 e8	 mov	 DWORD PTR tv138[ebp], eax
  0006d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00071	6a 01		 push	 1
  00073	ff 75 e8	 push	 DWORD PTR tv138[ebp]
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_0M@JMHEFFAI@InputBuffer@
  0007b	8d 45 d4	 lea	 eax, DWORD PTR $T3[ebp]
  0007e	50		 push	 eax
  0007f	e8 00 00 00 00	 call	 ??$MakeParameters@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@YA?AVAlgorithmParameters@0@PBDABVConstByteArrayParameter@0@_N@Z ; CryptoPP::MakeParameters<CryptoPP::ConstByteArrayParameter>
  00084	83 c4 10	 add	 esp, 16			; 00000010H
  00087	89 45 e4	 mov	 DWORD PTR tv185[ebp], eax
  0008a	8b 45 e4	 mov	 eax, DWORD PTR tv185[ebp]
  0008d	89 45 e0	 mov	 DWORD PTR tv140[ebp], eax
  00090	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00094	ff 75 e0	 push	 DWORD PTR tv140[ebp]
  00097	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?StoreInitialize@StringStore@CryptoPP@@EAEXABVNameValuePairs@2@@Z ; CryptoPP::StringStore::StoreInitialize
  0009f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000a3	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp+4]
  000a6	e8 00 00 00 00	 call	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
  000ab	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000af	8d 4d c8	 lea	 ecx, DWORD PTR $T2[ebp+12]
  000b2	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  000b7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c8	59		 pop	 ecx
  000c9	c9		 leave
  000ca	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StringStore@CryptoPP@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1Store@CryptoPP@@UAE@XZ
__unwindfunclet$??0StringStore@CryptoPP@@QAE@PBD@Z$1:
  00008	8d 4d bc	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1ConstByteArrayParameter@CryptoPP@@QAE@XZ
__unwindfunclet$??0StringStore@CryptoPP@@QAE@PBD@Z$2:
  00010	8d 4d d4	 lea	 ecx, DWORD PTR $T3[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1AlgorithmParameters@CryptoPP@@UAE@XZ
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??0StringStore@CryptoPP@@QAE@PBD@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0StringStore@CryptoPP@@QAE@PBD@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0StringStore@CryptoPP@@QAE@PBD@Z ENDP			; CryptoPP::StringStore::StringStore
; Function compile flags: /Odspy
;	COMDAT ??_GArraySink@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GArraySink@CryptoPP@@UAEPAXI@Z PROC			; CryptoPP::ArraySink::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000a	83 e0 01	 and	 eax, 1
  0000d	74 0c		 je	 SHORT $LN2@scalar
  0000f	6a 20		 push	 32			; 00000020H
  00011	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx
$LN2@scalar:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??_GArraySink@CryptoPP@@UAEPAXI@Z ENDP			; CryptoPP::ArraySink::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000a	83 e0 01	 and	 eax, 1
  0000d	74 0c		 je	 SHORT $LN2@scalar
  0000f	6a 10		 push	 16			; 00000010H
  00011	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx
$LN2@scalar:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??_G?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?Put2@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEIPBEIH_N@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T1 = -40						; size = 4
__ULast$2 = -36						; size = 4
__Last$ = -32						; size = 4
__First$ = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__UFirst$4 = -12					; size = 4
_size$5 = -8						; size = 4
_this$ = -4						; size = 4
_begin$ = 8						; size = 4
_length$ = 12						; size = 4
_messageEnd$ = 16					; size = 4
_blocking$ = 20						; size = 1
?Put2@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEIPBEIH_N@Z PROC ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::Put2, COMDAT
; _this$ = ecx

; 598  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 599  : 		if (length > 0)

  00009	83 7d 0c 00	 cmp	 DWORD PTR _length$[ebp], 0
  0000d	0f 86 83 00 00
	00		 jbe	 $LN2@Put2

; 600  : 		{
; 601  : 			typename T::size_type size = m_output->size();

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00019	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  0001c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00022	89 45 f8	 mov	 DWORD PTR _size$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 602  : 			if (length < size && size + length > m_output->capacity())

  00025	8b 45 0c	 mov	 eax, DWORD PTR _length$[ebp]
  00028	3b 45 f8	 cmp	 eax, DWORD PTR _size$5[ebp]
  0002b	73 2e		 jae	 SHORT $LN3@Put2
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00033	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3793 :         return _Mypair._Myval2._Myres;

  00036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 602  : 			if (length < size && size + length > m_output->capacity())

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _size$5[ebp]
  00042	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  00045	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  00048	76 11		 jbe	 SHORT $LN3@Put2

; 603  : 				m_output->reserve(2*size);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _size$5[ebp]
  0004d	d1 e0		 shl	 eax, 1
  0004f	50		 push	 eax
  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00056	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
$LN3@Put2:

; 604  : 		m_output->append((const char_type *)begin, (const char_type *)begin+length);

  0005b	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]
  0005e	03 45 0c	 add	 eax, DWORD PTR _length$[ebp]
  00061	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00064	8b 45 08	 mov	 eax, DWORD PTR _begin$[ebp]
  00067	89 45 e4	 mov	 DWORD PTR __First$[ebp], eax
  0006a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00070	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2986 :         const auto _UFirst = _Get_unwrapped(_First);

  00073	8b 45 e4	 mov	 eax, DWORD PTR __First$[ebp]
  00076	89 45 f4	 mov	 DWORD PTR __UFirst$4[ebp], eax

; 2987 :         const auto _ULast  = _Get_unwrapped(_Last);

  00079	8b 45 e0	 mov	 eax, DWORD PTR __Last$[ebp]
  0007c	89 45 dc	 mov	 DWORD PTR __ULast$2[ebp], eax

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  0007f	8b 45 dc	 mov	 eax, DWORD PTR __ULast$2[ebp]
  00082	2b 45 f4	 sub	 eax, DWORD PTR __UFirst$4[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00085	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2989 :             return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));

  00088	ff 75 d8	 push	 DWORD PTR $T1[ebp]
  0008b	ff 75 f4	 push	 DWORD PTR __UFirst$4[ebp]
  0008e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Put2:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 606  : 		return 0;

  00096	33 c0		 xor	 eax, eax

; 607  : 	}

  00098	c9		 leave
  00099	c2 10 00	 ret	 16			; 00000010H
?Put2@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEIPBEIH_N@Z ENDP ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::Put2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T2 = -80						; size = 40
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_parameters$ = 8					; size = 4
?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z PROC ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::IsolatedInitialize, COMDAT
; _this$ = ecx

; 595  : 		{if (!parameters.GetValue("OutputStringPointer", m_output)) throw InvalidArgument("StringSink: OutputStringPointer not specified");}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 264  : 		return GetVoidValue(name, typeid(T), &value);

  00031	50		 push	 eax
  00032	68 00 00 00 00	 push	 OFFSET ??_R0PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@NDOICOBI@OutputStringPointer@
  0003c	8b 45 08	 mov	 eax, DWORD PTR _parameters$[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _parameters$[ebp]
  00044	ff 50 04	 call	 DWORD PTR [eax+4]
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 595  : 		{if (!parameters.GetValue("OutputStringPointer", m_output)) throw InvalidArgument("StringSink: OutputStringPointer not specified");}

  00047	0f b6 c0	 movzx	 eax, al
  0004a	85 c0		 test	 eax, eax
  0004c	75 37		 jne	 SHORT $LN3@IsolatedIn
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@DDPAKADP@StringSink?3?5OutputStringPointer@
  00053	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00056	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0005b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005f	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00062	50		 push	 eax
  00063	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00066	e8 00 00 00 00	 call	 ??0InvalidArgument@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::InvalidArgument::InvalidArgument
  0006b	68 00 00 00 00	 push	 OFFSET __TI3?AVInvalidArgument@CryptoPP@@
  00070	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 __CxxThrowException@8
  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0007d	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00080	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN3@IsolatedIn:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 595  : 		{if (!parameters.GetValue("OutputStringPointer", m_output)) throw InvalidArgument("StringSink: OutputStringPointer not specified");}

  00085	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00088	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008f	59		 pop	 ecx
  00090	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	c9		 leave
  0009b	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IsolatedInitialize@?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@UAEXABVNameValuePairs@2@@Z ENDP ; CryptoPP::StringSinkTemplate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::IsolatedInitialize
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
;	COMDAT ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
tv75 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ PROC ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>, COMDAT
; _this$ = ecx

; 49   : template <class T> member_ptr<T>::~member_ptr() {delete m_p;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00015	74 11		 je	 SHORT $LN3@member_ptr
  00017	6a 01		 push	 1
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00021	ff 10		 call	 DWORD PTR [eax]
  00023	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00026	eb 04		 jmp	 SHORT $LN2@member_ptr
$LN3@member_ptr:
  00028	83 65 f4 00	 and	 DWORD PTR tv75[ebp], 0
$LN2@member_ptr:
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?ShouldPropagateMessageSeriesEnd@Filter@CryptoPP@@MBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShouldPropagateMessageSeriesEnd@Filter@CryptoPP@@MBE_NXZ PROC ; CryptoPP::Filter::ShouldPropagateMessageSeriesEnd, COMDAT
; _this$ = ecx

; 39   : 	virtual bool ShouldPropagateMessageSeriesEnd() const {return true;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	c9		 leave
  0000a	c3		 ret	 0
?ShouldPropagateMessageSeriesEnd@Filter@CryptoPP@@MBE_NXZ ENDP ; CryptoPP::Filter::ShouldPropagateMessageSeriesEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?ShouldPropagateMessageEnd@Filter@CryptoPP@@MBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ShouldPropagateMessageEnd@Filter@CryptoPP@@MBE_NXZ PROC ; CryptoPP::Filter::ShouldPropagateMessageEnd, COMDAT
; _this$ = ecx

; 38   : 	virtual bool ShouldPropagateMessageEnd() const {return true;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	c9		 leave
  0000a	c3		 ret	 0
?ShouldPropagateMessageEnd@Filter@CryptoPP@@MBE_NXZ ENDP ; CryptoPP::Filter::ShouldPropagateMessageEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
;	COMDAT ?Attachable@Filter@CryptoPP@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Attachable@Filter@CryptoPP@@UAE_NXZ PROC		; CryptoPP::Filter::Attachable, COMDAT
; _this$ = ecx

; 22   : 	bool Attachable() {return true;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b0 01		 mov	 al, 1
  00009	c9		 leave
  0000a	c3		 ret	 0
?Attachable@Filter@CryptoPP@@UAE_NXZ ENDP		; CryptoPP::Filter::Attachable
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1AlgorithmParameters@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1AlgorithmParameters@CryptoPP@@UAE@XZ PROC		; CryptoPP::AlgorithmParameters::~AlgorithmParameters, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
  00012	c9		 leave
  00013	c3		 ret	 0
??1AlgorithmParameters@CryptoPP@@UAE@XZ ENDP		; CryptoPP::AlgorithmParameters::~AlgorithmParameters
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0000d	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??1AlgorithmParametersBase@CryptoPP@@UAE@XZ ; CryptoPP::AlgorithmParametersBase::~AlgorithmParametersBase
  0001a	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001d	83 e0 01	 and	 eax, 1
  00020	74 0c		 je	 SHORT $LN2@scalar
  00022	6a 28		 push	 40			; 00000028H
  00024	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002c	59		 pop	 ecx
  0002d	59		 pop	 ecx
$LN2@scalar:
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	c9		 leave
  00032	c2 04 00	 ret	 4
??_G?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z
_TEXT	SEGMENT
_p$ = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_buffer$ = 8						; size = 4
?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z PROC ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::MoveInto, COMDAT
; _this$ = ecx

; 321  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00028	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  0002e	ff 75 ec	 push	 DWORD PTR _this$[ebp]
  00031	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  00034	e8 00 00 00 00	 call	 ??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::AlgorithmParametersBase::AlgorithmParametersBase
  00039	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003d	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@6B@
  00046	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00049	83 c0 10	 add	 eax, 16			; 00000010H
  0004c	50		 push	 eax
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  00050	83 c1 10	 add	 ecx, 16			; 00000010H
  00053	e8 00 00 00 00	 call	 ??0ConstByteArrayParameter@CryptoPP@@QAE@ABV01@@Z
  00058	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 322  : 		AlgorithmParametersTemplate<T>* p = new(buffer) AlgorithmParametersTemplate<T>(*this);

  0005c	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005f	89 45 e8	 mov	 DWORD PTR _p$[ebp], eax

; 323  : 	}

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	c9		 leave
  0006e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z$1:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1AlgorithmParametersBase@CryptoPP@@UAE@XZ ; CryptoPP::AlgorithmParametersBase::~AlgorithmParametersBase
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?MoveInto@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPAX@Z ENDP ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::MoveInto
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ?AssignValue@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPBDABVtype_info@@PAX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv89 = -8						; size = 4
$T1 = -1						; size = 1
_name$ = 8						; size = 4
_valueType$ = 12					; size = 4
_pValue$ = 16						; size = 4
?AssignValue@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPBDABVtype_info@@PAX@Z PROC ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::AssignValue, COMDAT
; _this$ = ecx

; 311  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 313  : 		if (!(g_pAssignIntToInteger != NULL && typeid(T) == typeid(int) && g_pAssignIntToInteger(valueType, pValue, &m_value)))

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pAssignIntToInteger@CryptoPP@@3P6A_NABVtype_info@@PAXPBX@ZA, 0 ; CryptoPP::g_pAssignIntToInteger
  00010	74 4d		 je	 SHORT $LN3@AssignValu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h

; 83   :         return __std_type_info_compare(&_Data, &_Other._Data) == 0;

  00012	68 04 00 00 00	 push	 OFFSET ??_R0H@8+4
  00017	68 04 00 00 00	 push	 OFFSET ??_R0?AVConstByteArrayParameter@CryptoPP@@@8+4
  0001c	e8 00 00 00 00	 call	 ___std_type_info_compare
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax
  00025	75 09		 jne	 SHORT $LN7@AssignValu
  00027	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv89[ebp], 1
  0002e	eb 04		 jmp	 SHORT $LN8@AssignValu
$LN7@AssignValu:
  00030	83 65 f8 00	 and	 DWORD PTR tv89[ebp], 0
$LN8@AssignValu:
  00034	8a 45 f8	 mov	 al, BYTE PTR tv89[ebp]
  00037	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 313  : 		if (!(g_pAssignIntToInteger != NULL && typeid(T) == typeid(int) && g_pAssignIntToInteger(valueType, pValue, &m_value)))

  0003a	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0003e	85 c0		 test	 eax, eax
  00040	74 1d		 je	 SHORT $LN3@AssignValu
  00042	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00045	83 c0 10	 add	 eax, 16			; 00000010H
  00048	50		 push	 eax
  00049	ff 75 10	 push	 DWORD PTR _pValue$[ebp]
  0004c	ff 75 0c	 push	 DWORD PTR _valueType$[ebp]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR ?g_pAssignIntToInteger@CryptoPP@@3P6A_NABVtype_info@@PAXPBX@ZA ; CryptoPP::g_pAssignIntToInteger
  00055	83 c4 0c	 add	 esp, 12			; 0000000cH
  00058	0f b6 c0	 movzx	 eax, al
  0005b	85 c0		 test	 eax, eax
  0005d	75 22		 jne	 SHORT $LN1@AssignValu
$LN3@AssignValu:

; 314  : 		{
; 315  : 			NameValuePairs::ThrowIfTypeMismatch(name, typeid(T), valueType);

  0005f	ff 75 0c	 push	 DWORD PTR _valueType$[ebp]
  00062	68 00 00 00 00	 push	 OFFSET ??_R0?AVConstByteArrayParameter@CryptoPP@@@8
  00067	ff 75 08	 push	 DWORD PTR _name$[ebp]
  0006a	e8 00 00 00 00	 call	 ?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z ; CryptoPP::NameValuePairs::ThrowIfTypeMismatch
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 316  : 			*reinterpret_cast<T *>(pValue) = m_value;

  00072	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00075	83 c0 10	 add	 eax, 16			; 00000010H
  00078	50		 push	 eax
  00079	8b 4d 10	 mov	 ecx, DWORD PTR _pValue$[ebp]
  0007c	e8 00 00 00 00	 call	 ??4ConstByteArrayParameter@CryptoPP@@QAEAAV01@ABV01@@Z
$LN1@AssignValu:

; 317  : 		}
; 318  : 	}

  00081	c9		 leave
  00082	c2 0c 00	 ret	 12			; 0000000cH
?AssignValue@?$AlgorithmParametersTemplate@VConstByteArrayParameter@CryptoPP@@@CryptoPP@@UBEXPBDABVtype_info@@PAX@Z ENDP ; CryptoPP::AlgorithmParametersTemplate<CryptoPP::ConstByteArrayParameter>::AssignValue
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GAlgorithmParametersBase@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GAlgorithmParametersBase@CryptoPP@@UAEPAXI@Z PROC	; CryptoPP::AlgorithmParametersBase::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1AlgorithmParametersBase@CryptoPP@@UAE@XZ ; CryptoPP::AlgorithmParametersBase::~AlgorithmParametersBase
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 10		 push	 16			; 00000010H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GAlgorithmParametersBase@CryptoPP@@UAEPAXI@Z ENDP	; CryptoPP::AlgorithmParametersBase::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
;	COMDAT ?reset@?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAEXPAVAlgorithmParametersBase@2@@Z
_TEXT	SEGMENT
tv71 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_p$ = 8							; size = 4
?reset@?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAEXPAVAlgorithmParametersBase@2@@Z PROC ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::reset, COMDAT
; _this$ = ecx

; 50   : template <class T> void member_ptr<T>::reset(T *p) {delete m_p; m_p = p;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00015	74 11		 je	 SHORT $LN3@reset
  00017	6a 01		 push	 1
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00021	ff 10		 call	 DWORD PTR [eax]
  00023	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00026	eb 04		 jmp	 SHORT $LN4@reset
$LN3@reset:
  00028	83 65 f4 00	 and	 DWORD PTR tv71[ebp], 0
$LN4@reset:
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00032	89 08		 mov	 DWORD PTR [eax], ecx
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
?reset@?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAEXPAVAlgorithmParametersBase@2@@Z ENDP ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::reset
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
;	COMDAT ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
tv71 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ PROC ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>, COMDAT
; _this$ = ecx

; 49   : template <class T> member_ptr<T>::~member_ptr() {delete m_p;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00015	74 11		 je	 SHORT $LN3@member_ptr
  00017	6a 01		 push	 1
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	8b 00		 mov	 eax, DWORD PTR [eax]
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00021	ff 10		 call	 DWORD PTR [eax]
  00023	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00026	eb 04		 jmp	 SHORT $LN2@member_ptr
$LN3@member_ptr:
  00028	83 65 f4 00	 and	 DWORD PTR tv71[ebp], 0
$LN2@member_ptr:
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ??1AlgorithmParametersBase@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -60						; size = 4
$T2 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1AlgorithmParametersBase@CryptoPP@@UAE@XZ PROC	; CryptoPP::AlgorithmParametersBase::~AlgorithmParametersBase, COMDAT
; _this$ = ecx

; 269  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1AlgorithmParametersBase@CryptoPP@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7AlgorithmParametersBase@CryptoPP@@6B@

; 270  : #ifdef CRYPTOPP_UNCAUGHT_EXCEPTION_AVAILABLE
; 271  : 		if (!std::uncaught_exception())

  00034	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  00039	0f b6 c0	 movzx	 eax, al
  0003c	85 c0		 test	 eax, eax
  0003e	75 32		 jne	 SHORT $LN1@AlgorithmP

; 272  : #else
; 273  : 		try
; 274  : #endif
; 275  : 		{
; 276  : 			if (m_throwIfNotUsed && !m_used)

  00040	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00043	0f b6 40 08	 movzx	 eax, BYTE PTR [eax+8]
  00047	85 c0		 test	 eax, eax
  00049	74 27		 je	 SHORT $LN1@AlgorithmP
  0004b	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	0f b6 40 09	 movzx	 eax, BYTE PTR [eax+9]
  00052	85 c0		 test	 eax, eax
  00054	75 1c		 jne	 SHORT $LN1@AlgorithmP

; 277  : 				throw ParameterNotUsed(m_name);

  00056	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  00059	ff 70 04	 push	 DWORD PTR [eax+4]
  0005c	8d 4d c8	 lea	 ecx, DWORD PTR $T2[ebp]
  0005f	e8 00 00 00 00	 call	 ??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::ParameterNotUsed
  00064	68 00 00 00 00	 push	 OFFSET __TI3?AVParameterNotUsed@AlgorithmParametersBase@CryptoPP@@
  00069	8d 45 c8	 lea	 eax, DWORD PTR $T2[ebp]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1@AlgorithmP:

; 278  : 		}
; 279  : #ifndef CRYPTOPP_UNCAUGHT_EXCEPTION_AVAILABLE
; 280  : 		catch(...)
; 281  : 		{
; 282  : 		}
; 283  : #endif
; 284  : 	}

  00072	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00078	e8 00 00 00 00	 call	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
$LN4@AlgorithmP:
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008b	33 cd		 xor	 ecx, ebp
  0008d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00092	c9		 leave
  00093	c3		 ret	 0
  00094	cc		 int	 3
  00095	cc		 int	 3
  00096	cc		 int	 3
  00097	cc		 int	 3
  00098	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1AlgorithmParametersBase@CryptoPP@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00016	33 c8		 xor	 ecx, eax
  00018	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1AlgorithmParametersBase@CryptoPP@@UAE@XZ
  00022	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1AlgorithmParametersBase@CryptoPP@@UAE@XZ ENDP	; CryptoPP::AlgorithmParametersBase::~AlgorithmParametersBase
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_old_p$2 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_x$ = 8							; size = 4
??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z PROC	; CryptoPP::AlgorithmParametersBase::AlgorithmParametersBase, COMDAT
; _this$ = ecx

; 260  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7AlgorithmParametersBase@CryptoPP@@6B@

; 259  : 		: m_name(x.m_name), m_throwIfNotUsed(x.m_throwIfNotUsed), m_used(x.m_used)

  00031	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00037	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0003a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00043	8a 49 08	 mov	 cl, BYTE PTR [ecx+8]
  00046	88 48 08	 mov	 BYTE PTR [eax+8], cl
  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0004f	8a 49 09	 mov	 cl, BYTE PTR [ecx+9]
  00052	88 48 09	 mov	 BYTE PTR [eax+9], cl

; 260  : 	{

  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	83 c0 0c	 add	 eax, 12			; 0000000cH
  0005b	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h

; 20   : 	explicit member_ptr(T *p = NULL) : m_p(p) {}

  0005e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00061	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 260  : 	{

  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 261  : 		m_next.reset(const_cast<AlgorithmParametersBase &>(x).m_next.release());

  00068	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  0006b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0006e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\smartptr.h

; 35   : 		T *old_p = m_p;

  00071	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	89 45 e4	 mov	 DWORD PTR _old_p$2[ebp], eax

; 36   : 		m_p = 0;

  00079	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 20 00	 and	 DWORD PTR [eax], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 261  : 		m_next.reset(const_cast<AlgorithmParametersBase &>(x).m_next.release());

  0007f	ff 75 e4	 push	 DWORD PTR _old_p$2[ebp]
  00082	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00088	e8 00 00 00 00	 call	 ?reset@?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAEXPAVAlgorithmParametersBase@2@@Z ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::reset

; 262  : 		x.m_used = true;

  0008d	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00090	c6 40 09 01	 mov	 BYTE PTR [eax+9], 1

; 263  : 	}

  00094	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00098	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a5	59		 pop	 ecx
  000a6	c9		 leave
  000a7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1?$member_ptr@VAlgorithmParametersBase@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::AlgorithmParametersBase>::~member_ptr<CryptoPP::AlgorithmParametersBase>
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0AlgorithmParametersBase@CryptoPP@@QAE@ABV01@@Z ENDP	; CryptoPP::AlgorithmParametersBase::AlgorithmParametersBase
; Function compile flags: /Odspy
;	COMDAT ??_GParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 28		 push	 40			; 00000028H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z PROC ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::ParameterNotUsed, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@ABV01@@Z
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@ABV012@@Z ENDP ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::ParameterNotUsed
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAE@XZ PROC ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::~ParameterNotUsed, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	c9		 leave
  00010	c3		 ret	 0
??1ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@UAE@XZ ENDP ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::~ParameterNotUsed
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z
_TEXT	SEGMENT
tv136 = -116						; size = 4
tv173 = -112						; size = 4
tv134 = -108						; size = 4
tv77 = -104						; size = 4
tv132 = -100						; size = 4
tv69 = -96						; size = 4
_this$ = -92						; size = 4
$T2 = -88						; size = 24
$T3 = -64						; size = 24
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z PROC ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::ParameterNotUsed, COMDAT
; _this$ = ecx

; 254  : 		ParameterNotUsed(const char *name) : Exception(OTHER_ERROR, std::string("AlgorithmParametersBase: parameter \"") + name + "\" not used") {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@BLINCPFB@AlgorithmParametersBase?3?5parame@
  00030	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	89 45 a0	 mov	 DWORD PTR tv69[ebp], eax
  0003b	8b 45 a0	 mov	 eax, DWORD PTR tv69[ebp]
  0003e	89 45 9c	 mov	 DWORD PTR tv132[ebp], eax
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	ff 75 08	 push	 DWORD PTR _name$[ebp]
  00048	ff 75 9c	 push	 DWORD PTR tv132[ebp]
  0004b	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00054	83 c4 0c	 add	 esp, 12			; 0000000cH
  00057	89 45 98	 mov	 DWORD PTR tv77[ebp], eax
  0005a	8b 45 98	 mov	 eax, DWORD PTR tv77[ebp]
  0005d	89 45 94	 mov	 DWORD PTR tv134[ebp], eax
  00060	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0L@IAABKFFP@?$CC?5not?5used@
  00069	ff 75 94	 push	 DWORD PTR tv134[ebp]
  0006c	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH
  00078	89 45 90	 mov	 DWORD PTR tv173[ebp], eax
  0007b	8b 45 90	 mov	 eax, DWORD PTR tv173[ebp]
  0007e	89 45 8c	 mov	 DWORD PTR tv136[ebp], eax
  00081	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00085	ff 75 8c	 push	 DWORD PTR tv136[ebp]
  00088	6a 06		 push	 6
  0008a	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::Exception::Exception
  00092	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00096	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00099	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 254  : 		ParameterNotUsed(const char *name) : Exception(OTHER_ERROR, std::string("AlgorithmParametersBase: parameter \"") + name + "\" not used") {}

  0009e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000a2	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 254  : 		ParameterNotUsed(const char *name) : Exception(OTHER_ERROR, std::string("AlgorithmParametersBase: parameter \"") + name + "\" not used") {}

  000aa	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000ae	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 254  : 		ParameterNotUsed(const char *name) : Exception(OTHER_ERROR, std::string("AlgorithmParametersBase: parameter \"") + name + "\" not used") {}

  000b6	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@6B@
  000bf	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000cc	59		 pop	 ecx
  000cd	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d0	33 cd		 xor	 ecx, ebp
  000d2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000d7	c9		 leave
  000d8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z$0:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z$2:
  00010	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
  0001c	cc		 int	 3
__ehhandler$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z:
  0001d	90		 npad	 1
  0001e	90		 npad	 1
  0001f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00023	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00026	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00033	33 c8		 xor	 ecx, eax
  00035	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z
  0003f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ParameterNotUsed@AlgorithmParametersBase@CryptoPP@@QAE@PBD@Z ENDP ; CryptoPP::AlgorithmParametersBase::ParameterNotUsed::ParameterNotUsed
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??4ConstByteArrayParameter@CryptoPP@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ConstByteArrayParameter@CryptoPP@@QAEAAV01@ABV01@@Z PROC ; CryptoPP::ConstByteArrayParameter::operator=, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000e	8a 09		 mov	 cl, BYTE PTR [ecx]
  00010	88 08		 mov	 BYTE PTR [eax], cl
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00018	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001b	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00024	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00027	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00030	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
  00033	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00036	83 c0 0c	 add	 eax, 12			; 0000000cH

; 328  : 		Assign(t);

  00039	50		 push	 eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?Assign@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXABV12@@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::Assign
  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	c9		 leave
  00046	c2 04 00	 ret	 4
??4ConstByteArrayParameter@CryptoPP@@QAEAAV01@ABV01@@Z ENDP ; CryptoPP::ConstByteArrayParameter::operator=
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0ConstByteArrayParameter@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ConstByteArrayParameter@CryptoPP@@QAE@ABV01@@Z PROC	; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0000d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0000f	88 08		 mov	 BYTE PTR [eax], cl
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00017	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0001a	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00023	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00026	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00029	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0002c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002f	50		 push	 eax
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00036	e8 00 00 00 00	 call	 ??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c9		 leave
  0003f	c2 04 00	 ret	 4
??0ConstByteArrayParameter@CryptoPP@@QAE@ABV01@@Z ENDP	; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1ConstByteArrayParameter@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ConstByteArrayParameter@CryptoPP@@QAE@XZ PROC	; CryptoPP::ConstByteArrayParameter::~ConstByteArrayParameter, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0000d	e8 00 00 00 00	 call	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  00012	c9		 leave
  00013	c3		 ret	 0
??1ConstByteArrayParameter@CryptoPP@@QAE@XZ ENDP	; CryptoPP::ConstByteArrayParameter::~ConstByteArrayParameter
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ?New@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXI@Z
_TEXT	SEGMENT
_p$ = -12						; size = 4
_oldSize$ = -8						; size = 4
_this$ = -4						; size = 4
_newSize$ = 8						; size = 4
?New@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXI@Z PROC ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::New, COMDAT
; _this$ = ecx

; 362  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 363  : 		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f8	 mov	 DWORD PTR _oldSize$[ebp], eax
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	89 45 f4	 mov	 DWORD PTR _p$[ebp], eax

; 117  : 		return StandardReallocate(*this, p, oldSize, newSize, preserve);

  0001b	6a 00		 push	 0
  0001d	ff 75 08	 push	 DWORD PTR _newSize$[ebp]
  00020	ff 75 f8	 push	 DWORD PTR _oldSize$[ebp]
  00023	ff 75 f4	 push	 DWORD PTR _p$[ebp]
  00026	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ??$StandardReallocate@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@YAPAEAAV?$AllocatorWithCleanup@E$0A@@0@PAEII_N@Z ; CryptoPP::StandardReallocate<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0002e	83 c4 14	 add	 esp, 20			; 00000014H

; 363  : 		m_ptr = m_alloc.reallocate(m_ptr, m_size, newSize, false);

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 364  : 		m_size = newSize;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _newSize$[ebp]
  0003d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 365  : 	}

  00040	c9		 leave
  00041	c2 04 00	 ret	 4
?New@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXI@Z ENDP ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::New
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ?Assign@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t$ = 8							; size = 4
?Assign@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXABV12@@Z PROC ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::Assign, COMDAT
; _this$ = ecx

; 318  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  : 		if (this != &t)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	3b 45 08	 cmp	 eax, DWORD PTR _t$[ebp]
  0000d	74 2e		 je	 SHORT $LN1@Assign

; 320  : 		{
; 321  : 			New(t.m_size);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00012	ff 70 04	 push	 DWORD PTR [eax+4]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?New@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXI@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::New

; 322  : 			memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	ff 70 04	 push	 DWORD PTR [eax+4]
  00023	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00026	ff 70 08	 push	 DWORD PTR [eax+8]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	ff 70 08	 push	 DWORD PTR [eax+8]
  00035	e8 00 00 00 00	 call	 _memcpy_s
  0003a	83 c4 10	 add	 esp, 16			; 00000010H
$LN1@Assign:

; 323  : 		}
; 324  : 	}

  0003d	c9		 leave
  0003e	c2 04 00	 ret	 4
?Assign@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXABV12@@Z ENDP ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::Assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_n$ = -24						; size = 4
_this$ = -20						; size = 4
_p$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ PROC ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >, COMDAT
; _this$ = ecx

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	89 45 e8	 mov	 DWORD PTR _n$[ebp], eax
  00031	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00037	89 45 f0	 mov	 DWORD PTR _p$[ebp], eax

; 105  : 		SecureWipeArray((pointer)p, n);

  0003a	ff 75 e8	 push	 DWORD PTR _n$[ebp]
  0003d	ff 75 f0	 push	 DWORD PTR _p$[ebp]
  00040	e8 00 00 00 00	 call	 ??$SecureWipeArray@E@CryptoPP@@YAXPAEI@Z ; CryptoPP::SecureWipeArray<unsigned char>
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 106  : 
; 107  : #if CRYPTOPP_BOOL_ALIGN16_ENABLED
; 108  : 		if (T_Align16 && n*sizeof(T) >= 16)

  00047	33 c0		 xor	 eax, eax
  00049	74 0b		 je	 SHORT $LN4@SecBlock

; 109  : 			return AlignedDeallocate(p);

  0004b	ff 75 f0	 push	 DWORD PTR _p$[ebp]
  0004e	e8 00 00 00 00	 call	 ?AlignedDeallocate@CryptoPP@@YAXPAX@Z ; CryptoPP::AlignedDeallocate
  00053	59		 pop	 ecx
  00054	eb 09		 jmp	 SHORT $LN2@SecBlock
$LN4@SecBlock:

; 110  : #endif
; 111  : 
; 112  : 		UnalignedDeallocate(p);

  00056	ff 75 f0	 push	 DWORD PTR _p$[ebp]
  00059	e8 00 00 00 00	 call	 ?UnalignedDeallocate@CryptoPP@@YAXPAX@Z ; CryptoPP::UnalignedDeallocate
  0005e	59		 pop	 ecx
$LN2@SecBlock:

; 261  : 		{m_alloc.deallocate(m_ptr, m_size);}

  0005f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00062	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00069	59		 pop	 ecx
  0006a	c9		 leave
  0006b	c3		 ret	 0
  0006c	cc		 int	 3
  0006d	cc		 int	 3
  0006e	cc		 int	 3
  0006f	cc		 int	 3
  00070	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ENDP ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
_n$ = -8						; size = 4
_this$ = -4						; size = 4
_t$ = 8							; size = 4
??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z PROC ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >, COMDAT
; _this$ = ecx

; 248  : 	SecBlock(const SecBlock<T, A> &t)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0000f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00012	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 91   : 		CheckSize(n);

  0001e	ff 75 f8	 push	 DWORD PTR _n$[ebp]
  00021	e8 00 00 00 00	 call	 ?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z ; CryptoPP::AllocatorBase<unsigned char>::CheckSize
  00026	59		 pop	 ecx

; 92   : 		if (n == 0)

  00027	83 7d f8 00	 cmp	 DWORD PTR _n$[ebp], 0
  0002b	75 06		 jne	 SHORT $LN6@SecBlock

; 93   : 			return NULL;

  0002d	83 65 f4 00	 and	 DWORD PTR $T1[ebp], 0
  00031	eb 1e		 jmp	 SHORT $LN5@SecBlock
$LN6@SecBlock:

; 94   : 
; 95   : #if CRYPTOPP_BOOL_ALIGN16_ENABLED
; 96   : 		if (T_Align16 && n*sizeof(T) >= 16)

  00033	33 c0		 xor	 eax, eax
  00035	74 0e		 je	 SHORT $LN7@SecBlock

; 97   : 			return (pointer)AlignedAllocate(n*sizeof(T));

  00037	ff 75 f8	 push	 DWORD PTR _n$[ebp]
  0003a	e8 00 00 00 00	 call	 ?AlignedAllocate@CryptoPP@@YAPAXI@Z ; CryptoPP::AlignedAllocate
  0003f	59		 pop	 ecx
  00040	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00043	eb 0c		 jmp	 SHORT $LN5@SecBlock
$LN7@SecBlock:

; 98   : #endif
; 99   : 
; 100  : 		return (pointer)UnalignedAllocate(n*sizeof(T));

  00045	ff 75 f8	 push	 DWORD PTR _n$[ebp]
  00048	e8 00 00 00 00	 call	 ?UnalignedAllocate@CryptoPP@@YAPAXI@Z ; CryptoPP::UnalignedAllocate
  0004d	59		 pop	 ecx
  0004e	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN5@SecBlock:

; 249  : 		: m_size(t.m_size) {m_ptr = m_alloc.allocate(m_size, NULL); memcpy_s(m_ptr, m_size*sizeof(T), t.m_ptr, m_size*sizeof(T));}

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00057	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	ff 70 04	 push	 DWORD PTR [eax+4]
  00060	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00063	ff 70 08	 push	 DWORD PTR [eax+8]
  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	ff 70 04	 push	 DWORD PTR [eax+4]
  0006c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	ff 70 08	 push	 DWORD PTR [eax+8]
  00072	e8 00 00 00 00	 call	 _memcpy_s
  00077	83 c4 10	 add	 esp, 16			; 00000010H
  0007a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	c9		 leave
  0007e	c2 04 00	 ret	 4
??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@ABV01@@Z ENDP ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_size$ = 8						; size = 4
??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z PROC ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >, COMDAT
; _this$ = ecx

; 246  : 	explicit SecBlock(size_type size=0)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  0000e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 91   : 		CheckSize(n);

  00011	ff 75 08	 push	 DWORD PTR _size$[ebp]
  00014	e8 00 00 00 00	 call	 ?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z ; CryptoPP::AllocatorBase<unsigned char>::CheckSize
  00019	59		 pop	 ecx

; 92   : 		if (n == 0)

  0001a	83 7d 08 00	 cmp	 DWORD PTR _size$[ebp], 0
  0001e	75 06		 jne	 SHORT $LN6@SecBlock

; 93   : 			return NULL;

  00020	83 65 fc 00	 and	 DWORD PTR $T1[ebp], 0
  00024	eb 1e		 jmp	 SHORT $LN5@SecBlock
$LN6@SecBlock:

; 94   : 
; 95   : #if CRYPTOPP_BOOL_ALIGN16_ENABLED
; 96   : 		if (T_Align16 && n*sizeof(T) >= 16)

  00026	33 c0		 xor	 eax, eax
  00028	74 0e		 je	 SHORT $LN7@SecBlock

; 97   : 			return (pointer)AlignedAllocate(n*sizeof(T));

  0002a	ff 75 08	 push	 DWORD PTR _size$[ebp]
  0002d	e8 00 00 00 00	 call	 ?AlignedAllocate@CryptoPP@@YAPAXI@Z ; CryptoPP::AlignedAllocate
  00032	59		 pop	 ecx
  00033	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00036	eb 0c		 jmp	 SHORT $LN5@SecBlock
$LN7@SecBlock:

; 98   : #endif
; 99   : 
; 100  : 		return (pointer)UnalignedAllocate(n*sizeof(T));

  00038	ff 75 08	 push	 DWORD PTR _size$[ebp]
  0003b	e8 00 00 00 00	 call	 ?UnalignedAllocate@CryptoPP@@YAPAXI@Z ; CryptoPP::UnalignedAllocate
  00040	59		 pop	 ecx
  00041	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
$LN5@SecBlock:

; 247  : 		: m_size(size) {m_ptr = m_alloc.allocate(size, NULL);}

  00044	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0004a	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	c9		 leave
  00051	c2 04 00	 ret	 4
??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ENDP ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ?Assign@ConstByteArrayParameter@CryptoPP@@QAEXPBEI_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_data$ = 8						; size = 4
_size$ = 12						; size = 4
_deepCopy$ = 16						; size = 1
?Assign@ConstByteArrayParameter@CryptoPP@@QAEXPBEI_N@Z PROC ; CryptoPP::ConstByteArrayParameter::Assign, COMDAT
; _this$ = ecx

; 31   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 32   : 		if (deepCopy)

  00008	0f b6 45 10	 movzx	 eax, BYTE PTR _deepCopy$[ebp]
  0000c	85 c0		 test	 eax, eax
  0000e	74 30		 je	 SHORT $LN2@Assign

; 33   : 			m_block.Assign(data, size);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 0c	 add	 eax, 12			; 0000000cH
  00016	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 312  : 		New(len);

  00019	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?New@?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAEXI@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::New

; 313  : 		memcpy_s(m_ptr, m_size*sizeof(T), t, len*sizeof(T));

  00024	ff 75 0c	 push	 DWORD PTR _size$[ebp]
  00027	ff 75 08	 push	 DWORD PTR _data$[ebp]
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	ff 70 04	 push	 DWORD PTR [eax+4]
  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	ff 70 08	 push	 DWORD PTR [eax+8]
  00036	e8 00 00 00 00	 call	 _memcpy_s
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h

; 33   : 			m_block.Assign(data, size);

  0003e	eb 12		 jmp	 SHORT $LN3@Assign
$LN2@Assign:

; 34   : 		else
; 35   : 		{
; 36   : 			m_data = data;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00046	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 37   : 			m_size = size;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0004f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
$LN3@Assign:

; 38   : 		}
; 39   : 		m_deepCopy = deepCopy;

  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8a 4d 10	 mov	 cl, BYTE PTR _deepCopy$[ebp]
  00058	88 08		 mov	 BYTE PTR [eax], cl

; 40   : 	}

  0005a	c9		 leave
  0005b	c2 0c 00	 ret	 12			; 0000000cH
?Assign@ConstByteArrayParameter@CryptoPP@@QAEXPBEI_N@Z ENDP ; CryptoPP::ConstByteArrayParameter::Assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\algparam.h
;	COMDAT ??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z
_TEXT	SEGMENT
tv75 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_data$ = 8						; size = 4
_deepCopy$ = 12						; size = 1
??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z PROC	; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter, COMDAT
; _this$ = ecx

; 16   : 	ConstByteArrayParameter(const char *data = NULL, bool deepCopy = false)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00027	6a 00		 push	 0
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0002f	e8 00 00 00 00	 call	 ??0?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@I@Z ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  00034	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 17   : 	{
; 18   : 		Assign((const byte *)data, data ? strlen(data) : 0, deepCopy);

  00038	83 7d 08 00	 cmp	 DWORD PTR _data$[ebp], 0
  0003c	74 0e		 je	 SHORT $LN3@ConstByteA
  0003e	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00041	e8 00 00 00 00	 call	 _strlen
  00046	59		 pop	 ecx
  00047	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0004a	eb 04		 jmp	 SHORT $LN4@ConstByteA
$LN3@ConstByteA:
  0004c	83 65 ec 00	 and	 DWORD PTR tv75[ebp], 0
$LN4@ConstByteA:
  00050	ff 75 0c	 push	 DWORD PTR _deepCopy$[ebp]
  00053	ff 75 ec	 push	 DWORD PTR tv75[ebp]
  00056	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00059	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?Assign@ConstByteArrayParameter@CryptoPP@@QAEXPBEI_N@Z ; CryptoPP::ConstByteArrayParameter::Assign

; 19   : 	}

  00061	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00065	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00072	59		 pop	 ecx
  00073	c9		 leave
  00074	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00006	e9 00 00 00 00	 jmp	 ??1?$SecBlock@EV?$AllocatorWithCleanup@E$0A@@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >::~SecBlock<unsigned char,CryptoPP::AllocatorWithCleanup<unsigned char,0> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ConstByteArrayParameter@CryptoPP@@QAE@PBD_N@Z ENDP	; CryptoPP::ConstByteArrayParameter::ConstByteArrayParameter
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??0?$unordered_map@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
??0?$unordered_map@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ PROC ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> > >::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> > >, COMDAT
; _this$ = ecx

; 1510 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1508 :         : table_(boost::unordered::detail::default_bucket_count, hasher(),

  00008	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  0000b	50		 push	 eax
  0000c	8d 45 fe	 lea	 eax, DWORD PTR $T2[ebp]
  0000f	50		 push	 eax
  00010	8d 45 fd	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	6a 0b		 push	 11			; 0000000bH
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> >,unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> >,unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long> > >

; 1511 :     }

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	c9		 leave
  00022	c3		 ret	 0
??0?$unordered_map@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ENDP ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> > >::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_which$ = -16						; size = 1
__$EHRec$ = -12						; size = 12
_num_buckets$ = 8					; size = 4
_hf$ = 12						; size = 4
_eq$ = 16						; size = 4
_a$ = 20						; size = 4
??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> >,unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> >,unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long> > >, COMDAT
; _this$ = ecx

; 3123 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2761 :         functions(H const& hf, P const& eq) : current_(0)

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2762 :         {
; 2763 :           construct_functions(current_, hf, eq);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8a 00		 mov	 al, BYTE PTR [eax]
  00033	88 45 f0	 mov	 BYTE PTR _which$[ebp], al

; 2827 :           new ((void*)&funcs_[which]) function_pair(hf, eq);

  00036	0f b6 45 f0	 movzx	 eax, BYTE PTR _which$[ebp]
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00041	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3120 :             : functions(hf, eq), allocators_(a, a),

  00044	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2609 :           return boost::unordered::detail::next_prime(min);

  00048	ff 75 08	 push	 DWORD PTR _num_buckets$[ebp]
  0004b	e8 00 00 00 00	 call	 ?next_prime@detail@unordered@boost@@YAII@Z ; boost::unordered::detail::next_prime
  00050	59		 pop	 ecx

; 3121 :               bucket_count_(policy::new_bucket_count(num_buckets)), size_(0),

  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00057	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 3122 :               mlf_(1.0f), max_load_(0), buckets_()

  0005e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00061	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00069	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 3124 :         }

  0007c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	c9		 leave
  0008f	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::~functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> >,unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> >,unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long> > >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ PROC ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >::~unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >, COMDAT
; _this$ = ecx

; 1645 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3333 :         ~table() { delete_buckets(); }

  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
  00032	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1646 :     }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	c9		 leave
  00042	c3		 ret	 0
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ENDP ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >::~unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??0?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
??0?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ PROC ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >, COMDAT
; _this$ = ecx

; 1510 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1508 :         : table_(boost::unordered::detail::default_bucket_count, hasher(),

  00008	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  0000b	50		 push	 eax
  0000c	8d 45 fe	 lea	 eax, DWORD PTR $T2[ebp]
  0000f	50		 push	 eax
  00010	8d 45 fd	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	6a 0b		 push	 11			; 0000000bH
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >

; 1511 :     }

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	c9		 leave
  00022	c3		 ret	 0
??0?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ENDP ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Ptr$ = -20						; size = 4
__Count$ = -16						; size = 4
_end$ = -12						; size = 4
_it$2 = -8						; size = 4
_this$ = -4						; size = 4
?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets, COMDAT
; _this$ = ecx

; 3370 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00015	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 3371 :           bucket_pointer end = get_bucket_pointer(bucket_count_ + 1);

  00019	89 45 f4	 mov	 DWORD PTR _end$[ebp], eax

; 3372 :           for (bucket_pointer it = buckets_; it != end; ++it) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00022	89 45 f8	 mov	 DWORD PTR _it$2[ebp], eax
  00025	eb 09		 jmp	 SHORT $LN4@destroy_bu
$LN2@destroy_bu:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  0002a	83 c0 04	 add	 eax, 4
  0002d	89 45 f8	 mov	 DWORD PTR _it$2[ebp], eax
$LN4@destroy_bu:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  00033	3b 45 f4	 cmp	 eax, DWORD PTR _end$[ebp]
  00036	74 08		 je	 SHORT $LN13@destroy_bu
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  0003b	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3374 :           }

  0003e	eb e7		 jmp	 SHORT $LN2@destroy_bu
$LN13@destroy_bu:

; 3375 : 
; 3376 :           bucket_allocator_traits::deallocate(

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00046	40		 inc	 eax
  00047	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	c1 e0 02	 shl	 eax, 2
  00059	50		 push	 eax
  0005a	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3378 :         }

  00064	c9		 leave
  00065	c3		 ret	 0
?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_next$2 = -24						; size = 4
_next$3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
_n$5 = -8						; size = 4
_this$ = -4						; size = 4
?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets, COMDAT
; _this$ = ecx

; 3344 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3345 :           if (buckets_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	0f 84 91 00 00
	00		 je	 $LN1@delete_buc

; 3346 :             node_pointer n = static_cast<node_pointer>(

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00022	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00025	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax

; 3347 :               get_bucket_pointer(bucket_count_)->next_);
; 3348 : 
; 3349 :             if (bucket::extra_node) {

  00028	33 c0		 xor	 eax, eax
  0002a	74 3d		 je	 SHORT $LN2@delete_buc

; 2964 :           return static_cast<node_pointer>(n->next_);

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 45 ec	 mov	 DWORD PTR _next$3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  00037	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c0 03	 add	 eax, 3
  00040	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00043	74 09		 je	 SHORT $LN20@delete_buc
  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00048	40		 inc	 eax
  00049	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004c	eb 04		 jmp	 SHORT $LN16@delete_buc
$LN20@delete_buc:
  0004e	83 65 f0 00	 and	 DWORD PTR $T4[ebp], 0
$LN16@delete_buc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00052	33 c0		 xor	 eax, eax
  00054	40		 inc	 eax
  00055	6b c0 2c	 imul	 eax, eax, 44
  00058	50		 push	 eax
  00059	ff 75 f8	 push	 DWORD PTR _n$5[ebp]
  0005c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00061	59		 pop	 ecx
  00062	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3353 :               n = next;

  00063	8b 45 ec	 mov	 eax, DWORD PTR _next$3[ebp]
  00066	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax
$LN2@delete_buc:

; 3354 :             }
; 3355 : 
; 3356 :             while (n) {

  00069	83 7d f8 00	 cmp	 DWORD PTR _n$5[ebp], 0
  0006d	74 1b		 je	 SHORT $LN3@delete_buc

; 2964 :           return static_cast<node_pointer>(n->next_);

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	89 45 e8	 mov	 DWORD PTR _next$2[ebp], eax

; 3357 :               node_pointer next = next_node(n);
; 3358 :               destroy_node(n);

  00077	ff 75 f8	 push	 DWORD PTR _n$5[ebp]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node

; 3359 :               n = next;

  00082	8b 45 e8	 mov	 eax, DWORD PTR _next$2[ebp]
  00085	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax

; 3360 :             }

  00088	eb df		 jmp	 SHORT $LN2@delete_buc
$LN3@delete_buc:

; 3361 : 
; 3362 :             destroy_buckets();

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets

; 3363 :             buckets_ = bucket_pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 3364 :             max_load_ = 0;

  00099	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 3365 :             size_ = 0;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LN1@delete_buc:

; 3366 :           }
; 3367 :         }

  000a7	c9		 leave
  000a8	c3		 ret	 0
?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@234@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node, COMDAT
; _this$ = ecx

; 3336 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 03	 add	 eax, 3
  0000f	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00012	74 09		 je	 SHORT $LN11@destroy_no
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	40		 inc	 eax
  00018	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0001b	eb 04		 jmp	 SHORT $LN15@destroy_no
$LN11@destroy_no:
  0001d	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0
$LN15@destroy_no:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00021	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00024	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 03	 add	 eax, 3
  0002d	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00030	74 09		 je	 SHORT $LN26@destroy_no
  00032	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00035	40		 inc	 eax
  00036	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00039	eb 04		 jmp	 SHORT $LN22@destroy_no
$LN26@destroy_no:
  0003b	83 65 ec 00	 and	 DWORD PTR $T2[ebp], 0
$LN22@destroy_no:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0003f	33 c0		 xor	 eax, eax
  00041	40		 inc	 eax
  00042	6b c0 2c	 imul	 eax, eax, 44
  00045	50		 push	 eax
  00046	ff 75 08	 push	 DWORD PTR _n$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0004e	59		 pop	 ecx
  0004f	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3341 :         }

  00050	c9		 leave
  00051	c2 04 00	 ret	 4
?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_which$ = -16						; size = 1
__$EHRec$ = -12						; size = 12
_num_buckets$ = 8					; size = 4
_hf$ = 12						; size = 4
_eq$ = 16						; size = 4
_a$ = 20						; size = 4
??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >, COMDAT
; _this$ = ecx

; 3123 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2761 :         functions(H const& hf, P const& eq) : current_(0)

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2762 :         {
; 2763 :           construct_functions(current_, hf, eq);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8a 00		 mov	 al, BYTE PTR [eax]
  00033	88 45 f0	 mov	 BYTE PTR _which$[ebp], al

; 2827 :           new ((void*)&funcs_[which]) function_pair(hf, eq);

  00036	0f b6 45 f0	 movzx	 eax, BYTE PTR _which$[ebp]
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00041	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3120 :             : functions(hf, eq), allocators_(a, a),

  00044	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2609 :           return boost::unordered::detail::next_prime(min);

  00048	ff 75 08	 push	 DWORD PTR _num_buckets$[ebp]
  0004b	e8 00 00 00 00	 call	 ?next_prime@detail@unordered@boost@@YAII@Z ; boost::unordered::detail::next_prime
  00050	59		 pop	 ecx

; 3121 :               bucket_count_(policy::new_bucket_count(num_buckets)), size_(0),

  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00057	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 3122 :               mlf_(1.0f), max_load_(0), buckets_()

  0005e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00061	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00069	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 3124 :         }

  0007c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	c9		 leave
  0008f	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::~functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$table@U?$map@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@std@@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@detail@unordered@boost@@@6@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> >,unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long> > >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h
;	COMDAT ?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z
_TEXT	SEGMENT
$T2 = -80						; size = 40
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_n$ = 8							; size = 4
?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z PROC	; CryptoPP::AllocatorBase<unsigned char>::CheckSize, COMDAT

; 38   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 39   : 		if (n > ~size_t(0) / sizeof(T))

  00028	83 7d 08 ff	 cmp	 DWORD PTR _n$[ebp], -1
  0002c	76 37		 jbe	 SHORT $LN3@CheckSize

; 40   : 			throw InvalidArgument("AllocatorBase: requested size would cause integer overflow");

  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@LFCPKOMM@AllocatorBase?3?5requested?5size?5w@
  00033	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00036	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00042	50		 push	 eax
  00043	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00046	e8 00 00 00 00	 call	 ??0InvalidArgument@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::InvalidArgument::InvalidArgument
  0004b	68 00 00 00 00	 push	 OFFSET __TI3?AVInvalidArgument@CryptoPP@@
  00050	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 __CxxThrowException@8
  00059	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0005d	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00060	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN3@CheckSize:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\secblock.h

; 41   : 	}

  00065	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006f	59		 pop	 ecx
  00070	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00073	33 cd		 xor	 ecx, ebp
  00075	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007a	c9		 leave
  0007b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?CheckSize@?$AllocatorBase@E@CryptoPP@@KAXI@Z ENDP	; CryptoPP::AllocatorBase<unsigned char>::CheckSize
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?IsolatedFlush@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@UAE_N_N0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_hardFlush$ = 8						; size = 1
_blocking$ = 12						; size = 1
?IsolatedFlush@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@UAE_N_N0@Z PROC ; CryptoPP::Bufferless<CryptoPP::Sink>::IsolatedFlush, COMDAT
; _this$ = ecx

; 52   : 	bool IsolatedFlush(bool hardFlush, bool blocking) {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c2 08 00	 ret	 8
?IsolatedFlush@?$Bufferless@VSink@CryptoPP@@@CryptoPP@@UAE_N_N0@Z ENDP ; CryptoPP::Bufferless<CryptoPP::Sink>::IsolatedFlush
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?CopyRangeTo2@Sink@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_target$ = 8						; size = 4
_begin$ = 12						; size = 4
_end$ = 16						; size = 8
_channel$ = 24						; size = 4
_blocking$ = 28						; size = 1
?CopyRangeTo2@Sink@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; CryptoPP::Sink::CopyRangeTo2, COMDAT
; _this$ = ecx

; 195  : 		{return 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c2 18 00	 ret	 24			; 00000018H
?CopyRangeTo2@Sink@CryptoPP@@UBEIAAVBufferedTransformation@2@AA_K_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; CryptoPP::Sink::CopyRangeTo2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?TransferTo2@Sink@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_target$ = 8						; size = 4
_transferBytes$ = 12					; size = 4
_channel$ = 16						; size = 4
_blocking$ = 20						; size = 1
?TransferTo2@Sink@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; CryptoPP::Sink::TransferTo2, COMDAT
; _this$ = ecx

; 193  : 		{transferBytes = 0; return 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _transferBytes$[ebp]
  0000a	33 c9		 xor	 ecx, ecx
  0000c	33 d2		 xor	 edx, edx
  0000e	89 08		 mov	 DWORD PTR [eax], ecx
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00013	33 c0		 xor	 eax, eax
  00015	c9		 leave
  00016	c2 10 00	 ret	 16			; 00000010H
?TransferTo2@Sink@CryptoPP@@UAEIAAVBufferedTransformation@2@AA_KABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; CryptoPP::Sink::TransferTo2
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1Store@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Store@CryptoPP@@UAE@XZ PROC				; CryptoPP::Store::~Store, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1Store@CryptoPP@@UAE@XZ ENDP				; CryptoPP::Store::~Store
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?NumberOfMessages@Store@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?NumberOfMessages@Store@CryptoPP@@UBEIXZ PROC		; CryptoPP::Store::NumberOfMessages, COMDAT
; _this$ = ecx

; 178  : 	unsigned int NumberOfMessages() const {return m_messageEnd ? 0 : 1;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	0f b6 40 10	 movzx	 eax, BYTE PTR [eax+16]
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN3@NumberOfMe
  00013	83 65 fc 00	 and	 DWORD PTR tv67[ebp], 0
  00017	eb 07		 jmp	 SHORT $LN4@NumberOfMe
$LN3@NumberOfMe:
  00019	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
$LN4@NumberOfMe:
  00020	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  00023	c9		 leave
  00024	c3		 ret	 0
?NumberOfMessages@Store@CryptoPP@@UBEIXZ ENDP		; CryptoPP::Store::NumberOfMessages
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?IsolatedInitialize@Store@CryptoPP@@UAEXABVNameValuePairs@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_parameters$ = 8					; size = 4
?IsolatedInitialize@Store@CryptoPP@@UAEXABVNameValuePairs@2@@Z PROC ; CryptoPP::Store::IsolatedInitialize, COMDAT
; _this$ = ecx

; 173  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 174  : 		m_messageEnd = false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 40 10 00	 mov	 BYTE PTR [eax+16], 0

; 175  : 		StoreInitialize(parameters);

  0000e	ff 75 08	 push	 DWORD PTR _parameters$[ebp]
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	ff 90 b0 00 00
	00		 call	 DWORD PTR [eax+176]

; 176  : 	}

  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
?IsolatedInitialize@Store@CryptoPP@@UAEXABVNameValuePairs@2@@Z ENDP ; CryptoPP::Store::IsolatedInitialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?GetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UBEHXZ PROC ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::GetAutoSignalPropagation, COMDAT
; _this$ = ecx

; 160  : 		{return m_autoSignalPropagation;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UBEHXZ ENDP ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::GetAutoSignalPropagation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?SetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_propagation$ = 8					; size = 4
?SetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UAEXH@Z PROC ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::SetAutoSignalPropagation, COMDAT
; _this$ = ecx

; 158  : 		{m_autoSignalPropagation = propagation;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _propagation$[ebp]
  0000d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetAutoSignalPropagation@?$AutoSignaling@V?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@@CryptoPP@@UAEXH@Z ENDP ; CryptoPP::AutoSignaling<CryptoPP::InputRejecting<CryptoPP::BufferedTransformation> >::SetAutoSignalPropagation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?ChannelMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
?ChannelMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::ChannelMessageSeriesEnd, COMDAT
; _this$ = ecx

; 95   : 	bool ChannelMessageSeriesEnd(const std::string &, int, bool) {throw InputRejected();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00016	e8 00 00 00 00	 call	 ??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected
  0001b	68 00 00 00 00	 push	 OFFSET __TI4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
  00020	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@ChannelMes:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	c9		 leave
  00034	c2 0c 00	 ret	 12			; 0000000cH
?ChannelMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H_N@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::ChannelMessageSeriesEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?ChannelPut2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_channel$ = 8						; size = 4
_begin$ = 12						; size = 4
_length$ = 16						; size = 4
_messageEnd$ = 20					; size = 4
_blocking$ = 24						; size = 1
?ChannelPut2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::ChannelPut2, COMDAT
; _this$ = ecx

; 94   : 		{throw InputRejected();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00016	e8 00 00 00 00	 call	 ??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected
  0001b	68 00 00 00 00	 push	 OFFSET __TI4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
  00020	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@ChannelPut:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	c9		 leave
  00034	c2 14 00	 ret	 20			; 00000014H
?ChannelPut2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEIH_N@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::ChannelPut2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?IsolatedMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
___formal$ = 8						; size = 1
?IsolatedMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N@Z PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::IsolatedMessageSeriesEnd, COMDAT
; _this$ = ecx

; 91   : 	bool IsolatedMessageSeriesEnd(bool) {throw InputRejected();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00016	e8 00 00 00 00	 call	 ??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected
  0001b	68 00 00 00 00	 push	 OFFSET __TI4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
  00020	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@IsolatedMe:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	c9		 leave
  00034	c2 04 00	 ret	 4
?IsolatedMessageSeriesEnd@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::IsolatedMessageSeriesEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?IsolatedFlush@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
___formal$ = 12						; size = 1
?IsolatedFlush@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N0@Z PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::IsolatedFlush, COMDAT
; _this$ = ecx

; 90   : 	bool IsolatedFlush(bool, bool) {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c2 08 00	 ret	 8
?IsolatedFlush@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAE_N_N0@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::IsolatedFlush
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\simple.h
;	COMDAT ?Put2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T1 = -44						; size = 40
__$ArrayPad$ = -4					; size = 4
_begin$ = 8						; size = 4
_length$ = 12						; size = 4
_messageEnd$ = 16					; size = 4
_blocking$ = 20						; size = 1
?Put2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z PROC ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::Put2, COMDAT
; _this$ = ecx

; 89   : 		{throw InputRejected();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 4d d4	 lea	 ecx, DWORD PTR $T1[ebp]
  00016	e8 00 00 00 00	 call	 ??0InputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::InputRejected::InputRejected
  0001b	68 00 00 00 00	 push	 OFFSET __TI4?AUInputRejected@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@
  00020	8d 45 d4	 lea	 eax, DWORD PTR $T1[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Put2:
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0002c	33 cd		 xor	 ecx, ebp
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	c9		 leave
  00034	c2 10 00	 ret	 16			; 00000010H
?Put2@?$InputRejecting@VBufferedTransformation@CryptoPP@@@CryptoPP@@UAEIPBEIH_N@Z ENDP ; CryptoPP::InputRejecting<CryptoPP::BufferedTransformation>::Put2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\misc.h
;	COMDAT ?IsAlignedOn@CryptoPP@@YA_NPBXI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
tv79 = -20						; size = 4
tv77 = -16						; size = 4
tv73 = -12						; size = 4
tv74 = -8						; size = 4
tv85 = -4						; size = 4
_p$ = 8							; size = 4
_alignment$ = 12					; size = 4
?IsAlignedOn@CryptoPP@@YA_NPBXI@Z PROC			; CryptoPP::IsAlignedOn, COMDAT

; 382  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 383  : 	return alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);

  00006	83 7d 0c 01	 cmp	 DWORD PTR _alignment$[ebp], 1
  0000a	74 73		 je	 SHORT $LN9@IsAlignedO

; 335  : 	return n > 0 && (n & (n-1)) == 0;

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _alignment$[ebp], 0
  00010	76 12		 jbe	 SHORT $LN13@IsAlignedO
  00012	8b 45 0c	 mov	 eax, DWORD PTR _alignment$[ebp]
  00015	48		 dec	 eax
  00016	23 45 0c	 and	 eax, DWORD PTR _alignment$[ebp]
  00019	75 09		 jne	 SHORT $LN13@IsAlignedO
  0001b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv85[ebp], 1
  00022	eb 04		 jmp	 SHORT $LN11@IsAlignedO
$LN13@IsAlignedO:
  00024	83 65 fc 00	 and	 DWORD PTR tv85[ebp], 0
$LN11@IsAlignedO:

; 383  : 	return alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);

  00028	0f b6 45 fc	 movzx	 eax, BYTE PTR tv85[ebp]
  0002c	85 c0		 test	 eax, eax
  0002e	74 24		 je	 SHORT $LN7@IsAlignedO
  00030	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00033	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 342  : 	return T2(a) & (b-1);

  00036	8b 45 0c	 mov	 eax, DWORD PTR _alignment$[ebp]
  00039	48		 dec	 eax
  0003a	23 45 e8	 and	 eax, DWORD PTR $T1[ebp]

; 383  : 	return alignment==1 || (IsPowerOf2(alignment) ? ModPowerOf2((size_t)p, alignment) == 0 : (size_t)p % alignment == 0);

  0003d	75 09		 jne	 SHORT $LN5@IsAlignedO
  0003f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00046	eb 04		 jmp	 SHORT $LN6@IsAlignedO
$LN5@IsAlignedO:
  00048	83 65 f8 00	 and	 DWORD PTR tv74[ebp], 0
$LN6@IsAlignedO:
  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]
  0004f	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  00052	eb 1f		 jmp	 SHORT $LN8@IsAlignedO
$LN7@IsAlignedO:
  00054	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00057	33 d2		 xor	 edx, edx
  00059	f7 75 0c	 div	 DWORD PTR _alignment$[ebp]
  0005c	85 d2		 test	 edx, edx
  0005e	75 09		 jne	 SHORT $LN3@IsAlignedO
  00060	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  00067	eb 04		 jmp	 SHORT $LN4@IsAlignedO
$LN3@IsAlignedO:
  00069	83 65 f4 00	 and	 DWORD PTR tv73[ebp], 0
$LN4@IsAlignedO:
  0006d	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00070	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
$LN8@IsAlignedO:
  00073	83 7d f0 00	 cmp	 DWORD PTR tv77[ebp], 0
  00077	75 06		 jne	 SHORT $LN9@IsAlignedO
  00079	83 65 ec 00	 and	 DWORD PTR tv79[ebp], 0
  0007d	eb 07		 jmp	 SHORT $LN10@IsAlignedO
$LN9@IsAlignedO:
  0007f	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
$LN10@IsAlignedO:
  00086	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]

; 384  : }

  00089	c9		 leave
  0008a	c3		 ret	 0
?IsAlignedOn@CryptoPP@@YA_NPBXI@Z ENDP			; CryptoPP::IsAlignedOn
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1BufferedTransformation@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1BufferedTransformation@CryptoPP@@UAE@XZ PROC		; CryptoPP::BufferedTransformation::~BufferedTransformation, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1BufferedTransformation@CryptoPP@@UAE@XZ ENDP		; CryptoPP::BufferedTransformation::~BufferedTransformation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T2 = -80						; size = 40
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_newAttachment$ = 8					; size = 4
?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z PROC ; CryptoPP::BufferedTransformation::Detach, COMDAT
; _this$ = ecx

; 1017 : 			{assert(!Attachable()); throw NotImplemented("BufferedTransformation: this object is not attachable");}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@FIHMKEGL@BufferedTransformation?3?5this?5ob@
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  0003f	50		 push	 eax
  00040	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	e8 00 00 00 00	 call	 ??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::NotImplemented::NotImplemented
  00048	68 00 00 00 00	 push	 OFFSET __TI3?AVNotImplemented@CryptoPP@@
  0004d	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 __CxxThrowException@8
  00056	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0005a	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN2@Detach:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 1017 : 			{assert(!Attachable()); throw NotImplemented("BufferedTransformation: this object is not attachable");}

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	c9		 leave
  00078	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Detach@BufferedTransformation@CryptoPP@@UAEXPAV12@@Z ENDP ; CryptoPP::BufferedTransformation::Detach
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?AttachedTransformation@BufferedTransformation@CryptoPP@@UBEPBV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AttachedTransformation@BufferedTransformation@CryptoPP@@UBEPBV12@XZ PROC ; CryptoPP::BufferedTransformation::AttachedTransformation, COMDAT
; _this$ = ecx

; 1014 : 			{return const_cast<BufferedTransformation *>(this)->AttachedTransformation();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 90 a4 00 00
	00		 call	 DWORD PTR [eax+164]
  00015	c9		 leave
  00016	c3		 ret	 0
?AttachedTransformation@BufferedTransformation@CryptoPP@@UBEPBV12@XZ ENDP ; CryptoPP::BufferedTransformation::AttachedTransformation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?AttachedTransformation@BufferedTransformation@CryptoPP@@UAEPAV12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?AttachedTransformation@BufferedTransformation@CryptoPP@@UAEPAV12@XZ PROC ; CryptoPP::BufferedTransformation::AttachedTransformation, COMDAT
; _this$ = ecx

; 1011 : 		virtual BufferedTransformation *AttachedTransformation() {assert(!Attachable()); return 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c3		 ret	 0
?AttachedTransformation@BufferedTransformation@CryptoPP@@UAEPAV12@XZ ENDP ; CryptoPP::BufferedTransformation::AttachedTransformation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?Attachable@BufferedTransformation@CryptoPP@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Attachable@BufferedTransformation@CryptoPP@@UAE_NXZ PROC ; CryptoPP::BufferedTransformation::Attachable, COMDAT
; _this$ = ecx

; 1009 : 		virtual bool Attachable() {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c3		 ret	 0
?Attachable@BufferedTransformation@CryptoPP@@UAE_NXZ ENDP ; CryptoPP::BufferedTransformation::Attachable
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ PROC ; CryptoPP::BufferedTransformation::NumberOfMessageSeries, COMDAT
; _this$ = ecx

; 951  : 		virtual unsigned int NumberOfMessageSeries() const {return 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c3		 ret	 0
?NumberOfMessageSeries@BufferedTransformation@CryptoPP@@UBEIXZ ENDP ; CryptoPP::BufferedTransformation::NumberOfMessageSeries
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ PROC ; CryptoPP::BufferedTransformation::NumberOfMessagesInThisSeries, COMDAT
; _this$ = ecx

; 950  : 		virtual unsigned int NumberOfMessagesInThisSeries() const {return NumberOfMessages();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 5c	 call	 DWORD PTR [eax+92]
  00012	c9		 leave
  00013	c3		 ret	 0
?NumberOfMessagesInThisSeries@BufferedTransformation@CryptoPP@@UBEIXZ ENDP ; CryptoPP::BufferedTransformation::NumberOfMessagesInThisSeries
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ PROC ; CryptoPP::BufferedTransformation::GetNextMessageSeries, COMDAT
; _this$ = ecx

; 949  : 		virtual bool GetNextMessageSeries() {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c3		 ret	 0
?GetNextMessageSeries@BufferedTransformation@CryptoPP@@UAE_NXZ ENDP ; CryptoPP::BufferedTransformation::GetNextMessageSeries
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?GetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UBEHXZ PROC ; CryptoPP::BufferedTransformation::GetAutoSignalPropagation, COMDAT
; _this$ = ecx

; 860  : 		virtual int GetAutoSignalPropagation() const {return 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c3		 ret	 0
?GetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UBEHXZ ENDP ; CryptoPP::BufferedTransformation::GetAutoSignalPropagation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?SetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_propagation$ = 8					; size = 4
?SetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UAEXH@Z PROC ; CryptoPP::BufferedTransformation::SetAutoSignalPropagation, COMDAT
; _this$ = ecx

; 857  : 		virtual void SetAutoSignalPropagation(int propagation) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 04 00	 ret	 4
?SetAutoSignalPropagation@BufferedTransformation@CryptoPP@@UAEXH@Z ENDP ; CryptoPP::BufferedTransformation::SetAutoSignalPropagation
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?IsolatedMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_N_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_blocking$ = 8						; size = 1
?IsolatedMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_N_N@Z PROC ; CryptoPP::BufferedTransformation::IsolatedMessageSeriesEnd, COMDAT
; _this$ = ecx

; 835  : 		virtual bool IsolatedMessageSeriesEnd(bool blocking) {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c2 04 00	 ret	 4
?IsolatedMessageSeriesEnd@BufferedTransformation@CryptoPP@@UAE_N_N@Z ENDP ; CryptoPP::BufferedTransformation::IsolatedMessageSeriesEnd
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_inString$ = 8						; size = 4
_length$ = 12						; size = 4
_messageEnd$ = 16					; size = 4
_blocking$ = 20						; size = 1
?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z PROC ; CryptoPP::BufferedTransformation::PutModifiable2, COMDAT
; _this$ = ecx

; 818  : 			{return Put2(inString, length, messageEnd, blocking);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 14	 push	 DWORD PTR _blocking$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR _messageEnd$[ebp]
  0000d	ff 75 0c	 push	 DWORD PTR _length$[ebp]
  00010	ff 75 08	 push	 DWORD PTR _inString$[ebp]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	ff 50 14	 call	 DWORD PTR [eax+20]
  0001e	c9		 leave
  0001f	c2 10 00	 ret	 16			; 00000010H
?PutModifiable2@BufferedTransformation@CryptoPP@@UAEIPAEIH_N@Z ENDP ; CryptoPP::BufferedTransformation::PutModifiable2
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ PROC ; CryptoPP::BufferedTransformation::CanModifyInput, COMDAT
; _this$ = ecx

; 801  : 		virtual bool CanModifyInput() const {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c3		 ret	 0
?CanModifyInput@BufferedTransformation@CryptoPP@@UBE_NXZ ENDP ; CryptoPP::BufferedTransformation::CanModifyInput
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?CreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEAAI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?CreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEAAI@Z PROC ; CryptoPP::BufferedTransformation::CreatePutSpace, COMDAT
; _this$ = ecx

; 799  : 		virtual byte * CreatePutSpace(size_t &size) {size=0; return NULL;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	33 c0		 xor	 eax, eax
  0000f	c9		 leave
  00010	c2 04 00	 ret	 4
?CreatePutSpace@BufferedTransformation@CryptoPP@@UAEPAEAAI@Z ENDP ; CryptoPP::BufferedTransformation::CreatePutSpace
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ??0BufferedTransformation@CryptoPP@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0BufferedTransformation@CryptoPP@@QAE@XZ PROC		; CryptoPP::BufferedTransformation::BufferedTransformation, COMDAT
; _this$ = ecx

; 777  : 	BufferedTransformation() : Algorithm(false) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	c9		 leave
  00015	c3		 ret	 0
??0BufferedTransformation@CryptoPP@@QAE@XZ ENDP		; CryptoPP::BufferedTransformation::BufferedTransformation
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1RandomNumberGenerator@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1RandomNumberGenerator@CryptoPP@@UAE@XZ PROC		; CryptoPP::RandomNumberGenerator::~RandomNumberGenerator, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1RandomNumberGenerator@CryptoPP@@UAE@XZ ENDP		; CryptoPP::RandomNumberGenerator::~RandomNumberGenerator
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?CanIncorporateEntropy@RandomNumberGenerator@CryptoPP@@UBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanIncorporateEntropy@RandomNumberGenerator@CryptoPP@@UBE_NXZ PROC ; CryptoPP::RandomNumberGenerator::CanIncorporateEntropy, COMDAT
; _this$ = ecx

; 676  : 	virtual bool CanIncorporateEntropy() const {return false;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	32 c0		 xor	 al, al
  00009	c9		 leave
  0000a	c3		 ret	 0
?CanIncorporateEntropy@RandomNumberGenerator@CryptoPP@@UBE_NXZ ENDP ; CryptoPP::RandomNumberGenerator::CanIncorporateEntropy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T2 = -80						; size = 40
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_input$ = 8						; size = 4
_length$ = 12						; size = 4
?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z PROC ; CryptoPP::RandomNumberGenerator::IncorporateEntropy, COMDAT
; _this$ = ecx

; 673  : 	virtual void IncorporateEntropy(const byte *input, size_t length) {throw NotImplemented("RandomNumberGenerator: IncorporateEntropy not implemented");}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@CFJCNMFC@RandomNumberGenerator?3?5Incorpor@
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  0003f	50		 push	 eax
  00040	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	e8 00 00 00 00	 call	 ??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::NotImplemented::NotImplemented
  00048	68 00 00 00 00	 push	 OFFSET __TI3?AVNotImplemented@CryptoPP@@
  0004d	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 __CxxThrowException@8
  00056	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0005a	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN2@Incorporat:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 673  : 	virtual void IncorporateEntropy(const byte *input, size_t length) {throw NotImplemented("RandomNumberGenerator: IncorporateEntropy not implemented");}

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	c9		 leave
  00078	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IncorporateEntropy@RandomNumberGenerator@CryptoPP@@UAEXPBEI@Z ENDP ; CryptoPP::RandomNumberGenerator::IncorporateEntropy
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?GetAlgorithm@SymmetricCipher@CryptoPP@@MBEABVAlgorithm@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAlgorithm@SymmetricCipher@CryptoPP@@MBEABVAlgorithm@2@XZ PROC ; CryptoPP::SymmetricCipher::GetAlgorithm, COMDAT
; _this$ = ecx

; 614  : 	const Algorithm & GetAlgorithm() const {return *this;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetAlgorithm@SymmetricCipher@CryptoPP@@MBEABVAlgorithm@2@XZ ENDP ; CryptoPP::SymmetricCipher::GetAlgorithm
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?VerifyTruncatedDigest@HashTransformation@CryptoPP@@UAE_NPBEI0I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_digest$ = 8						; size = 4
_digestLength$ = 12					; size = 4
_input$ = 16						; size = 4
_length$ = 20						; size = 4
?VerifyTruncatedDigest@HashTransformation@CryptoPP@@UAE_NPBEI0I@Z PROC ; CryptoPP::HashTransformation::VerifyTruncatedDigest, COMDAT
; _this$ = ecx

; 594  : 		{Update(input, length); return TruncatedVerify(digest, digestLength);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 14	 push	 DWORD PTR _length$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR _input$[ebp]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	ff 50 0c	 call	 DWORD PTR [eax+12]
  00018	ff 75 0c	 push	 DWORD PTR _digestLength$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR _digest$[ebp]
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	ff 50 40	 call	 DWORD PTR [eax+64]
  00029	c9		 leave
  0002a	c2 10 00	 ret	 16			; 00000010H
?VerifyTruncatedDigest@HashTransformation@CryptoPP@@UAE_NPBEI0I@Z ENDP ; CryptoPP::HashTransformation::VerifyTruncatedDigest
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?CalculateTruncatedDigest@HashTransformation@CryptoPP@@UAEXPAEIPBEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_digest$ = 8						; size = 4
_digestSize$ = 12					; size = 4
_input$ = 16						; size = 4
_length$ = 20						; size = 4
?CalculateTruncatedDigest@HashTransformation@CryptoPP@@UAEXPAEIPBEI@Z PROC ; CryptoPP::HashTransformation::CalculateTruncatedDigest, COMDAT
; _this$ = ecx

; 587  : 		{Update(input, length); TruncatedFinal(digest, digestSize);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 14	 push	 DWORD PTR _length$[ebp]
  0000a	ff 75 10	 push	 DWORD PTR _input$[ebp]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	ff 50 0c	 call	 DWORD PTR [eax+12]
  00018	ff 75 0c	 push	 DWORD PTR _digestSize$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR _digest$[ebp]
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	ff 50 38	 call	 DWORD PTR [eax+56]
  00029	c9		 leave
  0002a	c2 10 00	 ret	 16			; 00000010H
?CalculateTruncatedDigest@HashTransformation@CryptoPP@@UAEXPAEIPBEI@Z ENDP ; CryptoPP::HashTransformation::CalculateTruncatedDigest
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?VerifyDigest@HashTransformation@CryptoPP@@UAE_NPBE0I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_digest$ = 8						; size = 4
_input$ = 12						; size = 4
_length$ = 16						; size = 4
?VerifyDigest@HashTransformation@CryptoPP@@UAE_NPBE0I@Z PROC ; CryptoPP::HashTransformation::VerifyDigest, COMDAT
; _this$ = ecx

; 580  : 		{Update(input, length); return Verify(digest);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 10	 push	 DWORD PTR _length$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR _input$[ebp]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	ff 50 0c	 call	 DWORD PTR [eax+12]
  00018	ff 75 08	 push	 DWORD PTR _digest$[ebp]
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 50 30	 call	 DWORD PTR [eax+48]
  00026	c9		 leave
  00027	c2 0c 00	 ret	 12			; 0000000cH
?VerifyDigest@HashTransformation@CryptoPP@@UAE_NPBE0I@Z ENDP ; CryptoPP::HashTransformation::VerifyDigest
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?Verify@HashTransformation@CryptoPP@@UAE_NPBE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_digest$ = 8						; size = 4
?Verify@HashTransformation@CryptoPP@@UAE_NPBE@Z PROC	; CryptoPP::HashTransformation::Verify, COMDAT
; _this$ = ecx

; 576  : 		{return TruncatedVerify(digest, DigestSize());}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 1c	 call	 DWORD PTR [eax+28]
  00012	50		 push	 eax
  00013	ff 75 08	 push	 DWORD PTR _digest$[ebp]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	ff 50 40	 call	 DWORD PTR [eax+64]
  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?Verify@HashTransformation@CryptoPP@@UAE_NPBE@Z ENDP	; CryptoPP::HashTransformation::Verify
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?CalculateDigest@HashTransformation@CryptoPP@@UAEXPAEPBEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_digest$ = 8						; size = 4
_input$ = 12						; size = 4
_length$ = 16						; size = 4
?CalculateDigest@HashTransformation@CryptoPP@@UAEXPAEPBEI@Z PROC ; CryptoPP::HashTransformation::CalculateDigest, COMDAT
; _this$ = ecx

; 570  : 		{Update(input, length); Final(digest);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 10	 push	 DWORD PTR _length$[ebp]
  0000a	ff 75 0c	 push	 DWORD PTR _input$[ebp]
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	ff 50 0c	 call	 DWORD PTR [eax+12]
  00018	ff 75 08	 push	 DWORD PTR _digest$[ebp]
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 50 14	 call	 DWORD PTR [eax+20]
  00026	c9		 leave
  00027	c2 0c 00	 ret	 12			; 0000000cH
?CalculateDigest@HashTransformation@CryptoPP@@UAEXPAEPBEI@Z ENDP ; CryptoPP::HashTransformation::CalculateDigest
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?Final@HashTransformation@CryptoPP@@UAEXPAE@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_digest$ = 8						; size = 4
?Final@HashTransformation@CryptoPP@@UAEXPAE@Z PROC	; CryptoPP::HashTransformation::Final, COMDAT
; _this$ = ecx

; 546  : 		{TruncatedFinal(digest, DigestSize());}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 1c	 call	 DWORD PTR [eax+28]
  00012	50		 push	 eax
  00013	ff 75 08	 push	 DWORD PTR _digest$[ebp]
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 00		 mov	 eax, DWORD PTR [eax]
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	ff 50 38	 call	 DWORD PTR [eax+56]
  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?Final@HashTransformation@CryptoPP@@UAEXPAE@Z ENDP	; CryptoPP::HashTransformation::Final
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?MinLastBlockSize@StreamTransformation@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinLastBlockSize@StreamTransformation@CryptoPP@@UBEIXZ PROC ; CryptoPP::StreamTransformation::MinLastBlockSize, COMDAT
; _this$ = ecx

; 496  : 	virtual unsigned int MinLastBlockSize() const {return 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c3		 ret	 0
?MinLastBlockSize@StreamTransformation@CryptoPP@@UBEIXZ ENDP ; CryptoPP::StreamTransformation::MinLastBlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?GetOptimalBlockSizeUsed@StreamTransformation@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetOptimalBlockSizeUsed@StreamTransformation@CryptoPP@@UBEIXZ PROC ; CryptoPP::StreamTransformation::GetOptimalBlockSizeUsed, COMDAT
; _this$ = ecx

; 483  : 	virtual unsigned int GetOptimalBlockSizeUsed() const {return 0;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	c9		 leave
  0000a	c3		 ret	 0
?GetOptimalBlockSizeUsed@StreamTransformation@CryptoPP@@UBEIXZ ENDP ; CryptoPP::StreamTransformation::GetOptimalBlockSizeUsed
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?MandatoryBlockSize@StreamTransformation@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MandatoryBlockSize@StreamTransformation@CryptoPP@@UBEIXZ PROC ; CryptoPP::StreamTransformation::MandatoryBlockSize, COMDAT
; _this$ = ecx

; 477  : 	virtual unsigned int MandatoryBlockSize() const {return 1;}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?MandatoryBlockSize@StreamTransformation@CryptoPP@@UBEIXZ ENDP ; CryptoPP::StreamTransformation::MandatoryBlockSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?MaxIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MaxIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ PROC ; CryptoPP::SimpleKeyingInterface::MaxIVLength, COMDAT
; _this$ = ecx

; 400  : 	virtual unsigned int MaxIVLength() const {return IVSize();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 20	 call	 DWORD PTR [eax+32]
  00012	c9		 leave
  00013	c3		 ret	 0
?MaxIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ ENDP ; CryptoPP::SimpleKeyingInterface::MaxIVLength
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?MinIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?MinIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ PROC ; CryptoPP::SimpleKeyingInterface::MinIVLength, COMDAT
; _this$ = ecx

; 398  : 	virtual unsigned int MinIVLength() const {return IVSize();}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	ff 50 20	 call	 DWORD PTR [eax+32]
  00012	c9		 leave
  00013	c3		 ret	 0
?MinIVLength@SimpleKeyingInterface@CryptoPP@@UBEIXZ ENDP ; CryptoPP::SimpleKeyingInterface::MinIVLength
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ
_TEXT	SEGMENT
tv89 = -128						; size = 4
tv91 = -124						; size = 4
tv87 = -120						; size = 4
tv78 = -116						; size = 4
tv73 = -112						; size = 4
_this$ = -108						; size = 4
$T2 = -104						; size = 40
$T3 = -64						; size = 24
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ PROC	; CryptoPP::SimpleKeyingInterface::IVSize, COMDAT
; _this$ = ecx

; 394  : 	virtual unsigned int IVSize() const {throw NotImplemented(GetAlgorithm().AlgorithmName() + ": this object doesn't support resynchronization");}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 74	 sub	 esp, 116		; 00000074H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 00		 mov	 eax, DWORD PTR [eax]
  00030	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	ff 50 34	 call	 DWORD PTR [eax+52]
  00036	89 45 90	 mov	 DWORD PTR tv73[ebp], eax
  00039	8d 45 c0	 lea	 eax, DWORD PTR $T3[ebp]
  0003c	50		 push	 eax
  0003d	8b 45 90	 mov	 eax, DWORD PTR tv73[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	8b 4d 90	 mov	 ecx, DWORD PTR tv73[ebp]
  00045	ff 50 08	 call	 DWORD PTR [eax+8]
  00048	89 45 8c	 mov	 DWORD PTR tv78[ebp], eax
  0004b	8b 45 8c	 mov	 eax, DWORD PTR tv78[ebp]
  0004e	89 45 88	 mov	 DWORD PTR tv87[ebp], eax
  00051	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@CJIHPKKH@?3?5this?5object?5doesn?8t?5support?5r@
  0005a	ff 75 88	 push	 DWORD PTR tv87[ebp]
  0005d	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH
  00069	89 45 84	 mov	 DWORD PTR tv91[ebp], eax
  0006c	8b 45 84	 mov	 eax, DWORD PTR tv91[ebp]
  0006f	89 45 80	 mov	 DWORD PTR tv89[ebp], eax
  00072	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00076	ff 75 80	 push	 DWORD PTR tv89[ebp]
  00079	8d 4d 98	 lea	 ecx, DWORD PTR $T2[ebp]
  0007c	e8 00 00 00 00	 call	 ??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::NotImplemented::NotImplemented
  00081	68 00 00 00 00	 push	 OFFSET __TI3?AVNotImplemented@CryptoPP@@
  00086	8d 45 98	 lea	 eax, DWORD PTR $T2[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 __CxxThrowException@8
  0008f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00093	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00096	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 394  : 	virtual unsigned int IVSize() const {throw NotImplemented(GetAlgorithm().AlgorithmName() + ": this object doesn't support resynchronization");}

  0009b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0009f	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  000a2	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN2@IVSize:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 394  : 	virtual unsigned int IVSize() const {throw NotImplemented(GetAlgorithm().AlgorithmName() + ": this object doesn't support resynchronization");}

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000aa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b1	59		 pop	 ecx
  000b2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b5	33 cd		 xor	 ecx, ebp
  000b7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bc	c9		 leave
  000bd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?IVSize@SimpleKeyingInterface@CryptoPP@@UBEIXZ ENDP	; CryptoPP::SimpleKeyingInterface::IVSize
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?IsValidKeyLength@SimpleKeyingInterface@CryptoPP@@UBE_NI@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?IsValidKeyLength@SimpleKeyingInterface@CryptoPP@@UBE_NI@Z PROC ; CryptoPP::SimpleKeyingInterface::IsValidKeyLength, COMDAT
; _this$ = ecx

; 364  : 		{return n == GetValidKeyLength(n);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00008	ff 75 08	 push	 DWORD PTR _n$[ebp]
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	ff 50 10	 call	 DWORD PTR [eax+16]
  00016	39 45 08	 cmp	 DWORD PTR _n$[ebp], eax
  00019	75 09		 jne	 SHORT $LN3@IsValidKey
  0001b	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  00022	eb 04		 jmp	 SHORT $LN4@IsValidKey
$LN3@IsValidKey:
  00024	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN4@IsValidKey:
  00028	8a 45 f8	 mov	 al, BYTE PTR tv70[ebp]
  0002b	c9		 leave
  0002c	c2 04 00	 ret	 4
?IsValidKeyLength@SimpleKeyingInterface@CryptoPP@@UBE_NI@Z ENDP ; CryptoPP::SimpleKeyingInterface::IsValidKeyLength
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ??1SimpleKeyingInterface@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SimpleKeyingInterface@CryptoPP@@UAE@XZ PROC		; CryptoPP::SimpleKeyingInterface::~SimpleKeyingInterface, COMDAT
; _this$ = ecx

; 350  : 	virtual ~SimpleKeyingInterface() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1SimpleKeyingInterface@CryptoPP@@UAE@XZ ENDP		; CryptoPP::SimpleKeyingInterface::~SimpleKeyingInterface
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CryptoPP::Algorithm::AlgorithmName, COMDAT
; _this$ = ecx

; 343  : 	virtual std::string AlgorithmName() const {return "unknown";}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00008	83 65 fc 00	 and	 DWORD PTR $T1[ebp], 0
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_07CIFAGBMG@unknown@
  00011	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00019	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0001c	83 c8 01	 or	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	c9		 leave
  00026	c2 04 00	 ret	 4
?AlgorithmName@Algorithm@CryptoPP@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CryptoPP::Algorithm::AlgorithmName
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T2 = -80						; size = 40
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Clone@Clonable@CryptoPP@@UBEPAV12@XZ PROC		; CryptoPP::Clonable::Clone, COMDAT
; _this$ = ecx

; 331  : 	virtual Clonable* Clone() const {throw NotImplemented("Clone() is not implemented yet.");}	// TODO: make this =0

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@CCPAJEEJ@Clone?$CI?$CJ?5is?5not?5implemented?5yet?4@
  00030	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00033	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00038	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003c	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  0003f	50		 push	 eax
  00040	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	e8 00 00 00 00	 call	 ??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::NotImplemented::NotImplemented
  00048	68 00 00 00 00	 push	 OFFSET __TI3?AVNotImplemented@CryptoPP@@
  0004d	8d 45 b0	 lea	 eax, DWORD PTR $T2[ebp]
  00050	50		 push	 eax
  00051	e8 00 00 00 00	 call	 __CxxThrowException@8
  00056	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0005a	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0005d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN2@Clone:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 331  : 	virtual Clonable* Clone() const {throw NotImplemented("Clone() is not implemented yet.");}	// TODO: make this =0

  00062	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00065	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006c	59		 pop	 ecx
  0006d	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	c9		 leave
  00078	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Clone@Clonable@CryptoPP@@UBEPAV12@XZ$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Clone@Clonable@CryptoPP@@UBEPAV12@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Clone@Clonable@CryptoPP@@UBEPAV12@XZ
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Clone@Clonable@CryptoPP@@UBEPAV12@XZ ENDP		; CryptoPP::Clonable::Clone
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4541 :     basic_string<_Elem, _Traits, _Alloc>&& _Left, _In_z_ const _Elem* const _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	83 65 fc 00	 and	 DWORD PTR $T5[ebp], 0

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000a	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	59		 pop	 ecx
  00013	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00016	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00019	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001c	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0001f	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Left$[ebp]
  00025	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0002a	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0002d	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00030	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4542 :     return _STD move(_Left.append(_Right));

  00033	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003e	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00041	83 c8 01	 or	 eax, 1
  00044	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
  00047	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4543 : }

  0004a	c9		 leave
  0004b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 1
tv86 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__Left_size$ = -12					; size = 4
__Right_size$ = -8					; size = 4
$T4 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4456 :     _In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000a	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	59		 pop	 ecx
  00013	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00016	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00019	89 45 f4	 mov	 DWORD PTR __Left_size$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  0001c	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  0001f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00022	89 45 f8	 mov	 DWORD PTR __Right_size$[ebp], eax

; 4457 :     using _Size_type       = typename basic_string<_Elem, _Traits, _Alloc>::size_type;
; 4458 :     const auto _Left_size  = _Convert_size<_Size_type>(_Traits::length(_Left));
; 4459 :     const auto _Right_size = _Right.size();
; 4460 :     if (_Right.max_size() - _Right_size < _Left_size) {

  00025	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00028	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0002d	2b 45 f8	 sub	 eax, DWORD PTR __Right_size$[ebp]
  00030	3b 45 f4	 cmp	 eax, DWORD PTR __Left_size$[ebp]
  00033	73 05		 jae	 SHORT $LN2@operator

; 4461 :         _Xlen_string();

  00035	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@operator:

; 4462 :     }
; 4463 : 
; 4464 :     return {_String_constructor_concat_tag{}, _Right, _Left, _Left_size, _Right.c_str(), _Right_size};

  0003a	8a 45 ff	 mov	 al, BYTE PTR $T4[ebp]
  0003d	88 45 e4	 mov	 BYTE PTR $T1[ebp], al
  00040	8b 4d 10	 mov	 ecx, DWORD PTR __Right$[ebp]
  00043	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00048	89 45 e8	 mov	 DWORD PTR tv86[ebp], eax
  0004b	ff 75 f8	 push	 DWORD PTR __Right_size$[ebp]
  0004e	ff 75 e8	 push	 DWORD PTR tv86[ebp]
  00051	ff 75 f4	 push	 DWORD PTR __Left_size$[ebp]
  00054	ff 75 0c	 push	 DWORD PTR __Left$[ebp]
  00057	ff 75 10	 push	 DWORD PTR __Right$[ebp]
  0005a	ff 75 e4	 push	 DWORD PTR $T1[ebp]
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00060	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00065	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00068	83 c8 01	 or	 eax, 1
  0006b	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@operator:

; 4465 : }

  00071	c9		 leave
  00072	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z
_TEXT	SEGMENT
tv86 = -96						; size = 4
$T2 = -89						; size = 1
$T3 = -88						; size = 48
$T4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_name$ = 8						; size = 4
_stored$ = 12						; size = 4
_retrieving$ = 16					; size = 4
?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z PROC ; CryptoPP::NameValuePairs::ThrowIfTypeMismatch, COMDAT

; 291  : 		{if (stored != retrieving) throw ValueTypeMismatch(name, stored, retrieving);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h

; 88   :         return __std_type_info_compare(&_Data, &_Other._Data) != 0;

  00028	8b 45 10	 mov	 eax, DWORD PTR _retrieving$[ebp]
  0002b	83 c0 04	 add	 eax, 4
  0002e	50		 push	 eax
  0002f	8b 45 0c	 mov	 eax, DWORD PTR _stored$[ebp]
  00032	83 c0 04	 add	 eax, 4
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ___std_type_info_compare
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
  0003d	85 c0		 test	 eax, eax
  0003f	74 09		 je	 SHORT $LN7@ThrowIfTyp
  00041	c7 45 a0 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  00048	eb 04		 jmp	 SHORT $LN8@ThrowIfTyp
$LN7@ThrowIfTyp:
  0004a	83 65 a0 00	 and	 DWORD PTR tv86[ebp], 0
$LN8@ThrowIfTyp:
  0004e	8a 45 a0	 mov	 al, BYTE PTR tv86[ebp]
  00051	88 45 a7	 mov	 BYTE PTR $T2[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 291  : 		{if (stored != retrieving) throw ValueTypeMismatch(name, stored, retrieving);}

  00054	0f b6 45 a7	 movzx	 eax, BYTE PTR $T2[ebp]
  00058	85 c0		 test	 eax, eax
  0005a	74 3b		 je	 SHORT $LN3@ThrowIfTyp
  0005c	ff 75 08	 push	 DWORD PTR _name$[ebp]
  0005f	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00067	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0006b	ff 75 10	 push	 DWORD PTR _retrieving$[ebp]
  0006e	ff 75 0c	 push	 DWORD PTR _stored$[ebp]
  00071	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00074	50		 push	 eax
  00075	8d 4d a8	 lea	 ecx, DWORD PTR $T3[ebp]
  00078	e8 00 00 00 00	 call	 ??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z ; CryptoPP::NameValuePairs::ValueTypeMismatch::ValueTypeMismatch
  0007d	68 00 00 00 00	 push	 OFFSET __TI4?AVValueTypeMismatch@NameValuePairs@CryptoPP@@
  00082	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 __CxxThrowException@8
  0008b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0008f	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00092	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN3@ThrowIfTyp:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 291  : 		{if (stored != retrieving) throw ValueTypeMismatch(name, stored, retrieving);}

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	c9		 leave
  000ad	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T4[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ThrowIfTypeMismatch@NameValuePairs@CryptoPP@@SAXPBDABVtype_info@@1@Z ENDP ; CryptoPP::NameValuePairs::ThrowIfTypeMismatch
; Function compile flags: /Odspy
;	COMDAT ??_GValueTypeMismatch@NameValuePairs@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GValueTypeMismatch@NameValuePairs@CryptoPP@@UAEPAXI@Z PROC ; CryptoPP::NameValuePairs::ValueTypeMismatch::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 30		 push	 48			; 00000030H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GValueTypeMismatch@NameValuePairs@CryptoPP@@UAEPAXI@Z ENDP ; CryptoPP::NameValuePairs::ValueTypeMismatch::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z PROC ; CryptoPP::NameValuePairs::ValueTypeMismatch::ValueTypeMismatch, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@ABV01@@Z
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7InvalidArgument@CryptoPP@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0002a	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  0002d	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00036	8b 49 2c	 mov	 ecx, DWORD PTR [ecx+44]
  00039	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	c9		 leave
  00040	c2 04 00	 ret	 4
??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV012@@Z ENDP ; CryptoPP::NameValuePairs::ValueTypeMismatch::ValueTypeMismatch
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1ValueTypeMismatch@NameValuePairs@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ValueTypeMismatch@NameValuePairs@CryptoPP@@UAE@XZ PROC ; CryptoPP::NameValuePairs::ValueTypeMismatch::~ValueTypeMismatch, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	c9		 leave
  00010	c3		 ret	 0
??1ValueTypeMismatch@NameValuePairs@CryptoPP@@UAE@XZ ENDP ; CryptoPP::NameValuePairs::ValueTypeMismatch::~ValueTypeMismatch
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z
_TEXT	SEGMENT
$T2 = -72						; size = 4
tv210 = -68						; size = 4
tv164 = -64						; size = 4
tv211 = -60						; size = 4
tv162 = -56						; size = 4
$T3 = -52						; size = 4
tv92 = -48						; size = 4
tv160 = -44						; size = 4
tv68 = -40						; size = 4
tv158 = -36						; size = 4
$T4 = -32						; size = 4
tv88 = -28						; size = 4
tv156 = -24						; size = 4
tv179 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T5 = 0							; size = 24
$T6 = 24						; size = 24
$T7 = 48						; size = 24
$T8 = 72						; size = 24
$T9 = 96						; size = 24
$T10 = 120						; size = 24
__$ArrayPad$ = 144					; size = 4
_name$ = 156						; size = 4
_stored$ = 160						; size = 4
_retrieving$ = 164					; size = 4
??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z PROC ; CryptoPP::NameValuePairs::ValueTypeMismatch::ValueTypeMismatch, COMDAT
; _this$ = ecx

; 236  : 			, m_stored(stored), m_retrieving(retrieving) {}

  00000	55		 push	 ebp
  00001	8d ac 24 6c ff
	ff ff		 lea	 ebp, DWORD PTR [esp-148]
  00008	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 3c	 sub	 esp, 60			; 0000003cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 90 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  00039	ff b5 9c 00 00
	00		 push	 DWORD PTR _name$[ebp]
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@LNMKHLKF@NameValuePairs?3?5type?5mismatch?5f@
  00044	8d 45 00	 lea	 eax, DWORD PTR $T5[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00050	89 45 ec	 mov	 DWORD PTR tv179[ebp], eax
  00053	8b 45 ec	 mov	 eax, DWORD PTR tv179[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv156[ebp], eax
  00059	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_0M@PGGGIJHH@?8?0?5stored?5?8@
  00062	ff 75 e8	 push	 DWORD PTR tv156[ebp]
  00065	8d 45 18	 lea	 eax, DWORD PTR $T6[ebp]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0006e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00071	89 45 e4	 mov	 DWORD PTR tv88[ebp], eax
  00074	8b 45 e4	 mov	 eax, DWORD PTR tv88[ebp]
  00077	89 45 dc	 mov	 DWORD PTR tv158[ebp], eax
  0007a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h

; 101  :         return __std_type_info_name(&_Data, &__type_info_root_node);

  0007e	68 00 00 00 00	 push	 OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
  00083	8b 85 a0 00 00
	00		 mov	 eax, DWORD PTR _stored$[ebp]
  00089	83 c0 04	 add	 eax, 4
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ___std_type_info_name
  00092	59		 pop	 ecx
  00093	59		 pop	 ecx
  00094	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  00097	ff 75 e0	 push	 DWORD PTR $T4[ebp]
  0009a	ff 75 dc	 push	 DWORD PTR tv158[ebp]
  0009d	8d 45 30	 lea	 eax, DWORD PTR $T7[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000a6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a9	89 45 d8	 mov	 DWORD PTR tv68[ebp], eax
  000ac	8b 45 d8	 mov	 eax, DWORD PTR tv68[ebp]
  000af	89 45 d4	 mov	 DWORD PTR tv160[ebp], eax
  000b2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CPJAGCKP@?8?0?5trying?5to?5retrieve?5?8@
  000bb	ff 75 d4	 push	 DWORD PTR tv160[ebp]
  000be	8d 45 48	 lea	 eax, DWORD PTR $T8[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000c7	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ca	89 45 d0	 mov	 DWORD PTR tv92[ebp], eax
  000cd	8b 45 d0	 mov	 eax, DWORD PTR tv92[ebp]
  000d0	89 45 c8	 mov	 DWORD PTR tv162[ebp], eax
  000d3	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h

; 101  :         return __std_type_info_name(&_Data, &__type_info_root_node);

  000d7	68 00 00 00 00	 push	 OFFSET ?__type_info_root_node@@3U__type_info_node@@A ; __type_info_root_node
  000dc	8b 85 a4 00 00
	00		 mov	 eax, DWORD PTR _retrieving$[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 ___std_type_info_name
  000eb	59		 pop	 ecx
  000ec	59		 pop	 ecx
  000ed	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  000f0	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  000f3	ff 75 c8	 push	 DWORD PTR tv162[ebp]
  000f6	8d 45 60	 lea	 eax, DWORD PTR $T9[ebp]
  000f9	50		 push	 eax
  000fa	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  000ff	83 c4 0c	 add	 esp, 12			; 0000000cH
  00102	89 45 c4	 mov	 DWORD PTR tv211[ebp], eax
  00105	8b 45 c4	 mov	 eax, DWORD PTR tv211[ebp]
  00108	89 45 c0	 mov	 DWORD PTR tv164[ebp], eax
  0010b	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0010f	68 00 00 00 00	 push	 OFFSET ??_C@_01GEODFPGF@?8@
  00114	ff 75 c0	 push	 DWORD PTR tv164[ebp]
  00117	8d 45 78	 lea	 eax, DWORD PTR $T10[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@QBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00120	83 c4 0c	 add	 esp, 12			; 0000000cH
  00123	89 45 bc	 mov	 DWORD PTR tv210[ebp], eax
  00126	8b 45 bc	 mov	 eax, DWORD PTR tv210[ebp]
  00129	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  0012c	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 148  : 	explicit InvalidArgument(const std::string &s) : Exception(INVALID_ARGUMENT, s) {}

  00130	ff 75 b8	 push	 DWORD PTR $T2[ebp]
  00133	6a 01		 push	 1
  00135	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::Exception::Exception
  0013d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00140	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7InvalidArgument@CryptoPP@@6B@

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  00146	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0014a	8d 4d 78	 lea	 ecx, DWORD PTR $T10[ebp]
  0014d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  00152	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00156	8d 4d 60	 lea	 ecx, DWORD PTR $T9[ebp]
  00159	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  0015e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00162	8d 4d 48	 lea	 ecx, DWORD PTR $T8[ebp]
  00165	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  0016a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0016e	8d 4d 30	 lea	 ecx, DWORD PTR $T7[ebp]
  00171	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  00176	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0017a	8d 4d 18	 lea	 ecx, DWORD PTR $T6[ebp]
  0017d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 235  : 			: InvalidArgument("NameValuePairs: type mismatch for '" + name + "', stored '" + stored.name() + "', trying to retrieve '" + retrieving.name() + "'")

  00182	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00186	8d 4d 00	 lea	 ecx, DWORD PTR $T5[ebp]
  00189	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 236  : 			, m_stored(stored), m_retrieving(retrieving) {}

  0018e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00191	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ValueTypeMismatch@NameValuePairs@CryptoPP@@6B@
  00197	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	8b 8d a0 00 00
	00		 mov	 ecx, DWORD PTR _stored$[ebp]
  001a0	89 48 28	 mov	 DWORD PTR [eax+40], ecx
  001a3	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001a6	8b 8d a4 00 00
	00		 mov	 ecx, DWORD PTR _retrieving$[ebp]
  001ac	89 48 2c	 mov	 DWORD PTR [eax+44], ecx
  001af	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c3	33 cd		 xor	 ecx, ebp
  001c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ca	81 c5 94 00 00
	00		 add	 ebp, 148		; 00000094H
  001d0	c9		 leave
  001d1	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR $T5[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$1:
  00008	8d 4d 18	 lea	 ecx, DWORD PTR $T6[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$2:
  00010	8d 4d 30	 lea	 ecx, DWORD PTR $T7[ebp]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$3:
  00018	8d 4d 48	 lea	 ecx, DWORD PTR $T8[ebp]
  0001b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$4:
  00020	8d 4d 60	 lea	 ecx, DWORD PTR $T9[ebp]
  00023	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z$5:
  00028	8d 4d 78	 lea	 ecx, DWORD PTR $T10[ebp]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00030	cc		 int	 3
  00031	cc		 int	 3
  00032	cc		 int	 3
  00033	cc		 int	 3
  00034	cc		 int	 3
__ehhandler$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z:
  00035	90		 npad	 1
  00036	90		 npad	 1
  00037	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003e	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	8b 8a 9c 00 00
	00		 mov	 ecx, DWORD PTR [edx+156]
  0004e	33 c8		 xor	 ecx, eax
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z
  0005a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0ValueTypeMismatch@NameValuePairs@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVtype_info@@1@Z ENDP ; CryptoPP::NameValuePairs::ValueTypeMismatch::ValueTypeMismatch
; Function compile flags: /Odspy
;	COMDAT ??_GNotImplemented@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GNotImplemented@CryptoPP@@UAEPAXI@Z PROC		; CryptoPP::NotImplemented::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 28		 push	 40			; 00000028H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GNotImplemented@CryptoPP@@UAEPAXI@Z ENDP		; CryptoPP::NotImplemented::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0NotImplemented@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0NotImplemented@CryptoPP@@QAE@ABV01@@Z PROC		; CryptoPP::NotImplemented::NotImplemented, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@ABV01@@Z
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7NotImplemented@CryptoPP@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0NotImplemented@CryptoPP@@QAE@ABV01@@Z ENDP		; CryptoPP::NotImplemented::NotImplemented
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1NotImplemented@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1NotImplemented@CryptoPP@@UAE@XZ PROC			; CryptoPP::NotImplemented::~NotImplemented, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	c9		 leave
  00010	c3		 ret	 0
??1NotImplemented@CryptoPP@@UAE@XZ ENDP			; CryptoPP::NotImplemented::~NotImplemented
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CryptoPP::NotImplemented::NotImplemented, COMDAT
; _this$ = ecx

; 169  : 	explicit NotImplemented(const std::string &s) : Exception(NOT_IMPLEMENTED, s) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR _s$[ebp]
  0000a	6a 00		 push	 0
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::Exception::Exception
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7NotImplemented@CryptoPP@@6B@
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c9		 leave
  00021	c2 04 00	 ret	 4
??0NotImplemented@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CryptoPP::NotImplemented::NotImplemented
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GInvalidArgument@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GInvalidArgument@CryptoPP@@UAEPAXI@Z PROC		; CryptoPP::InvalidArgument::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 28		 push	 40			; 00000028H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GInvalidArgument@CryptoPP@@UAEPAXI@Z ENDP		; CryptoPP::InvalidArgument::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z PROC		; CryptoPP::InvalidArgument::InvalidArgument, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@ABV01@@Z
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7InvalidArgument@CryptoPP@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0InvalidArgument@CryptoPP@@QAE@ABV01@@Z ENDP		; CryptoPP::InvalidArgument::InvalidArgument
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1InvalidArgument@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1InvalidArgument@CryptoPP@@UAE@XZ PROC		; CryptoPP::InvalidArgument::~InvalidArgument, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	c9		 leave
  00010	c3		 ret	 0
??1InvalidArgument@CryptoPP@@UAE@XZ ENDP		; CryptoPP::InvalidArgument::~InvalidArgument
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ??0InvalidArgument@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_s$ = 8							; size = 4
??0InvalidArgument@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CryptoPP::InvalidArgument::InvalidArgument, COMDAT
; _this$ = ecx

; 148  : 	explicit InvalidArgument(const std::string &s) : Exception(INVALID_ARGUMENT, s) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR _s$[ebp]
  0000a	6a 01		 push	 1
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CryptoPP::Exception::Exception
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7InvalidArgument@CryptoPP@@6B@
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c9		 leave
  00021	c2 04 00	 ret	 4
??0InvalidArgument@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CryptoPP::InvalidArgument::InvalidArgument
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GException@CryptoPP@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GException@CryptoPP@@UAEPAXI@Z PROC			; CryptoPP::Exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Exception@CryptoPP@@UAE@XZ ; CryptoPP::Exception::~Exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 28		 push	 40			; 00000028H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GException@CryptoPP@@UAEPAXI@Z ENDP			; CryptoPP::Exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0Exception@CryptoPP@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Exception@CryptoPP@@QAE@ABV01@@Z PROC		; CryptoPP::Exception::Exception, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Exception@CryptoPP@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00031	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00035	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Exception@CryptoPP@@6B@
  0003e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00044	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00047	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  0004a	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0004d	83 c0 10	 add	 eax, 16			; 00000010H
  00050	50		 push	 eax
  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	83 c1 10	 add	 ecx, 16			; 00000010H
  00057	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0005c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00060	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006d	59		 pop	 ecx
  0006e	c9		 leave
  0006f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Exception@CryptoPP@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0Exception@CryptoPP@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Exception@CryptoPP@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Exception@CryptoPP@@QAE@ABV01@@Z ENDP		; CryptoPP::Exception::Exception
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ?what@Exception@CryptoPP@@UBEPBDXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?what@Exception@CryptoPP@@UBEPBDXZ PROC			; CryptoPP::Exception::what, COMDAT
; _this$ = ecx

; 133  : 	const char *what() const throw() {return (m_what.c_str());}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 10	 add	 ecx, 16			; 00000010H
  0000e	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00013	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 133  : 	const char *what() const throw() {return (m_what.c_str());}

  00016	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00019	c9		 leave
  0001a	c3		 ret	 0
?what@Exception@CryptoPP@@UBEPBDXZ ENDP			; CryptoPP::Exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ??1Exception@CryptoPP@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Exception@CryptoPP@@UAE@XZ PROC			; CryptoPP::Exception::~Exception, COMDAT
; _this$ = ecx

; 132  : 	virtual ~Exception() throw() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Exception@CryptoPP@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00016	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h

; 89   :     {

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_destroy
  00030	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 132  : 	virtual ~Exception() throw() {}

  00031	c9		 leave
  00032	c3		 ret	 0
??1Exception@CryptoPP@@UAE@XZ ENDP			; CryptoPP::Exception::~Exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
;	COMDAT ??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_errorType$ = 8						; size = 4
_s$ = 12						; size = 4
??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CryptoPP::Exception::Exception, COMDAT
; _this$ = ecx

; 131  : 	explicit Exception(ErrorType errorType, const std::string &s) : m_errorType(errorType), m_what(s) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h

; 54   :     {

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 53   :         : _Data()

  0002f	33 c0		 xor	 eax, eax
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 04	 add	 ecx, 4
  00037	89 01		 mov	 DWORD PTR [ecx], eax
  00039	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 131  : 	explicit Exception(ErrorType errorType, const std::string &s) : m_errorType(errorType), m_what(s) {}

  0003c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7Exception@CryptoPP@@6B@
  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _errorType$[ebp]
  0004f	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00052	ff 75 0c	 push	 DWORD PTR _s$[ebp]
  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 10	 add	 ecx, 16			; 00000010H
  0005b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00060	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00064	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00071	59		 pop	 ecx
  00072	c9		 leave
  00073	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Exception@CryptoPP@@QAE@W4ErrorType@01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CryptoPP::Exception::Exception
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\Inline.h
;	COMDAT ?inlineConvertPackFilename@@YAXPAD@Z
_TEXT	SEGMENT
_p$ = -4						; size = 4
_name$ = 8						; size = 4
?inlineConvertPackFilename@@YAXPAD@Z PROC		; inlineConvertPackFilename, COMDAT

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 22   : 	char * p = name;

  00004	8b 45 08	 mov	 eax, DWORD PTR _name$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
$LN2@inlineConv:

; 23   : 
; 24   : 	while (*p)

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0000d	0f be 00	 movsx	 eax, BYTE PTR [eax]
  00010	85 c0		 test	 eax, eax
  00012	74 2e		 je	 SHORT $LN1@inlineConv

; 25   : 	{
; 26   : 		if (*p == '\\')

  00014	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00017	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0001a	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0001d	75 08		 jne	 SHORT $LN4@inlineConv

; 27   : 			*p = '/';

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00022	c6 00 2f	 mov	 BYTE PTR [eax], 47	; 0000002fH
  00025	eb 12		 jmp	 SHORT $LN5@inlineConv
$LN4@inlineConv:

; 28   : 		else
; 29   : 			*p = (int) tolower(*p);

  00027	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0002a	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _tolower
  00033	59		 pop	 ecx
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00037	88 01		 mov	 BYTE PTR [ecx], al
$LN5@inlineConv:

; 30   : 		p++;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0003c	40		 inc	 eax
  0003d	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 31   : 	}

  00040	eb c8		 jmp	 SHORT $LN2@inlineConv
$LN1@inlineConv:

; 32   : }

  00042	c9		 leave
  00043	c3		 ret	 0
?inlineConvertPackFilename@@YAXPAD@Z ENDP		; inlineConvertPackFilename
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\Inline.h
;	COMDAT ?inlinePathCreate@@YAXPBD@Z
_TEXT	SEGMENT
_p$ = -76						; size = 4
_k$ = -72						; size = 4
_dir$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
_path$ = 8						; size = 4
?inlinePathCreate@@YAXPBD@Z PROC			; inlinePathCreate, COMDAT

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6    : 	char dir[64];
; 7    : 	const char* p, *k;
; 8    : 	
; 9    : 	p = path + 3;

  00010	8b 45 08	 mov	 eax, DWORD PTR _path$[ebp]
  00013	83 c0 03	 add	 eax, 3
  00016	89 45 b4	 mov	 DWORD PTR _p$[ebp], eax
$LN2@inlinePath:

; 10   : 	
; 11   : 	while (NULL != (k = strchr(p, '/')))

  00019	6a 2f		 push	 47			; 0000002fH
  0001b	ff 75 b4	 push	 DWORD PTR _p$[ebp]
  0001e	e8 00 00 00 00	 call	 _strchr
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	89 45 b8	 mov	 DWORD PTR _k$[ebp], eax
  00028	83 7d b8 00	 cmp	 DWORD PTR _k$[ebp], 0
  0002c	74 3b		 je	 SHORT $LN1@inlinePath

; 12   : 	{
; 13   : 		memset(dir, 0, sizeof(dir));

  0002e	6a 40		 push	 64			; 00000040H
  00030	6a 00		 push	 0
  00032	8d 45 bc	 lea	 eax, DWORD PTR _dir$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _memset
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 14   : 		strncpy(dir, path, k - path);

  0003e	8b 45 b8	 mov	 eax, DWORD PTR _k$[ebp]
  00041	2b 45 08	 sub	 eax, DWORD PTR _path$[ebp]
  00044	50		 push	 eax
  00045	ff 75 08	 push	 DWORD PTR _path$[ebp]
  00048	8d 45 bc	 lea	 eax, DWORD PTR _dir$[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 _strncpy
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 15   : 		CreateDirectory(dir, NULL);

  00054	6a 00		 push	 0
  00056	8d 45 bc	 lea	 eax, DWORD PTR _dir$[ebp]
  00059	50		 push	 eax
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateDirectoryA@8

; 16   : 		p = k + 1;

  00060	8b 45 b8	 mov	 eax, DWORD PTR _k$[ebp]
  00063	40		 inc	 eax
  00064	89 45 b4	 mov	 DWORD PTR _p$[ebp], eax

; 17   : 	}

  00067	eb b0		 jmp	 SHORT $LN2@inlinePath
$LN1@inlinePath:

; 18   : }

  00069	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006c	33 cd		 xor	 ecx, ebp
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	c9		 leave
  00074	c3		 ret	 0
?inlinePathCreate@@YAXPBD@Z ENDP			; inlinePathCreate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?__IsLogMode@CMakePackLog@@AAE_NXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
_this$ = -12						; size = 4
tv72 = -8						; size = 4
$T2 = -1						; size = 1
?__IsLogMode@CMakePackLog@@AAE_NXZ PROC			; CMakePackLog::__IsLogMode, COMDAT
; _this$ = ecx

; 71   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000f	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 3848 :         return size() == 0;

  00012	83 7d f0 00	 cmp	 DWORD PTR $T1[ebp], 0
  00016	75 09		 jne	 SHORT $LN6@IsLogMode
  00018	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@IsLogMode
$LN6@IsLogMode:
  00021	83 65 f8 00	 and	 DWORD PTR tv72[ebp], 0
$LN7@IsLogMode:
  00025	8a 45 f8	 mov	 al, BYTE PTR tv72[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 72   : 	if (m_stFileName.empty())

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 04		 je	 SHORT $LN2@IsLogMode

; 73   : 		return false;

  00033	32 c0		 xor	 al, al
  00035	eb 02		 jmp	 SHORT $LN1@IsLogMode
$LN2@IsLogMode:

; 74   : 
; 75   : 	return true;

  00037	b0 01		 mov	 al, 1
$LN1@IsLogMode:

; 76   : }

  00039	c9		 leave
  0003a	c3		 ret	 0
?__IsLogMode@CMakePackLog@@AAE_NXZ ENDP			; CMakePackLog::__IsLogMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?__WriteError@CMakePackLog@@AAEXPBDH@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_c_szBuf$ = 8						; size = 4
_nBufLen$ = 12						; size = 4
?__WriteError@CMakePackLog@@AAEXPBDH@Z PROC		; CMakePackLog::__WriteError, COMDAT
; _this$ = ecx

; 174  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 175  : 	if (!__IsLogMode())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?__IsLogMode@CMakePackLog@@AAE_NXZ ; CMakePackLog::__IsLogMode
  00010	0f b6 c0	 movzx	 eax, al
  00013	85 c0		 test	 eax, eax
  00015	75 02		 jne	 SHORT $LN2@WriteError

; 176  : 		return;

  00017	eb 51		 jmp	 SHORT $LN1@WriteError
$LN2@WriteError:

; 177  : 
; 178  : 	if (NULL==m_fp_err)

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00020	75 23		 jne	 SHORT $LN3@WriteError
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 20	 add	 ecx, 32			; 00000020H
  00028	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0002d	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 179  : 		m_fp_err=fopen(m_stErrorFileName.c_str(), "w");

  00030	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  00035	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00038	e8 00 00 00 00	 call	 _fopen
  0003d	59		 pop	 ecx
  0003e	59		 pop	 ecx
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN3@WriteError:

; 180  : 
; 181  : 	fwrite(c_szBuf, nBufLen, 1, m_fp_err);

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	ff 70 04	 push	 DWORD PTR [eax+4]
  0004b	6a 01		 push	 1
  0004d	ff 75 0c	 push	 DWORD PTR _nBufLen$[ebp]
  00050	ff 75 08	 push	 DWORD PTR _c_szBuf$[ebp]
  00053	e8 00 00 00 00	 call	 _fwrite
  00058	83 c4 10	 add	 esp, 16			; 00000010H

; 182  : 
; 183  : 	printf("Error: %s", c_szBuf);

  0005b	ff 75 08	 push	 DWORD PTR _c_szBuf$[ebp]
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_09BOOFBHDC@Error?3?5?$CFs@
  00063	e8 00 00 00 00	 call	 _printf
  00068	59		 pop	 ecx
  00069	59		 pop	 ecx
$LN1@WriteError:

; 184  : }

  0006a	c9		 leave
  0006b	c2 08 00	 ret	 8
?__WriteError@CMakePackLog@@AAEXPBDH@Z ENDP		; CMakePackLog::__WriteError
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?__Write@CMakePackLog@@AAEXPBDH@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_c_szBuf$ = 8						; size = 4
_nBufLen$ = 12						; size = 4
?__Write@CMakePackLog@@AAEXPBDH@Z PROC			; CMakePackLog::__Write, COMDAT
; _this$ = ecx

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 	if (!__IsLogMode())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?__IsLogMode@CMakePackLog@@AAE_NXZ ; CMakePackLog::__IsLogMode
  00010	0f b6 c0	 movzx	 eax, al
  00013	85 c0		 test	 eax, eax
  00015	75 02		 jne	 SHORT $LN2@Write

; 121  : 		return;

  00017	eb 4e		 jmp	 SHORT $LN1@Write
$LN2@Write:

; 122  : 
; 123  : 	if (NULL==m_fp)

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001f	75 22		 jne	 SHORT $LN3@Write
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 08	 add	 ecx, 8
  00027	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0002c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 124  : 		m_fp=fopen(m_stFileName.c_str(), "w");

  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w@
  00034	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00037	e8 00 00 00 00	 call	 _fopen
  0003c	59		 pop	 ecx
  0003d	59		 pop	 ecx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@Write:

; 125  : 
; 126  : 	fwrite(c_szBuf, nBufLen, 1, m_fp);

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	ff 30		 push	 DWORD PTR [eax]
  00048	6a 01		 push	 1
  0004a	ff 75 0c	 push	 DWORD PTR _nBufLen$[ebp]
  0004d	ff 75 08	 push	 DWORD PTR _c_szBuf$[ebp]
  00050	e8 00 00 00 00	 call	 _fwrite
  00055	83 c4 10	 add	 esp, 16			; 00000010H

; 127  : 
; 128  : 	printf("%s", c_szBuf);

  00058	ff 75 08	 push	 DWORD PTR _c_szBuf$[ebp]
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00060	e8 00 00 00 00	 call	 _printf
  00065	59		 pop	 ecx
  00066	59		 pop	 ecx
$LN1@Write:

; 129  : }

  00067	c9		 leave
  00068	c2 08 00	 ret	 8
?__Write@CMakePackLog@@AAEXPBDH@Z ENDP			; CMakePackLog::__Write
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?FlushError@CMakePackLog@@QAEXXZ
_TEXT	SEGMENT
_iFile$ = -292						; size = 184
$T2 = -108						; size = 8
$T3 = -100						; size = 4
$T4 = -96						; size = 4
$T5 = -92						; size = 4
$T6 = -88						; size = 4
$T7 = -84						; size = 4
$T8 = -80						; size = 4
$T9 = -76						; size = 4
_this$ = -72						; size = 4
$T10 = -68						; size = 4
_this$ = -64						; size = 4
_oit$ = -60						; size = 8
$T11 = -52						; size = 4
$T12 = -48						; size = 4
$T13 = -44						; size = 4
___param0$ = -40					; size = 4
$T14 = -36						; size = 4
___param0$ = -32					; size = 4
$T15 = -28						; size = 4
$T16 = -24						; size = 4
$T17 = -20						; size = 4
___param0$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
$T18 = 0						; size = 4
___param0$ = 4						; size = 4
$T19 = 8						; size = 4
$T20 = 12						; size = 4
$T21 = 16						; size = 4
$T22 = 20						; size = 4
_vText$ = 24						; size = 12
__My_data$23 = 36					; size = 4
__My_data$24 = 40					; size = 4
__My_data$25 = 44					; size = 4
__My_data$26 = 48					; size = 4
_this$ = 52						; size = 4
_this$ = 56						; size = 4
_eos$ = 60						; size = 28
_iit$ = 88						; size = 28
__$ArrayPad$ = 116					; size = 4
?FlushError@CMakePackLog@@QAEXXZ PROC			; CMakePackLog::FlushError, COMDAT
; _this$ = ecx

; 187  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	83 ec 78	 sub	 esp, 120		; 00000078H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?FlushError@CMakePackLog@@QAEXXZ
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 74	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	50		 push	 eax
  00027	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00030	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 188  : 	std::wifstream iFile(m_stErrorFileName.c_str());

  00033	6a 01		 push	 1
  00035	6a 40		 push	 64			; 00000040H
  00037	6a 01		 push	 1
  00039	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	83 c1 20	 add	 ecx, 32			; 00000020H
  0003f	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00044	50		 push	 eax
  00045	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _iFile$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAE@PBDHH@Z ; std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >::basic_ifstream<wchar_t,std::char_traits<wchar_t> >
  00050	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00054	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR _iFile$[ebp]
  0005a	89 45 bc	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator

; 248  :     istream_iterator(istream_type& _Istr) : _Myistr(_STD addressof(_Istr)) {

  0005d	8b 45 bc	 mov	 eax, DWORD PTR $T10[ebp]
  00060	89 45 58	 mov	 DWORD PTR _iit$[ebp], eax

; 286  :     _Ty _Myval{}; // lookahead value (valid if _Myistr is not null)

  00063	8d 4d 5c	 lea	 ecx, DWORD PTR _iit$[ebp+4]
  00066	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0006b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 249  :         _Getval();

  0006f	8d 4d 58	 lea	 ecx, DWORD PTR _iit$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Getval@?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@AAEXXZ ; std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>::_Getval
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 189  :     std::istream_iterator <std::wstring, wchar_t> iit(iFile);

  00077	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator

; 285  :     istream_type* _Myistr{nullptr}; // pointer to input stream

  0007b	83 65 3c 00	 and	 DWORD PTR _eos$[ebp], 0

; 286  :     _Ty _Myval{}; // lookahead value (valid if _Myistr is not null)

  0007f	8d 4d 40	 lea	 ecx, DWORD PTR _eos$[ebp+4]
  00082	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 190  :     std::istream_iterator <std::wstring, wchar_t> eos;

  00087	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0008b	8d 45 18	 lea	 eax, DWORD PTR _vText$[ebp]
  0008e	89 45 b8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00091	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 192  :     std::vector <std::wstring> vText;

  00099	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0009d	8d 45 18	 lea	 eax, DWORD PTR _vText$[ebp]
  000a0	89 45 14	 mov	 DWORD PTR $T22[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator

; 42   :         : container(_STD addressof(_Cont)) {}

  000a3	8b 45 14	 mov	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 10	 mov	 DWORD PTR $T21[ebp], eax

; 74   :     return back_insert_iterator<_Container>(_Cont);

  000a9	8d 45 10	 lea	 eax, DWORD PTR $T21[ebp]
  000ac	89 45 0c	 mov	 DWORD PTR $T20[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 194  :     std::copy (iit, eos, std::back_inserter(vText));

  000af	8b 45 0c	 mov	 eax, DWORD PTR $T20[ebp]
  000b2	ff 30		 push	 DWORD PTR [eax]
  000b4	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000b7	8b c4		 mov	 eax, esp
  000b9	89 65 a8	 mov	 DWORD PTR $T6[ebp], esp
  000bc	89 45 38	 mov	 DWORD PTR _this$[ebp], eax
  000bf	8b 45 38	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 4d 3c	 mov	 ecx, DWORD PTR _eos$[ebp]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx
  000c7	8d 45 40	 lea	 eax, DWORD PTR _eos$[ebp+4]
  000ca	50		 push	 eax
  000cb	8b 4d 38	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	83 c1 04	 add	 ecx, 4
  000d1	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000d6	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000da	83 ec 1c	 sub	 esp, 28			; 0000001cH
  000dd	8b c4		 mov	 eax, esp
  000df	89 65 a4	 mov	 DWORD PTR $T5[ebp], esp
  000e2	89 45 34	 mov	 DWORD PTR _this$[ebp], eax
  000e5	8b 45 34	 mov	 eax, DWORD PTR _this$[ebp]
  000e8	8b 4d 58	 mov	 ecx, DWORD PTR _iit$[ebp]
  000eb	89 08		 mov	 DWORD PTR [eax], ecx
  000ed	8d 45 5c	 lea	 eax, DWORD PTR _iit$[ebp+4]
  000f0	50		 push	 eax
  000f1	8b 4d 34	 mov	 ecx, DWORD PTR _this$[ebp]
  000f4	83 c1 04	 add	 ecx, 4
  000f7	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000fc	8d 45 a0	 lea	 eax, DWORD PTR $T4[ebp]
  000ff	50		 push	 eax
  00100	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00104	e8 00 00 00 00	 call	 ??$copy@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@V?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@2@@std@@YA?AV?$back_insert_iterator@V?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@@0@V?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@0@0V10@@Z ; std::copy<std::istream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t>,int>,std::back_insert_iterator<std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
  00109	83 c4 40	 add	 esp, 64			; 00000040H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator

; 316  :         : _Mydelim(_Delim), _Myostr(_STD addressof(_Ostr)) {}

  0010c	83 65 c4 00	 and	 DWORD PTR _oit$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00110	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T19[ebp], OFFSET ?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A ; std::wcout
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\iterator

; 316  :         : _Mydelim(_Delim), _Myostr(_STD addressof(_Ostr)) {}

  00117	8b 45 08	 mov	 eax, DWORD PTR $T19[ebp]
  0011a	89 45 c8	 mov	 DWORD PTR _oit$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0011d	8d 45 18	 lea	 eax, DWORD PTR _vText$[ebp]
  00120	89 45 30	 mov	 DWORD PTR __My_data$26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00123	8b 45 30	 mov	 eax, DWORD PTR __My_data$26[ebp]
  00126	89 45 9c	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00129	8b 45 30	 mov	 eax, DWORD PTR __My_data$26[ebp]
  0012c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0012f	89 45 04	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00132	8b 45 04	 mov	 eax, DWORD PTR ___param0$[ebp]
  00135	89 45 00	 mov	 DWORD PTR $T18[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00138	8d 45 00	 lea	 eax, DWORD PTR $T18[ebp]
  0013b	89 45 e8	 mov	 DWORD PTR $T16[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0013e	8d 45 18	 lea	 eax, DWORD PTR _vText$[ebp]
  00141	89 45 2c	 mov	 DWORD PTR __My_data$25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00144	8b 45 2c	 mov	 eax, DWORD PTR __My_data$25[ebp]
  00147	89 45 b4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0014a	8b 45 2c	 mov	 eax, DWORD PTR __My_data$25[ebp]
  0014d	8b 00		 mov	 eax, DWORD PTR [eax]
  0014f	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00152	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00155	89 45 ec	 mov	 DWORD PTR $T17[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00158	8d 45 ec	 lea	 eax, DWORD PTR $T17[ebp]
  0015b	89 45 e4	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 198  :     std::sort (vText.begin(), vText.end());

  0015e	8b 45 e8	 mov	 eax, DWORD PTR $T16[ebp]
  00161	ff 30		 push	 DWORD PTR [eax]
  00163	8b 45 e4	 mov	 eax, DWORD PTR $T15[ebp]
  00166	ff 30		 push	 DWORD PTR [eax]
  00168	e8 00 00 00 00	 call	 ??$sort@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0@Z ; std::sort<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > > >
  0016d	59		 pop	 ecx
  0016e	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  0016f	8d 45 18	 lea	 eax, DWORD PTR _vText$[ebp]
  00172	89 45 28	 mov	 DWORD PTR __My_data$24[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00175	8b 45 28	 mov	 eax, DWORD PTR __My_data$24[ebp]
  00178	89 45 b0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0017b	8b 45 28	 mov	 eax, DWORD PTR __My_data$24[ebp]
  0017e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00181	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00184	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00187	89 45 dc	 mov	 DWORD PTR $T14[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0018a	8d 45 dc	 lea	 eax, DWORD PTR $T14[ebp]
  0018d	89 45 d0	 mov	 DWORD PTR $T12[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  00190	8d 45 18	 lea	 eax, DWORD PTR _vText$[ebp]
  00193	89 45 24	 mov	 DWORD PTR __My_data$23[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00196	8b 45 24	 mov	 eax, DWORD PTR __My_data$23[ebp]
  00199	89 45 ac	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0019c	8b 45 24	 mov	 eax, DWORD PTR __My_data$23[ebp]
  0019f	8b 00		 mov	 eax, DWORD PTR [eax]
  001a1	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  001a4	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  001a7	89 45 d4	 mov	 DWORD PTR $T13[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  001aa	8d 45 d4	 lea	 eax, DWORD PTR $T13[ebp]
  001ad	89 45 cc	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 199  :     std::copy (vText.begin(), vText.end(), oit);

  001b0	ff 75 c8	 push	 DWORD PTR _oit$[ebp+4]
  001b3	ff 75 c4	 push	 DWORD PTR _oit$[ebp]
  001b6	8b 45 d0	 mov	 eax, DWORD PTR $T12[ebp]
  001b9	ff 30		 push	 DWORD PTR [eax]
  001bb	8b 45 cc	 mov	 eax, DWORD PTR $T11[ebp]
  001be	ff 30		 push	 DWORD PTR [eax]
  001c0	8d 45 94	 lea	 eax, DWORD PTR $T2[ebp]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 ??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@std@@V?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@2@@std@@YA?AV?$ostream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > > >,std::ostream_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,wchar_t,std::char_traits<wchar_t> > >
  001c9	83 c4 14	 add	 esp, 20			; 00000014H

; 200  : }

  001cc	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  001d0	8d 4d 18	 lea	 ecx, DWORD PTR _vText$[ebp]
  001d3	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@AAEXXZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 200  : }

  001d8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001dc	8d 4d 40	 lea	 ecx, DWORD PTR _eos$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001df	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 200  : }

  001e4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001e8	8d 4d 5c	 lea	 ecx, DWORD PTR _iit$[ebp+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  001eb	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 200  : }

  001f0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001f4	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _iFile$[ebp]
  001fa	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
  001ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00202	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00209	59		 pop	 ecx
  0020a	8b 4d 74	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0020d	33 cd		 xor	 ecx, ebp
  0020f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00214	83 c5 78	 add	 ebp, 120		; 00000078H
  00217	c9		 leave
  00218	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$0:
  00000	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR _iFile$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@_WU?$char_traits@_W@std@@@std@@QAEXXZ
__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$10:
  0000b	8d 4d 5c	 lea	 ecx, DWORD PTR _iit$[ebp+4]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$1:
  00013	8d 4d 58	 lea	 ecx, DWORD PTR _iit$[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$2:
  0001b	8d 4d 3c	 lea	 ecx, DWORD PTR _eos$[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$3:
  00023	8d 4d 18	 lea	 ecx, DWORD PTR _vText$[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$vector@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@V?$allocator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >::~vector<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >,std::allocator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > > >
__unwindfunclet$?FlushError@CMakePackLog@@QAEXXZ$4:
  0002b	8b 4d a8	 mov	 ecx, DWORD PTR $T6[ebp]
  0002e	e9 00 00 00 00	 jmp	 ??1?$istream_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@_WU?$char_traits@_W@2@H@std@@QAE@XZ
  00033	cc		 int	 3
  00034	cc		 int	 3
  00035	cc		 int	 3
  00036	cc		 int	 3
  00037	cc		 int	 3
__ehhandler$?FlushError@CMakePackLog@@QAEXXZ:
  00038	90		 npad	 1
  00039	90		 npad	 1
  0003a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00041	8b 8a e4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-284]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b 8a 80 00 00
	00		 mov	 ecx, DWORD PTR [edx+128]
  00054	33 c8		 xor	 ecx, eax
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?FlushError@CMakePackLog@@QAEXXZ
  00060	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?FlushError@CMakePackLog@@QAEXXZ ENDP			; CMakePackLog::FlushError
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?WriteError@CMakePackLog@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_szBuf$ = 8						; size = 4
?WriteError@CMakePackLog@@QAEXPBD@Z PROC		; CMakePackLog::WriteError, COMDAT
; _this$ = ecx

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 167  : 	if (!__IsLogMode())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__IsLogMode@CMakePackLog@@AAE_NXZ ; CMakePackLog::__IsLogMode
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@WriteError

; 168  : 		return;

  00016	eb 16		 jmp	 SHORT $LN1@WriteError
$LN2@WriteError:

; 169  : 
; 170  : 	__WriteError(c_szBuf, strlen(c_szBuf)+1);

  00018	ff 75 08	 push	 DWORD PTR _c_szBuf$[ebp]
  0001b	e8 00 00 00 00	 call	 _strlen
  00020	59		 pop	 ecx
  00021	40		 inc	 eax
  00022	50		 push	 eax
  00023	ff 75 08	 push	 DWORD PTR _c_szBuf$[ebp]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?__WriteError@CMakePackLog@@AAEXPBDH@Z ; CMakePackLog::__WriteError
$LN1@WriteError:

; 171  : }

  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
?WriteError@CMakePackLog@@QAEXPBD@Z ENDP		; CMakePackLog::WriteError
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?WriteErrornf@CMakePackLog@@QAAXPBDZZ
_TEXT	SEGMENT
__Format$ = -128					; size = 4
_args$ = -124						; size = 4
$T1 = -120						; size = 4
tv133 = -116						; size = 4
__Result$2 = -112					; size = 4
_nBufLen$ = -108					; size = 4
_szBuf$ = -104						; size = 1025
__$ArrayPad$ = 924					; size = 4
_this$ = 936						; size = 4
_c_szFormat$ = 940					; size = 4
?WriteErrornf@CMakePackLog@@QAAXPBDZZ PROC		; CMakePackLog::WriteErrornf, COMDAT

; 148  : {

  00000	55		 push	 ebp
  00001	8d ac 24 60 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-928]
  00008	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 9c 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 149  : 	if (!__IsLogMode())

  0001b	8b 8d a8 03 00
	00		 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?__IsLogMode@CMakePackLog@@AAE_NXZ ; CMakePackLog::__IsLogMode
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@WriteError

; 150  : 		return;

  0002d	e9 a1 00 00 00	 jmp	 $LN4@WriteError
$LN2@WriteError:

; 151  : 
; 152  : 	va_list args;
; 153  : 	va_start(args, c_szFormat);

  00032	8d 85 b0 03 00
	00		 lea	 eax, DWORD PTR _c_szFormat$[ebp+4]
  00038	89 45 84	 mov	 DWORD PTR _args$[ebp], eax

; 156  : 	int nBufLen = _vsnprintf(szBuf, sizeof(szBuf)-1, c_szFormat, args);

  0003b	8b 85 ac 03 00
	00		 mov	 eax, DWORD PTR _c_szFormat$[ebp]
  00041	89 45 80	 mov	 DWORD PTR __Format$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00044	ff 75 84	 push	 DWORD PTR _args$[ebp]
  00047	6a 00		 push	 0
  00049	ff 75 80	 push	 DWORD PTR __Format$[ebp]
  0004c	68 00 04 00 00	 push	 1024			; 00000400H
  00051	8d 45 98	 lea	 eax, DWORD PTR _szBuf$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	83 c9 01	 or	 ecx, 1
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	50		 push	 eax
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00069	83 c4 1c	 add	 esp, 28			; 0000001cH
  0006c	89 45 90	 mov	 DWORD PTR __Result$2[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0006f	83 7d 90 00	 cmp	 DWORD PTR __Result$2[ebp], 0
  00073	7d 06		 jge	 SHORT $LN11@WriteError
  00075	83 4d 8c ff	 or	 DWORD PTR tv133[ebp], -1
  00079	eb 06		 jmp	 SHORT $LN7@WriteError
$LN11@WriteError:
  0007b	8b 45 90	 mov	 eax, DWORD PTR __Result$2[ebp]
  0007e	89 45 8c	 mov	 DWORD PTR tv133[ebp], eax
$LN7@WriteError:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 156  : 	int nBufLen = _vsnprintf(szBuf, sizeof(szBuf)-1, c_szFormat, args);

  00081	8b 45 8c	 mov	 eax, DWORD PTR tv133[ebp]
  00084	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax

; 157  : 	if (nBufLen > 0)

  00087	83 7d 94 00	 cmp	 DWORD PTR _nBufLen$[ebp], 0
  0008b	7e 34		 jle	 SHORT $LN3@WriteError

; 158  : 	{
; 159  : 		szBuf[nBufLen++] = '\n';

  0008d	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  00090	c6 44 05 98 0a	 mov	 BYTE PTR _szBuf$[ebp+eax], 10 ; 0000000aH
  00095	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  00098	40		 inc	 eax
  00099	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax

; 160  : 		szBuf[nBufLen++] = '\0';

  0009c	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  0009f	89 45 88	 mov	 DWORD PTR $T1[ebp], eax
  000a2	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  000a5	40		 inc	 eax
  000a6	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax
  000a9	81 7d 88 01 04
	00 00		 cmp	 DWORD PTR $T1[ebp], 1025 ; 00000401H
  000b0	73 02		 jae	 SHORT $LN5@WriteError
  000b2	eb 05		 jmp	 SHORT $LN6@WriteError
$LN5@WriteError:
  000b4	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN6@WriteError:
  000b9	8b 45 88	 mov	 eax, DWORD PTR $T1[ebp]
  000bc	c6 44 05 98 00	 mov	 BYTE PTR _szBuf$[ebp+eax], 0
$LN3@WriteError:

; 161  : 	}
; 162  : 	__WriteError(szBuf, nBufLen);

  000c1	ff 75 94	 push	 DWORD PTR _nBufLen$[ebp]
  000c4	8d 45 98	 lea	 eax, DWORD PTR _szBuf$[ebp]
  000c7	50		 push	 eax
  000c8	8b 8d a8 03 00
	00		 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?__WriteError@CMakePackLog@@AAEXPBDH@Z ; CMakePackLog::__WriteError
$LN4@WriteError:

; 163  : }

  000d3	8b 8d 9c 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	81 c5 a0 03 00
	00		 add	 ebp, 928		; 000003a0H
  000e6	c9		 leave
  000e7	c3		 ret	 0
?WriteErrornf@CMakePackLog@@QAAXPBDZZ ENDP		; CMakePackLog::WriteErrornf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?WriteErrorf@CMakePackLog@@QAAXPBDZZ
_TEXT	SEGMENT
__Format$ = -128					; size = 4
_args$ = -124						; size = 4
$T1 = -120						; size = 4
tv129 = -116						; size = 4
__Result$2 = -112					; size = 4
_nBufLen$ = -108					; size = 4
_szBuf$ = -104						; size = 1024
__$ArrayPad$ = 920					; size = 4
_this$ = 932						; size = 4
_c_szFormat$ = 936					; size = 4
?WriteErrorf@CMakePackLog@@QAAXPBDZZ PROC		; CMakePackLog::WriteErrorf, COMDAT

; 134  : {

  00000	55		 push	 ebp
  00001	8d ac 24 64 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-924]
  00008	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 98 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 135  : 	if (!__IsLogMode())

  0001b	8b 8d a4 03 00
	00		 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?__IsLogMode@CMakePackLog@@AAE_NXZ ; CMakePackLog::__IsLogMode
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@WriteError

; 136  : 		return;

  0002d	e9 8c 00 00 00	 jmp	 $LN3@WriteError
$LN2@WriteError:

; 137  : 
; 138  : 	va_list args;
; 139  : 	va_start(args, c_szFormat);

  00032	8d 85 ac 03 00
	00		 lea	 eax, DWORD PTR _c_szFormat$[ebp+4]
  00038	89 45 84	 mov	 DWORD PTR _args$[ebp], eax

; 142  : 	int nBufLen = _vsnprintf(szBuf, sizeof(szBuf), c_szFormat, args);

  0003b	8b 85 a8 03 00
	00		 mov	 eax, DWORD PTR _c_szFormat$[ebp]
  00041	89 45 80	 mov	 DWORD PTR __Format$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00044	ff 75 84	 push	 DWORD PTR _args$[ebp]
  00047	6a 00		 push	 0
  00049	ff 75 80	 push	 DWORD PTR __Format$[ebp]
  0004c	68 00 04 00 00	 push	 1024			; 00000400H
  00051	8d 45 98	 lea	 eax, DWORD PTR _szBuf$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	83 c9 01	 or	 ecx, 1
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	50		 push	 eax
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00069	83 c4 1c	 add	 esp, 28			; 0000001cH
  0006c	89 45 90	 mov	 DWORD PTR __Result$2[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0006f	83 7d 90 00	 cmp	 DWORD PTR __Result$2[ebp], 0
  00073	7d 06		 jge	 SHORT $LN10@WriteError
  00075	83 4d 8c ff	 or	 DWORD PTR tv129[ebp], -1
  00079	eb 06		 jmp	 SHORT $LN6@WriteError
$LN10@WriteError:
  0007b	8b 45 90	 mov	 eax, DWORD PTR __Result$2[ebp]
  0007e	89 45 8c	 mov	 DWORD PTR tv129[ebp], eax
$LN6@WriteError:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 142  : 	int nBufLen = _vsnprintf(szBuf, sizeof(szBuf), c_szFormat, args);

  00081	8b 45 8c	 mov	 eax, DWORD PTR tv129[ebp]
  00084	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax

; 143  : 	szBuf[nBufLen++] = '\0';

  00087	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  0008a	89 45 88	 mov	 DWORD PTR $T1[ebp], eax
  0008d	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  00090	40		 inc	 eax
  00091	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax
  00094	81 7d 88 00 04
	00 00		 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  0009b	73 02		 jae	 SHORT $LN4@WriteError
  0009d	eb 05		 jmp	 SHORT $LN5@WriteError
$LN4@WriteError:
  0009f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN5@WriteError:
  000a4	8b 45 88	 mov	 eax, DWORD PTR $T1[ebp]
  000a7	c6 44 05 98 00	 mov	 BYTE PTR _szBuf$[ebp+eax], 0

; 144  : 	__WriteError(szBuf, nBufLen);

  000ac	ff 75 94	 push	 DWORD PTR _nBufLen$[ebp]
  000af	8d 45 98	 lea	 eax, DWORD PTR _szBuf$[ebp]
  000b2	50		 push	 eax
  000b3	8b 8d a4 03 00
	00		 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?__WriteError@CMakePackLog@@AAEXPBDH@Z ; CMakePackLog::__WriteError
$LN3@WriteError:

; 145  : }

  000be	8b 8d 98 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c4	33 cd		 xor	 ecx, ebp
  000c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cb	81 c5 9c 03 00
	00		 add	 ebp, 924		; 0000039cH
  000d1	c9		 leave
  000d2	c3		 ret	 0
?WriteErrorf@CMakePackLog@@QAAXPBDZZ ENDP		; CMakePackLog::WriteErrorf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Write@CMakePackLog@@QAEXPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_szBuf$ = 8						; size = 4
?Write@CMakePackLog@@QAEXPBD@Z PROC			; CMakePackLog::Write, COMDAT
; _this$ = ecx

; 111  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 112  : 	if (!__IsLogMode())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__IsLogMode@CMakePackLog@@AAE_NXZ ; CMakePackLog::__IsLogMode
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@Write

; 113  : 		return;

  00016	eb 16		 jmp	 SHORT $LN1@Write
$LN2@Write:

; 114  : 
; 115  : 	__Write(c_szBuf, strlen(c_szBuf)+1);

  00018	ff 75 08	 push	 DWORD PTR _c_szBuf$[ebp]
  0001b	e8 00 00 00 00	 call	 _strlen
  00020	59		 pop	 ecx
  00021	40		 inc	 eax
  00022	50		 push	 eax
  00023	ff 75 08	 push	 DWORD PTR _c_szBuf$[ebp]
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?__Write@CMakePackLog@@AAEXPBDH@Z ; CMakePackLog::__Write
$LN1@Write:

; 116  : }

  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
?Write@CMakePackLog@@QAEXPBD@Z ENDP			; CMakePackLog::Write
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Writenf@CMakePackLog@@QAAXPBDZZ
_TEXT	SEGMENT
__Format$ = -128					; size = 4
_args$ = -124						; size = 4
$T1 = -120						; size = 4
tv133 = -116						; size = 4
__Result$2 = -112					; size = 4
_nBufLen$ = -108					; size = 4
_szBuf$ = -104						; size = 1025
__$ArrayPad$ = 924					; size = 4
_this$ = 936						; size = 4
_c_szFormat$ = 940					; size = 4
?Writenf@CMakePackLog@@QAAXPBDZZ PROC			; CMakePackLog::Writenf, COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8d ac 24 60 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-928]
  00008	81 ec 20 04 00
	00		 sub	 esp, 1056		; 00000420H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 9c 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 94   : 	if (!__IsLogMode())

  0001b	8b 8d a8 03 00
	00		 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?__IsLogMode@CMakePackLog@@AAE_NXZ ; CMakePackLog::__IsLogMode
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@Writenf

; 95   : 		return;

  0002d	e9 a1 00 00 00	 jmp	 $LN4@Writenf
$LN2@Writenf:

; 96   : 
; 97   : 	va_list args;
; 98   : 	va_start(args, c_szFormat);

  00032	8d 85 b0 03 00
	00		 lea	 eax, DWORD PTR _c_szFormat$[ebp+4]
  00038	89 45 84	 mov	 DWORD PTR _args$[ebp], eax

; 101  : 	int nBufLen = _vsnprintf(szBuf, sizeof(szBuf)-1, c_szFormat, args);

  0003b	8b 85 ac 03 00
	00		 mov	 eax, DWORD PTR _c_szFormat$[ebp]
  00041	89 45 80	 mov	 DWORD PTR __Format$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00044	ff 75 84	 push	 DWORD PTR _args$[ebp]
  00047	6a 00		 push	 0
  00049	ff 75 80	 push	 DWORD PTR __Format$[ebp]
  0004c	68 00 04 00 00	 push	 1024			; 00000400H
  00051	8d 45 98	 lea	 eax, DWORD PTR _szBuf$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	83 c9 01	 or	 ecx, 1
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	50		 push	 eax
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00069	83 c4 1c	 add	 esp, 28			; 0000001cH
  0006c	89 45 90	 mov	 DWORD PTR __Result$2[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0006f	83 7d 90 00	 cmp	 DWORD PTR __Result$2[ebp], 0
  00073	7d 06		 jge	 SHORT $LN11@Writenf
  00075	83 4d 8c ff	 or	 DWORD PTR tv133[ebp], -1
  00079	eb 06		 jmp	 SHORT $LN7@Writenf
$LN11@Writenf:
  0007b	8b 45 90	 mov	 eax, DWORD PTR __Result$2[ebp]
  0007e	89 45 8c	 mov	 DWORD PTR tv133[ebp], eax
$LN7@Writenf:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 101  : 	int nBufLen = _vsnprintf(szBuf, sizeof(szBuf)-1, c_szFormat, args);

  00081	8b 45 8c	 mov	 eax, DWORD PTR tv133[ebp]
  00084	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax

; 102  : 	if (nBufLen > 0)

  00087	83 7d 94 00	 cmp	 DWORD PTR _nBufLen$[ebp], 0
  0008b	7e 34		 jle	 SHORT $LN3@Writenf

; 103  : 	{
; 104  : 		szBuf[nBufLen++] = '\n';

  0008d	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  00090	c6 44 05 98 0a	 mov	 BYTE PTR _szBuf$[ebp+eax], 10 ; 0000000aH
  00095	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  00098	40		 inc	 eax
  00099	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax

; 105  : 		szBuf[nBufLen++] = '\0';

  0009c	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  0009f	89 45 88	 mov	 DWORD PTR $T1[ebp], eax
  000a2	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  000a5	40		 inc	 eax
  000a6	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax
  000a9	81 7d 88 01 04
	00 00		 cmp	 DWORD PTR $T1[ebp], 1025 ; 00000401H
  000b0	73 02		 jae	 SHORT $LN5@Writenf
  000b2	eb 05		 jmp	 SHORT $LN6@Writenf
$LN5@Writenf:
  000b4	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN6@Writenf:
  000b9	8b 45 88	 mov	 eax, DWORD PTR $T1[ebp]
  000bc	c6 44 05 98 00	 mov	 BYTE PTR _szBuf$[ebp+eax], 0
$LN3@Writenf:

; 106  : 	}
; 107  : 	__Write(szBuf, nBufLen);

  000c1	ff 75 94	 push	 DWORD PTR _nBufLen$[ebp]
  000c4	8d 45 98	 lea	 eax, DWORD PTR _szBuf$[ebp]
  000c7	50		 push	 eax
  000c8	8b 8d a8 03 00
	00		 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?__Write@CMakePackLog@@AAEXPBDH@Z ; CMakePackLog::__Write
$LN4@Writenf:

; 108  : }

  000d3	8b 8d 9c 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d9	33 cd		 xor	 ecx, ebp
  000db	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e0	81 c5 a0 03 00
	00		 add	 ebp, 928		; 000003a0H
  000e6	c9		 leave
  000e7	c3		 ret	 0
?Writenf@CMakePackLog@@QAAXPBDZZ ENDP			; CMakePackLog::Writenf
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Writef@CMakePackLog@@QAAXPBDZZ
_TEXT	SEGMENT
__Format$ = -128					; size = 4
_args$ = -124						; size = 4
$T1 = -120						; size = 4
tv129 = -116						; size = 4
__Result$2 = -112					; size = 4
_nBufLen$ = -108					; size = 4
_szBuf$ = -104						; size = 1024
__$ArrayPad$ = 920					; size = 4
_this$ = 932						; size = 4
_c_szFormat$ = 936					; size = 4
?Writef@CMakePackLog@@QAAXPBDZZ PROC			; CMakePackLog::Writef, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8d ac 24 64 fc
	ff ff		 lea	 ebp, DWORD PTR [esp-924]
  00008	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 98 03 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 80   : 	if (!__IsLogMode())

  0001b	8b 8d a4 03 00
	00		 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?__IsLogMode@CMakePackLog@@AAE_NXZ ; CMakePackLog::__IsLogMode
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 05		 jne	 SHORT $LN2@Writef

; 81   : 		return;

  0002d	e9 8c 00 00 00	 jmp	 $LN3@Writef
$LN2@Writef:

; 82   : 
; 83   : 	va_list args;
; 84   : 	va_start(args, c_szFormat);

  00032	8d 85 ac 03 00
	00		 lea	 eax, DWORD PTR _c_szFormat$[ebp+4]
  00038	89 45 84	 mov	 DWORD PTR _args$[ebp], eax

; 87   : 	int nBufLen = _vsnprintf(szBuf, sizeof(szBuf), c_szFormat, args);

  0003b	8b 85 a8 03 00
	00		 mov	 eax, DWORD PTR _c_szFormat$[ebp]
  00041	89 45 80	 mov	 DWORD PTR __Format$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00044	ff 75 84	 push	 DWORD PTR _args$[ebp]
  00047	6a 00		 push	 0
  00049	ff 75 80	 push	 DWORD PTR __Format$[ebp]
  0004c	68 00 04 00 00	 push	 1024			; 00000400H
  00051	8d 45 98	 lea	 eax, DWORD PTR _szBuf$[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0005a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005c	83 c9 01	 or	 ecx, 1
  0005f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00062	50		 push	 eax
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00069	83 c4 1c	 add	 esp, 28			; 0000001cH
  0006c	89 45 90	 mov	 DWORD PTR __Result$2[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0006f	83 7d 90 00	 cmp	 DWORD PTR __Result$2[ebp], 0
  00073	7d 06		 jge	 SHORT $LN10@Writef
  00075	83 4d 8c ff	 or	 DWORD PTR tv129[ebp], -1
  00079	eb 06		 jmp	 SHORT $LN6@Writef
$LN10@Writef:
  0007b	8b 45 90	 mov	 eax, DWORD PTR __Result$2[ebp]
  0007e	89 45 8c	 mov	 DWORD PTR tv129[ebp], eax
$LN6@Writef:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 87   : 	int nBufLen = _vsnprintf(szBuf, sizeof(szBuf), c_szFormat, args);

  00081	8b 45 8c	 mov	 eax, DWORD PTR tv129[ebp]
  00084	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax

; 88   : 	szBuf[nBufLen++] = '\0';

  00087	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  0008a	89 45 88	 mov	 DWORD PTR $T1[ebp], eax
  0008d	8b 45 94	 mov	 eax, DWORD PTR _nBufLen$[ebp]
  00090	40		 inc	 eax
  00091	89 45 94	 mov	 DWORD PTR _nBufLen$[ebp], eax
  00094	81 7d 88 00 04
	00 00		 cmp	 DWORD PTR $T1[ebp], 1024 ; 00000400H
  0009b	73 02		 jae	 SHORT $LN4@Writef
  0009d	eb 05		 jmp	 SHORT $LN5@Writef
$LN4@Writef:
  0009f	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN5@Writef:
  000a4	8b 45 88	 mov	 eax, DWORD PTR $T1[ebp]
  000a7	c6 44 05 98 00	 mov	 BYTE PTR _szBuf$[ebp+eax], 0

; 89   : 	__Write(szBuf, nBufLen);

  000ac	ff 75 94	 push	 DWORD PTR _nBufLen$[ebp]
  000af	8d 45 98	 lea	 eax, DWORD PTR _szBuf$[ebp]
  000b2	50		 push	 eax
  000b3	8b 8d a4 03 00
	00		 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?__Write@CMakePackLog@@AAEXPBDH@Z ; CMakePackLog::__Write
$LN3@Writef:

; 90   : }

  000be	8b 8d 98 03 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c4	33 cd		 xor	 ecx, ebp
  000c6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cb	81 c5 9c 03 00
	00		 add	 ebp, 924		; 0000039cH
  000d1	c9		 leave
  000d2	c3		 ret	 0
?Writef@CMakePackLog@@QAAXPBDZZ ENDP			; CMakePackLog::Writef
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?SetFileName@CMakePackLog@@QAEXPBD@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
$T7 = -12						; size = 4
$T8 = -8						; size = 4
_this$ = -4						; size = 4
_c_szFileName$ = 8					; size = 4
?SetFileName@CMakePackLog@@QAEXPBD@Z PROC		; CMakePackLog::SetFileName, COMDAT
; _this$ = ecx

; 37   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 f8	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00015	8b 45 f8	 mov	 eax, DWORD PTR $T8[ebp]
  00018	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001b	ff 75 f4	 push	 DWORD PTR $T7[ebp]
  0001e	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 38   : 	m_stFileName=c_szFileName;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 08	 add	 ecx, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_04FPOLKAEB@?4log@
  00031	e8 00 00 00 00	 call	 _strlen
  00036	59		 pop	 ecx
  00037	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0003a	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00040	ff 75 ec	 push	 DWORD PTR $T5[ebp]
  00043	68 00 00 00 00	 push	 OFFSET ??_C@_04FPOLKAEB@?4log@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 39   : 	m_stFileName +=".log";

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	83 c1 08	 add	 ecx, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0004e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00053	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00056	e8 00 00 00 00	 call	 _strlen
  0005b	59		 pop	 ecx
  0005c	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0005f	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00062	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00065	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  00068	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 40   : 	m_stErrorFileName = c_szFileName;

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	83 c1 20	 add	 ecx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00071	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00076	68 00 00 00 00	 push	 OFFSET ??_C@_04BKIDJPM@?4err@
  0007b	e8 00 00 00 00	 call	 _strlen
  00080	59		 pop	 ecx
  00081	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00084	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00087	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0008a	ff 75 dc	 push	 DWORD PTR $T1[ebp]
  0008d	68 00 00 00 00	 push	 OFFSET ??_C@_04BKIDJPM@?4err@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 41   : 	m_stErrorFileName += ".err";

  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	83 c1 20	 add	 ecx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00098	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 42   : }

  0009d	c9		 leave
  0009e	c2 04 00	 ret	 4
?SetFileName@CMakePackLog@@QAEXPBD@Z ENDP		; CMakePackLog::SetFileName
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ??1CMakePackLog@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CMakePackLog@@QAE@XZ PROC				; CMakePackLog::~CMakePackLog, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   : 	if (NULL!=m_fp)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 11		 je	 SHORT $LN2@CMakePackL

; 59   : 	{
; 60   : 		fclose(m_fp);

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	ff 30		 push	 DWORD PTR [eax]
  00014	e8 00 00 00 00	 call	 _fclose
  00019	59		 pop	 ecx

; 61   : 		m_fp=NULL;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 20 00	 and	 DWORD PTR [eax], 0
$LN2@CMakePackL:

; 62   : 	}
; 63   : 	if (NULL != m_fp_err)

  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00027	74 13		 je	 SHORT $LN1@CMakePackL

; 64   : 	{
; 65   : 		fclose(m_fp_err);

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	ff 70 04	 push	 DWORD PTR [eax+4]
  0002f	e8 00 00 00 00	 call	 _fclose
  00034	59		 pop	 ecx

; 66   : 		m_fp_err = NULL;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	83 60 04 00	 and	 DWORD PTR [eax+4], 0
$LN1@CMakePackL:

; 68   : }

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 20	 add	 ecx, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00042	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 68   : }

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 c1 08	 add	 ecx, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0004d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 68   : }

  00052	c9		 leave
  00053	c3		 ret	 0
??1CMakePackLog@@QAE@XZ ENDP				; CMakePackLog::~CMakePackLog
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ??0CMakePackLog@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CMakePackLog@@QAE@XZ PROC				; CMakePackLog::CMakePackLog, COMDAT
; _this$ = ecx

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 20	 add	 ecx, 32			; 00000020H
  00018	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 52   : 	m_fp=NULL;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 20 00	 and	 DWORD PTR [eax], 0

; 53   : 	m_fp_err = NULL;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 54   : }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0CMakePackLog@@QAE@XZ ENDP				; CMakePackLog::CMakePackLog
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetSingleton@CMakePackLog@@SAAAV1@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?GetSingleton@CMakePackLog@@SAAAV1@XZ PROC		; CMakePackLog::GetSingleton, COMDAT

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetSingleton@CMakePackLog@@SAAAV1@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 46   : 	static CMakePackLog s_kMakePackLog;

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00027	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0002e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4HA
  00037	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  0003d	7e 3c		 jle	 SHORT $LN2@GetSinglet
  0003f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4HA
  00044	e8 00 00 00 00	 call	 __Init_thread_header
  00049	59		 pop	 ecx
  0004a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4HA, -1
  00051	75 28		 jne	 SHORT $LN2@GetSinglet
  00053	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4V2@A
  0005c	e8 00 00 00 00	 call	 ??0CMakePackLog@@QAE@XZ	; CMakePackLog::CMakePackLog
  00061	68 00 00 00 00	 push	 OFFSET ??__Fs_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV1@XZ@YAXXZ ; `CMakePackLog::GetSingleton'::`2'::`dynamic atexit destructor for 's_kMakePackLog''
  00066	e8 00 00 00 00	 call	 _atexit
  0006b	59		 pop	 ecx
  0006c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00070	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4HA
  00075	e8 00 00 00 00	 call	 __Init_thread_footer
  0007a	59		 pop	 ecx
$LN2@GetSinglet:

; 47   : 	return s_kMakePackLog;

  0007b	b8 00 00 00 00	 mov	 eax, OFFSET ?s_kMakePackLog@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4V2@A

; 48   : }

  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	c9		 leave
  0008c	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetSingleton@CMakePackLog@@SAAAV1@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??GetSingleton@CMakePackLog@@SAAAV2@XZ@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?GetSingleton@CMakePackLog@@SAAAV1@XZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetSingleton@CMakePackLog@@SAAAV1@XZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetSingleton@CMakePackLog@@SAAAV1@XZ ENDP		; CMakePackLog::GetSingleton
; Function compile flags: /Odspy
;	COMDAT ??_GCEterPack@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCEterPack@@UAEPAXI@Z PROC				; CEterPack::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CEterPack@@UAE@XZ	; CEterPack::~CEterPack
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 ec 13 00 00	 push	 5100			; 000013ecH
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCEterPack@@UAEPAXI@Z ENDP				; CEterPack::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z
_TEXT	SEGMENT
$T2 = -1412						; size = 4
$T3 = -1408						; size = 4
$T4 = -1404						; size = 4
$T5 = -1400						; size = 4
$T6 = -1396						; size = 4
_this$ = -1392						; size = 4
$T7 = -1388						; size = 4
tv181 = -1384						; size = 4
$T8 = -1380						; size = 4
tv174 = -1376						; size = 4
tv135 = -1372						; size = 4
_this$ = -1368						; size = 4
$T9 = -1364						; size = 4
$T10 = -1359						; size = 1
$T11 = -1358						; size = 1
$T12 = -1357						; size = 1
_cryptSize$ = -1356					; size = 4
_Encryptor$ = -1352					; size = 1216
$T13 = -132						; size = 56
_tmp$ = -76						; size = 24
_key$ = -52						; size = 32
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 4
_data$ = 12						; size = 4
_dataSize$ = 16						; size = 4
_zObj$ = 20						; size = 4
?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z PROC ; CEterPack::__Encrypt_Panama, COMDAT
; _this$ = ecx

; 1440 : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	83 e4 f8	 and	 esp, -8			; fffffff8H
  00008	83 c4 04	 add	 esp, 4
  0000b	55		 push	 ebp
  0000c	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000f	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00013	8b ec		 mov	 ebp, esp
  00015	6a ff		 push	 -1
  00017	68 00 00 00 00	 push	 __ehhandler$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z
  0001c	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00022	50		 push	 eax
  00023	53		 push	 ebx
  00024	81 ec 78 05 00
	00		 sub	 esp, 1400		; 00000578H
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 8d a8 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00044	8b 85 a8 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 80 e4 13 00
	00		 mov	 eax, DWORD PTR [eax+5092]
  00050	89 85 94 fa ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1441 : 	if (32 != m_stIV_Panama.length())

  00056	83 bd 94 fa ff
	ff 20		 cmp	 DWORD PTR $T7[ebp], 32	; 00000020H
  0005d	74 07		 je	 SHORT $LN2@Encrypt_Pa

; 1442 : 	{
; 1443 : 		//        
; 1444 : #ifdef _DEBUG
; 1445 : 		TraceError("IV not set (filename: %s)", filename);
; 1446 : #endif
; 1447 : 		return false;

  0005f	32 c0		 xor	 al, al
  00061	e9 b6 02 00 00	 jmp	 $LN1@Encrypt_Pa
$LN2@Encrypt_Pa:

; 1448 : 	}
; 1449 : 
; 1450 : 	CryptoPP::PanamaCipher<CryptoPP::LittleEndian>::Encryption Encryptor;

  00066	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Encryptor$[ebp]
  0006c	e8 00 00 00 00	 call	 ??0?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@QAE@XZ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >
  00071	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1451 : 
; 1452 : 	if (dataSize < Encryptor.MandatoryBlockSize())

  00075	83 7b 10 01	 cmp	 DWORD PTR _dataSize$[ebx], 1
  00079	73 21		 jae	 SHORT $LN3@Encrypt_Pa

; 1453 : 	{
; 1454 : #ifdef _DEBUG
; 1455 : 		TraceError("Type 3 pack file must be bigger than %u bytes (filename: %s)", Encryptor.MandatoryBlockSize(), filename);
; 1456 : #endif
; 1457 : 		return false;

  0007b	c6 85 b3 fa ff
	ff 00		 mov	 BYTE PTR $T12[ebp], 0
  00082	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00086	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Encryptor$[ebp]
  0008c	e8 00 00 00 00	 call	 ??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ
  00091	8a 85 b3 fa ff
	ff		 mov	 al, BYTE PTR $T12[ebp]
  00097	e9 80 02 00 00	 jmp	 $LN1@Encrypt_Pa
$LN3@Encrypt_Pa:

; 1458 : 	}
; 1459 : 
; 1460 : 	BYTE key[32];
; 1461 : 
; 1462 : 	__CreateFileNameKey_Panama(filename, key, sizeof(key));

  0009c	6a 20		 push	 32			; 00000020H
  0009e	8d 45 cc	 lea	 eax, DWORD PTR _key$[ebp]
  000a1	50		 push	 eax
  000a2	ff 73 08	 push	 DWORD PTR _filename$[ebx]
  000a5	8b 8d a8 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	e8 00 00 00 00	 call	 ?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z ; CEterPack::__CreateFileNameKey_Panama

; 1463 : 	Encryptor.SetKeyWithIV(key, sizeof(key), (const BYTE*) m_stIV_Panama.c_str(), 32);

  000b0	6a 20		 push	 32			; 00000020H
  000b2	8b 8d a8 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000b8	81 c1 d4 13 00
	00		 add	 ecx, 5076		; 000013d4H
  000be	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000c3	50		 push	 eax
  000c4	6a 20		 push	 32			; 00000020H
  000c6	8d 45 cc	 lea	 eax, DWORD PTR _key$[ebp]
  000c9	50		 push	 eax
  000ca	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Encryptor$[ebp]
  000d0	e8 00 00 00 00	 call	 ?SetKeyWithIV@SimpleKeyingInterface@CryptoPP@@QAEXPBEI0I@Z ; CryptoPP::SimpleKeyingInterface::SetKeyWithIV

; 1464 : 
; 1465 : 	// MandatoryBlockSize     2048 
; 1466 : 	DWORD cryptSize = dataSize - (dataSize % Encryptor.MandatoryBlockSize());

  000d5	8b 43 10	 mov	 eax, DWORD PTR _dataSize$[ebx]
  000d8	33 d2		 xor	 edx, edx
  000da	33 c9		 xor	 ecx, ecx
  000dc	41		 inc	 ecx
  000dd	f7 f1		 div	 ecx
  000df	8b 43 10	 mov	 eax, DWORD PTR _dataSize$[ebx]
  000e2	2b c2		 sub	 eax, edx
  000e4	89 85 b4 fa ff
	ff		 mov	 DWORD PTR _cryptSize$[ebp], eax

; 1467 : 	cryptSize = cryptSize > 2048 ? 2048 : cryptSize;

  000ea	81 bd b4 fa ff
	ff 00 08 00 00	 cmp	 DWORD PTR _cryptSize$[ebp], 2048 ; 00000800H
  000f4	76 0c		 jbe	 SHORT $LN7@Encrypt_Pa
  000f6	c7 85 a4 fa ff
	ff 00 08 00 00	 mov	 DWORD PTR tv135[ebp], 2048 ; 00000800H
  00100	eb 0c		 jmp	 SHORT $LN8@Encrypt_Pa
$LN7@Encrypt_Pa:
  00102	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _cryptSize$[ebp]
  00108	89 85 a4 fa ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
$LN8@Encrypt_Pa:
  0010e	8b 85 a4 fa ff
	ff		 mov	 eax, DWORD PTR tv135[ebp]
  00114	89 85 b4 fa ff
	ff		 mov	 DWORD PTR _cryptSize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0011a	8d 45 b4	 lea	 eax, DWORD PTR _tmp$[ebp]
  0011d	89 85 90 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00123	8b 8d 90 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00129	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  0012e	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  00131	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1469 : 	std::string tmp;

  00136	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1470 : 
; 1471 : 	tmp.reserve(cryptSize);

  0013a	ff b5 b4 fa ff
	ff		 push	 DWORD PTR _cryptSize$[ebp]
  00140	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  00143	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1473 : 	CryptoPP::ArraySource(data, cryptSize, true,

  00148	6a 60		 push	 96			; 00000060H
  0014a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0014f	59		 pop	 ecx
  00150	89 85 9c fa ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  00156	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0015a	83 bd 9c fa ff
	ff 00		 cmp	 DWORD PTR $T8[ebp], 0
  00161	0f 84 94 00 00
	00		 je	 $LN11@Encrypt_Pa
  00167	6a 10		 push	 16			; 00000010H
  00169	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0016e	59		 pop	 ecx
  0016f	89 85 ac fa ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  00175	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00179	83 bd ac fa ff
	ff 00		 cmp	 DWORD PTR $T9[ebp], 0
  00180	74 3e		 je	 SHORT $LN9@Encrypt_Pa
  00182	8b 8d ac fa ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  00188	e8 00 00 00 00	 call	 ??0BufferedTransformation@CryptoPP@@QAE@XZ ; CryptoPP::BufferedTransformation::BufferedTransformation
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 592  : 		: m_output(&output) {assert(sizeof(output[0])==1);}

  0018d	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00193	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@
  00199	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  0019f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@
  001a6	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  001ac	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  001af	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1473 : 	CryptoPP::ArraySource(data, cryptSize, true,

  001b2	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  001b8	89 85 a0 fa ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
  001be	eb 07		 jmp	 SHORT $LN10@Encrypt_Pa
$LN9@Encrypt_Pa:
  001c0	83 a5 a0 fa ff
	ff 00		 and	 DWORD PTR tv174[ebp], 0
$LN10@Encrypt_Pa:
  001c7	8b 85 a0 fa ff
	ff		 mov	 eax, DWORD PTR tv174[ebp]
  001cd	89 85 8c fa ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  001d3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001d7	6a 00		 push	 0
  001d9	6a 04		 push	 4
  001db	ff b5 8c fa ff
	ff		 push	 DWORD PTR $T6[ebp]
  001e1	8d 85 bc fa ff
	ff		 lea	 eax, DWORD PTR _Encryptor$[ebp+4]
  001e7	50		 push	 eax
  001e8	8b 8d 9c fa ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp]
  001ee	e8 00 00 00 00	 call	 ??0StreamTransformationFilter@CryptoPP@@QAE@AAVStreamTransformation@1@PAVBufferedTransformation@1@W4BlockPaddingScheme@BlockPaddingSchemeDef@1@_N@Z ; CryptoPP::StreamTransformationFilter::StreamTransformationFilter
  001f3	89 85 98 fa ff
	ff		 mov	 DWORD PTR tv181[ebp], eax
  001f9	eb 07		 jmp	 SHORT $LN12@Encrypt_Pa
$LN11@Encrypt_Pa:
  001fb	83 a5 98 fa ff
	ff 00		 and	 DWORD PTR tv181[ebp], 0
$LN12@Encrypt_Pa:
  00202	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR tv181[ebp]
  00208	89 85 88 fa ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  0020e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00212	ff b5 88 fa ff
	ff		 push	 DWORD PTR $T5[ebp]
  00218	6a 01		 push	 1
  0021a	ff b5 b4 fa ff
	ff		 push	 DWORD PTR _cryptSize$[ebp]
  00220	ff 73 0c	 push	 DWORD PTR _data$[ebx]
  00223	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00229	e8 00 00 00 00	 call	 ??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z ; CryptoPP::StringSource::StringSource
  0022e	8d 4d 94	 lea	 ecx, DWORD PTR $T13[ebp+24]
  00231	e8 00 00 00 00	 call	 ??1BufferedTransformation@CryptoPP@@UAE@XZ
  00236	8d 4d 88	 lea	 ecx, DWORD PTR $T13[ebp+12]
  00239	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  0023e	8b 45 c4	 mov	 eax, DWORD PTR _tmp$[ebp+16]
  00241	89 85 84 fa ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1479 : 	if (tmp.length() != cryptSize)

  00247	8b 85 84 fa ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  0024d	3b 85 b4 fa ff
	ff		 cmp	 eax, DWORD PTR _cryptSize$[ebp]
  00253	74 2d		 je	 SHORT $LN4@Encrypt_Pa

; 1484 : 		return false;

  00255	c6 85 b2 fa ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  0025c	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00260	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  00263	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1484 : 		return false;

  00268	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0026c	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Encryptor$[ebp]
  00272	e8 00 00 00 00	 call	 ??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ
  00277	8a 85 b2 fa ff
	ff		 mov	 al, BYTE PTR $T11[ebp]
  0027d	e9 9a 00 00 00	 jmp	 $LN1@Encrypt_Pa
$LN4@Encrypt_Pa:

; 1485 : 	}
; 1486 : 
; 1487 : 	zObj.AllocBuffer(dataSize);

  00282	ff 73 10	 push	 DWORD PTR _dataSize$[ebx]
  00285	8b 4b 14	 mov	 ecx, DWORD PTR _zObj$[ebx]
  00288	e8 00 00 00 00	 call	 ?AllocBuffer@CLZObject@@QAEXK@Z ; CLZObject::AllocBuffer
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  0028d	8b 43 14	 mov	 eax, DWORD PTR _zObj$[ebx]
  00290	8b 00		 mov	 eax, DWORD PTR [eax]
  00292	89 85 80 fa ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1488 : 	memcpy(zObj.GetBuffer(), tmp.c_str(), cryptSize);

  00298	ff b5 b4 fa ff
	ff		 push	 DWORD PTR _cryptSize$[ebp]
  0029e	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  002a1	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  002a6	50		 push	 eax
  002a7	ff b5 80 fa ff
	ff		 push	 DWORD PTR $T3[ebp]
  002ad	e8 00 00 00 00	 call	 _memcpy
  002b2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1489 : 
; 1490 : 	if (dataSize - cryptSize > 0)

  002b5	8b 43 10	 mov	 eax, DWORD PTR _dataSize$[ebx]
  002b8	2b 85 b4 fa ff
	ff		 sub	 eax, DWORD PTR _cryptSize$[ebp]
  002be	74 34		 je	 SHORT $LN5@Encrypt_Pa
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  002c0	8b 43 14	 mov	 eax, DWORD PTR _zObj$[ebx]
  002c3	8b 00		 mov	 eax, DWORD PTR [eax]
  002c5	89 85 7c fa ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1491 : 		memcpy(zObj.GetBuffer() + cryptSize, data + cryptSize, dataSize - cryptSize);

  002cb	8b 43 10	 mov	 eax, DWORD PTR _dataSize$[ebx]
  002ce	2b 85 b4 fa ff
	ff		 sub	 eax, DWORD PTR _cryptSize$[ebp]
  002d4	50		 push	 eax
  002d5	8b 43 0c	 mov	 eax, DWORD PTR _data$[ebx]
  002d8	03 85 b4 fa ff
	ff		 add	 eax, DWORD PTR _cryptSize$[ebp]
  002de	50		 push	 eax
  002df	8b 85 7c fa ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  002e5	03 85 b4 fa ff
	ff		 add	 eax, DWORD PTR _cryptSize$[ebp]
  002eb	50		 push	 eax
  002ec	e8 00 00 00 00	 call	 _memcpy
  002f1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@Encrypt_Pa:

; 1493 : 	return true;

  002f4	c6 85 b1 fa ff
	ff 01		 mov	 BYTE PTR $T10[ebp], 1
  002fb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002ff	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  00302	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1493 : 	return true;

  00307	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0030b	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Encryptor$[ebp]
  00311	e8 00 00 00 00	 call	 ??1?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAE@XZ
  00316	8a 85 b1 fa ff
	ff		 mov	 al, BYTE PTR $T10[ebp]
$LN1@Encrypt_Pa:

; 1494 : }

  0031c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0031f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00326	59		 pop	 ecx
  00327	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0032a	33 cd		 xor	 ecx, ebp
  0032c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00331	8b e5		 mov	 esp, ebp
  00333	5d		 pop	 ebp
  00334	8b e3		 mov	 esp, ebx
  00336	5b		 pop	 ebx
  00337	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$0:
  00000	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Encryptor$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ
__unwindfunclet$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$1:
  0000b	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$2:
  00013	6a 60		 push	 96			; 00000060H
  00015	ff b5 9c fa ff
	ff		 push	 DWORD PTR $T8[ebp]
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00020	59		 pop	 ecx
  00021	59		 pop	 ecx
  00022	c3		 ret	 0
__unwindfunclet$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$3:
  00023	6a 10		 push	 16			; 00000010H
  00025	ff b5 ac fa ff
	ff		 push	 DWORD PTR $T9[ebp]
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx
  00032	c3		 ret	 0
  00033	cc		 int	 3
  00034	cc		 int	 3
  00035	cc		 int	 3
  00036	cc		 int	 3
  00037	cc		 int	 3
__ehhandler$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z:
  00038	90		 npad	 1
  00039	90		 npad	 1
  0003a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00041	8b 8a 80 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1408]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00051	33 c8		 xor	 ecx, eax
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z
  0005d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z ENDP ; CEterPack::__Encrypt_Panama
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z
_TEXT	SEGMENT
$T2 = -1412						; size = 4
$T3 = -1408						; size = 4
$T4 = -1404						; size = 4
$T5 = -1400						; size = 4
$T6 = -1396						; size = 4
_this$ = -1392						; size = 4
$T7 = -1388						; size = 4
tv174 = -1384						; size = 4
$T8 = -1380						; size = 4
tv167 = -1376						; size = 4
tv128 = -1372						; size = 4
_this$ = -1368						; size = 4
$T9 = -1364						; size = 4
$T10 = -1358						; size = 1
$T11 = -1357						; size = 1
_cryptSize$ = -1356					; size = 4
_Decryptor$ = -1352					; size = 1216
$T12 = -132						; size = 56
_tmp$ = -76						; size = 24
_key$ = -52						; size = 32
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_filename$ = 8						; size = 4
_data$ = 12						; size = 4
_dataSize$ = 16						; size = 4
_zObj$ = 20						; size = 4
?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z PROC ; CEterPack::__Decrypt_Panama, COMDAT
; _this$ = ecx

; 1497 : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	83 e4 f8	 and	 esp, -8			; fffffff8H
  00008	83 c4 04	 add	 esp, 4
  0000b	55		 push	 ebp
  0000c	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  0000f	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00013	8b ec		 mov	 ebp, esp
  00015	6a ff		 push	 -1
  00017	68 00 00 00 00	 push	 __ehhandler$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z
  0001c	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00022	50		 push	 eax
  00023	53		 push	 ebx
  00024	81 ec 78 05 00
	00		 sub	 esp, 1400		; 00000578H
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00034	50		 push	 eax
  00035	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00038	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003e	89 8d a8 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00044	8b 85 a8 fa ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 80 e4 13 00
	00		 mov	 eax, DWORD PTR [eax+5092]
  00050	89 85 94 fa ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1498 : 	if (32 != m_stIV_Panama.length())

  00056	83 bd 94 fa ff
	ff 20		 cmp	 DWORD PTR $T7[ebp], 32	; 00000020H
  0005d	74 07		 je	 SHORT $LN2@Decrypt_Pa

; 1499 : 	{
; 1500 : 		//        
; 1501 : #ifdef _DEBUG
; 1502 : 		TraceError("IV not set (filename: %s)", filename);
; 1503 : #endif
; 1504 : 		return false;

  0005f	32 c0		 xor	 al, al
  00061	e9 8f 02 00 00	 jmp	 $LN1@Decrypt_Pa
$LN2@Decrypt_Pa:

; 1505 : 	}
; 1506 : 
; 1507 : 	CryptoPP::PanamaCipher<CryptoPP::LittleEndian>::Decryption Decryptor;

  00066	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Decryptor$[ebp]
  0006c	e8 00 00 00 00	 call	 ??0?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@QAE@XZ ; CryptoPP::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >::SymmetricCipherFinal<CryptoPP::ConcretePolicyHolder<CryptoPP::PanamaCipherPolicy<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> >,CryptoPP::AdditiveCipherTemplate<CryptoPP::AbstractPolicyHolder<CryptoPP::AdditiveCipherAbstractPolicy,CryptoPP::SymmetricCipher> >,CryptoPP::AdditiveCipherAbstractPolicy>,CryptoPP::PanamaCipherInfo<CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0> > >
  00071	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1508 : 
; 1509 : 	BYTE key[32];
; 1510 : 
; 1511 : 	__CreateFileNameKey_Panama(filename, key, sizeof(key));

  00075	6a 20		 push	 32			; 00000020H
  00077	8d 45 cc	 lea	 eax, DWORD PTR _key$[ebp]
  0007a	50		 push	 eax
  0007b	ff 73 08	 push	 DWORD PTR _filename$[ebx]
  0007e	8b 8d a8 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z ; CEterPack::__CreateFileNameKey_Panama

; 1512 : 	Decryptor.SetKeyWithIV(key, sizeof(key), (const BYTE*) m_stIV_Panama.c_str(), 32);

  00089	6a 20		 push	 32			; 00000020H
  0008b	8b 8d a8 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00091	81 c1 d4 13 00
	00		 add	 ecx, 5076		; 000013d4H
  00097	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0009c	50		 push	 eax
  0009d	6a 20		 push	 32			; 00000020H
  0009f	8d 45 cc	 lea	 eax, DWORD PTR _key$[ebp]
  000a2	50		 push	 eax
  000a3	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Decryptor$[ebp]
  000a9	e8 00 00 00 00	 call	 ?SetKeyWithIV@SimpleKeyingInterface@CryptoPP@@QAEXPBEI0I@Z ; CryptoPP::SimpleKeyingInterface::SetKeyWithIV

; 1513 : 
; 1514 : 	// MandatoryBlockSize     2048 
; 1515 : 	DWORD cryptSize = dataSize - (dataSize % Decryptor.MandatoryBlockSize());

  000ae	8b 43 10	 mov	 eax, DWORD PTR _dataSize$[ebx]
  000b1	33 d2		 xor	 edx, edx
  000b3	33 c9		 xor	 ecx, ecx
  000b5	41		 inc	 ecx
  000b6	f7 f1		 div	 ecx
  000b8	8b 43 10	 mov	 eax, DWORD PTR _dataSize$[ebx]
  000bb	2b c2		 sub	 eax, edx
  000bd	89 85 b4 fa ff
	ff		 mov	 DWORD PTR _cryptSize$[ebp], eax

; 1516 : 	cryptSize = cryptSize > 2048 ? 2048 : cryptSize;

  000c3	81 bd b4 fa ff
	ff 00 08 00 00	 cmp	 DWORD PTR _cryptSize$[ebp], 2048 ; 00000800H
  000cd	76 0c		 jbe	 SHORT $LN6@Decrypt_Pa
  000cf	c7 85 a4 fa ff
	ff 00 08 00 00	 mov	 DWORD PTR tv128[ebp], 2048 ; 00000800H
  000d9	eb 0c		 jmp	 SHORT $LN7@Decrypt_Pa
$LN6@Decrypt_Pa:
  000db	8b 85 b4 fa ff
	ff		 mov	 eax, DWORD PTR _cryptSize$[ebp]
  000e1	89 85 a4 fa ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
$LN7@Decrypt_Pa:
  000e7	8b 85 a4 fa ff
	ff		 mov	 eax, DWORD PTR tv128[ebp]
  000ed	89 85 b4 fa ff
	ff		 mov	 DWORD PTR _cryptSize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  000f3	8d 45 b4	 lea	 eax, DWORD PTR _tmp$[ebp]
  000f6	89 85 90 fa ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  000fc	8b 8d 90 fa ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00102	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00107	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  0010a	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1518 : 	std::string tmp;

  0010f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 1519 : 
; 1520 : 	tmp.reserve(cryptSize);

  00113	ff b5 b4 fa ff
	ff		 push	 DWORD PTR _cryptSize$[ebp]
  00119	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  0011c	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1522 : 	CryptoPP::ArraySource(data, cryptSize, true,

  00121	6a 60		 push	 96			; 00000060H
  00123	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00128	59		 pop	 ecx
  00129	89 85 9c fa ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  0012f	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00133	83 bd 9c fa ff
	ff 00		 cmp	 DWORD PTR $T8[ebp], 0
  0013a	0f 84 94 00 00
	00		 je	 $LN10@Decrypt_Pa
  00140	6a 10		 push	 16			; 00000010H
  00142	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00147	59		 pop	 ecx
  00148	89 85 ac fa ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  0014e	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00152	83 bd ac fa ff
	ff 00		 cmp	 DWORD PTR $T9[ebp], 0
  00159	74 3e		 je	 SHORT $LN8@Decrypt_Pa
  0015b	8b 8d ac fa ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  00161	e8 00 00 00 00	 call	 ??0BufferedTransformation@CryptoPP@@QAE@XZ ; CryptoPP::BufferedTransformation::BufferedTransformation
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 592  : 		: m_output(&output) {assert(sizeof(output[0])==1);}

  00166	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  0016c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BAlgorithm@1@@
  00172	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00178	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7?$StringSinkTemplate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@CryptoPP@@6BWaitable@1@@
  0017f	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00185	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  00188	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1522 : 	CryptoPP::ArraySource(data, cryptSize, true,

  0018b	8b 85 ac fa ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00191	89 85 a0 fa ff
	ff		 mov	 DWORD PTR tv167[ebp], eax
  00197	eb 07		 jmp	 SHORT $LN9@Decrypt_Pa
$LN8@Decrypt_Pa:
  00199	83 a5 a0 fa ff
	ff 00		 and	 DWORD PTR tv167[ebp], 0
$LN9@Decrypt_Pa:
  001a0	8b 85 a0 fa ff
	ff		 mov	 eax, DWORD PTR tv167[ebp]
  001a6	89 85 8c fa ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  001ac	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001b0	6a 00		 push	 0
  001b2	6a 04		 push	 4
  001b4	ff b5 8c fa ff
	ff		 push	 DWORD PTR $T6[ebp]
  001ba	8d 85 bc fa ff
	ff		 lea	 eax, DWORD PTR _Decryptor$[ebp+4]
  001c0	50		 push	 eax
  001c1	8b 8d 9c fa ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp]
  001c7	e8 00 00 00 00	 call	 ??0StreamTransformationFilter@CryptoPP@@QAE@AAVStreamTransformation@1@PAVBufferedTransformation@1@W4BlockPaddingScheme@BlockPaddingSchemeDef@1@_N@Z ; CryptoPP::StreamTransformationFilter::StreamTransformationFilter
  001cc	89 85 98 fa ff
	ff		 mov	 DWORD PTR tv174[ebp], eax
  001d2	eb 07		 jmp	 SHORT $LN11@Decrypt_Pa
$LN10@Decrypt_Pa:
  001d4	83 a5 98 fa ff
	ff 00		 and	 DWORD PTR tv174[ebp], 0
$LN11@Decrypt_Pa:
  001db	8b 85 98 fa ff
	ff		 mov	 eax, DWORD PTR tv174[ebp]
  001e1	89 85 88 fa ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  001e7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001eb	ff b5 88 fa ff
	ff		 push	 DWORD PTR $T5[ebp]
  001f1	6a 01		 push	 1
  001f3	ff b5 b4 fa ff
	ff		 push	 DWORD PTR _cryptSize$[ebp]
  001f9	ff 73 0c	 push	 DWORD PTR _data$[ebx]
  001fc	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00202	e8 00 00 00 00	 call	 ??0StringSource@CryptoPP@@QAE@PBEI_NPAVBufferedTransformation@1@@Z ; CryptoPP::StringSource::StringSource
  00207	8d 4d 94	 lea	 ecx, DWORD PTR $T12[ebp+24]
  0020a	e8 00 00 00 00	 call	 ??1BufferedTransformation@CryptoPP@@UAE@XZ
  0020f	8d 4d 88	 lea	 ecx, DWORD PTR $T12[ebp+12]
  00212	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00217	8b 45 c4	 mov	 eax, DWORD PTR _tmp$[ebp+16]
  0021a	89 85 84 fa ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1528 : 	if (tmp.length() != cryptSize)

  00220	8b 85 84 fa ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  00226	3b 85 b4 fa ff
	ff		 cmp	 eax, DWORD PTR _cryptSize$[ebp]
  0022c	74 2d		 je	 SHORT $LN3@Decrypt_Pa

; 1533 : 		return false;

  0022e	c6 85 b3 fa ff
	ff 00		 mov	 BYTE PTR $T11[ebp], 0
  00235	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00239	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  0023c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1533 : 		return false;

  00241	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00245	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Decryptor$[ebp]
  0024b	e8 00 00 00 00	 call	 ??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ
  00250	8a 85 b3 fa ff
	ff		 mov	 al, BYTE PTR $T11[ebp]
  00256	e9 9a 00 00 00	 jmp	 $LN1@Decrypt_Pa
$LN3@Decrypt_Pa:

; 1534 : 	}
; 1535 : 
; 1536 : 	zObj.AllocBuffer(dataSize);

  0025b	ff 73 10	 push	 DWORD PTR _dataSize$[ebx]
  0025e	8b 4b 14	 mov	 ecx, DWORD PTR _zObj$[ebx]
  00261	e8 00 00 00 00	 call	 ?AllocBuffer@CLZObject@@QAEXK@Z ; CLZObject::AllocBuffer
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  00266	8b 43 14	 mov	 eax, DWORD PTR _zObj$[ebx]
  00269	8b 00		 mov	 eax, DWORD PTR [eax]
  0026b	89 85 80 fa ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1537 : 	memcpy(zObj.GetBuffer(), tmp.c_str(), cryptSize);

  00271	ff b5 b4 fa ff
	ff		 push	 DWORD PTR _cryptSize$[ebp]
  00277	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  0027a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0027f	50		 push	 eax
  00280	ff b5 80 fa ff
	ff		 push	 DWORD PTR $T3[ebp]
  00286	e8 00 00 00 00	 call	 _memcpy
  0028b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1538 : 
; 1539 : 	if (dataSize - cryptSize > 0)

  0028e	8b 43 10	 mov	 eax, DWORD PTR _dataSize$[ebx]
  00291	2b 85 b4 fa ff
	ff		 sub	 eax, DWORD PTR _cryptSize$[ebp]
  00297	74 34		 je	 SHORT $LN4@Decrypt_Pa
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  00299	8b 43 14	 mov	 eax, DWORD PTR _zObj$[ebx]
  0029c	8b 00		 mov	 eax, DWORD PTR [eax]
  0029e	89 85 7c fa ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1540 : 		memcpy(zObj.GetBuffer() + cryptSize, data + cryptSize, dataSize - cryptSize);

  002a4	8b 43 10	 mov	 eax, DWORD PTR _dataSize$[ebx]
  002a7	2b 85 b4 fa ff
	ff		 sub	 eax, DWORD PTR _cryptSize$[ebp]
  002ad	50		 push	 eax
  002ae	8b 43 0c	 mov	 eax, DWORD PTR _data$[ebx]
  002b1	03 85 b4 fa ff
	ff		 add	 eax, DWORD PTR _cryptSize$[ebp]
  002b7	50		 push	 eax
  002b8	8b 85 7c fa ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  002be	03 85 b4 fa ff
	ff		 add	 eax, DWORD PTR _cryptSize$[ebp]
  002c4	50		 push	 eax
  002c5	e8 00 00 00 00	 call	 _memcpy
  002ca	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@Decrypt_Pa:

; 1542 : 	return true;

  002cd	c6 85 b2 fa ff
	ff 01		 mov	 BYTE PTR $T10[ebp], 1
  002d4	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  002d8	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  002db	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1542 : 	return true;

  002e0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  002e4	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Decryptor$[ebp]
  002ea	e8 00 00 00 00	 call	 ??1?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@UAE@XZ
  002ef	8a 85 b2 fa ff
	ff		 mov	 al, BYTE PTR $T10[ebp]
$LN1@Decrypt_Pa:

; 1543 : }

  002f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002ff	59		 pop	 ecx
  00300	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00303	33 cd		 xor	 ecx, ebp
  00305	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0030a	8b e5		 mov	 esp, ebp
  0030c	5d		 pop	 ebp
  0030d	8b e3		 mov	 esp, ebx
  0030f	5b		 pop	 ebx
  00310	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$0:
  00000	8d 8d b8 fa ff
	ff		 lea	 ecx, DWORD PTR _Decryptor$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$SymmetricCipherFinal@V?$ConcretePolicyHolder@V?$PanamaCipherPolicy@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@CryptoPP@@V?$AdditiveCipherTemplate@V?$AbstractPolicyHolder@UAdditiveCipherAbstractPolicy@CryptoPP@@VSymmetricCipher@2@@CryptoPP@@@2@UAdditiveCipherAbstractPolicy@2@@CryptoPP@@U?$PanamaCipherInfo@U?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@@2@@CryptoPP@@UAE@XZ
__unwindfunclet$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$1:
  0000b	8d 4d b4	 lea	 ecx, DWORD PTR _tmp$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$2:
  00013	6a 60		 push	 96			; 00000060H
  00015	ff b5 9c fa ff
	ff		 push	 DWORD PTR $T8[ebp]
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00020	59		 pop	 ecx
  00021	59		 pop	 ecx
  00022	c3		 ret	 0
__unwindfunclet$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z$3:
  00023	6a 10		 push	 16			; 00000010H
  00025	ff b5 ac fa ff
	ff		 push	 DWORD PTR $T9[ebp]
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx
  00032	c3		 ret	 0
  00033	cc		 int	 3
  00034	cc		 int	 3
  00035	cc		 int	 3
  00036	cc		 int	 3
  00037	cc		 int	 3
__ehhandler$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z:
  00038	90		 npad	 1
  00039	90		 npad	 1
  0003a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00041	8b 8a 80 fa ff
	ff		 mov	 ecx, DWORD PTR [edx-1408]
  00047	33 c8		 xor	 ecx, eax
  00049	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004e	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00051	33 c8		 xor	 ecx, eax
  00053	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00058	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z
  0005d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z ENDP ; CEterPack::__Decrypt_Panama
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z
_TEXT	SEGMENT
_this$ = -92						; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
_idx2$ = -80						; size = 4
$T4 = -76						; size = 4
$T5 = -72						; size = 4
_idx$ = -68						; size = 4
$T6 = -64						; size = 4
tv277 = -60						; size = 4
$T7 = -56						; size = 4
tv274 = -52						; size = 4
tv210 = -48						; size = 4
$T8 = -44						; size = 4
tv207 = -40						; size = 4
tv216 = -36						; size = 4
tv150 = -32						; size = 4
_hm2$ = -28						; size = 4
_hm1$ = -24						; size = 4
$T9 = -20						; size = 4
$T10 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T11 = 0						; size = 56
$T12 = 56						; size = 56
_SrcStringForKey$ = 112					; size = 24
__$ArrayPad$ = 136					; size = 4
_filename$ = 148					; size = 4
_key$ = 152						; size = 4
_keySize$ = 156						; size = 4
?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z PROC ; CEterPack::__CreateFileNameKey_Panama, COMDAT
; _this$ = ecx

; 1364 : {

  00000	55		 push	 ebp
  00001	8d ac 24 74 ff
	ff ff		 lea	 ebp, DWORD PTR [esp-140]
  00008	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 50	 sub	 esp, 80			; 00000050H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 88 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 1365 : 	//  
; 1366 : 	if (keySize != 32)

  00039	83 bd 9c 00 00
	00 20		 cmp	 DWORD PTR _keySize$[ebp], 32 ; 00000020H
  00040	74 05		 je	 SHORT $LN10@CreateFile

; 1367 : 		return;

  00042	e9 fc 03 00 00	 jmp	 $LN1@CreateFile
$LN10@CreateFile:

; 1368 : 
; 1369 : 	std::string SrcStringForKey(filename);

  00047	ff b5 94 00 00
	00		 push	 DWORD PTR _filename$[ebp]
  0004d	8d 4d 70	 lea	 ecx, DWORD PTR _SrcStringForKey$[ebp]
  00050	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00055	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00059	8b 85 80 00 00
	00		 mov	 eax, DWORD PTR _SrcStringForKey$[ebp+16]
  0005f	89 45 c0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1370 : 	unsigned int idx = GetCRC32(SrcStringForKey.c_str(), SrcStringForKey.length()) & 3;

  00062	ff 75 c0	 push	 DWORD PTR $T6[ebp]
  00065	8d 4d 70	 lea	 ecx, DWORD PTR _SrcStringForKey$[ebp]
  00068	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  00073	59		 pop	 ecx
  00074	59		 pop	 ecx
  00075	83 e0 03	 and	 eax, 3
  00078	89 45 bc	 mov	 DWORD PTR _idx$[ebp], eax

; 1371 : 
; 1372 : 	CryptoPP::HashTransformation* hm1 = NULL;

  0007b	83 65 e8 00	 and	 DWORD PTR _hm1$[ebp], 0

; 1373 : 	CryptoPP::HashTransformation* hm2 = NULL;

  0007f	83 65 e4 00	 and	 DWORD PTR _hm2$[ebp], 0

; 1374 : 
; 1375 : 	static CryptoPP::Tiger tiger;

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00088	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0008f	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00092	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  00098	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  0009e	7e 46		 jle	 SHORT $LN2@CreateFile
  000a0	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  000a5	e8 00 00 00 00	 call	 __Init_thread_header
  000aa	59		 pop	 ecx
  000ab	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA, -1
  000b2	75 32		 jne	 SHORT $LN2@CreateFile
  000b4	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000b8	b9 00 00 00 00	 mov	 ecx, OFFSET ?tiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VTiger@CryptoPP@@A
  000bd	e8 00 00 00 00	 call	 ??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BI@VTiger@2@$0A@$0A@@CryptoPP@@IAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,24,CryptoPP::Tiger,0,0>
  000c2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?tiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VTiger@CryptoPP@@A, OFFSET ??_7Tiger@CryptoPP@@6B@
  000cc	68 00 00 00 00	 push	 OFFSET ??__Ftiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'tiger''
  000d1	e8 00 00 00 00	 call	 _atexit
  000d6	59		 pop	 ecx
  000d7	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000db	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  000e0	e8 00 00 00 00	 call	 __Init_thread_footer
  000e5	59		 pop	 ecx
$LN2@CreateFile:

; 1376 : 	static CryptoPP::SHA1 sha1;

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  000eb	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  000f2	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  000f5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  000fb	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00101	7e 46		 jle	 SHORT $LN3@CreateFile
  00103	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  00108	e8 00 00 00 00	 call	 __Init_thread_header
  0010d	59		 pop	 ecx
  0010e	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA, -1
  00115	75 32		 jne	 SHORT $LN3@CreateFile
  00117	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0011b	b9 00 00 00 00	 mov	 ecx, OFFSET ?sha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VSHA1@CryptoPP@@A
  00120	e8 00 00 00 00	 call	 ??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0BE@VSHA1@2@$0A@$0A@@CryptoPP@@IAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,20,CryptoPP::SHA1,0,0>
  00125	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?sha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VSHA1@CryptoPP@@A, OFFSET ??_7SHA1@CryptoPP@@6B@
  0012f	68 00 00 00 00	 push	 OFFSET ??__Fsha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'sha1''
  00134	e8 00 00 00 00	 call	 _atexit
  00139	59		 pop	 ecx
  0013a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0013e	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  00143	e8 00 00 00 00	 call	 __Init_thread_footer
  00148	59		 pop	 ecx
$LN3@CreateFile:

; 1377 : 	static CryptoPP::RIPEMD128 ripemd128;

  00149	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  0014e	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  00155	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00158	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS2@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  0015e	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  00164	7e 46		 jle	 SHORT $LN4@CreateFile
  00166	68 00 00 00 00	 push	 OFFSET ?$TSS2@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  0016b	e8 00 00 00 00	 call	 __Init_thread_header
  00170	59		 pop	 ecx
  00171	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS2@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA, -1
  00178	75 32		 jne	 SHORT $LN4@CreateFile
  0017a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0017e	b9 00 00 00 00	 mov	 ecx, OFFSET ?ripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VRIPEMD128@CryptoPP@@A
  00183	e8 00 00 00 00	 call	 ??0?$IteratedHashWithStaticTransform@IU?$EnumToType@W4ByteOrder@CryptoPP@@$0A@@CryptoPP@@$0EA@$0BA@VRIPEMD128@2@$0A@$0A@@CryptoPP@@IAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>::IteratedHashWithStaticTransform<unsigned int,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,0>,64,16,CryptoPP::RIPEMD128,0,0>
  00188	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VRIPEMD128@CryptoPP@@A, OFFSET ??_7RIPEMD128@CryptoPP@@6B@
  00192	68 00 00 00 00	 push	 OFFSET ??__Fripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'ripemd128''
  00197	e8 00 00 00 00	 call	 _atexit
  0019c	59		 pop	 ecx
  0019d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001a1	68 00 00 00 00	 push	 OFFSET ?$TSS2@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  001a6	e8 00 00 00 00	 call	 __Init_thread_footer
  001ab	59		 pop	 ecx
$LN4@CreateFile:

; 1378 : 	static CryptoPP::Whirlpool whirlpool;

  001ac	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  001b1	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  001b8	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  001bb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS3@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  001c1	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  001c7	7e 46		 jle	 SHORT $LN5@CreateFile
  001c9	68 00 00 00 00	 push	 OFFSET ?$TSS3@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  001ce	e8 00 00 00 00	 call	 __Init_thread_header
  001d3	59		 pop	 ecx
  001d4	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS3@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA, -1
  001db	75 32		 jne	 SHORT $LN5@CreateFile
  001dd	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  001e1	b9 00 00 00 00	 mov	 ecx, OFFSET ?whirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VWhirlpool@CryptoPP@@A
  001e6	e8 00 00 00 00	 call	 ??0?$IteratedHashWithStaticTransform@_KU?$EnumToType@W4ByteOrder@CryptoPP@@$00@CryptoPP@@$0EA@$0EA@VWhirlpool@2@$0A@$0A@@CryptoPP@@IAE@XZ ; CryptoPP::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>::IteratedHashWithStaticTransform<unsigned __int64,CryptoPP::EnumToType<enum CryptoPP::ByteOrder,1>,64,64,CryptoPP::Whirlpool,0,0>
  001eb	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?whirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VWhirlpool@CryptoPP@@A, OFFSET ??_7Whirlpool@CryptoPP@@6B@
  001f5	68 00 00 00 00	 push	 OFFSET ??__Fwhirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@YAXXZ ; `CEterPack::__CreateFileNameKey_Panama'::`2'::`dynamic atexit destructor for 'whirlpool''
  001fa	e8 00 00 00 00	 call	 _atexit
  001ff	59		 pop	 ecx
  00200	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00204	68 00 00 00 00	 push	 OFFSET ?$TSS3@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  00209	e8 00 00 00 00	 call	 __Init_thread_footer
  0020e	59		 pop	 ecx
$LN5@CreateFile:

; 1379 : 
; 1380 : 	switch (idx & 3)

  0020f	8b 45 bc	 mov	 eax, DWORD PTR _idx$[ebp]
  00212	83 e0 03	 and	 eax, 3
  00215	89 45 e0	 mov	 DWORD PTR tv150[ebp], eax
  00218	74 14		 je	 SHORT $LN11@CreateFile
  0021a	83 7d e0 01	 cmp	 DWORD PTR tv150[ebp], 1
  0021e	74 17		 je	 SHORT $LN12@CreateFile
  00220	83 7d e0 02	 cmp	 DWORD PTR tv150[ebp], 2
  00224	74 1a		 je	 SHORT $LN13@CreateFile
  00226	83 7d e0 03	 cmp	 DWORD PTR tv150[ebp], 3
  0022a	74 1d		 je	 SHORT $LN14@CreateFile
  0022c	eb 22		 jmp	 SHORT $LN6@CreateFile
$LN11@CreateFile:

; 1381 : 	{
; 1382 : 		case 0:
; 1383 : 			hm1 = &whirlpool;

  0022e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hm1$[ebp], OFFSET ?whirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VWhirlpool@CryptoPP@@A

; 1384 : 			break;

  00235	eb 19		 jmp	 SHORT $LN6@CreateFile
$LN12@CreateFile:

; 1385 : 
; 1386 : 		case 1:
; 1387 : 			hm1 = &tiger;

  00237	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hm1$[ebp], OFFSET ?tiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VTiger@CryptoPP@@A

; 1388 : 			break;

  0023e	eb 10		 jmp	 SHORT $LN6@CreateFile
$LN13@CreateFile:

; 1389 : 
; 1390 : 		case 2:
; 1391 : 			hm1 = &sha1;

  00240	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hm1$[ebp], OFFSET ?sha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VSHA1@CryptoPP@@A

; 1392 : 			break;

  00247	eb 07		 jmp	 SHORT $LN6@CreateFile
$LN14@CreateFile:

; 1393 : 
; 1394 : 		case 3:
; 1395 : 			hm1 = &ripemd128;

  00249	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _hm1$[ebp], OFFSET ?ripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VRIPEMD128@CryptoPP@@A
$LN6@CreateFile:

; 1399 : 	CryptoPP::StringSource(SrcStringForKey, true,

  00250	6a 64		 push	 100			; 00000064H
  00252	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00257	59		 pop	 ecx
  00258	89 45 d4	 mov	 DWORD PTR $T8[ebp], eax
  0025b	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  0025f	83 7d d4 00	 cmp	 DWORD PTR $T8[ebp], 0
  00263	0f 84 8c 00 00
	00		 je	 $LN22@CreateFile
  00269	6a 20		 push	 32			; 00000020H
  0026b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00270	59		 pop	 ecx
  00271	89 45 f0	 mov	 DWORD PTR $T10[ebp], eax
  00274	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00278	83 7d f0 00	 cmp	 DWORD PTR $T10[ebp], 0
  0027c	74 48		 je	 SHORT $LN20@CreateFile
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 777  : 	BufferedTransformation() : Algorithm(false) {}

  0027e	6a 00		 push	 0
  00280	8b 4d f0	 mov	 ecx, DWORD PTR $T10[ebp]
  00283	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 639  : 	ArraySink(byte *buf, size_t size) : m_buf(buf), m_size(size), m_total(0) {}

  00288	8b 45 f0	 mov	 eax, DWORD PTR $T10[ebp]
  0028b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ArraySink@CryptoPP@@6BAlgorithm@1@@
  00291	8b 45 f0	 mov	 eax, DWORD PTR $T10[ebp]
  00294	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7ArraySink@CryptoPP@@6BWaitable@1@@
  0029b	8b 45 f0	 mov	 eax, DWORD PTR $T10[ebp]
  0029e	8b 8d 98 00 00
	00		 mov	 ecx, DWORD PTR _key$[ebp]
  002a4	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  002a7	8b 45 f0	 mov	 eax, DWORD PTR $T10[ebp]
  002aa	c7 40 10 10 00
	00 00		 mov	 DWORD PTR [eax+16], 16	; 00000010H
  002b1	8b 45 f0	 mov	 eax, DWORD PTR $T10[ebp]
  002b4	33 c9		 xor	 ecx, ecx
  002b6	33 d2		 xor	 edx, edx
  002b8	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  002bb	89 50 1c	 mov	 DWORD PTR [eax+28], edx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1399 : 	CryptoPP::StringSource(SrcStringForKey, true,

  002be	8b 45 f0	 mov	 eax, DWORD PTR $T10[ebp]
  002c1	89 45 d8	 mov	 DWORD PTR tv207[ebp], eax
  002c4	eb 04		 jmp	 SHORT $LN21@CreateFile
$LN20@CreateFile:
  002c6	83 65 d8 00	 and	 DWORD PTR tv207[ebp], 0
$LN21@CreateFile:
  002ca	8b 45 d8	 mov	 eax, DWORD PTR tv207[ebp]
  002cd	89 45 b8	 mov	 DWORD PTR $T5[ebp], eax
  002d0	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  002d4	68 00 00 00 00	 push	 OFFSET ?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CryptoPP::DEFAULT_CHANNEL
  002d9	68 00 00 00 00	 push	 OFFSET ?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CryptoPP::DEFAULT_CHANNEL
  002de	6a ff		 push	 -1
  002e0	6a 00		 push	 0
  002e2	ff 75 b8	 push	 DWORD PTR $T5[ebp]
  002e5	ff 75 e8	 push	 DWORD PTR _hm1$[ebp]
  002e8	8b 4d d4	 mov	 ecx, DWORD PTR $T8[ebp]
  002eb	e8 00 00 00 00	 call	 ??0HashFilter@CryptoPP@@QAE@AAVHashTransformation@1@PAVBufferedTransformation@1@_NHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@3@Z ; CryptoPP::HashFilter::HashFilter
  002f0	89 45 d0	 mov	 DWORD PTR tv210[ebp], eax
  002f3	eb 04		 jmp	 SHORT $LN23@CreateFile
$LN22@CreateFile:
  002f5	83 65 d0 00	 and	 DWORD PTR tv210[ebp], 0
$LN23@CreateFile:
  002f9	8b 45 d0	 mov	 eax, DWORD PTR tv210[ebp]
  002fc	89 45 b4	 mov	 DWORD PTR $T4[ebp], eax
  002ff	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00303	ff 75 b4	 push	 DWORD PTR $T4[ebp]
  00306	6a 01		 push	 1
  00308	8d 45 70	 lea	 eax, DWORD PTR _SrcStringForKey$[ebp]
  0030b	50		 push	 eax
  0030c	8d 4d 38	 lea	 ecx, DWORD PTR $T12[ebp]
  0030f	e8 00 00 00 00	 call	 ??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z ; CryptoPP::StringSource::StringSource
  00314	8d 4d 44	 lea	 ecx, DWORD PTR $T12[ebp+12]
  00317	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>

; 1400 : 					 new CryptoPP::HashFilter(*hm1, 
; 1401 : 						//new CryptoPP::HexEncoder(
; 1402 : 							new CryptoPP::ArraySink(key, 16)
; 1403 : 						//) // HexEncoder
; 1404 : 					 ) // HashFilter
; 1405 : 				 ); // StringSource
; 1406 : 
; 1407 : 	//    4  16    
; 1408 : 	unsigned int idx2 = *(unsigned int*) key;

  0031c	8b 85 98 00 00
	00		 mov	 eax, DWORD PTR _key$[ebp]
  00322	8b 00		 mov	 eax, DWORD PTR [eax]
  00324	89 45 b0	 mov	 DWORD PTR _idx2$[ebp], eax

; 1409 : 
; 1410 : 	switch (idx2 & 3)

  00327	8b 45 b0	 mov	 eax, DWORD PTR _idx2$[ebp]
  0032a	83 e0 03	 and	 eax, 3
  0032d	89 45 dc	 mov	 DWORD PTR tv216[ebp], eax
  00330	74 14		 je	 SHORT $LN15@CreateFile
  00332	83 7d dc 01	 cmp	 DWORD PTR tv216[ebp], 1
  00336	74 17		 je	 SHORT $LN16@CreateFile
  00338	83 7d dc 02	 cmp	 DWORD PTR tv216[ebp], 2
  0033c	74 1a		 je	 SHORT $LN17@CreateFile
  0033e	83 7d dc 03	 cmp	 DWORD PTR tv216[ebp], 3
  00342	74 1d		 je	 SHORT $LN18@CreateFile
  00344	eb 22		 jmp	 SHORT $LN8@CreateFile
$LN15@CreateFile:

; 1411 : 	{
; 1412 : 		case 0:
; 1413 : 			hm2 = &sha1;

  00346	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hm2$[ebp], OFFSET ?sha1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VSHA1@CryptoPP@@A

; 1414 : 			break;

  0034d	eb 19		 jmp	 SHORT $LN8@CreateFile
$LN16@CreateFile:

; 1415 : 
; 1416 : 		case 1:
; 1417 : 			hm2 = &ripemd128;

  0034f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hm2$[ebp], OFFSET ?ripemd128@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VRIPEMD128@CryptoPP@@A

; 1418 : 			break;

  00356	eb 10		 jmp	 SHORT $LN8@CreateFile
$LN17@CreateFile:

; 1419 : 
; 1420 : 		case 2:
; 1421 : 			hm2 = &whirlpool;

  00358	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hm2$[ebp], OFFSET ?whirlpool@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VWhirlpool@CryptoPP@@A

; 1422 : 			break;

  0035f	eb 07		 jmp	 SHORT $LN8@CreateFile
$LN18@CreateFile:

; 1423 : 
; 1424 : 		case 3:
; 1425 : 			hm2 = &tiger;

  00361	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _hm2$[ebp], OFFSET ?tiger@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4VTiger@CryptoPP@@A
$LN8@CreateFile:

; 1429 : 	CryptoPP::StringSource(SrcStringForKey, true,

  00368	6a 64		 push	 100			; 00000064H
  0036a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0036f	59		 pop	 ecx
  00370	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
  00373	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00377	83 7d c8 00	 cmp	 DWORD PTR $T7[ebp], 0
  0037b	0f 84 8f 00 00
	00		 je	 $LN26@CreateFile
  00381	6a 20		 push	 32			; 00000020H
  00383	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00388	59		 pop	 ecx
  00389	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
  0038c	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00390	83 7d ec 00	 cmp	 DWORD PTR $T9[ebp], 0
  00394	74 4b		 je	 SHORT $LN24@CreateFile
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\cryptlib.h

; 777  : 	BufferedTransformation() : Algorithm(false) {}

  00396	6a 00		 push	 0
  00398	8b 4d ec	 mov	 ecx, DWORD PTR $T9[ebp]
  0039b	e8 00 00 00 00	 call	 ??0Algorithm@CryptoPP@@QAE@_N@Z ; CryptoPP::Algorithm::Algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 639  : 	ArraySink(byte *buf, size_t size) : m_buf(buf), m_size(size), m_total(0) {}

  003a0	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  003a3	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ArraySink@CryptoPP@@6BAlgorithm@1@@
  003a9	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  003ac	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_7ArraySink@CryptoPP@@6BWaitable@1@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1429 : 	CryptoPP::StringSource(SrcStringForKey, true,

  003b3	8b 85 98 00 00
	00		 mov	 eax, DWORD PTR _key$[ebp]
  003b9	83 c0 10	 add	 eax, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\cryptopp\filters.h

; 639  : 	ArraySink(byte *buf, size_t size) : m_buf(buf), m_size(size), m_total(0) {}

  003bc	8b 4d ec	 mov	 ecx, DWORD PTR $T9[ebp]
  003bf	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  003c2	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  003c5	c7 40 10 10 00
	00 00		 mov	 DWORD PTR [eax+16], 16	; 00000010H
  003cc	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  003cf	33 c9		 xor	 ecx, ecx
  003d1	33 d2		 xor	 edx, edx
  003d3	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  003d6	89 50 1c	 mov	 DWORD PTR [eax+28], edx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1429 : 	CryptoPP::StringSource(SrcStringForKey, true,

  003d9	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  003dc	89 45 cc	 mov	 DWORD PTR tv274[ebp], eax
  003df	eb 04		 jmp	 SHORT $LN25@CreateFile
$LN24@CreateFile:
  003e1	83 65 cc 00	 and	 DWORD PTR tv274[ebp], 0
$LN25@CreateFile:
  003e5	8b 45 cc	 mov	 eax, DWORD PTR tv274[ebp]
  003e8	89 45 ac	 mov	 DWORD PTR $T3[ebp], eax
  003eb	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  003ef	68 00 00 00 00	 push	 OFFSET ?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CryptoPP::DEFAULT_CHANNEL
  003f4	68 00 00 00 00	 push	 OFFSET ?DEFAULT_CHANNEL@CryptoPP@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B ; CryptoPP::DEFAULT_CHANNEL
  003f9	6a ff		 push	 -1
  003fb	6a 00		 push	 0
  003fd	ff 75 ac	 push	 DWORD PTR $T3[ebp]
  00400	ff 75 e4	 push	 DWORD PTR _hm2$[ebp]
  00403	8b 4d c8	 mov	 ecx, DWORD PTR $T7[ebp]
  00406	e8 00 00 00 00	 call	 ??0HashFilter@CryptoPP@@QAE@AAVHashTransformation@1@PAVBufferedTransformation@1@_NHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@3@Z ; CryptoPP::HashFilter::HashFilter
  0040b	89 45 c4	 mov	 DWORD PTR tv277[ebp], eax
  0040e	eb 04		 jmp	 SHORT $LN27@CreateFile
$LN26@CreateFile:
  00410	83 65 c4 00	 and	 DWORD PTR tv277[ebp], 0
$LN27@CreateFile:
  00414	8b 45 c4	 mov	 eax, DWORD PTR tv277[ebp]
  00417	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
  0041a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0041e	ff 75 a8	 push	 DWORD PTR $T2[ebp]
  00421	6a 01		 push	 1
  00423	8d 45 70	 lea	 eax, DWORD PTR _SrcStringForKey$[ebp]
  00426	50		 push	 eax
  00427	8d 4d 00	 lea	 ecx, DWORD PTR $T11[ebp]
  0042a	e8 00 00 00 00	 call	 ??0StringSource@CryptoPP@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_NPAVBufferedTransformation@1@@Z ; CryptoPP::StringSource::StringSource
  0042f	8d 4d 0c	 lea	 ecx, DWORD PTR $T11[ebp+12]
  00432	e8 00 00 00 00	 call	 ??1?$member_ptr@VBufferedTransformation@CryptoPP@@@CryptoPP@@QAE@XZ ; CryptoPP::member_ptr<CryptoPP::BufferedTransformation>::~member_ptr<CryptoPP::BufferedTransformation>

; 1437 : }

  00437	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0043b	8d 4d 70	 lea	 ecx, DWORD PTR _SrcStringForKey$[ebp]
  0043e	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN1@CreateFile:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1437 : }

  00443	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00446	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0044d	59		 pop	 ecx
  0044e	8b 8d 88 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00454	33 cd		 xor	 ecx, ebp
  00456	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045b	81 c5 8c 00 00
	00		 add	 ebp, 140		; 0000008cH
  00461	c9		 leave
  00462	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$0:
  00000	8d 4d 70	 lea	 ecx, DWORD PTR _SrcStringForKey$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$1:
  00008	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  0000d	e8 00 00 00 00	 call	 __Init_thread_abort
  00012	59		 pop	 ecx
  00013	c3		 ret	 0
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$2:
  00014	68 00 00 00 00	 push	 OFFSET ?$TSS1@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  00019	e8 00 00 00 00	 call	 __Init_thread_abort
  0001e	59		 pop	 ecx
  0001f	c3		 ret	 0
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$3:
  00020	68 00 00 00 00	 push	 OFFSET ?$TSS2@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  00025	e8 00 00 00 00	 call	 __Init_thread_abort
  0002a	59		 pop	 ecx
  0002b	c3		 ret	 0
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$4:
  0002c	68 00 00 00 00	 push	 OFFSET ?$TSS3@?1??__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z@4HA
  00031	e8 00 00 00 00	 call	 __Init_thread_abort
  00036	59		 pop	 ecx
  00037	c3		 ret	 0
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$5:
  00038	6a 64		 push	 100			; 00000064H
  0003a	ff 75 d4	 push	 DWORD PTR $T8[ebp]
  0003d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00042	59		 pop	 ecx
  00043	59		 pop	 ecx
  00044	c3		 ret	 0
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$6:
  00045	6a 20		 push	 32			; 00000020H
  00047	ff 75 f0	 push	 DWORD PTR $T10[ebp]
  0004a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0004f	59		 pop	 ecx
  00050	59		 pop	 ecx
  00051	c3		 ret	 0
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$8:
  00052	6a 64		 push	 100			; 00000064H
  00054	ff 75 c8	 push	 DWORD PTR $T7[ebp]
  00057	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx
  0005e	c3		 ret	 0
__unwindfunclet$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z$9:
  0005f	6a 20		 push	 32			; 00000020H
  00061	ff 75 ec	 push	 DWORD PTR $T9[ebp]
  00064	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00069	59		 pop	 ecx
  0006a	59		 pop	 ecx
  0006b	c3		 ret	 0
  0006c	cc		 int	 3
  0006d	cc		 int	 3
  0006e	cc		 int	 3
  0006f	cc		 int	 3
  00070	cc		 int	 3
__ehhandler$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z:
  00071	90		 npad	 1
  00072	90		 npad	 1
  00073	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00077	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0007a	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0007d	33 c8		 xor	 ecx, eax
  0007f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00084	8b 8a 94 00 00
	00		 mov	 ecx, DWORD PTR [edx+148]
  0008a	33 c8		 xor	 ecx, eax
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z
  00096	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__CreateFileNameKey_Panama@CEterPack@@AAEXPBDPAEI@Z ENDP ; CEterPack::__CreateFileNameKey_Panama
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S11$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ PROC ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S11$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 0c	 imul	 eax, eax, 12
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PAUSEterPackIndex@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSEterPackIndex@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<SEterPackIndex *,void *> *,std::_List_node<SEterPackIndex *,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ ENDP ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ PROC ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ; std::_List_node<SEterPackIndex *,void *>::_Free_non_head<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ; std::_List_node<SEterPackIndex *,void *>::_Freenode0<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ ENDP ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEXXZ PROC ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ; std::_List_node<SEterPackIndex *,void *>::_Free_non_head<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEXXZ ENDP ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?erase@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Result$ = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@@Z PROC ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::erase, COMDAT
; _this$ = ecx

; 1349 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1350 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1351 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "list erase iterator outside range");
; 1352 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1353 :         const auto _Result = _Where._Ptr->_Next;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax

; 1354 :         _Node::_Freenode(_Getal(), _Mypair._Myval2._Unlinknode(_Where._Ptr));

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 396  :         _Pnode->_Prev->_Next = _Pnode->_Next;

  00017	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00022	89 08		 mov	 DWORD PTR [eax], ecx

; 397  :         _Pnode->_Next->_Prev = _Pnode->_Prev;

  00024	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0002c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 398  :         --_Mysize;

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	48		 dec	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 399  :         return _Pnode;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00042	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0004b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00051	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00054	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00057	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  0005a	ff 75 f4	 push	 DWORD PTR $T5[ebp]
  0005d	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00060	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@std@@@?$_List_node@PAUSEterPackIndex@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSEterPackIndex@@PAX@std@@@1@PAU01@@Z ; std::_List_node<SEterPackIndex *,void *>::_Freenode0<std::allocator<std::_List_node<SEterPackIndex *,void *> > >
  00065	59		 pop	 ecx
  00066	59		 pop	 ecx

; 1124 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0006a	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00073	89 08		 mov	 DWORD PTR [eax], ecx

; 1355 :         return _Make_iter(_Result);

  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1356 :     }

  00078	c9		 leave
  00079	c2 08 00	 ret	 8
?erase@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@@Z ENDP ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?begin@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
___param0$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@XZ PROC ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?begin@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@XZ ENDP ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ PROC ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::~list<SEterPackIndex *,std::allocator<SEterPackIndex *> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ ENDP ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::~list<SEterPackIndex *,std::allocator<SEterPackIndex *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ PROC ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@AAEXXZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ ENDP ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ?find@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z
_TEXT	SEGMENT
_x$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_k$ = 12						; size = 4
?find@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z PROC ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::find, COMDAT
; _this$ = ecx

; 1803 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1804 :       return iterator(table_.find_node(k));

  00008	ff 75 0c	 push	 DWORD PTR _k$[ebp]
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@ABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
  00013	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2371 :           : node_(static_cast<node_pointer>(x))

  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0001c	89 08		 mov	 DWORD PTR [eax], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1804 :       return iterator(table_.find_node(k));

  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1805 :     }

  00021	c9		 leave
  00022	c2 08 00	 ret	 8
?find@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z ENDP ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ?erase@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@U4523@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv93 = -20						; size = 4
$T1 = -16						; size = 4
_this$ = -12						; size = 4
_next$ = -8						; size = 4
_node$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_position$ = 12						; size = 4
?erase@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@U4523@@Z PROC ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::erase, COMDAT
; _this$ = ecx

; 1699 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1700 :       node_pointer node = table::get_node(position);

  00009	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2431 :         c_iterator(n_iterator const& x) BOOST_NOEXCEPT : node_(x.node_) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _position$[ebp]
  00015	89 08		 mov	 DWORD PTR [eax], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1700 :       node_pointer node = table::get_node(position);

  00017	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  0001a	89 45 ec	 mov	 DWORD PTR tv93[ebp], eax
  0001d	8b 45 ec	 mov	 eax, DWORD PTR tv93[ebp]
  00020	89 45 fc	 mov	 DWORD PTR _node$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2964 :           return static_cast<node_pointer>(n->next_);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _node$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	89 45 f8	 mov	 DWORD PTR _next$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1703 :       table_.erase_nodes_unique(node, next);

  0002b	ff 75 f8	 push	 DWORD PTR _next$[ebp]
  0002e	ff 75 fc	 push	 DWORD PTR _node$[ebp]
  00031	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?erase_nodes_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@0@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::erase_nodes_unique
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2371 :           : node_(static_cast<node_pointer>(x))

  00039	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _next$[ebp]
  0003f	89 08		 mov	 DWORD PTR [eax], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1704 :       return iterator(next);

  00041	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1705 :     }

  00044	c9		 leave
  00045	c2 08 00	 ret	 8
?erase@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@U4523@@Z ENDP ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ PROC ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::~unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >, COMDAT
; _this$ = ecx

; 1645 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3333 :         ~table() { delete_buckets(); }

  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
  00032	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1646 :     }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	c9		 leave
  00042	c3		 ret	 0
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ ENDP ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::~unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??0?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
??0?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ PROC ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >, COMDAT
; _this$ = ecx

; 1510 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1508 :         : table_(boost::unordered::detail::default_bucket_count, hasher(),

  00008	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  0000b	50		 push	 eax
  0000c	8d 45 fe	 lea	 eax, DWORD PTR $T2[ebp]
  0000f	50		 push	 eax
  00010	8d 45 fd	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	6a 0b		 push	 11			; 0000000bH
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >

; 1511 :     }

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	c9		 leave
  00022	c3		 ret	 0
??0?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ ENDP ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?erase_nodes_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@0@Z
_TEXT	SEGMENT
_next$1 = -16						; size = 4
_bucket_index$ = -12					; size = 4
_this$ = -8						; size = 4
_prev$ = -4						; size = 4
_i$ = 8							; size = 4
_j$ = 12						; size = 4
?erase_nodes_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@0@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::erase_nodes_unique, COMDAT
; _this$ = ecx

; 4053 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  00009	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 4054 :           std::size_t bucket_index = this->node_bucket(i);

  00014	89 45 f4	 mov	 DWORD PTR _bucket_index$[ebp], eax

; 3036 :           return get_bucket_pointer(bucket_index)->next_;

  00017	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  00020	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00023	89 45 fc	 mov	 DWORD PTR _prev$[ebp], eax
$LN2@erase_node:

; 4055 : 
; 4056 :           // Find the node before i.
; 4057 :           link_pointer prev = this->get_previous_start(bucket_index);
; 4058 :           while (prev->next_ != i)

  00026	8b 45 fc	 mov	 eax, DWORD PTR _prev$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	3b 45 08	 cmp	 eax, DWORD PTR _i$[ebp]
  0002e	74 0a		 je	 SHORT $LN3@erase_node

; 4059 :             prev = prev->next_;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _prev$[ebp]
  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 45 fc	 mov	 DWORD PTR _prev$[ebp], eax
  00038	eb ec		 jmp	 SHORT $LN2@erase_node
$LN3@erase_node:

; 4060 : 
; 4061 :           // Delete the nodes.
; 4062 :           prev->next_ = j;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _prev$[ebp]
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR _j$[ebp]
  00040	89 08		 mov	 DWORD PTR [eax], ecx
$LN6@erase_node:

; 2964 :           return static_cast<node_pointer>(n->next_);

  00042	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 f0	 mov	 DWORD PTR _next$1[ebp], eax

; 4063 :           do {
; 4064 :             node_pointer next = next_node(i);
; 4065 :             destroy_node(i);

  0004a	ff 75 08	 push	 DWORD PTR _i$[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node

; 4066 :             --size_;

  00055	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0005b	48		 dec	 eax
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4067 :             bucket_index = this->fix_bucket(bucket_index, prev, next);

  00062	ff 75 f0	 push	 DWORD PTR _next$1[ebp]
  00065	ff 75 fc	 push	 DWORD PTR _prev$[ebp]
  00068	ff 75 f4	 push	 DWORD PTR _bucket_index$[ebp]
  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?fix_bucket@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEIIPAUptr_bucket@234@PAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::fix_bucket
  00073	89 45 f4	 mov	 DWORD PTR _bucket_index$[ebp], eax

; 4068 :             i = next;

  00076	8b 45 f0	 mov	 eax, DWORD PTR _next$1[ebp]
  00079	89 45 08	 mov	 DWORD PTR _i$[ebp], eax

; 4069 :           } while (i != j);

  0007c	8b 45 08	 mov	 eax, DWORD PTR _i$[ebp]
  0007f	3b 45 0c	 cmp	 eax, DWORD PTR _j$[ebp]
  00082	75 be		 jne	 SHORT $LN6@erase_node

; 4070 :         }

  00084	c9		 leave
  00085	c2 08 00	 ret	 8
?erase_nodes_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@0@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::erase_nodes_unique
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z
_TEXT	SEGMENT
_b$ = -40						; size = 8
$T2 = -32						; size = 4
_p$3 = -28						; size = 4
$T4 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_n$ = 8							; size = 4
_key_hash$ = 12						; size = 4
?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::resize_and_add_node_unique, COMDAT
; _this$ = ecx

; 3715 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 03	 add	 eax, 3
  0002e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00031	74 09		 je	 SHORT $LN8@resize_and
  00033	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00036	40		 inc	 eax
  00037	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
  0003a	eb 04		 jmp	 SHORT $LN4@resize_and
$LN8@resize_and:
  0003c	83 65 e8 00	 and	 DWORD PTR $T4[ebp], 0
$LN4@resize_and:

; 1999 :         explicit node_tmp(node_pointer n, NodeAlloc& a) : alloc_(a), node_(n) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00043	89 45 d8	 mov	 DWORD PTR _b$[ebp], eax
  00046	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00049	89 45 dc	 mov	 DWORD PTR _b$[ebp+4], eax

; 3716 :           node_tmp b(n, this->node_alloc());

  0004c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 3717 :           this->reserve_for_insert(this->size_ + 1);

  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00056	40		 inc	 eax
  00057	50		 push	 eax
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert

; 2006 :           node_pointer p = node_;

  00060	8b 45 dc	 mov	 eax, DWORD PTR _b$[ebp+4]
  00063	89 45 e4	 mov	 DWORD PTR _p$3[ebp], eax

; 2007 :           node_ = node_pointer();

  00066	83 65 dc 00	 and	 DWORD PTR _b$[ebp+4], 0

; 3718 :           return this->add_node_unique(b.release(), key_hash);

  0006a	ff 75 0c	 push	 DWORD PTR _key_hash$[ebp]
  0006d	ff 75 e4	 push	 DWORD PTR _p$3[ebp]
  00070	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_unique
  00078	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  0007b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007f	8d 4d d8	 lea	 ecx, DWORD PTR _b$[ebp]
  00082	e8 00 00 00 00	 call	 ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
  00087	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]

; 3719 :         }

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	c9		 leave
  00096	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _b$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::resize_and_add_node_unique
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_bucket_index$ = -16					; size = 4
_b$ = -12						; size = 4
_start_node$4 = -8					; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
_key_hash$ = 12						; size = 4
?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_unique, COMDAT
; _this$ = ecx

; 3686 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2604 :           return hash % bucket_count;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _key_hash$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	f7 71 04	 div	 DWORD PTR [ecx+4]

; 3687 :           std::size_t bucket_index = this->hash_to_bucket(key_hash);

  00014	89 55 f0	 mov	 DWORD PTR _bucket_index$[ebp], edx

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001d	8b 4d f0	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  00020	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 3688 :           bucket_pointer b = this->get_bucket_pointer(bucket_index);

  00023	89 45 f4	 mov	 DWORD PTR _b$[ebp], eax

; 3689 : 
; 3690 :           n->bucket_info_ = bucket_index;

  00026	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  0002c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4883 :           bucket_info_ = bucket_info_ & ((std::size_t)-1 >> 1);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00032	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00035	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  0003d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3691 :           n->set_first_in_group();
; 3692 : 
; 3693 :           if (!b->next_) {

  00040	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]
  00043	83 38 00	 cmp	 DWORD PTR [eax], 0
  00046	75 61		 jne	 SHORT $LN2@add_node_u

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00054	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00057	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 3694 :             link_pointer start_node = this->get_previous_start();

  0005a	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	89 45 f8	 mov	 DWORD PTR _start_node$4[ebp], eax

; 3695 : 
; 3696 :             if (start_node->next_) {

  00060	8b 45 f8	 mov	 eax, DWORD PTR _start_node$4[ebp]
  00063	83 38 00	 cmp	 DWORD PTR [eax], 0
  00066	74 25		 je	 SHORT $LN4@add_node_u

; 2964 :           return static_cast<node_pointer>(n->next_);

  00068	8b 45 f8	 mov	 eax, DWORD PTR _start_node$4[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  00070	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00073	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00076	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 2999 :           return n->get_bucket();

  0007b	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3697 :               this->get_bucket_pointer(node_bucket(next_node(start_node)))

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00084	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  00087	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  0008a	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN4@add_node_u:

; 3698 :                 ->next_ = n;
; 3699 :             }
; 3700 : 
; 3701 :             b->next_ = start_node;

  0008d	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _start_node$4[ebp]
  00093	89 08		 mov	 DWORD PTR [eax], ecx

; 3702 :             n->next_ = start_node->next_;

  00095	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _start_node$4[ebp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx

; 3703 :             start_node->next_ = n;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _start_node$4[ebp]
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  000a5	89 08		 mov	 DWORD PTR [eax], ecx

; 3704 :           } else {

  000a7	eb 16		 jmp	 SHORT $LN3@add_node_u
$LN2@add_node_u:

; 3705 :             n->next_ = b->next_->next_;

  000a9	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]
  000ac	8b 00		 mov	 eax, DWORD PTR [eax]
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 3706 :             b->next_->next_ = n;

  000b5	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  000bd	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@add_node_u:

; 3707 :           }
; 3708 : 
; 3709 :           ++this->size_;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c5	40		 inc	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3710 :           return n;

  000cc	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]

; 3711 :         }

  000cf	c9		 leave
  000d0	c2 08 00	 ret	 8
?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAU5234@I@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_unique
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
$T2 = -76						; size = 4
_next$3 = -72						; size = 4
_next$4 = -68						; size = 4
_key_hash$5 = -64					; size = 4
tv129 = -60						; size = 4
_v$6 = -56						; size = 4
$T7 = -52						; size = 4
tv221 = -48						; size = 4
_bucket_index$8 = -44					; size = 4
_next$9 = -40						; size = 4
_n$10 = -36						; size = 4
_b$11 = -32						; size = 4
_prev$ = -28						; size = 4
_this$ = -24						; size = 4
_n$12 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_num_buckets$ = 8					; size = 4
?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl, COMDAT
; _this$ = ecx

; 4577 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 4578 :         BOOST_ASSERT(this->buckets_);
; 4579 : 
; 4580 :         this->create_buckets(num_buckets);

  0002f	ff 75 08	 push	 DWORD PTR _num_buckets$[ebp]
  00032	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  0003a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00040	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00046	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00049	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 4581 :         link_pointer prev = this->get_previous_start();

  0004c	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  0004f	89 45 e4	 mov	 DWORD PTR _prev$[ebp], eax

; 4582 :         BOOST_TRY

  00052	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
$LN2@rehash_imp:

; 4583 :         {
; 4584 :           while (prev->next_) {

  00056	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00059	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005c	0f 84 04 01 00
	00		 je	 $LN3@rehash_imp

; 2964 :           return static_cast<node_pointer>(n->next_);

  00062	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 ec	 mov	 DWORD PTR _n$12[ebp], eax

; 2791 :           return *static_cast<function_pair const*>(

  0006a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00070	83 e0 01	 and	 eax, 1
  00073	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  0007a	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 2599 :           return hf(x);

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00080	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00083	89 45 c8	 mov	 DWORD PTR _v$6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp

; 621  :     BOOST_HASH_SPECIALIZE(unsigned long)

  00086	ff 75 c8	 push	 DWORD PTR _v$6[ebp]
  00089	e8 00 00 00 00	 call	 ??$hash_value@K@boost@@YAIK@Z ; boost::hash_value<unsigned long>
  0008e	59		 pop	 ecx
  0008f	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4586 :             std::size_t key_hash = this->hash(this->get_key(n));

  00092	8b 45 c4	 mov	 eax, DWORD PTR tv129[ebp]
  00095	89 45 c0	 mov	 DWORD PTR _key_hash$5[ebp], eax

; 2604 :           return hash % bucket_count;

  00098	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 45 c0	 mov	 eax, DWORD PTR _key_hash$5[ebp]
  0009e	33 d2		 xor	 edx, edx
  000a0	f7 71 04	 div	 DWORD PTR [ecx+4]

; 4587 :             std::size_t bucket_index = this->hash_to_bucket(key_hash);

  000a3	89 55 d4	 mov	 DWORD PTR _bucket_index$8[ebp], edx

; 4588 : 
; 4589 :             n->bucket_info_ = bucket_index;

  000a6	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000a9	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  000ac	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4883 :           bucket_info_ = bucket_info_ & ((std::size_t)-1 >> 1);

  000af	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  000bd	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN6@rehash_imp:

; 2964 :           return static_cast<node_pointer>(n->next_);

  000c0	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000c3	8b 00		 mov	 eax, DWORD PTR [eax]
  000c5	89 45 d8	 mov	 DWORD PTR _next$9[ebp], eax

; 4590 :             n->set_first_in_group();
; 4591 : 
; 4592 :             // Iterator through the rest of the group of equal nodes,
; 4593 :             // setting the bucket.
; 4594 :             for (;;) {
; 4595 :               node_pointer next = next_node(n);
; 4596 :               if (!next || next->is_first_in_group()) {

  000c8	83 7d d8 00	 cmp	 DWORD PTR _next$9[ebp], 0
  000cc	74 20		 je	 SHORT $LN11@rehash_imp

; 4878 :           return !(bucket_info_ & ~((std::size_t)-1 >> 1));

  000ce	8b 45 d8	 mov	 eax, DWORD PTR _next$9[ebp]
  000d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000d9	75 09		 jne	 SHORT $LN61@rehash_imp
  000db	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv221[ebp], 1
  000e2	eb 04		 jmp	 SHORT $LN59@rehash_imp
$LN61@rehash_imp:
  000e4	83 65 d0 00	 and	 DWORD PTR tv221[ebp], 0
$LN59@rehash_imp:

; 4590 :             n->set_first_in_group();
; 4591 : 
; 4592 :             // Iterator through the rest of the group of equal nodes,
; 4593 :             // setting the bucket.
; 4594 :             for (;;) {
; 4595 :               node_pointer next = next_node(n);
; 4596 :               if (!next || next->is_first_in_group()) {

  000e8	83 7d d0 00	 cmp	 DWORD PTR tv221[ebp], 0
  000ec	74 02		 je	 SHORT $LN10@rehash_imp
$LN11@rehash_imp:

; 4597 :                 break;

  000ee	eb 22		 jmp	 SHORT $LN65@rehash_imp
$LN10@rehash_imp:

; 4598 :               }
; 4599 :               n = next;

  000f0	8b 45 d8	 mov	 eax, DWORD PTR _next$9[ebp]
  000f3	89 45 ec	 mov	 DWORD PTR _n$12[ebp], eax

; 4600 :               n->bucket_info_ = bucket_index;

  000f6	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000f9	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  000fc	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4888 :           bucket_info_ = bucket_info_ | ~((std::size_t)-1 >> 1);

  000ff	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00102	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00105	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  0010a	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  0010d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 4601 :               n->reset_first_in_group();
; 4602 :             }

  00110	eb ae		 jmp	 SHORT $LN6@rehash_imp
$LN65@rehash_imp:

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00112	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00118	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  0011b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 4603 : 
; 4604 :             // n is now the last node in the group
; 4605 :             bucket_pointer b = this->get_bucket_pointer(bucket_index);

  0011e	89 45 e0	 mov	 DWORD PTR _b$11[ebp], eax

; 4606 :             if (!b->next_) {

  00121	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00124	83 38 00	 cmp	 DWORD PTR [eax], 0
  00127	75 10		 jne	 SHORT $LN12@rehash_imp

; 4607 :               b->next_ = prev;

  00129	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  0012c	8b 4d e4	 mov	 ecx, DWORD PTR _prev$[ebp]
  0012f	89 08		 mov	 DWORD PTR [eax], ecx

; 4608 :               prev = n;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00134	89 45 e4	 mov	 DWORD PTR _prev$[ebp], eax

; 4609 :             } else {

  00137	eb 28		 jmp	 SHORT $LN13@rehash_imp
$LN12@rehash_imp:

; 4610 :               link_pointer next = n->next_;

  00139	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  0013c	8b 00		 mov	 eax, DWORD PTR [eax]
  0013e	89 45 bc	 mov	 DWORD PTR _next$4[ebp], eax

; 4611 :               n->next_ = b->next_->next_;

  00141	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00144	8b 00		 mov	 eax, DWORD PTR [eax]
  00146	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	89 01		 mov	 DWORD PTR [ecx], eax

; 4612 :               b->next_->next_ = prev->next_;

  0014d	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00150	8b 00		 mov	 eax, DWORD PTR [eax]
  00152	8b 4d e4	 mov	 ecx, DWORD PTR _prev$[ebp]
  00155	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00157	89 08		 mov	 DWORD PTR [eax], ecx

; 4613 :               prev->next_ = next;

  00159	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  0015c	8b 4d bc	 mov	 ecx, DWORD PTR _next$4[ebp]
  0015f	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@rehash_imp:

; 4614 :             }
; 4615 :           }

  00161	e9 f0 fe ff ff	 jmp	 $LN2@rehash_imp
$LN3@rehash_imp:

; 4616 :         }

  00166	eb 53		 jmp	 SHORT $LN15@rehash_imp
__catch$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0:

; 4617 :         BOOST_CATCH(...)
; 4618 :         {
; 4619 :           node_pointer n = next_node(prev);

  00168	ff 75 e4	 push	 DWORD PTR _prev$[ebp]
  0016b	e8 00 00 00 00	 call	 ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
  00170	59		 pop	 ecx
  00171	89 45 dc	 mov	 DWORD PTR _n$10[ebp], eax

; 4620 :           prev->next_ = node_pointer();

  00174	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00177	83 20 00	 and	 DWORD PTR [eax], 0
$LN7@rehash_imp:

; 4621 :           while (n) {

  0017a	83 7d dc 00	 cmp	 DWORD PTR _n$10[ebp], 0
  0017e	74 2c		 je	 SHORT $LN8@rehash_imp

; 4622 :             node_pointer next = next_node(n);

  00180	ff 75 dc	 push	 DWORD PTR _n$10[ebp]
  00183	e8 00 00 00 00	 call	 ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
  00188	59		 pop	 ecx
  00189	89 45 b8	 mov	 DWORD PTR _next$3[ebp], eax

; 4623 :             destroy_node(n);

  0018c	ff 75 dc	 push	 DWORD PTR _n$10[ebp]
  0018f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00192	e8 00 00 00 00	 call	 ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node

; 4624 :             --size_;

  00197	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0019d	48		 dec	 eax
  0019e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4625 :             n = next;

  001a4	8b 45 b8	 mov	 eax, DWORD PTR _next$3[ebp]
  001a7	89 45 dc	 mov	 DWORD PTR _n$10[ebp], eax

; 4626 :           }

  001aa	eb ce		 jmp	 SHORT $LN7@rehash_imp
$LN8@rehash_imp:

; 4627 :           BOOST_RETHROW

  001ac	6a 00		 push	 0
  001ae	6a 00		 push	 0
  001b0	e8 00 00 00 00	 call	 __CxxThrowException@8

; 4628 :         }

  001b5	b8 00 00 00 00	 mov	 eax, $LN18@rehash_imp
  001ba	c3		 ret	 0
$LN15@rehash_imp:
  001bb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001bf	eb 04		 jmp	 SHORT $LN14@rehash_imp
$LN18@rehash_imp:
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
$LN14@rehash_imp:

; 4629 :         BOOST_CATCH_END
; 4630 :       }

  001c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cf	59		 pop	 ecx
  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	c9		 leave
  001d4	c2 04 00	 ret	 4
  001d7	cc		 int	 3
  001d8	cc		 int	 3
  001d9	cc		 int	 3
  001da	cc		 int	 3
  001db	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
_num_buckets$5 = -28					; size = 4
tv73 = -24						; size = 4
$T6 = -20						; size = 4
tv137 = -16						; size = 4
__Left$ = -12						; size = 4
$T7 = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert, COMDAT
; _this$ = ecx

; 4541 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4542 :         if (!buckets_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	75 4a		 jne	 SHORT $LN2@reserve_fo

; 4543 :           create_buckets((std::max)(bucket_count_, min_buckets_for_size(size)));

  00012	ff 75 08	 push	 DWORD PTR _size$[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
  0001d	89 45 f8	 mov	 DWORD PTR $T7[ebp], eax
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 f4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00029	8b 45 f4	 mov	 eax, DWORD PTR __Left$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	3b 45 f8	 cmp	 eax, DWORD PTR $T7[ebp]
  00031	73 08		 jae	 SHORT $LN55@reserve_fo
  00033	8d 45 f8	 lea	 eax, DWORD PTR $T7[ebp]
  00036	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
  00039	eb 06		 jmp	 SHORT $LN56@reserve_fo
$LN55@reserve_fo:
  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Left$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
$LN56@reserve_fo:
  00041	8b 45 f0	 mov	 eax, DWORD PTR tv137[ebp]
  00044	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
  00047	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0004a	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4543 :           create_buckets((std::max)(bucket_count_, min_buckets_for_size(size)));

  0004d	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00050	ff 30		 push	 DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
  0005a	eb 64		 jmp	 SHORT $LN1@reserve_fo
$LN2@reserve_fo:

; 4544 :         } else if (size > max_load_) {

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  00062	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00065	76 59		 jbe	 SHORT $LN1@reserve_fo

; 4545 :           std::size_t num_buckets =

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00075	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00078	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0007b	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  0007e	73 08		 jae	 SHORT $LN60@reserve_fo
  00080	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00083	89 45 e8	 mov	 DWORD PTR tv73[ebp], eax
  00086	eb 06		 jmp	 SHORT $LN61@reserve_fo
$LN60@reserve_fo:
  00088	8d 45 08	 lea	 eax, DWORD PTR _size$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv73[ebp], eax
$LN61@reserve_fo:
  0008e	8b 45 e8	 mov	 eax, DWORD PTR tv73[ebp]
  00091	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  00094	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00097	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4545 :           std::size_t num_buckets =

  0009a	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp]
  0009d	ff 30		 push	 DWORD PTR [eax]
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
  000a7	89 45 e4	 mov	 DWORD PTR _num_buckets$5[ebp], eax

; 4546 :             min_buckets_for_size((std::max)(size, size_ + (size_ >> 1)));
; 4547 : 
; 4548 :           if (num_buckets != bucket_count_)

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR _num_buckets$5[ebp]
  000b0	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000b3	74 0b		 je	 SHORT $LN1@reserve_fo

; 4549 :             this->rehash_impl(num_buckets);

  000b5	ff 75 e4	 push	 DWORD PTR _num_buckets$5[ebp]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
$LN1@reserve_fo:

; 4550 :         }
; 4551 :       }

  000c0	c9		 leave
  000c1	c2 04 00	 ret	 4
?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@ABK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_v$3 = -8						; size = 4
_this$ = -4						; size = 4
_k$ = 8							; size = 4
?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@ABK@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node, COMDAT
; _this$ = ecx

; 3580 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2791 :           return *static_cast<function_pair const*>(

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000f	83 e0 01	 and	 eax, 1
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00019	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 2599 :           return hf(x);

  0001c	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 f8	 mov	 DWORD PTR _v$3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp

; 621  :     BOOST_HASH_SPECIALIZE(unsigned long)

  00024	ff 75 f8	 push	 DWORD PTR _v$3[ebp]
  00027	e8 00 00 00 00	 call	 ??$hash_value@K@boost@@YAIK@Z ; boost::hash_value<unsigned long>
  0002c	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3569 :           return policy::apply_hash(this->hash_function(), k);

  0002d	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax

; 3581 :           return this->find_node_impl(hash(k), k, this->key_eq());

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::key_eq
  00038	50		 push	 eax
  00039	ff 75 08	 push	 DWORD PTR _k$[ebp]
  0003c	ff 75 f4	 push	 DWORD PTR $T2[ebp]
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@123@IABKABU?$equal_to@K@std@@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >

; 3582 :         }

  00047	c9		 leave
  00048	c2 04 00	 ret	 4
?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@ABK@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?clear_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
_next$1 = -24						; size = 4
_prev$2 = -20						; size = 4
_end$3 = -16						; size = 4
_n$4 = -12						; size = 4
_it$5 = -8						; size = 4
_this$ = -4						; size = 4
?clear_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::clear_impl, COMDAT
; _this$ = ecx

; 4515 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4516 :         if (size_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 72		 je	 SHORT $LN1@clear_impl

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0001e	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 4517 :           bucket_pointer end = get_bucket_pointer(bucket_count_);

  00021	89 45 f0	 mov	 DWORD PTR _end$3[ebp], eax

; 4518 :           for (bucket_pointer it = buckets_; it != end; ++it) {

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0002a	89 45 f8	 mov	 DWORD PTR _it$5[ebp], eax
  0002d	eb 09		 jmp	 SHORT $LN4@clear_impl
$LN2@clear_impl:
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _it$5[ebp]
  00032	83 c0 04	 add	 eax, 4
  00035	89 45 f8	 mov	 DWORD PTR _it$5[ebp], eax
$LN4@clear_impl:
  00038	8b 45 f8	 mov	 eax, DWORD PTR _it$5[ebp]
  0003b	3b 45 f0	 cmp	 eax, DWORD PTR _end$3[ebp]
  0003e	74 08		 je	 SHORT $LN11@clear_impl

; 4519 :             it->next_ = node_pointer();

  00040	8b 45 f8	 mov	 eax, DWORD PTR _it$5[ebp]
  00043	83 20 00	 and	 DWORD PTR [eax], 0

; 4520 :           }

  00046	eb e7		 jmp	 SHORT $LN2@clear_impl
$LN11@clear_impl:

; 4521 : 
; 4522 :           link_pointer prev = end->first_from_start();

  00048	8b 45 f0	 mov	 eax, DWORD PTR _end$3[ebp]
  0004b	89 45 ec	 mov	 DWORD PTR _prev$2[ebp], eax

; 2964 :           return static_cast<node_pointer>(n->next_);

  0004e	8b 45 ec	 mov	 eax, DWORD PTR _prev$2[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 f4	 mov	 DWORD PTR _n$4[ebp], eax

; 4523 :           node_pointer n = next_node(prev);
; 4524 :           prev->next_ = node_pointer();

  00056	8b 45 ec	 mov	 eax, DWORD PTR _prev$2[ebp]
  00059	83 20 00	 and	 DWORD PTR [eax], 0

; 4525 :           size_ = 0;

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LN5@clear_impl:

; 4526 : 
; 4527 :           while (n) {

  00063	83 7d f4 00	 cmp	 DWORD PTR _n$4[ebp], 0
  00067	74 1b		 je	 SHORT $LN1@clear_impl

; 2964 :           return static_cast<node_pointer>(n->next_);

  00069	8b 45 f4	 mov	 eax, DWORD PTR _n$4[ebp]
  0006c	8b 00		 mov	 eax, DWORD PTR [eax]
  0006e	89 45 e8	 mov	 DWORD PTR _next$1[ebp], eax

; 4528 :             node_pointer next = next_node(n);
; 4529 :             destroy_node(n);

  00071	ff 75 f4	 push	 DWORD PTR _n$4[ebp]
  00074	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node

; 4530 :             n = next;

  0007c	8b 45 e8	 mov	 eax, DWORD PTR _next$1[ebp]
  0007f	89 45 f4	 mov	 DWORD PTR _n$4[ebp], eax

; 4531 :           }

  00082	eb df		 jmp	 SHORT $LN5@clear_impl
$LN1@clear_impl:

; 4532 :         }
; 4533 :       }

  00084	c9		 leave
  00085	c3		 ret	 0
?clear_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::clear_impl
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?fix_bucket@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEIIPAUptr_bucket@234@PAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z
_TEXT	SEGMENT
_this_bucket$ = -12					; size = 4
_this$ = -8						; size = 4
_bucket_index2$ = -4					; size = 4
_bucket_index$ = 8					; size = 4
_prev$ = 12						; size = 4
_next$ = 16						; size = 4
?fix_bucket@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEIIPAUptr_bucket@234@PAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::fix_bucket, COMDAT
; _this$ = ecx

; 3389 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3390 :           std::size_t bucket_index2 = bucket_index;

  00009	8b 45 08	 mov	 eax, DWORD PTR _bucket_index$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _bucket_index2$[ebp], eax

; 3391 : 
; 3392 :           if (next) {

  0000f	83 7d 10 00	 cmp	 DWORD PTR _next$[ebp], 0
  00013	74 2a		 je	 SHORT $LN12@fix_bucket

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  00015	8b 45 10	 mov	 eax, DWORD PTR _next$[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 3393 :             bucket_index2 = node_bucket(next);

  00020	89 45 fc	 mov	 DWORD PTR _bucket_index2$[ebp], eax

; 3394 : 
; 3395 :             // If next is in the same bucket, then there's nothing to do.
; 3396 :             if (bucket_index == bucket_index2) {

  00023	8b 45 08	 mov	 eax, DWORD PTR _bucket_index$[ebp]
  00026	3b 45 fc	 cmp	 eax, DWORD PTR _bucket_index2$[ebp]
  00029	75 05		 jne	 SHORT $LN10@fix_bucket

; 3397 :               return bucket_index2;

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _bucket_index2$[ebp]
  0002e	eb 31		 jmp	 SHORT $LN1@fix_bucket
$LN10@fix_bucket:

; 3398 :             }
; 3399 : 
; 3400 :             // Update the bucket containing next.
; 3401 :             get_bucket_pointer(bucket_index2)->next_ = prev;

  00030	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00033	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _bucket_index2$[ebp]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _prev$[ebp]
  0003c	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN12@fix_bucket:

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  00048	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 3402 :           }
; 3403 : 
; 3404 :           // Check if this bucket is now empty.
; 3405 :           bucket_pointer this_bucket = get_bucket_pointer(bucket_index);

  0004b	89 45 f4	 mov	 DWORD PTR _this_bucket$[ebp], eax

; 3406 :           if (this_bucket->next_ == prev) {

  0004e	8b 45 f4	 mov	 eax, DWORD PTR _this_bucket$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	3b 45 0c	 cmp	 eax, DWORD PTR _prev$[ebp]
  00056	75 06		 jne	 SHORT $LN4@fix_bucket

; 3407 :             this_bucket->next_ = link_pointer();

  00058	8b 45 f4	 mov	 eax, DWORD PTR _this_bucket$[ebp]
  0005b	83 20 00	 and	 DWORD PTR [eax], 0
$LN4@fix_bucket:

; 3408 :           }
; 3409 : 
; 3410 :           return bucket_index2;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _bucket_index2$[ebp]
$LN1@fix_bucket:

; 3411 :         }

  00061	c9		 leave
  00062	c2 0c 00	 ret	 12			; 0000000cH
?fix_bucket@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEIIPAUptr_bucket@234@PAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::fix_bucket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Ptr$ = -20						; size = 4
__Count$ = -16						; size = 4
_end$ = -12						; size = 4
_it$2 = -8						; size = 4
_this$ = -4						; size = 4
?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets, COMDAT
; _this$ = ecx

; 3370 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00015	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 3371 :           bucket_pointer end = get_bucket_pointer(bucket_count_ + 1);

  00019	89 45 f4	 mov	 DWORD PTR _end$[ebp], eax

; 3372 :           for (bucket_pointer it = buckets_; it != end; ++it) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00022	89 45 f8	 mov	 DWORD PTR _it$2[ebp], eax
  00025	eb 09		 jmp	 SHORT $LN4@destroy_bu
$LN2@destroy_bu:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  0002a	83 c0 04	 add	 eax, 4
  0002d	89 45 f8	 mov	 DWORD PTR _it$2[ebp], eax
$LN4@destroy_bu:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  00033	3b 45 f4	 cmp	 eax, DWORD PTR _end$[ebp]
  00036	74 08		 je	 SHORT $LN13@destroy_bu
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  0003b	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3374 :           }

  0003e	eb e7		 jmp	 SHORT $LN2@destroy_bu
$LN13@destroy_bu:

; 3375 : 
; 3376 :           bucket_allocator_traits::deallocate(

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00046	40		 inc	 eax
  00047	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	c1 e0 02	 shl	 eax, 2
  00059	50		 push	 eax
  0005a	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3378 :         }

  00064	c9		 leave
  00065	c3		 ret	 0
?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_next$2 = -24						; size = 4
_next$3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
_n$5 = -8						; size = 4
_this$ = -4						; size = 4
?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets, COMDAT
; _this$ = ecx

; 3344 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3345 :           if (buckets_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	0f 84 91 00 00
	00		 je	 $LN1@delete_buc

; 3346 :             node_pointer n = static_cast<node_pointer>(

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00022	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00025	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax

; 3347 :               get_bucket_pointer(bucket_count_)->next_);
; 3348 : 
; 3349 :             if (bucket::extra_node) {

  00028	33 c0		 xor	 eax, eax
  0002a	74 3d		 je	 SHORT $LN2@delete_buc

; 2964 :           return static_cast<node_pointer>(n->next_);

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 45 ec	 mov	 DWORD PTR _next$3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  00037	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c0 03	 add	 eax, 3
  00040	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00043	74 09		 je	 SHORT $LN20@delete_buc
  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00048	40		 inc	 eax
  00049	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004c	eb 04		 jmp	 SHORT $LN16@delete_buc
$LN20@delete_buc:
  0004e	83 65 f0 00	 and	 DWORD PTR $T4[ebp], 0
$LN16@delete_buc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00052	33 c0		 xor	 eax, eax
  00054	40		 inc	 eax
  00055	c1 e0 04	 shl	 eax, 4
  00058	50		 push	 eax
  00059	ff 75 f8	 push	 DWORD PTR _n$5[ebp]
  0005c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00061	59		 pop	 ecx
  00062	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3353 :               n = next;

  00063	8b 45 ec	 mov	 eax, DWORD PTR _next$3[ebp]
  00066	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax
$LN2@delete_buc:

; 3354 :             }
; 3355 : 
; 3356 :             while (n) {

  00069	83 7d f8 00	 cmp	 DWORD PTR _n$5[ebp], 0
  0006d	74 1b		 je	 SHORT $LN3@delete_buc

; 2964 :           return static_cast<node_pointer>(n->next_);

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	89 45 e8	 mov	 DWORD PTR _next$2[ebp], eax

; 3357 :               node_pointer next = next_node(n);
; 3358 :               destroy_node(n);

  00077	ff 75 f8	 push	 DWORD PTR _n$5[ebp]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node

; 3359 :               n = next;

  00082	8b 45 e8	 mov	 eax, DWORD PTR _next$2[ebp]
  00085	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax

; 3360 :             }

  00088	eb df		 jmp	 SHORT $LN2@delete_buc
$LN3@delete_buc:

; 3361 : 
; 3362 :             destroy_buckets();

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets

; 3363 :             buckets_ = bucket_pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 3364 :             max_load_ = 0;

  00099	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 3365 :             size_ = 0;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LN1@delete_buc:

; 3366 :           }
; 3367 :         }

  000a7	c9		 leave
  000a8	c3		 ret	 0
?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node, COMDAT
; _this$ = ecx

; 3336 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 03	 add	 eax, 3
  0000f	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00012	74 09		 je	 SHORT $LN11@destroy_no
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	40		 inc	 eax
  00018	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0001b	eb 04		 jmp	 SHORT $LN15@destroy_no
$LN11@destroy_no:
  0001d	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0
$LN15@destroy_no:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00021	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00024	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 03	 add	 eax, 3
  0002d	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00030	74 09		 je	 SHORT $LN26@destroy_no
  00032	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00035	40		 inc	 eax
  00036	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00039	eb 04		 jmp	 SHORT $LN22@destroy_no
$LN26@destroy_no:
  0003b	83 65 ec 00	 and	 DWORD PTR $T2[ebp], 0
$LN22@destroy_no:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0003f	33 c0		 xor	 eax, eax
  00041	40		 inc	 eax
  00042	c1 e0 04	 shl	 eax, 4
  00045	50		 push	 eax
  00046	ff 75 08	 push	 DWORD PTR _n$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0004e	59		 pop	 ecx
  0004f	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3341 :         }

  00050	c9		 leave
  00051	c2 04 00	 ret	 4
?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
_a$2 = -116						; size = 8
__Max_possible$3 = -108					; size = 4
__Max_possible$4 = -104					; size = 4
__Max_possible$5 = -100					; size = 4
$T6 = -96						; size = 4
$T7 = -92						; size = 4
$T8 = -88						; size = 4
$T9 = -84						; size = 4
$T10 = -80						; size = 4
$T11 = -76						; size = 4
_p$12 = -72						; size = 4
$T13 = -68						; size = 4
$T14 = -64						; size = 4
_new_buckets$15 = -60					; size = 4
$T16 = -56						; size = 4
_end$ = -52						; size = 4
__Count$ = -48						; size = 4
__Count$ = -44						; size = 4
$T17 = -40						; size = 4
_this$ = -36						; size = 4
__Count$ = -32						; size = 4
_dummy_node$ = -28					; size = 4
_i$18 = -24						; size = 4
_this$ = -20						; size = 4
__Overflow_is_possible$19 = -15				; size = 1
__Overflow_is_possible$20 = -14				; size = 1
__Overflow_is_possible$21 = -13				; size = 1
__$EHRec$ = -12						; size = 12
_new_count$ = 8						; size = 4
?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets, COMDAT
; _this$ = ecx

; 3178 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3179 :           link_pointer dummy_node;
; 3180 : 
; 3181 :           // Construct the new buckets and dummy node, and destroy the old
; 3182 :           // buckets
; 3183 :           if (buckets_) {

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0002f	74 5d		 je	 SHORT $LN5@create_buc

; 3184 :             dummy_node =

  00031	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0003d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00040	89 45 e4	 mov	 DWORD PTR _dummy_node$[ebp], eax

; 3185 :               (buckets_ + static_cast<std::ptrdiff_t>(bucket_count_))->next_;
; 3186 :             bucket_pointer new_buckets =

  00043	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  00046	40		 inc	 eax
  00047	89 45 e0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0004a	c6 45 f3 01	 mov	 BYTE PTR __Overflow_is_possible$21[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0004e	c7 45 9c ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$5[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00055	81 7d e0 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0005c	76 05		 jbe	 SHORT $LN20@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0005e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN20@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00063	8b 45 e0	 mov	 eax, DWORD PTR __Count$[ebp]
  00066	c1 e0 02	 shl	 eax, 2
  00069	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  0006c	ff 75 c8	 push	 DWORD PTR $T16[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00074	59		 pop	 ecx
  00075	89 45 c4	 mov	 DWORD PTR _new_buckets$15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3188 :             destroy_buckets();

  00078	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets

; 3189 :             buckets_ = new_buckets;

  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d c4	 mov	 ecx, DWORD PTR _new_buckets$15[ebp]
  00086	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00089	e9 d4 00 00 00	 jmp	 $LN6@create_buc
$LN5@create_buc:

; 3190 :           } else if (bucket::extra_node) {

  0008e	33 c0		 xor	 eax, eax
  00090	0f 84 8a 00 00
	00		 je	 $LN7@create_buc

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00096	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 03	 add	 eax, 3
  0009c	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  0009f	74 09		 je	 SHORT $LN48@create_buc
  000a1	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	40		 inc	 eax
  000a5	89 45 d8	 mov	 DWORD PTR $T17[ebp], eax
  000a8	eb 04		 jmp	 SHORT $LN44@create_buc
$LN48@create_buc:
  000aa	83 65 d8 00	 and	 DWORD PTR $T17[ebp], 0
$LN44@create_buc:

; 1946 :         node_constructor(node_allocator& n) : alloc_(n), node_() {}

  000ae	8b 45 d8	 mov	 eax, DWORD PTR $T17[ebp]
  000b1	89 45 8c	 mov	 DWORD PTR _a$2[ebp], eax
  000b4	83 65 90 00	 and	 DWORD PTR _a$2[ebp+4], 0

; 3191 :             node_constructor a(node_alloc());

  000b8	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 3192 :             a.create_node();

  000bc	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  000bf	e8 00 00 00 00	 call	 ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::create_node

; 3193 :             buckets_ =

  000c4	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  000c7	40		 inc	 eax
  000c8	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000cb	c6 45 f2 01	 mov	 BYTE PTR __Overflow_is_possible$20[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000cf	c7 45 98 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$4[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000d6	81 7d d4 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  000dd	76 05		 jbe	 SHORT $LN63@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000df	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN63@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000e4	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  000e7	c1 e0 02	 shl	 eax, 2
  000ea	89 45 c0	 mov	 DWORD PTR $T14[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  000ed	ff 75 c0	 push	 DWORD PTR $T14[ebp]
  000f0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000f5	59		 pop	 ecx
  000f6	89 45 bc	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3193 :             buckets_ =

  000f9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	8b 4d bc	 mov	 ecx, DWORD PTR $T13[ebp]
  000ff	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1956 :           node_pointer p = node_;

  00102	8b 45 90	 mov	 eax, DWORD PTR _a$2[ebp+4]
  00105	89 45 b8	 mov	 DWORD PTR _p$12[ebp], eax

; 1957 :           node_ = node_pointer();

  00108	83 65 90 00	 and	 DWORD PTR _a$2[ebp+4], 0

; 3194 :               bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);
; 3195 :             dummy_node = a.release();

  0010c	8b 45 b8	 mov	 eax, DWORD PTR _p$12[ebp]
  0010f	89 45 e4	 mov	 DWORD PTR _dummy_node$[ebp], eax

; 3196 :           } else {

  00112	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00116	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  00119	e8 00 00 00 00	 call	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
  0011e	eb 42		 jmp	 SHORT $LN6@create_buc
$LN7@create_buc:

; 3197 :             dummy_node = link_pointer();

  00120	83 65 e4 00	 and	 DWORD PTR _dummy_node$[ebp], 0

; 3198 :             buckets_ =

  00124	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  00127	40		 inc	 eax
  00128	89 45 d0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0012b	c6 45 f1 01	 mov	 BYTE PTR __Overflow_is_possible$19[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0012f	c7 45 94 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$3[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00136	81 7d d0 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0013d	76 05		 jbe	 SHORT $LN77@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0013f	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN77@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00144	8b 45 d0	 mov	 eax, DWORD PTR __Count$[ebp]
  00147	c1 e0 02	 shl	 eax, 2
  0014a	89 45 b4	 mov	 DWORD PTR $T11[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  0014d	ff 75 b4	 push	 DWORD PTR $T11[ebp]
  00150	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00155	59		 pop	 ecx
  00156	89 45 b0	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3198 :             buckets_ =

  00159	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	8b 4d b0	 mov	 ecx, DWORD PTR $T10[ebp]
  0015f	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN6@create_buc:

; 3199 :               bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);
; 3200 :           }
; 3201 : 
; 3202 :           // nothrow from here...
; 3203 :           bucket_count_ = new_count;

  00162	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00165	8b 4d 08	 mov	 ecx, DWORD PTR _new_count$[ebp]
  00168	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3204 :           recalculate_max_load();

  0016b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load

; 3205 : 
; 3206 :           bucket_pointer end =

  00173	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00176	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00179	8b 4d 08	 mov	 ecx, DWORD PTR _new_count$[ebp]
  0017c	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0017f	89 45 cc	 mov	 DWORD PTR _end$[ebp], eax

; 3207 :             buckets_ + static_cast<std::ptrdiff_t>(new_count);
; 3208 :           for (bucket_pointer i = buckets_; i != end; ++i) {

  00182	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00185	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00188	89 45 e8	 mov	 DWORD PTR _i$18[ebp], eax
  0018b	eb 09		 jmp	 SHORT $LN4@create_buc
$LN2@create_buc:
  0018d	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  00190	83 c0 04	 add	 eax, 4
  00193	89 45 e8	 mov	 DWORD PTR _i$18[ebp], eax
$LN4@create_buc:
  00196	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  00199	3b 45 cc	 cmp	 eax, DWORD PTR _end$[ebp]
  0019c	74 14		 je	 SHORT $LN3@create_buc
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0019e	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  001a1	89 45 ac	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001a4	8b 45 ac	 mov	 eax, DWORD PTR $T9[ebp]
  001a7	89 45 a8	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2579 :         ptr_bucket() : next_(0) {}

  001aa	8b 45 a8	 mov	 eax, DWORD PTR $T8[ebp]
  001ad	83 20 00	 and	 DWORD PTR [eax], 0

; 3209 :             new ((void*)boost::to_address(i)) bucket();
; 3210 :           }

  001b0	eb db		 jmp	 SHORT $LN2@create_buc
$LN3@create_buc:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  001b2	8b 45 cc	 mov	 eax, DWORD PTR _end$[ebp]
  001b5	89 45 a4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001b8	8b 45 a4	 mov	 eax, DWORD PTR $T7[ebp]
  001bb	89 45 a0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2580 :         ptr_bucket(link_pointer n) : next_(n) {}

  001be	8b 45 a0	 mov	 eax, DWORD PTR $T6[ebp]
  001c1	8b 4d e4	 mov	 ecx, DWORD PTR _dummy_node$[ebp]
  001c4	89 08		 mov	 DWORD PTR [eax], ecx
$LN23@create_buc:

; 3211 :           new ((void*)boost::to_address(end)) bucket(dummy_node);
; 3212 :         }

  001c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d0	59		 pop	 ecx
  001d1	c9		 leave
  001d2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0:
  00000	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,SEterPackIndex *> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_which$ = -16						; size = 1
__$EHRec$ = -12						; size = 12
_num_buckets$ = 8					; size = 4
_hf$ = 12						; size = 4
_eq$ = 16						; size = 4
_a$ = 20						; size = 4
??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >, COMDAT
; _this$ = ecx

; 3123 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2761 :         functions(H const& hf, P const& eq) : current_(0)

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2762 :         {
; 2763 :           construct_functions(current_, hf, eq);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8a 00		 mov	 al, BYTE PTR [eax]
  00033	88 45 f0	 mov	 BYTE PTR _which$[ebp], al

; 2827 :           new ((void*)&funcs_[which]) function_pair(hf, eq);

  00036	0f b6 45 f0	 movzx	 eax, BYTE PTR _which$[ebp]
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00041	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3120 :             : functions(hf, eq), allocators_(a, a),

  00044	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2609 :           return boost::unordered::detail::next_prime(min);

  00048	ff 75 08	 push	 DWORD PTR _num_buckets$[ebp]
  0004b	e8 00 00 00 00	 call	 ?next_prime@detail@unordered@boost@@YAII@Z ; boost::unordered::detail::next_prime
  00050	59		 pop	 ecx

; 3121 :               bucket_count_(policy::new_bucket_count(num_buckets)), size_(0),

  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00057	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 3122 :               mlf_(1.0f), max_load_(0), buckets_()

  0005e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00061	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00069	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 3124 :         }

  0007c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	c9		 leave
  0008f	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::~functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@6@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z
_TEXT	SEGMENT
tv91 = -40						; size = 8
_f$ = -32						; size = 8
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
tv81 = -12						; size = 4
tv87 = -8						; size = 4
$T3 = -4						; size = 4
_size$ = 8						; size = 4
?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size, COMDAT
; _this$ = ecx

; 3095 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3096 :           BOOST_ASSERT(mlf_ >= minimum_max_load_factor);
; 3097 : 
; 3098 :           using namespace std;
; 3099 : 
; 3100 :           // From insert/emplace requirements:
; 3101 :           //
; 3102 :           // size <= mlf_ * count
; 3103 :           // => count >= size / mlf_
; 3104 :           //
; 3105 :           // Or from rehash post-condition:
; 3106 :           //
; 3107 :           // count >= size / mlf_
; 3108 : 
; 3109 :           return policy::new_bucket_count(

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	f3 0f 5a 40 0c	 cvtss2sd xmm0, DWORD PTR [eax+12]
  00011	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR tv87[ebp], eax
  00017	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR tv87[ebp]
  0001c	8b 45 f8	 mov	 eax, DWORD PTR tv87[ebp]
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0002b	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0002f	51		 push	 ecx
  00030	51		 push	 ecx
  00031	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00036	e8 00 00 00 00	 call	 _floor
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
  0003d	dd 5d d8	 fstp	 QWORD PTR tv91[ebp]
  00040	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR tv91[ebp]
  00045	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0004d	f2 0f 11 45 e0	 movsd	 QWORD PTR _f$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00052	83 4d ec ff	 or	 DWORD PTR $T2[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00056	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00059	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
  0005c	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR tv81[ebp]
  00061	8b 45 f4	 mov	 eax, DWORD PTR tv81[ebp]
  00064	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00067	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00070	f2 0f 10 4d e0	 movsd	 xmm1, QWORD PTR _f$[ebp]
  00075	66 0f 2f c8	 comisd	 xmm1, xmm0
  00079	72 0c		 jb	 SHORT $LN5@min_bucket
  0007b	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0007e	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00081	83 4d fc ff	 or	 DWORD PTR $T3[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00085	eb 0d		 jmp	 SHORT $LN6@min_bucket
$LN5@min_bucket:
  00087	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR _f$[ebp]
  0008c	e8 00 00 00 00	 call	 __dtoui3
  00091	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
$LN6@min_bucket:

; 2609 :           return boost::unordered::detail::next_prime(min);

  00094	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00097	e8 00 00 00 00	 call	 ?next_prime@detail@unordered@boost@@YAII@Z ; boost::unordered::detail::next_prime
  0009c	59		 pop	 ecx

; 3110 :             boost::unordered::detail::double_to_size(
; 3111 :               floor(static_cast<double>(size) / static_cast<double>(mlf_)) +
; 3112 :               1));
; 3113 :         }

  0009d	c9		 leave
  0009e	c2 04 00	 ret	 4
?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
_f$ = -36						; size = 8
$T1 = -28						; size = 4
$T2 = -24						; size = 4
tv76 = -20						; size = 4
tv92 = -16						; size = 4
tv83 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load, COMDAT
; _this$ = ecx

; 3076 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3077 :           using namespace std;
; 3078 : 
; 3079 :           // From 6.3.1/13:
; 3080 :           // Only resize when size >= mlf_ * count
; 3081 :           max_load_ = buckets_ ? boost::unordered::detail::double_to_size(

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	0f 84 84 00 00
	00		 je	 $LN3@recalculat
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
  0001f	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR tv83[ebp]
  00024	8b 45 f4	 mov	 eax, DWORD PTR tv83[ebp]
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	f3 0f 5a 48 0c	 cvtss2sd xmm1, DWORD PTR [eax+12]
  0003b	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0003f	51		 push	 ecx
  00040	51		 push	 ecx
  00041	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00046	e8 00 00 00 00	 call	 _ceil
  0004b	59		 pop	 ecx
  0004c	59		 pop	 ecx
  0004d	dd 5d dc	 fstp	 QWORD PTR _f$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00050	83 4d e8 ff	 or	 DWORD PTR $T2[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00054	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00057	89 45 f0	 mov	 DWORD PTR tv92[ebp], eax
  0005a	f2 0f 2a 45 f0	 cvtsi2sd xmm0, DWORD PTR tv92[ebp]
  0005f	8b 45 f0	 mov	 eax, DWORD PTR tv92[ebp]
  00062	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00065	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0006e	f2 0f 10 4d dc	 movsd	 xmm1, QWORD PTR _f$[ebp]
  00073	66 0f 2f c8	 comisd	 xmm1, xmm0
  00077	72 0c		 jb	 SHORT $LN7@recalculat
  00079	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0007c	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  0007f	83 4d f8 ff	 or	 DWORD PTR tv82[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00083	eb 0d		 jmp	 SHORT $LN8@recalculat
$LN7@recalculat:
  00085	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR _f$[ebp]
  0008a	e8 00 00 00 00	 call	 __dtoui3
  0008f	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
$LN8@recalculat:

; 3077 :           using namespace std;
; 3078 : 
; 3079 :           // From 6.3.1/13:
; 3080 :           // Only resize when size >= mlf_ * count
; 3081 :           max_load_ = buckets_ ? boost::unordered::detail::double_to_size(

  00092	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00095	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  00098	eb 04		 jmp	 SHORT $LN4@recalculat
$LN3@recalculat:
  0009a	83 65 ec 00	 and	 DWORD PTR tv76[ebp], 0
$LN4@recalculat:
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  000a4	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3082 :                                    ceil(static_cast<double>(mlf_) *
; 3083 :                                         static_cast<double>(bucket_count_)))
; 3084 :                                : 0;
; 3085 :         }

  000a7	c9		 leave
  000a8	c3		 ret	 0
?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@I@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_prev$ = -12						; size = 4
_this$ = -8						; size = 4
tv72 = -4						; size = 4
_bucket_index$ = 8					; size = 4
?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@I@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin, COMDAT
; _this$ = ecx

; 3045 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3046 :           if (!size_)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	75 04		 jne	 SHORT $LN8@begin

; 3047 :             return node_pointer();

  00012	33 c0		 xor	 eax, eax
  00014	eb 2c		 jmp	 SHORT $LN1@begin
$LN8@begin:

; 3036 :           return get_bucket_pointer(bucket_index)->next_;

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  0001f	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00022	89 45 f4	 mov	 DWORD PTR _prev$[ebp], eax

; 3048 :           link_pointer prev = get_previous_start(bucket_index);
; 3049 :           return prev ? next_node(prev) : node_pointer();

  00025	83 7d f4 00	 cmp	 DWORD PTR _prev$[ebp], 0
  00029	74 10		 je	 SHORT $LN4@begin
  0002b	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR tv72[ebp], eax

; 2964 :           return static_cast<node_pointer>(n->next_);

  00031	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 fc	 mov	 DWORD PTR tv72[ebp], eax

; 3048 :           link_pointer prev = get_previous_start(bucket_index);
; 3049 :           return prev ? next_node(prev) : node_pointer();

  00039	eb 04		 jmp	 SHORT $LN5@begin
$LN4@begin:
  0003b	83 65 fc 00	 and	 DWORD PTR tv72[ebp], 0
$LN5@begin:
  0003f	8b 45 fc	 mov	 eax, DWORD PTR tv72[ebp]
$LN1@begin:

; 3050 :         }

  00042	c9		 leave
  00043	c2 04 00	 ret	 4
?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@I@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@XZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@XZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin, COMDAT
; _this$ = ecx

; 3040 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 22		 je	 SHORT $LN3@begin

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0001e	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00021	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  00024	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00027	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax

; 2964 :           return static_cast<node_pointer>(n->next_);

  0002a	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  00032	eb 04		 jmp	 SHORT $LN4@begin
$LN3@begin:
  00034	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN4@begin:
  00038	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 3042 :         }

  0003b	c9		 leave
  0003c	c3		 ret	 0
?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@XZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z
_TEXT	SEGMENT
tv84 = -8						; size = 4
_n2$ = -4						; size = 4
_n$ = 8							; size = 4
?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find, COMDAT

; 2968 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 2969 :           node_pointer n2 = static_cast<node_pointer>(n);

  00005	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _n2$[ebp], eax
$LN4@next_for_f:

; 2964 :           return static_cast<node_pointer>(n->next_);

  0000b	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	89 45 fc	 mov	 DWORD PTR _n2$[ebp], eax

; 2970 :           do {
; 2971 :             n2 = next_node(n2);
; 2972 :           } while (n2 && !n2->is_first_in_group());

  00013	83 7d fc 00	 cmp	 DWORD PTR _n2$[ebp], 0
  00017	74 20		 je	 SHORT $LN3@next_for_f

; 4878 :           return !(bucket_info_ & ~((std::size_t)-1 >> 1));

  00019	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00024	75 09		 jne	 SHORT $LN11@next_for_f
  00026	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
  0002d	eb 04		 jmp	 SHORT $LN9@next_for_f
$LN11@next_for_f:
  0002f	83 65 f8 00	 and	 DWORD PTR tv84[ebp], 0
$LN9@next_for_f:

; 2970 :           do {
; 2971 :             n2 = next_node(n2);
; 2972 :           } while (n2 && !n2->is_first_in_group());

  00033	83 7d f8 00	 cmp	 DWORD PTR tv84[ebp], 0
  00037	74 d2		 je	 SHORT $LN4@next_for_f
$LN3@next_for_f:

; 2973 :           return n2;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]

; 2974 :         }

  0003c	c9		 leave
  0003d	c3		 ret	 0
?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node, COMDAT

; 2963 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2964 :           return static_cast<node_pointer>(n->next_);

  00003	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 2965 :         }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@PAUptr_bucket@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??A?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAEAAKABK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_k$ = 8							; size = 4
??A?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAEAAKABK@Z PROC ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[], COMDAT
; _this$ = ecx

; 1865 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1866 :       return table_.try_emplace_unique(k).first->second;

  00009	ff 75 08	 push	 DWORD PTR _k$[ebp]
  0000c	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??$try_emplace_unique@ABK@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::try_emplace_unique<unsigned long const &>
  00018	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	83 c0 0c	 add	 eax, 12			; 0000000cH

; 1867 :     }

  00023	c9		 leave
  00024	c2 04 00	 ret	 4
??A?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAEAAKABK@Z ENDP ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ PROC ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::~unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >, COMDAT
; _this$ = ecx

; 1645 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3333 :         ~table() { delete_buckets(); }

  00026	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
  00032	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1646 :     }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	c9		 leave
  00042	c3		 ret	 0
  00043	cc		 int	 3
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ ENDP ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::~unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ??0?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
??0?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ PROC ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >, COMDAT
; _this$ = ecx

; 1510 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1508 :         : table_(boost::unordered::detail::default_bucket_count, hasher(),

  00008	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  0000b	50		 push	 eax
  0000c	8d 45 fe	 lea	 eax, DWORD PTR $T2[ebp]
  0000f	50		 push	 eax
  00010	8d 45 fd	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	6a 0b		 push	 11			; 0000000bH
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >

; 1511 :     }

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	c9		 leave
  00022	c3		 ret	 0
??0?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ ENDP ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z
_TEXT	SEGMENT
_b$ = -40						; size = 8
$T2 = -32						; size = 4
_p$3 = -28						; size = 4
$T4 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_n$ = 8							; size = 4
_key_hash$ = 12						; size = 4
?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::resize_and_add_node_unique, COMDAT
; _this$ = ecx

; 3715 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 03	 add	 eax, 3
  0002e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00031	74 09		 je	 SHORT $LN8@resize_and
  00033	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00036	40		 inc	 eax
  00037	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
  0003a	eb 04		 jmp	 SHORT $LN4@resize_and
$LN8@resize_and:
  0003c	83 65 e8 00	 and	 DWORD PTR $T4[ebp], 0
$LN4@resize_and:

; 1999 :         explicit node_tmp(node_pointer n, NodeAlloc& a) : alloc_(a), node_(n) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00043	89 45 d8	 mov	 DWORD PTR _b$[ebp], eax
  00046	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00049	89 45 dc	 mov	 DWORD PTR _b$[ebp+4], eax

; 3716 :           node_tmp b(n, this->node_alloc());

  0004c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 3717 :           this->reserve_for_insert(this->size_ + 1);

  00050	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00056	40		 inc	 eax
  00057	50		 push	 eax
  00058	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert

; 2006 :           node_pointer p = node_;

  00060	8b 45 dc	 mov	 eax, DWORD PTR _b$[ebp+4]
  00063	89 45 e4	 mov	 DWORD PTR _p$3[ebp], eax

; 2007 :           node_ = node_pointer();

  00066	83 65 dc 00	 and	 DWORD PTR _b$[ebp+4], 0

; 3718 :           return this->add_node_unique(b.release(), key_hash);

  0006a	ff 75 0c	 push	 DWORD PTR _key_hash$[ebp]
  0006d	ff 75 e4	 push	 DWORD PTR _p$3[ebp]
  00070	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_unique
  00078	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  0007b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007f	8d 4d d8	 lea	 ecx, DWORD PTR _b$[ebp]
  00082	e8 00 00 00 00	 call	 ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
  00087	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]

; 3719 :         }

  0008a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00094	59		 pop	 ecx
  00095	c9		 leave
  00096	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _b$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?resize_and_add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::resize_and_add_node_unique
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
_bucket_index$ = -16					; size = 4
_b$ = -12						; size = 4
_start_node$4 = -8					; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
_key_hash$ = 12						; size = 4
?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_unique, COMDAT
; _this$ = ecx

; 3686 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2604 :           return hash % bucket_count;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _key_hash$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	f7 71 04	 div	 DWORD PTR [ecx+4]

; 3687 :           std::size_t bucket_index = this->hash_to_bucket(key_hash);

  00014	89 55 f0	 mov	 DWORD PTR _bucket_index$[ebp], edx

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001d	8b 4d f0	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  00020	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 3688 :           bucket_pointer b = this->get_bucket_pointer(bucket_index);

  00023	89 45 f4	 mov	 DWORD PTR _b$[ebp], eax

; 3689 : 
; 3690 :           n->bucket_info_ = bucket_index;

  00026	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  0002c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4883 :           bucket_info_ = bucket_info_ & ((std::size_t)-1 >> 1);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00032	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00035	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  0003d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3691 :           n->set_first_in_group();
; 3692 : 
; 3693 :           if (!b->next_) {

  00040	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]
  00043	83 38 00	 cmp	 DWORD PTR [eax], 0
  00046	75 61		 jne	 SHORT $LN2@add_node_u

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00054	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00057	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 3694 :             link_pointer start_node = this->get_previous_start();

  0005a	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	89 45 f8	 mov	 DWORD PTR _start_node$4[ebp], eax

; 3695 : 
; 3696 :             if (start_node->next_) {

  00060	8b 45 f8	 mov	 eax, DWORD PTR _start_node$4[ebp]
  00063	83 38 00	 cmp	 DWORD PTR [eax], 0
  00066	74 25		 je	 SHORT $LN4@add_node_u

; 2964 :           return static_cast<node_pointer>(n->next_);

  00068	8b 45 f8	 mov	 eax, DWORD PTR _start_node$4[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  00070	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00073	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00076	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 2999 :           return n->get_bucket();

  0007b	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3697 :               this->get_bucket_pointer(node_bucket(next_node(start_node)))

  0007e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00084	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  00087	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  0008a	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN4@add_node_u:

; 3698 :                 ->next_ = n;
; 3699 :             }
; 3700 : 
; 3701 :             b->next_ = start_node;

  0008d	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]
  00090	8b 4d f8	 mov	 ecx, DWORD PTR _start_node$4[ebp]
  00093	89 08		 mov	 DWORD PTR [eax], ecx

; 3702 :             n->next_ = start_node->next_;

  00095	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00098	8b 4d f8	 mov	 ecx, DWORD PTR _start_node$4[ebp]
  0009b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0009d	89 08		 mov	 DWORD PTR [eax], ecx

; 3703 :             start_node->next_ = n;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _start_node$4[ebp]
  000a2	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  000a5	89 08		 mov	 DWORD PTR [eax], ecx

; 3704 :           } else {

  000a7	eb 16		 jmp	 SHORT $LN3@add_node_u
$LN2@add_node_u:

; 3705 :             n->next_ = b->next_->next_;

  000a9	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]
  000ac	8b 00		 mov	 eax, DWORD PTR [eax]
  000ae	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  000b1	8b 00		 mov	 eax, DWORD PTR [eax]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 3706 :             b->next_->next_ = n;

  000b5	8b 45 f4	 mov	 eax, DWORD PTR _b$[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  000bd	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@add_node_u:

; 3707 :           }
; 3708 : 
; 3709 :           ++this->size_;

  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000c5	40		 inc	 eax
  000c6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 3710 :           return n;

  000cc	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]

; 3711 :         }

  000cf	c9		 leave
  000d0	c2 08 00	 ret	 8
?add_node_unique@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAU5234@I@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_unique
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
$T2 = -76						; size = 4
_next$3 = -72						; size = 4
_next$4 = -68						; size = 4
_key_hash$5 = -64					; size = 4
tv129 = -60						; size = 4
_v$6 = -56						; size = 4
$T7 = -52						; size = 4
tv221 = -48						; size = 4
_bucket_index$8 = -44					; size = 4
_next$9 = -40						; size = 4
_n$10 = -36						; size = 4
_b$11 = -32						; size = 4
_prev$ = -28						; size = 4
_this$ = -24						; size = 4
_n$12 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_num_buckets$ = 8					; size = 4
?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl, COMDAT
; _this$ = ecx

; 4577 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 4578 :         BOOST_ASSERT(this->buckets_);
; 4579 : 
; 4580 :         this->create_buckets(num_buckets);

  0002f	ff 75 08	 push	 DWORD PTR _num_buckets$[ebp]
  00032	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  0003a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00040	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00046	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00049	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 4581 :         link_pointer prev = this->get_previous_start();

  0004c	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  0004f	89 45 e4	 mov	 DWORD PTR _prev$[ebp], eax

; 4582 :         BOOST_TRY

  00052	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
$LN2@rehash_imp:

; 4583 :         {
; 4584 :           while (prev->next_) {

  00056	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00059	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005c	0f 84 04 01 00
	00		 je	 $LN3@rehash_imp

; 2964 :           return static_cast<node_pointer>(n->next_);

  00062	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 ec	 mov	 DWORD PTR _n$12[ebp], eax

; 2791 :           return *static_cast<function_pair const*>(

  0006a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00070	83 e0 01	 and	 eax, 1
  00073	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  0007a	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 2599 :           return hf(x);

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00080	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00083	89 45 c8	 mov	 DWORD PTR _v$6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp

; 621  :     BOOST_HASH_SPECIALIZE(unsigned long)

  00086	ff 75 c8	 push	 DWORD PTR _v$6[ebp]
  00089	e8 00 00 00 00	 call	 ??$hash_value@K@boost@@YAIK@Z ; boost::hash_value<unsigned long>
  0008e	59		 pop	 ecx
  0008f	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4586 :             std::size_t key_hash = this->hash(this->get_key(n));

  00092	8b 45 c4	 mov	 eax, DWORD PTR tv129[ebp]
  00095	89 45 c0	 mov	 DWORD PTR _key_hash$5[ebp], eax

; 2604 :           return hash % bucket_count;

  00098	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 45 c0	 mov	 eax, DWORD PTR _key_hash$5[ebp]
  0009e	33 d2		 xor	 edx, edx
  000a0	f7 71 04	 div	 DWORD PTR [ecx+4]

; 4587 :             std::size_t bucket_index = this->hash_to_bucket(key_hash);

  000a3	89 55 d4	 mov	 DWORD PTR _bucket_index$8[ebp], edx

; 4588 : 
; 4589 :             n->bucket_info_ = bucket_index;

  000a6	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000a9	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  000ac	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4883 :           bucket_info_ = bucket_info_ & ((std::size_t)-1 >> 1);

  000af	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  000bd	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN6@rehash_imp:

; 2964 :           return static_cast<node_pointer>(n->next_);

  000c0	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000c3	8b 00		 mov	 eax, DWORD PTR [eax]
  000c5	89 45 d8	 mov	 DWORD PTR _next$9[ebp], eax

; 4590 :             n->set_first_in_group();
; 4591 : 
; 4592 :             // Iterator through the rest of the group of equal nodes,
; 4593 :             // setting the bucket.
; 4594 :             for (;;) {
; 4595 :               node_pointer next = next_node(n);
; 4596 :               if (!next || next->is_first_in_group()) {

  000c8	83 7d d8 00	 cmp	 DWORD PTR _next$9[ebp], 0
  000cc	74 20		 je	 SHORT $LN11@rehash_imp

; 4878 :           return !(bucket_info_ & ~((std::size_t)-1 >> 1));

  000ce	8b 45 d8	 mov	 eax, DWORD PTR _next$9[ebp]
  000d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000d9	75 09		 jne	 SHORT $LN61@rehash_imp
  000db	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv221[ebp], 1
  000e2	eb 04		 jmp	 SHORT $LN59@rehash_imp
$LN61@rehash_imp:
  000e4	83 65 d0 00	 and	 DWORD PTR tv221[ebp], 0
$LN59@rehash_imp:

; 4590 :             n->set_first_in_group();
; 4591 : 
; 4592 :             // Iterator through the rest of the group of equal nodes,
; 4593 :             // setting the bucket.
; 4594 :             for (;;) {
; 4595 :               node_pointer next = next_node(n);
; 4596 :               if (!next || next->is_first_in_group()) {

  000e8	83 7d d0 00	 cmp	 DWORD PTR tv221[ebp], 0
  000ec	74 02		 je	 SHORT $LN10@rehash_imp
$LN11@rehash_imp:

; 4597 :                 break;

  000ee	eb 22		 jmp	 SHORT $LN65@rehash_imp
$LN10@rehash_imp:

; 4598 :               }
; 4599 :               n = next;

  000f0	8b 45 d8	 mov	 eax, DWORD PTR _next$9[ebp]
  000f3	89 45 ec	 mov	 DWORD PTR _n$12[ebp], eax

; 4600 :               n->bucket_info_ = bucket_index;

  000f6	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000f9	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  000fc	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4888 :           bucket_info_ = bucket_info_ | ~((std::size_t)-1 >> 1);

  000ff	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00102	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00105	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  0010a	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  0010d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 4601 :               n->reset_first_in_group();
; 4602 :             }

  00110	eb ae		 jmp	 SHORT $LN6@rehash_imp
$LN65@rehash_imp:

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00112	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00118	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  0011b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 4603 : 
; 4604 :             // n is now the last node in the group
; 4605 :             bucket_pointer b = this->get_bucket_pointer(bucket_index);

  0011e	89 45 e0	 mov	 DWORD PTR _b$11[ebp], eax

; 4606 :             if (!b->next_) {

  00121	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00124	83 38 00	 cmp	 DWORD PTR [eax], 0
  00127	75 10		 jne	 SHORT $LN12@rehash_imp

; 4607 :               b->next_ = prev;

  00129	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  0012c	8b 4d e4	 mov	 ecx, DWORD PTR _prev$[ebp]
  0012f	89 08		 mov	 DWORD PTR [eax], ecx

; 4608 :               prev = n;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00134	89 45 e4	 mov	 DWORD PTR _prev$[ebp], eax

; 4609 :             } else {

  00137	eb 28		 jmp	 SHORT $LN13@rehash_imp
$LN12@rehash_imp:

; 4610 :               link_pointer next = n->next_;

  00139	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  0013c	8b 00		 mov	 eax, DWORD PTR [eax]
  0013e	89 45 bc	 mov	 DWORD PTR _next$4[ebp], eax

; 4611 :               n->next_ = b->next_->next_;

  00141	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00144	8b 00		 mov	 eax, DWORD PTR [eax]
  00146	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	89 01		 mov	 DWORD PTR [ecx], eax

; 4612 :               b->next_->next_ = prev->next_;

  0014d	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00150	8b 00		 mov	 eax, DWORD PTR [eax]
  00152	8b 4d e4	 mov	 ecx, DWORD PTR _prev$[ebp]
  00155	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00157	89 08		 mov	 DWORD PTR [eax], ecx

; 4613 :               prev->next_ = next;

  00159	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  0015c	8b 4d bc	 mov	 ecx, DWORD PTR _next$4[ebp]
  0015f	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@rehash_imp:

; 4614 :             }
; 4615 :           }

  00161	e9 f0 fe ff ff	 jmp	 $LN2@rehash_imp
$LN3@rehash_imp:

; 4616 :         }

  00166	eb 53		 jmp	 SHORT $LN15@rehash_imp
__catch$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0:

; 4617 :         BOOST_CATCH(...)
; 4618 :         {
; 4619 :           node_pointer n = next_node(prev);

  00168	ff 75 e4	 push	 DWORD PTR _prev$[ebp]
  0016b	e8 00 00 00 00	 call	 ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
  00170	59		 pop	 ecx
  00171	89 45 dc	 mov	 DWORD PTR _n$10[ebp], eax

; 4620 :           prev->next_ = node_pointer();

  00174	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00177	83 20 00	 and	 DWORD PTR [eax], 0
$LN7@rehash_imp:

; 4621 :           while (n) {

  0017a	83 7d dc 00	 cmp	 DWORD PTR _n$10[ebp], 0
  0017e	74 2c		 je	 SHORT $LN8@rehash_imp

; 4622 :             node_pointer next = next_node(n);

  00180	ff 75 dc	 push	 DWORD PTR _n$10[ebp]
  00183	e8 00 00 00 00	 call	 ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
  00188	59		 pop	 ecx
  00189	89 45 b8	 mov	 DWORD PTR _next$3[ebp], eax

; 4623 :             destroy_node(n);

  0018c	ff 75 dc	 push	 DWORD PTR _n$10[ebp]
  0018f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00192	e8 00 00 00 00	 call	 ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node

; 4624 :             --size_;

  00197	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0019d	48		 dec	 eax
  0019e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4625 :             n = next;

  001a4	8b 45 b8	 mov	 eax, DWORD PTR _next$3[ebp]
  001a7	89 45 dc	 mov	 DWORD PTR _n$10[ebp], eax

; 4626 :           }

  001aa	eb ce		 jmp	 SHORT $LN7@rehash_imp
$LN8@rehash_imp:

; 4627 :           BOOST_RETHROW

  001ac	6a 00		 push	 0
  001ae	6a 00		 push	 0
  001b0	e8 00 00 00 00	 call	 __CxxThrowException@8

; 4628 :         }

  001b5	b8 00 00 00 00	 mov	 eax, $LN18@rehash_imp
  001ba	c3		 ret	 0
$LN15@rehash_imp:
  001bb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001bf	eb 04		 jmp	 SHORT $LN14@rehash_imp
$LN18@rehash_imp:
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
$LN14@rehash_imp:

; 4629 :         BOOST_CATCH_END
; 4630 :       }

  001c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cf	59		 pop	 ecx
  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	c9		 leave
  001d4	c2 04 00	 ret	 4
  001d7	cc		 int	 3
  001d8	cc		 int	 3
  001d9	cc		 int	 3
  001da	cc		 int	 3
  001db	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
_num_buckets$5 = -28					; size = 4
tv73 = -24						; size = 4
$T6 = -20						; size = 4
tv137 = -16						; size = 4
__Left$ = -12						; size = 4
$T7 = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert, COMDAT
; _this$ = ecx

; 4541 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4542 :         if (!buckets_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	75 4a		 jne	 SHORT $LN2@reserve_fo

; 4543 :           create_buckets((std::max)(bucket_count_, min_buckets_for_size(size)));

  00012	ff 75 08	 push	 DWORD PTR _size$[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
  0001d	89 45 f8	 mov	 DWORD PTR $T7[ebp], eax
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 f4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00029	8b 45 f4	 mov	 eax, DWORD PTR __Left$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	3b 45 f8	 cmp	 eax, DWORD PTR $T7[ebp]
  00031	73 08		 jae	 SHORT $LN55@reserve_fo
  00033	8d 45 f8	 lea	 eax, DWORD PTR $T7[ebp]
  00036	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
  00039	eb 06		 jmp	 SHORT $LN56@reserve_fo
$LN55@reserve_fo:
  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Left$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
$LN56@reserve_fo:
  00041	8b 45 f0	 mov	 eax, DWORD PTR tv137[ebp]
  00044	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
  00047	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0004a	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4543 :           create_buckets((std::max)(bucket_count_, min_buckets_for_size(size)));

  0004d	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00050	ff 30		 push	 DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
  0005a	eb 64		 jmp	 SHORT $LN1@reserve_fo
$LN2@reserve_fo:

; 4544 :         } else if (size > max_load_) {

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  00062	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00065	76 59		 jbe	 SHORT $LN1@reserve_fo

; 4545 :           std::size_t num_buckets =

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00075	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00078	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0007b	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  0007e	73 08		 jae	 SHORT $LN60@reserve_fo
  00080	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00083	89 45 e8	 mov	 DWORD PTR tv73[ebp], eax
  00086	eb 06		 jmp	 SHORT $LN61@reserve_fo
$LN60@reserve_fo:
  00088	8d 45 08	 lea	 eax, DWORD PTR _size$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv73[ebp], eax
$LN61@reserve_fo:
  0008e	8b 45 e8	 mov	 eax, DWORD PTR tv73[ebp]
  00091	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  00094	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00097	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4545 :           std::size_t num_buckets =

  0009a	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp]
  0009d	ff 30		 push	 DWORD PTR [eax]
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
  000a7	89 45 e4	 mov	 DWORD PTR _num_buckets$5[ebp], eax

; 4546 :             min_buckets_for_size((std::max)(size, size_ + (size_ >> 1)));
; 4547 : 
; 4548 :           if (num_buckets != bucket_count_)

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR _num_buckets$5[ebp]
  000b0	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000b3	74 0b		 je	 SHORT $LN1@reserve_fo

; 4549 :             this->rehash_impl(num_buckets);

  000b5	ff 75 e4	 push	 DWORD PTR _num_buckets$5[ebp]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
$LN1@reserve_fo:

; 4550 :         }
; 4551 :       }

  000c0	c9		 leave
  000c1	c2 04 00	 ret	 4
?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Ptr$ = -20						; size = 4
__Count$ = -16						; size = 4
_end$ = -12						; size = 4
_it$2 = -8						; size = 4
_this$ = -4						; size = 4
?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets, COMDAT
; _this$ = ecx

; 3370 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00015	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 3371 :           bucket_pointer end = get_bucket_pointer(bucket_count_ + 1);

  00019	89 45 f4	 mov	 DWORD PTR _end$[ebp], eax

; 3372 :           for (bucket_pointer it = buckets_; it != end; ++it) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00022	89 45 f8	 mov	 DWORD PTR _it$2[ebp], eax
  00025	eb 09		 jmp	 SHORT $LN4@destroy_bu
$LN2@destroy_bu:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  0002a	83 c0 04	 add	 eax, 4
  0002d	89 45 f8	 mov	 DWORD PTR _it$2[ebp], eax
$LN4@destroy_bu:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  00033	3b 45 f4	 cmp	 eax, DWORD PTR _end$[ebp]
  00036	74 08		 je	 SHORT $LN13@destroy_bu
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  0003b	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3374 :           }

  0003e	eb e7		 jmp	 SHORT $LN2@destroy_bu
$LN13@destroy_bu:

; 3375 : 
; 3376 :           bucket_allocator_traits::deallocate(

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00046	40		 inc	 eax
  00047	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	c1 e0 02	 shl	 eax, 2
  00059	50		 push	 eax
  0005a	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3378 :         }

  00064	c9		 leave
  00065	c3		 ret	 0
?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_next$2 = -24						; size = 4
_next$3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
_n$5 = -8						; size = 4
_this$ = -4						; size = 4
?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets, COMDAT
; _this$ = ecx

; 3344 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3345 :           if (buckets_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	0f 84 91 00 00
	00		 je	 $LN1@delete_buc

; 3346 :             node_pointer n = static_cast<node_pointer>(

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00022	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00025	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax

; 3347 :               get_bucket_pointer(bucket_count_)->next_);
; 3348 : 
; 3349 :             if (bucket::extra_node) {

  00028	33 c0		 xor	 eax, eax
  0002a	74 3d		 je	 SHORT $LN2@delete_buc

; 2964 :           return static_cast<node_pointer>(n->next_);

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 45 ec	 mov	 DWORD PTR _next$3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  00037	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	83 c0 03	 add	 eax, 3
  00040	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00043	74 09		 je	 SHORT $LN20@delete_buc
  00045	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00048	40		 inc	 eax
  00049	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004c	eb 04		 jmp	 SHORT $LN16@delete_buc
$LN20@delete_buc:
  0004e	83 65 f0 00	 and	 DWORD PTR $T4[ebp], 0
$LN16@delete_buc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00052	33 c0		 xor	 eax, eax
  00054	40		 inc	 eax
  00055	c1 e0 04	 shl	 eax, 4
  00058	50		 push	 eax
  00059	ff 75 f8	 push	 DWORD PTR _n$5[ebp]
  0005c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00061	59		 pop	 ecx
  00062	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3353 :               n = next;

  00063	8b 45 ec	 mov	 eax, DWORD PTR _next$3[ebp]
  00066	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax
$LN2@delete_buc:

; 3354 :             }
; 3355 : 
; 3356 :             while (n) {

  00069	83 7d f8 00	 cmp	 DWORD PTR _n$5[ebp], 0
  0006d	74 1b		 je	 SHORT $LN3@delete_buc

; 2964 :           return static_cast<node_pointer>(n->next_);

  0006f	8b 45 f8	 mov	 eax, DWORD PTR _n$5[ebp]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	89 45 e8	 mov	 DWORD PTR _next$2[ebp], eax

; 3357 :               node_pointer next = next_node(n);
; 3358 :               destroy_node(n);

  00077	ff 75 f8	 push	 DWORD PTR _n$5[ebp]
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node

; 3359 :               n = next;

  00082	8b 45 e8	 mov	 eax, DWORD PTR _next$2[ebp]
  00085	89 45 f8	 mov	 DWORD PTR _n$5[ebp], eax

; 3360 :             }

  00088	eb df		 jmp	 SHORT $LN2@delete_buc
$LN3@delete_buc:

; 3361 : 
; 3362 :             destroy_buckets();

  0008a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets

; 3363 :             buckets_ = bucket_pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00095	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 3364 :             max_load_ = 0;

  00099	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 3365 :             size_ = 0;

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	83 60 08 00	 and	 DWORD PTR [eax+8], 0
$LN1@delete_buc:

; 3366 :           }
; 3367 :         }

  000a7	c9		 leave
  000a8	c3		 ret	 0
?delete_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::delete_buckets
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node, COMDAT
; _this$ = ecx

; 3336 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 03	 add	 eax, 3
  0000f	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00012	74 09		 je	 SHORT $LN11@destroy_no
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	40		 inc	 eax
  00018	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0001b	eb 04		 jmp	 SHORT $LN15@destroy_no
$LN11@destroy_no:
  0001d	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0
$LN15@destroy_no:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00021	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00024	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 03	 add	 eax, 3
  0002d	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00030	74 09		 je	 SHORT $LN26@destroy_no
  00032	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00035	40		 inc	 eax
  00036	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00039	eb 04		 jmp	 SHORT $LN22@destroy_no
$LN26@destroy_no:
  0003b	83 65 ec 00	 and	 DWORD PTR $T2[ebp], 0
$LN22@destroy_no:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0003f	33 c0		 xor	 eax, eax
  00041	40		 inc	 eax
  00042	c1 e0 04	 shl	 eax, 4
  00045	50		 push	 eax
  00046	ff 75 08	 push	 DWORD PTR _n$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0004e	59		 pop	 ecx
  0004f	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3341 :         }

  00050	c9		 leave
  00051	c2 04 00	 ret	 4
?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
_a$2 = -116						; size = 8
__Max_possible$3 = -108					; size = 4
__Max_possible$4 = -104					; size = 4
__Max_possible$5 = -100					; size = 4
$T6 = -96						; size = 4
$T7 = -92						; size = 4
$T8 = -88						; size = 4
$T9 = -84						; size = 4
$T10 = -80						; size = 4
$T11 = -76						; size = 4
_p$12 = -72						; size = 4
$T13 = -68						; size = 4
$T14 = -64						; size = 4
_new_buckets$15 = -60					; size = 4
$T16 = -56						; size = 4
_end$ = -52						; size = 4
__Count$ = -48						; size = 4
__Count$ = -44						; size = 4
$T17 = -40						; size = 4
_this$ = -36						; size = 4
__Count$ = -32						; size = 4
_dummy_node$ = -28					; size = 4
_i$18 = -24						; size = 4
_this$ = -20						; size = 4
__Overflow_is_possible$19 = -15				; size = 1
__Overflow_is_possible$20 = -14				; size = 1
__Overflow_is_possible$21 = -13				; size = 1
__$EHRec$ = -12						; size = 12
_new_count$ = 8						; size = 4
?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets, COMDAT
; _this$ = ecx

; 3178 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3179 :           link_pointer dummy_node;
; 3180 : 
; 3181 :           // Construct the new buckets and dummy node, and destroy the old
; 3182 :           // buckets
; 3183 :           if (buckets_) {

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0002f	74 5d		 je	 SHORT $LN5@create_buc

; 3184 :             dummy_node =

  00031	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0003d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00040	89 45 e4	 mov	 DWORD PTR _dummy_node$[ebp], eax

; 3185 :               (buckets_ + static_cast<std::ptrdiff_t>(bucket_count_))->next_;
; 3186 :             bucket_pointer new_buckets =

  00043	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  00046	40		 inc	 eax
  00047	89 45 e0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0004a	c6 45 f3 01	 mov	 BYTE PTR __Overflow_is_possible$21[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0004e	c7 45 9c ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$5[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00055	81 7d e0 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0005c	76 05		 jbe	 SHORT $LN20@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0005e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN20@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00063	8b 45 e0	 mov	 eax, DWORD PTR __Count$[ebp]
  00066	c1 e0 02	 shl	 eax, 2
  00069	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  0006c	ff 75 c8	 push	 DWORD PTR $T16[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00074	59		 pop	 ecx
  00075	89 45 c4	 mov	 DWORD PTR _new_buckets$15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3188 :             destroy_buckets();

  00078	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets

; 3189 :             buckets_ = new_buckets;

  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d c4	 mov	 ecx, DWORD PTR _new_buckets$15[ebp]
  00086	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00089	e9 d4 00 00 00	 jmp	 $LN6@create_buc
$LN5@create_buc:

; 3190 :           } else if (bucket::extra_node) {

  0008e	33 c0		 xor	 eax, eax
  00090	0f 84 8a 00 00
	00		 je	 $LN7@create_buc

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00096	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 03	 add	 eax, 3
  0009c	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  0009f	74 09		 je	 SHORT $LN48@create_buc
  000a1	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	40		 inc	 eax
  000a5	89 45 d8	 mov	 DWORD PTR $T17[ebp], eax
  000a8	eb 04		 jmp	 SHORT $LN44@create_buc
$LN48@create_buc:
  000aa	83 65 d8 00	 and	 DWORD PTR $T17[ebp], 0
$LN44@create_buc:

; 1946 :         node_constructor(node_allocator& n) : alloc_(n), node_() {}

  000ae	8b 45 d8	 mov	 eax, DWORD PTR $T17[ebp]
  000b1	89 45 8c	 mov	 DWORD PTR _a$2[ebp], eax
  000b4	83 65 90 00	 and	 DWORD PTR _a$2[ebp+4], 0

; 3191 :             node_constructor a(node_alloc());

  000b8	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 3192 :             a.create_node();

  000bc	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  000bf	e8 00 00 00 00	 call	 ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::create_node

; 3193 :             buckets_ =

  000c4	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  000c7	40		 inc	 eax
  000c8	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000cb	c6 45 f2 01	 mov	 BYTE PTR __Overflow_is_possible$20[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000cf	c7 45 98 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$4[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000d6	81 7d d4 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  000dd	76 05		 jbe	 SHORT $LN63@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000df	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN63@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000e4	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  000e7	c1 e0 02	 shl	 eax, 2
  000ea	89 45 c0	 mov	 DWORD PTR $T14[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  000ed	ff 75 c0	 push	 DWORD PTR $T14[ebp]
  000f0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000f5	59		 pop	 ecx
  000f6	89 45 bc	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3193 :             buckets_ =

  000f9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	8b 4d bc	 mov	 ecx, DWORD PTR $T13[ebp]
  000ff	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1956 :           node_pointer p = node_;

  00102	8b 45 90	 mov	 eax, DWORD PTR _a$2[ebp+4]
  00105	89 45 b8	 mov	 DWORD PTR _p$12[ebp], eax

; 1957 :           node_ = node_pointer();

  00108	83 65 90 00	 and	 DWORD PTR _a$2[ebp+4], 0

; 3194 :               bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);
; 3195 :             dummy_node = a.release();

  0010c	8b 45 b8	 mov	 eax, DWORD PTR _p$12[ebp]
  0010f	89 45 e4	 mov	 DWORD PTR _dummy_node$[ebp], eax

; 3196 :           } else {

  00112	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00116	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  00119	e8 00 00 00 00	 call	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
  0011e	eb 42		 jmp	 SHORT $LN6@create_buc
$LN7@create_buc:

; 3197 :             dummy_node = link_pointer();

  00120	83 65 e4 00	 and	 DWORD PTR _dummy_node$[ebp], 0

; 3198 :             buckets_ =

  00124	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  00127	40		 inc	 eax
  00128	89 45 d0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0012b	c6 45 f1 01	 mov	 BYTE PTR __Overflow_is_possible$19[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0012f	c7 45 94 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$3[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00136	81 7d d0 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0013d	76 05		 jbe	 SHORT $LN77@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0013f	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN77@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00144	8b 45 d0	 mov	 eax, DWORD PTR __Count$[ebp]
  00147	c1 e0 02	 shl	 eax, 2
  0014a	89 45 b4	 mov	 DWORD PTR $T11[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  0014d	ff 75 b4	 push	 DWORD PTR $T11[ebp]
  00150	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00155	59		 pop	 ecx
  00156	89 45 b0	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3198 :             buckets_ =

  00159	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	8b 4d b0	 mov	 ecx, DWORD PTR $T10[ebp]
  0015f	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN6@create_buc:

; 3199 :               bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);
; 3200 :           }
; 3201 : 
; 3202 :           // nothrow from here...
; 3203 :           bucket_count_ = new_count;

  00162	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00165	8b 4d 08	 mov	 ecx, DWORD PTR _new_count$[ebp]
  00168	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3204 :           recalculate_max_load();

  0016b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load

; 3205 : 
; 3206 :           bucket_pointer end =

  00173	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00176	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00179	8b 4d 08	 mov	 ecx, DWORD PTR _new_count$[ebp]
  0017c	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0017f	89 45 cc	 mov	 DWORD PTR _end$[ebp], eax

; 3207 :             buckets_ + static_cast<std::ptrdiff_t>(new_count);
; 3208 :           for (bucket_pointer i = buckets_; i != end; ++i) {

  00182	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00185	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00188	89 45 e8	 mov	 DWORD PTR _i$18[ebp], eax
  0018b	eb 09		 jmp	 SHORT $LN4@create_buc
$LN2@create_buc:
  0018d	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  00190	83 c0 04	 add	 eax, 4
  00193	89 45 e8	 mov	 DWORD PTR _i$18[ebp], eax
$LN4@create_buc:
  00196	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  00199	3b 45 cc	 cmp	 eax, DWORD PTR _end$[ebp]
  0019c	74 14		 je	 SHORT $LN3@create_buc
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0019e	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  001a1	89 45 ac	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001a4	8b 45 ac	 mov	 eax, DWORD PTR $T9[ebp]
  001a7	89 45 a8	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2579 :         ptr_bucket() : next_(0) {}

  001aa	8b 45 a8	 mov	 eax, DWORD PTR $T8[ebp]
  001ad	83 20 00	 and	 DWORD PTR [eax], 0

; 3209 :             new ((void*)boost::to_address(i)) bucket();
; 3210 :           }

  001b0	eb db		 jmp	 SHORT $LN2@create_buc
$LN3@create_buc:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  001b2	8b 45 cc	 mov	 eax, DWORD PTR _end$[ebp]
  001b5	89 45 a4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001b8	8b 45 a4	 mov	 eax, DWORD PTR $T7[ebp]
  001bb	89 45 a0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2580 :         ptr_bucket(link_pointer n) : next_(n) {}

  001be	8b 45 a0	 mov	 eax, DWORD PTR $T6[ebp]
  001c1	8b 4d e4	 mov	 ecx, DWORD PTR _dummy_node$[ebp]
  001c4	89 08		 mov	 DWORD PTR [eax], ecx
$LN23@create_buc:

; 3211 :           new ((void*)boost::to_address(end)) bucket(dummy_node);
; 3212 :         }

  001c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d0	59		 pop	 ecx
  001d1	c9		 leave
  001d2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0:
  00000	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,unsigned long> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z
_TEXT	SEGMENT
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_which$ = -16						; size = 1
__$EHRec$ = -12						; size = 12
_num_buckets$ = 8					; size = 4
_hf$ = 12						; size = 4
_eq$ = 16						; size = 4
_a$ = 20						; size = 4
??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >, COMDAT
; _this$ = ecx

; 3123 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2761 :         functions(H const& hf, P const& eq) : current_(0)

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c6 00 00	 mov	 BYTE PTR [eax], 0

; 2762 :         {
; 2763 :           construct_functions(current_, hf, eq);

  0002e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8a 00		 mov	 al, BYTE PTR [eax]
  00033	88 45 f0	 mov	 BYTE PTR _which$[ebp], al

; 2827 :           new ((void*)&funcs_[which]) function_pair(hf, eq);

  00036	0f b6 45 f0	 movzx	 eax, BYTE PTR _which$[ebp]
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00041	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3120 :             : functions(hf, eq), allocators_(a, a),

  00044	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2609 :           return boost::unordered::detail::next_prime(min);

  00048	ff 75 08	 push	 DWORD PTR _num_buckets$[ebp]
  0004b	e8 00 00 00 00	 call	 ?next_prime@detail@unordered@boost@@YAII@Z ; boost::unordered::detail::next_prime
  00050	59		 pop	 ecx

; 3121 :               bucket_count_(policy::new_bucket_count(num_buckets)), size_(0),

  00051	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00057	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 3122 :               mlf_(1.0f), max_load_(0), buckets_()

  0005e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00061	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00069	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0
  0006e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00071	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00075	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 3124 :         }

  0007c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	c9		 leave
  0008f	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::~functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE@IABU?$hash@K@3@ABU?$equal_to@K@std@@ABV?$allocator@U?$ptr_node@U?$pair@$$CBKK@std@@@detail@unordered@boost@@@6@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z
_TEXT	SEGMENT
tv91 = -40						; size = 8
_f$ = -32						; size = 8
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
tv81 = -12						; size = 4
tv87 = -8						; size = 4
$T3 = -4						; size = 4
_size$ = 8						; size = 4
?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size, COMDAT
; _this$ = ecx

; 3095 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3096 :           BOOST_ASSERT(mlf_ >= minimum_max_load_factor);
; 3097 : 
; 3098 :           using namespace std;
; 3099 : 
; 3100 :           // From insert/emplace requirements:
; 3101 :           //
; 3102 :           // size <= mlf_ * count
; 3103 :           // => count >= size / mlf_
; 3104 :           //
; 3105 :           // Or from rehash post-condition:
; 3106 :           //
; 3107 :           // count >= size / mlf_
; 3108 : 
; 3109 :           return policy::new_bucket_count(

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	f3 0f 5a 40 0c	 cvtss2sd xmm0, DWORD PTR [eax+12]
  00011	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR tv87[ebp], eax
  00017	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR tv87[ebp]
  0001c	8b 45 f8	 mov	 eax, DWORD PTR tv87[ebp]
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0002b	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0002f	51		 push	 ecx
  00030	51		 push	 ecx
  00031	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00036	e8 00 00 00 00	 call	 _floor
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
  0003d	dd 5d d8	 fstp	 QWORD PTR tv91[ebp]
  00040	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR tv91[ebp]
  00045	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0004d	f2 0f 11 45 e0	 movsd	 QWORD PTR _f$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00052	83 4d ec ff	 or	 DWORD PTR $T2[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00056	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00059	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
  0005c	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR tv81[ebp]
  00061	8b 45 f4	 mov	 eax, DWORD PTR tv81[ebp]
  00064	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00067	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00070	f2 0f 10 4d e0	 movsd	 xmm1, QWORD PTR _f$[ebp]
  00075	66 0f 2f c8	 comisd	 xmm1, xmm0
  00079	72 0c		 jb	 SHORT $LN5@min_bucket
  0007b	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0007e	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00081	83 4d fc ff	 or	 DWORD PTR $T3[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00085	eb 0d		 jmp	 SHORT $LN6@min_bucket
$LN5@min_bucket:
  00087	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR _f$[ebp]
  0008c	e8 00 00 00 00	 call	 __dtoui3
  00091	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
$LN6@min_bucket:

; 2609 :           return boost::unordered::detail::next_prime(min);

  00094	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00097	e8 00 00 00 00	 call	 ?next_prime@detail@unordered@boost@@YAII@Z ; boost::unordered::detail::next_prime
  0009c	59		 pop	 ecx

; 3110 :             boost::unordered::detail::double_to_size(
; 3111 :               floor(static_cast<double>(size) / static_cast<double>(mlf_)) +
; 3112 :               1));
; 3113 :         }

  0009d	c9		 leave
  0009e	c2 04 00	 ret	 4
?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
_f$ = -36						; size = 8
$T1 = -28						; size = 4
$T2 = -24						; size = 4
tv76 = -20						; size = 4
tv92 = -16						; size = 4
tv83 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load, COMDAT
; _this$ = ecx

; 3076 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3077 :           using namespace std;
; 3078 : 
; 3079 :           // From 6.3.1/13:
; 3080 :           // Only resize when size >= mlf_ * count
; 3081 :           max_load_ = buckets_ ? boost::unordered::detail::double_to_size(

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	0f 84 84 00 00
	00		 je	 $LN3@recalculat
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
  0001f	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR tv83[ebp]
  00024	8b 45 f4	 mov	 eax, DWORD PTR tv83[ebp]
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	f3 0f 5a 48 0c	 cvtss2sd xmm1, DWORD PTR [eax+12]
  0003b	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0003f	51		 push	 ecx
  00040	51		 push	 ecx
  00041	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00046	e8 00 00 00 00	 call	 _ceil
  0004b	59		 pop	 ecx
  0004c	59		 pop	 ecx
  0004d	dd 5d dc	 fstp	 QWORD PTR _f$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00050	83 4d e8 ff	 or	 DWORD PTR $T2[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00054	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00057	89 45 f0	 mov	 DWORD PTR tv92[ebp], eax
  0005a	f2 0f 2a 45 f0	 cvtsi2sd xmm0, DWORD PTR tv92[ebp]
  0005f	8b 45 f0	 mov	 eax, DWORD PTR tv92[ebp]
  00062	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00065	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0006e	f2 0f 10 4d dc	 movsd	 xmm1, QWORD PTR _f$[ebp]
  00073	66 0f 2f c8	 comisd	 xmm1, xmm0
  00077	72 0c		 jb	 SHORT $LN7@recalculat
  00079	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0007c	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  0007f	83 4d f8 ff	 or	 DWORD PTR tv82[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00083	eb 0d		 jmp	 SHORT $LN8@recalculat
$LN7@recalculat:
  00085	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR _f$[ebp]
  0008a	e8 00 00 00 00	 call	 __dtoui3
  0008f	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
$LN8@recalculat:

; 3077 :           using namespace std;
; 3078 : 
; 3079 :           // From 6.3.1/13:
; 3080 :           // Only resize when size >= mlf_ * count
; 3081 :           max_load_ = buckets_ ? boost::unordered::detail::double_to_size(

  00092	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00095	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  00098	eb 04		 jmp	 SHORT $LN4@recalculat
$LN3@recalculat:
  0009a	83 65 ec 00	 and	 DWORD PTR tv76[ebp], 0
$LN4@recalculat:
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  000a4	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3082 :                                    ceil(static_cast<double>(mlf_) *
; 3083 :                                         static_cast<double>(bucket_count_)))
; 3084 :                                : 0;
; 3085 :         }

  000a7	c9		 leave
  000a8	c3		 ret	 0
?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@I@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_prev$ = -12						; size = 4
_this$ = -8						; size = 4
tv72 = -4						; size = 4
_bucket_index$ = 8					; size = 4
?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@I@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin, COMDAT
; _this$ = ecx

; 3045 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3046 :           if (!size_)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	75 04		 jne	 SHORT $LN8@begin

; 3047 :             return node_pointer();

  00012	33 c0		 xor	 eax, eax
  00014	eb 2c		 jmp	 SHORT $LN1@begin
$LN8@begin:

; 3036 :           return get_bucket_pointer(bucket_index)->next_;

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  0001f	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00022	89 45 f4	 mov	 DWORD PTR _prev$[ebp], eax

; 3048 :           link_pointer prev = get_previous_start(bucket_index);
; 3049 :           return prev ? next_node(prev) : node_pointer();

  00025	83 7d f4 00	 cmp	 DWORD PTR _prev$[ebp], 0
  00029	74 10		 je	 SHORT $LN4@begin
  0002b	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR tv72[ebp], eax

; 2964 :           return static_cast<node_pointer>(n->next_);

  00031	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 fc	 mov	 DWORD PTR tv72[ebp], eax

; 3048 :           link_pointer prev = get_previous_start(bucket_index);
; 3049 :           return prev ? next_node(prev) : node_pointer();

  00039	eb 04		 jmp	 SHORT $LN5@begin
$LN4@begin:
  0003b	83 65 fc 00	 and	 DWORD PTR tv72[ebp], 0
$LN5@begin:
  0003f	8b 45 fc	 mov	 eax, DWORD PTR tv72[ebp]
$LN1@begin:

; 3050 :         }

  00042	c9		 leave
  00043	c2 04 00	 ret	 4
?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@I@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z
_TEXT	SEGMENT
tv84 = -8						; size = 4
_n2$ = -4						; size = 4
_n$ = 8							; size = 4
?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find, COMDAT

; 2968 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 2969 :           node_pointer n2 = static_cast<node_pointer>(n);

  00005	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _n2$[ebp], eax
$LN4@next_for_f:

; 2964 :           return static_cast<node_pointer>(n->next_);

  0000b	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	89 45 fc	 mov	 DWORD PTR _n2$[ebp], eax

; 2970 :           do {
; 2971 :             n2 = next_node(n2);
; 2972 :           } while (n2 && !n2->is_first_in_group());

  00013	83 7d fc 00	 cmp	 DWORD PTR _n2$[ebp], 0
  00017	74 20		 je	 SHORT $LN3@next_for_f

; 4878 :           return !(bucket_info_ & ~((std::size_t)-1 >> 1));

  00019	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00024	75 09		 jne	 SHORT $LN11@next_for_f
  00026	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
  0002d	eb 04		 jmp	 SHORT $LN9@next_for_f
$LN11@next_for_f:
  0002f	83 65 f8 00	 and	 DWORD PTR tv84[ebp], 0
$LN9@next_for_f:

; 2970 :           do {
; 2971 :             n2 = next_node(n2);
; 2972 :           } while (n2 && !n2->is_first_in_group());

  00033	83 7d f8 00	 cmp	 DWORD PTR tv84[ebp], 0
  00037	74 d2		 je	 SHORT $LN4@next_for_f
$LN3@next_for_f:

; 2973 :           return n2;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]

; 2974 :         }

  0003c	c9		 leave
  0003d	c3		 ret	 0
?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node, COMDAT

; 2963 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2964 :           return static_cast<node_pointer>(n->next_);

  00003	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 2965 :         }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKK@std@@@std@@KKU?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKK@std@@@234@PAUptr_bucket@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,unsigned long> >,unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -14						; size = 1
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_fileIndex$ = 0						; size = 280
__$ArrayPad$ = 280					; size = 4
_pIndex$ = 292						; size = 4
?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z PROC	; CEterPack::Delete, COMDAT
; _this$ = ecx

; 741  : {

  00000	55		 push	 ebp
  00001	8d ac 24 e4 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-284]
  00008	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	51		 push	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 85 18 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	50		 push	 eax
  0002c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00035	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 742  : 	CFileBase fileIndex;

  00038	8d 4d 00	 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  0003b	e8 00 00 00 00	 call	 ??0CFileBase@@QAE@XZ	; CFileBase::CFileBase
  00040	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 743  : 
; 744  : 	if (!fileIndex.Create(m_indexFileName, CFileBase::FILEMODE_WRITE))

  00044	6a 02		 push	 2
  00046	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00049	05 55 02 00 00	 add	 eax, 597		; 00000255H
  0004e	50		 push	 eax
  0004f	8d 4d 00	 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  00052	e8 00 00 00 00	 call	 ?Create@CFileBase@@QAEHPBDW4EFileMode@1@@Z ; CFileBase::Create
  00057	85 c0		 test	 eax, eax
  00059	75 15		 jne	 SHORT $LN2@Delete

; 745  : 		return false;

  0005b	c6 45 f3 00	 mov	 BYTE PTR $T3[ebp], 0
  0005f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00063	8d 4d 00	 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  00066	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  0006b	8a 45 f3	 mov	 al, BYTE PTR $T3[ebp]
  0006e	eb 33		 jmp	 SHORT $LN1@Delete
$LN2@Delete:

; 746  : 
; 747  : 	PushFreeIndex(pIndex);

  00070	ff b5 24 01 00
	00		 push	 DWORD PTR _pIndex$[ebp]
  00076	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?PushFreeIndex@CEterPack@@AAEXPAUSEterPackIndex@@@Z ; CEterPack::PushFreeIndex

; 748  : 	WriteIndex(fileIndex, pIndex);

  0007e	ff b5 24 01 00
	00		 push	 DWORD PTR _pIndex$[ebp]
  00084	8d 45 00	 lea	 eax, DWORD PTR _fileIndex$[ebp]
  00087	50		 push	 eax
  00088	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008b	e8 00 00 00 00	 call	 ?WriteIndex@CEterPack@@AAEXAAVCFileBase@@PAUSEterPackIndex@@@Z ; CEterPack::WriteIndex

; 749  : 	return true;

  00090	c6 45 f2 01	 mov	 BYTE PTR $T2[ebp], 1
  00094	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00098	8d 4d 00	 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  0009b	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  000a0	8a 45 f2	 mov	 al, BYTE PTR $T2[ebp]
$LN1@Delete:

; 750  : }

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ad	59		 pop	 ecx
  000ae	8b 8d 18 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	33 cd		 xor	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	81 c5 1c 01 00
	00		 add	 ebp, 284		; 0000011cH
  000c1	c9		 leave
  000c2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 24 01 00
	00		 mov	 ecx, DWORD PTR [edx+292]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z ENDP	; CEterPack::Delete
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?WriteNewData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_empty_buf$ = -8					; size = 4
_empty_size$ = -4					; size = 4
_file$ = 8						; size = 4
_index$ = 12						; size = 4
_data$ = 16						; size = 4
?WriteNewData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z PROC ; CEterPack::WriteNewData, COMDAT
; _this$ = ecx

; 1301 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 	file.Seek(index->data_position);

  00009	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0000c	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00015	e8 00 00 00 00	 call	 ?Seek@CFileBase@@QAEXK@Z ; CFileBase::Seek

; 1303 : 	
; 1304 : 	if (!file.Write(data, index->data_size))

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0001d	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  00023	ff 75 10	 push	 DWORD PTR _data$[ebp]
  00026	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0002e	ff 50 04	 call	 DWORD PTR [eax+4]
  00031	85 c0		 test	 eax, eax
  00033	75 04		 jne	 SHORT $LN2@WriteNewDa

; 1305 : 	{
; 1306 : 		assert(!"WriteData: fwrite data failed");
; 1307 : 		return false;

  00035	32 c0		 xor	 al, al
  00037	eb 66		 jmp	 SHORT $LN6@WriteNewDa
$LN2@WriteNewDa:

; 1308 : 	}
; 1309 : 
; 1310 : 	int empty_size = index->real_data_size - index->data_size;

  00039	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _index$[ebp]
  0003f	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00045	2b 81 b0 00 00
	00		 sub	 eax, DWORD PTR [ecx+176]
  0004b	89 45 fc	 mov	 DWORD PTR _empty_size$[ebp], eax

; 1311 : 
; 1312 : 	if (empty_size < 0)

  0004e	79 12		 jns	 SHORT $LN3@WriteNewDa

; 1313 : 	{
; 1314 : 		printf("SYSERR: WriteNewData(): CRITICAL ERROR: empty_size lower than 0!\n");

  00050	68 00 00 00 00	 push	 OFFSET ??_C@_0EC@IGPMDEEF@SYSERR?3?5WriteNewData?$CI?$CJ?3?5CRITICA@
  00055	e8 00 00 00 00	 call	 _printf
  0005a	59		 pop	 ecx

; 1315 : 		exit(1);

  0005b	6a 01		 push	 1
  0005d	e8 00 00 00 00	 call	 _exit
$LN3@WriteNewDa:

; 1316 : 	}
; 1317 : 
; 1318 : 	if (empty_size == 0)

  00062	83 7d fc 00	 cmp	 DWORD PTR _empty_size$[ebp], 0
  00066	75 04		 jne	 SHORT $LN4@WriteNewDa

; 1319 : 		return true;

  00068	b0 01		 mov	 al, 1
  0006a	eb 33		 jmp	 SHORT $LN6@WriteNewDa
$LN4@WriteNewDa:

; 1320 : 
; 1321 : 	char * empty_buf = (char *) calloc(empty_size, sizeof(char));

  0006c	6a 01		 push	 1
  0006e	ff 75 fc	 push	 DWORD PTR _empty_size$[ebp]
  00071	e8 00 00 00 00	 call	 _calloc
  00076	59		 pop	 ecx
  00077	59		 pop	 ecx
  00078	89 45 f8	 mov	 DWORD PTR _empty_buf$[ebp], eax

; 1322 : 
; 1323 : 	if (!file.Write(empty_buf, empty_size))

  0007b	ff 75 fc	 push	 DWORD PTR _empty_size$[ebp]
  0007e	ff 75 f8	 push	 DWORD PTR _empty_buf$[ebp]
  00081	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00084	8b 00		 mov	 eax, DWORD PTR [eax]
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00089	ff 50 04	 call	 DWORD PTR [eax+4]
  0008c	85 c0		 test	 eax, eax
  0008e	75 04		 jne	 SHORT $LN5@WriteNewDa

; 1324 : 	{
; 1325 : 		assert(!"WriteData: fwrite empty data failed");
; 1326 : 		return false;

  00090	32 c0		 xor	 al, al
  00092	eb 0b		 jmp	 SHORT $LN6@WriteNewDa
$LN5@WriteNewDa:

; 1327 : 	}
; 1328 : 
; 1329 : 	free(empty_buf);

  00094	ff 75 f8	 push	 DWORD PTR _empty_buf$[ebp]
  00097	e8 00 00 00 00	 call	 _free
  0009c	59		 pop	 ecx

; 1330 : 	return true;

  0009d	b0 01		 mov	 al, 1
$LN6@WriteNewDa:

; 1331 : }

  0009f	c9		 leave
  000a0	c2 0c 00	 ret	 12			; 0000000cH
?WriteNewData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z ENDP ; CEterPack::WriteNewData
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?WriteData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_file$ = 8						; size = 4
_index$ = 12						; size = 4
_data$ = 16						; size = 4
?WriteData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z PROC ; CEterPack::WriteData, COMDAT
; _this$ = ecx

; 1288 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1289 : 	file.Seek(index->data_position);

  00007	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00013	e8 00 00 00 00	 call	 ?Seek@CFileBase@@QAEXK@Z ; CFileBase::Seek

; 1290 : 	
; 1291 : 	if (!file.Write(data, index->data_size))

  00018	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0001b	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  00021	ff 75 10	 push	 DWORD PTR _data$[ebp]
  00024	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0002c	ff 50 04	 call	 DWORD PTR [eax+4]
  0002f	85 c0		 test	 eax, eax
  00031	75 04		 jne	 SHORT $LN2@WriteData

; 1292 : 	{
; 1293 : 		assert(!"WriteData: fwrite data failed");
; 1294 : 		return false;

  00033	32 c0		 xor	 al, al
  00035	eb 02		 jmp	 SHORT $LN1@WriteData
$LN2@WriteData:

; 1295 : 	}
; 1296 : 
; 1297 : 	return true;

  00037	b0 01		 mov	 al, 1
$LN1@WriteData:

; 1298 : }

  00039	c9		 leave
  0003a	c2 0c 00	 ret	 12			; 0000000cH
?WriteData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z ENDP ; CEterPack::WriteData
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?ReadData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PAXJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_file$ = 8						; size = 4
_index$ = 12						; size = 4
_data$ = 16						; size = 4
_maxsize$ = 20						; size = 4
?ReadData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PAXJ@Z PROC ; CEterPack::ReadData, COMDAT
; _this$ = ecx

; 1278 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1279 : 	if (index->data_size > maxsize)

  00007	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0000a	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [eax+176]
  00010	3b 45 14	 cmp	 eax, DWORD PTR _maxsize$[ebp]
  00013	7e 04		 jle	 SHORT $LN2@ReadData

; 1280 : 		return false;

  00015	32 c0		 xor	 al, al
  00017	eb 27		 jmp	 SHORT $LN1@ReadData
$LN2@ReadData:

; 1281 : 
; 1282 : 	file.Seek(index->data_position);

  00019	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0001c	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  00022	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00025	e8 00 00 00 00	 call	 ?Seek@CFileBase@@QAEXK@Z ; CFileBase::Seek

; 1283 : 	file.Read(data, index->data_size);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0002d	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  00033	ff 75 10	 push	 DWORD PTR _data$[ebp]
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00039	e8 00 00 00 00	 call	 ?Read@CFileBase@@QAEHPAXH@Z ; CFileBase::Read

; 1284 : 	return true;

  0003e	b0 01		 mov	 al, 1
$LN1@ReadData:

; 1285 : }

  00040	c9		 leave
  00041	c2 10 00	 ret	 16			; 00000010H
?ReadData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PAXJ@Z ENDP ; CEterPack::ReadData
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetNewDataPosition@CEterPack@@AAEJAAVCFileBase@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_file$ = 8						; size = 4
?GetNewDataPosition@CEterPack@@AAEJAAVCFileBase@@@Z PROC ; CEterPack::GetNewDataPosition, COMDAT
; _this$ = ecx

; 1273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1274 : 	return file.Size();

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Size@CFileBase@@QAEKXZ	; CFileBase::Size

; 1275 : }

  0000f	c9		 leave
  00010	c2 04 00	 ret	 4
?GetNewDataPosition@CEterPack@@AAEJAAVCFileBase@@@Z ENDP ; CEterPack::GetNewDataPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?CreateDataFile@CEterPack@@AAE_NXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
_fp$ = -4						; size = 4
?CreateDataFile@CEterPack@@AAE_NXZ PROC			; CEterPack::CreateDataFile, COMDAT
; _this$ = ecx

; 1252 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  00012	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00017	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1255 : 	if (NULL != (fp = fopen(m_stDataFileName.c_str(), "rb")))

  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0001f	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00022	e8 00 00 00 00	 call	 _fopen
  00027	59		 pop	 ecx
  00028	59		 pop	 ecx
  00029	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax
  0002c	83 7d fc 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00030	74 0f		 je	 SHORT $LN2@CreateData

; 1256 : 	{
; 1257 : 		fclose(fp);

  00032	ff 75 fc	 push	 DWORD PTR _fp$[ebp]
  00035	e8 00 00 00 00	 call	 _fclose
  0003a	59		 pop	 ecx

; 1258 : 		return true;

  0003b	b0 01		 mov	 al, 1
  0003d	eb 47		 jmp	 SHORT $LN1@CreateData

; 1259 : 	}

  0003f	eb 12		 jmp	 SHORT $LN3@CreateData
$LN2@CreateData:

; 1260 : 	else if (m_bReadOnly)

  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	0f b6 80 64 03
	00 00		 movzx	 eax, BYTE PTR [eax+868]
  0004b	85 c0		 test	 eax, eax
  0004d	74 04		 je	 SHORT $LN3@CreateData

; 1261 : 		return false;

  0004f	32 c0		 xor	 al, al
  00051	eb 33		 jmp	 SHORT $LN1@CreateData
$LN3@CreateData:

; 1262 : 
; 1263 : 	fp = fopen(m_stDataFileName.c_str(), "wb");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  00058	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  00061	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _fopen
  0006c	59		 pop	 ecx
  0006d	59		 pop	 ecx
  0006e	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 1264 : 
; 1265 : 	if (!fp)

  00071	83 7d fc 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00075	75 04		 jne	 SHORT $LN5@CreateData

; 1266 : 		return false;

  00077	32 c0		 xor	 al, al
  00079	eb 0b		 jmp	 SHORT $LN1@CreateData
$LN5@CreateData:

; 1267 : 
; 1268 : 	fclose(fp);

  0007b	ff 75 fc	 push	 DWORD PTR _fp$[ebp]
  0007e	e8 00 00 00 00	 call	 _fclose
  00083	59		 pop	 ecx

; 1269 : 	return true;

  00084	b0 01		 mov	 al, 1
$LN1@CreateData:

; 1270 : }

  00086	c9		 leave
  00087	c3		 ret	 0
?CreateDataFile@CEterPack@@AAE_NXZ ENDP			; CEterPack::CreateDataFile
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?PushFreeIndex@CEterPack@@AAEXPAUSEterPackIndex@@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
_blockidx$ = -32					; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
_i$4 = -16						; size = 4
tv134 = -12						; size = 4
_this$ = -8						; size = 4
$T5 = -1						; size = 1
_index$ = 8						; size = 4
?PushFreeIndex@CEterPack@@AAEXPAUSEterPackIndex@@@Z PROC ; CEterPack::PushFreeIndex, COMDAT
; _this$ = ecx

; 1166 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1167 : 	if (index->filename_crc != 0)

  00009	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  0000c	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  00013	74 7f		 je	 SHORT $LN2@PushFreeIn

; 1168 : 	{
; 1169 : 		TDataPositionMap::iterator i = m_DataPositionMap.find(index->filename_crc);

  00015	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00018	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  0001d	50		 push	 eax
  0001e	8d 45 f0	 lea	 eax, DWORD PTR _i$4[ebp]
  00021	50		 push	 eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  0002b	e8 00 00 00 00	 call	 ?find@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::find
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2368 :         iterator() BOOST_NOEXCEPT : node_() {}

  00030	83 65 e8 00	 and	 DWORD PTR $T3[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 200  :       iterator end() BOOST_NOEXCEPT { return iterator(); }

  00034	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00037	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2399 :           return node_ != x.node_;

  0003a	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _i$4[ebp]
  00040	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00042	74 09		 je	 SHORT $LN13@PushFreeIn
  00044	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv134[ebp], 1
  0004b	eb 04		 jmp	 SHORT $LN14@PushFreeIn
$LN13@PushFreeIn:
  0004d	83 65 f4 00	 and	 DWORD PTR tv134[ebp], 0
$LN14@PushFreeIn:
  00051	8a 45 f4	 mov	 al, BYTE PTR tv134[ebp]
  00054	88 45 ff	 mov	 BYTE PTR $T5[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1171 : 		if (i != m_DataPositionMap.end())

  00057	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  0005b	85 c0		 test	 eax, eax
  0005d	74 15		 je	 SHORT $LN3@PushFreeIn

; 1172 : 			m_DataPositionMap.erase(i);

  0005f	ff 75 f0	 push	 DWORD PTR _i$4[ebp]
  00062	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  00065	50		 push	 eax
  00066	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  0006f	e8 00 00 00 00	 call	 ?erase@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@U4523@@Z ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::erase
$LN3@PushFreeIn:

; 1173 : 
; 1174 : 		index->filename_crc = 0;

  00074	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00077	83 a0 a8 00 00
	00 00		 and	 DWORD PTR [eax+168], 0

; 1175 : 		memset(index->filename, 0, sizeof(index->filename));

  0007e	68 a1 00 00 00	 push	 161			; 000000a1H
  00083	6a 00		 push	 0
  00085	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00088	83 c0 04	 add	 eax, 4
  0008b	50		 push	 eax
  0008c	e8 00 00 00 00	 call	 _memset
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@PushFreeIn:

; 1176 : 	}
; 1177 : 
; 1178 : 	int blockidx = GetFreeBlockIndex(index->real_data_size);

  00094	8b 45 08	 mov	 eax, DWORD PTR _index$[ebp]
  00097	ff b0 ac 00 00
	00		 push	 DWORD PTR [eax+172]
  0009d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	e8 00 00 00 00	 call	 ?GetFreeBlockIndex@CEterPack@@AAEHJ@Z ; CEterPack::GetFreeBlockIndex
  000a5	89 45 e0	 mov	 DWORD PTR _blockidx$[ebp], eax

; 1179 : 	m_FreeIndexList[blockidx].push_back(index);

  000a8	8b 45 e0	 mov	 eax, DWORD PTR _blockidx$[ebp]
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	8d 84 c1 98 03
	00 00		 lea	 eax, DWORD PTR [ecx+eax*8+920]
  000b5	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  000b8	8d 45 08	 lea	 eax, DWORD PTR _index$[ebp]
  000bb	50		 push	 eax
  000bc	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	ff 30		 push	 DWORD PTR [eax]
  000c1	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	e8 00 00 00 00	 call	 ??$_Emplace@ABQAUSEterPackIndex@@@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEPAU?$_List_node@PAUSEterPackIndex@@PAX@1@QAU21@ABQAUSEterPackIndex@@@Z ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::_Emplace<SEterPackIndex * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1180 : 	m_FragmentSize += index->real_data_size;

  000c9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000cc	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [eax+864]
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR _index$[ebp]
  000d5	03 81 ac 00 00
	00		 add	 eax, DWORD PTR [ecx+172]
  000db	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	89 81 60 03 00
	00		 mov	 DWORD PTR [ecx+864], eax

; 1181 : 	//printf("FreeIndex: size %d: blockidx: %d\n", index->real_data_size, blockidx);
; 1182 : }

  000e4	c9		 leave
  000e5	c2 04 00	 ret	 4
?PushFreeIndex@CEterPack@@AAEXPAUSEterPackIndex@@@Z ENDP ; CEterPack::PushFreeIndex
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetFreeBlockIndex@CEterPack@@AAEHJ@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
_size$ = 8						; size = 4
?GetFreeBlockIndex@CEterPack@@AAEHJ@Z PROC		; CEterPack::GetFreeBlockIndex, COMDAT
; _this$ = ecx

; 1161 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1162 : 	return min(FREE_INDEX_MAX_SIZE, size / FREE_INDEX_BLOCK_SIZE);

  00008	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0000b	99		 cdq
  0000c	81 e2 ff 7f 00
	00		 and	 edx, 32767		; 00007fffH
  00012	03 c2		 add	 eax, edx
  00014	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  00017	3d 00 02 00 00	 cmp	 eax, 512		; 00000200H
  0001c	7e 09		 jle	 SHORT $LN3@GetFreeBlo
  0001e	c7 45 fc 00 02
	00 00		 mov	 DWORD PTR tv67[ebp], 512 ; 00000200H
  00025	eb 12		 jmp	 SHORT $LN4@GetFreeBlo
$LN3@GetFreeBlo:
  00027	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0002a	99		 cdq
  0002b	81 e2 ff 7f 00
	00		 and	 edx, 32767		; 00007fffH
  00031	03 c2		 add	 eax, edx
  00033	c1 f8 0f	 sar	 eax, 15			; 0000000fH
  00036	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax
$LN4@GetFreeBlo:
  00039	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]

; 1163 : }

  0003c	c9		 leave
  0003d	c2 04 00	 ret	 4
?GetFreeBlockIndex@CEterPack@@AAEHJ@Z ENDP		; CEterPack::GetFreeBlockIndex
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?WriteIndex@CEterPack@@AAEXAAVCFileBase@@PAUSEterPackIndex@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_file$ = 8						; size = 4
_index$ = 12						; size = 4
?WriteIndex@CEterPack@@AAEXAAVCFileBase@@PAUSEterPackIndex@@@Z PROC ; CEterPack::WriteIndex, COMDAT
; _this$ = ecx

; 1136 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1137 : 	file.Seek(sizeof(DWORD) + sizeof(DWORD));

  00007	6a 08		 push	 8
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0000c	e8 00 00 00 00	 call	 ?Seek@CFileBase@@QAEXK@Z ; CFileBase::Seek

; 1138 : 	file.Write(&m_indexCount, sizeof(long));

  00011	6a 04		 push	 4
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	05 50 01 00 00	 add	 eax, 336		; 00000150H
  0001b	50		 push	 eax
  0001c	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00024	ff 50 04	 call	 DWORD PTR [eax+4]

; 1139 : 	file.Seek(eterpack::c_HeaderSize + (index->id * sizeof(TEterPackIndex)));

  00027	8b 45 0c	 mov	 eax, DWORD PTR _index$[ebp]
  0002a	69 00 c0 00 00
	00		 imul	 eax, DWORD PTR [eax], 192
  00030	83 c0 0c	 add	 eax, 12			; 0000000cH
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00037	e8 00 00 00 00	 call	 ?Seek@CFileBase@@QAEXK@Z ; CFileBase::Seek

; 1140 : 
; 1141 : 	if (!file.Write(index, sizeof(TEterPackIndex)))

  0003c	68 c0 00 00 00	 push	 192			; 000000c0H
  00041	ff 75 0c	 push	 DWORD PTR _index$[ebp]
  00044	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00047	8b 00		 mov	 eax, DWORD PTR [eax]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0004c	ff 50 04	 call	 DWORD PTR [eax+4]

; 1142 : 	{
; 1143 : 		assert(!"WriteIndex: fwrite failed");
; 1144 : 		return;
; 1145 : 	}
; 1146 : }

  0004f	c9		 leave
  00050	c2 08 00	 ret	 8
?WriteIndex@CEterPack@@AAEXAAVCFileBase@@PAUSEterPackIndex@@@Z ENDP ; CEterPack::WriteIndex
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?NewIndex@CEterPack@@AAEPAUSEterPackIndex@@AAVCFileBase@@PBDJ@Z
_TEXT	SEGMENT
$T1 = -120						; size = 8
$T2 = -112						; size = 8
$T3 = -104						; size = 4
$T4 = -100						; size = 4
$T5 = -96						; size = 4
$T6 = -92						; size = 4
$T7 = -88						; size = 4
$T8 = -84						; size = 4
__Val1$ = -80						; size = 4
$T9 = -76						; size = 4
$T10 = -72						; size = 4
$T11 = -68						; size = 4
$T12 = -64						; size = 4
$T13 = -60						; size = 4
$T14 = -56						; size = 4
$T15 = -52						; size = 4
$T16 = -48						; size = 4
___param0$ = -44					; size = 4
$T17 = -40						; size = 4
_block_size$ = -36					; size = 4
tv226 = -32						; size = 4
tv250 = -28						; size = 4
_this$ = -24						; size = 4
_blockidx$ = -20					; size = 4
_this$ = -16						; size = 4
_i$18 = -12						; size = 4
_index$ = -8						; size = 4
$T19 = -2						; size = 1
$T20 = -1						; size = 1
_file$ = 8						; size = 4
_filename$ = 12						; size = 4
_size$ = 16						; size = 4
?NewIndex@CEterPack@@AAEPAUSEterPackIndex@@AAVCFileBase@@PBDJ@Z PROC ; CEterPack::NewIndex, COMDAT
; _this$ = ecx

; 1192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 78	 sub	 esp, 120		; 00000078H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1193 : 	TEterPackIndex* index = NULL;

  00009	83 65 f8 00	 and	 DWORD PTR _index$[ebp], 0

; 1194 : 	int block_size = size + (DATA_BLOCK_SIZE - (size % DATA_BLOCK_SIZE));

  0000d	8b 45 10	 mov	 eax, DWORD PTR _size$[ebp]
  00010	25 ff 00 00 80	 and	 eax, -2147483393	; 800000ffH
  00015	79 07		 jns	 SHORT $LN355@NewIndex
  00017	48		 dec	 eax
  00018	0d 00 ff ff ff	 or	 eax, -256		; ffffff00H
  0001d	40		 inc	 eax
$LN355@NewIndex:
  0001e	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00023	2b c8		 sub	 ecx, eax
  00025	03 4d 10	 add	 ecx, DWORD PTR _size$[ebp]
  00028	89 4d dc	 mov	 DWORD PTR _block_size$[ebp], ecx

; 1195 : //	if ((index = FindIndex(filename))) //    
; 1196 : //		return index;
; 1197 : 
; 1198 : 	int blockidx = GetFreeBlockIndex(block_size);

  0002b	ff 75 dc	 push	 DWORD PTR _block_size$[ebp]
  0002e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?GetFreeBlockIndex@CEterPack@@AAEHJ@Z ; CEterPack::GetFreeBlockIndex
  00036	89 45 ec	 mov	 DWORD PTR _blockidx$[ebp], eax

; 1199 : 
; 1200 : 	for (TFreeIndexList::iterator i = m_FreeIndexList[blockidx].begin();

  00039	8d 45 f4	 lea	 eax, DWORD PTR _i$18[ebp]
  0003c	50		 push	 eax
  0003d	8b 45 ec	 mov	 eax, DWORD PTR _blockidx$[ebp]
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8d 8c c1 98 03
	00 00		 lea	 ecx, DWORD PTR [ecx+eax*8+920]
  0004a	e8 00 00 00 00	 call	 ?begin@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@XZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::begin
  0004f	eb 08		 jmp	 SHORT $LN4@NewIndex
$LN2@NewIndex:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  00051	8b 45 f4	 mov	 eax, DWORD PTR _i$18[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	89 45 f4	 mov	 DWORD PTR _i$18[ebp], eax
$LN4@NewIndex:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1201 : 		 i != m_FreeIndexList[blockidx].end();

  00059	8b 45 ec	 mov	 eax, DWORD PTR _blockidx$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	8d 84 c1 98 03
	00 00		 lea	 eax, DWORD PTR [ecx+eax*8+920]
  00066	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00069	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0006c	89 45 9c	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0006f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00077	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0007a	89 45 d0	 mov	 DWORD PTR $T16[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0007d	8d 45 d0	 lea	 eax, DWORD PTR $T16[ebp]
  00080	89 45 cc	 mov	 DWORD PTR $T15[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00083	8b 45 cc	 mov	 eax, DWORD PTR $T15[ebp]
  00086	8b 4d f4	 mov	 ecx, DWORD PTR _i$18[ebp]
  00089	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0008b	75 09		 jne	 SHORT $LN57@NewIndex
  0008d	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv250[ebp], 1
  00094	eb 04		 jmp	 SHORT $LN58@NewIndex
$LN57@NewIndex:
  00096	83 65 e4 00	 and	 DWORD PTR tv250[ebp], 0
$LN58@NewIndex:
  0009a	8a 45 e4	 mov	 al, BYTE PTR tv250[ebp]
  0009d	88 45 ff	 mov	 BYTE PTR $T20[ebp], al

; 203  :         return !(*this == _Right);

  000a0	0f b6 45 ff	 movzx	 eax, BYTE PTR $T20[ebp]
  000a4	85 c0		 test	 eax, eax
  000a6	75 09		 jne	 SHORT $LN52@NewIndex
  000a8	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv226[ebp], 1
  000af	eb 04		 jmp	 SHORT $LN53@NewIndex
$LN52@NewIndex:
  000b1	83 65 e0 00	 and	 DWORD PTR tv226[ebp], 0
$LN53@NewIndex:
  000b5	8a 45 e0	 mov	 al, BYTE PTR tv226[ebp]
  000b8	88 45 fe	 mov	 BYTE PTR $T19[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1201 : 		 i != m_FreeIndexList[blockidx].end();

  000bb	0f b6 45 fe	 movzx	 eax, BYTE PTR $T19[ebp]
  000bf	85 c0		 test	 eax, eax
  000c1	74 5c		 je	 SHORT $LN3@NewIndex
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000c3	8b 45 f4	 mov	 eax, DWORD PTR _i$18[ebp]
  000c6	83 c0 08	 add	 eax, 8
  000c9	89 45 c8	 mov	 DWORD PTR $T14[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000cc	8b 45 c8	 mov	 eax, DWORD PTR $T14[ebp]
  000cf	89 45 c4	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1204 : 		 if ((*i)->real_data_size >= size)

  000d2	8b 45 c4	 mov	 eax, DWORD PTR $T13[ebp]
  000d5	8b 00		 mov	 eax, DWORD PTR [eax]
  000d7	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  000dd	3b 45 10	 cmp	 eax, DWORD PTR _size$[ebp]
  000e0	7c 38		 jl	 SHORT $LN5@NewIndex
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000e2	8b 45 f4	 mov	 eax, DWORD PTR _i$18[ebp]
  000e5	83 c0 08	 add	 eax, 8
  000e8	89 45 c0	 mov	 DWORD PTR $T12[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000eb	8b 45 c0	 mov	 eax, DWORD PTR $T12[ebp]
  000ee	89 45 bc	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1206 : 			 index = *i;

  000f1	8b 45 bc	 mov	 eax, DWORD PTR $T11[ebp]
  000f4	8b 00		 mov	 eax, DWORD PTR [eax]
  000f6	89 45 f8	 mov	 DWORD PTR _index$[ebp], eax

; 1207 : 			 m_FreeIndexList[blockidx].erase(i);

  000f9	8b 45 f4	 mov	 eax, DWORD PTR _i$18[ebp]
  000fc	89 45 b8	 mov	 DWORD PTR $T10[ebp], eax
  000ff	ff 75 b8	 push	 DWORD PTR $T10[ebp]
  00102	8d 45 98	 lea	 eax, DWORD PTR $T3[ebp]
  00105	50		 push	 eax
  00106	8b 45 ec	 mov	 eax, DWORD PTR _blockidx$[ebp]
  00109	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	8d 8c c1 98 03
	00 00		 lea	 ecx, DWORD PTR [ecx+eax*8+920]
  00113	e8 00 00 00 00	 call	 ?erase@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSEterPackIndex@@@std@@@std@@@2@@Z ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::erase

; 1208 : 
; 1209 : 			 assert(index->filename_crc == 0);
; 1210 : 			 break;

  00118	eb 05		 jmp	 SHORT $LN3@NewIndex
$LN5@NewIndex:

; 1211 : 		 }
; 1212 : 	}

  0011a	e9 32 ff ff ff	 jmp	 $LN2@NewIndex
$LN3@NewIndex:

; 1213 : 
; 1214 : 	if (!index)

  0011f	83 7d f8 00	 cmp	 DWORD PTR _index$[ebp], 0
  00123	75 30		 jne	 SHORT $LN6@NewIndex

; 1215 : 	{
; 1216 : 		index = new TEterPackIndex;

  00125	68 c0 00 00 00	 push	 192			; 000000c0H
  0012a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0012f	59		 pop	 ecx
  00130	89 45 b4	 mov	 DWORD PTR $T9[ebp], eax
  00133	8b 45 b4	 mov	 eax, DWORD PTR $T9[ebp]
  00136	89 45 f8	 mov	 DWORD PTR _index$[ebp], eax

; 1217 : 		index->real_data_size = block_size;

  00139	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  0013c	8b 4d dc	 mov	 ecx, DWORD PTR _block_size$[ebp]
  0013f	89 88 ac 00 00
	00		 mov	 DWORD PTR [eax+172], ecx

; 1218 : 		index->id = GetNewIndexPosition(file);

  00145	ff 75 08	 push	 DWORD PTR _file$[ebp]
  00148	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014b	e8 00 00 00 00	 call	 ?GetNewIndexPosition@CEterPack@@AAEJAAVCFileBase@@@Z ; CEterPack::GetNewIndexPosition
  00150	8b 4d f8	 mov	 ecx, DWORD PTR _index$[ebp]
  00153	89 01		 mov	 DWORD PTR [ecx], eax
$LN6@NewIndex:

; 1219 : 	}
; 1220 : 
; 1221 : 	strncpy(index->filename, filename, FILENAME_MAX_LEN);

  00155	68 a0 00 00 00	 push	 160			; 000000a0H
  0015a	ff 75 0c	 push	 DWORD PTR _filename$[ebp]
  0015d	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  00160	83 c0 04	 add	 eax, 4
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 _strncpy
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1222 : 	index->filename[FILENAME_MAX_LEN] = '\0';

  0016c	33 c0		 xor	 eax, eax
  0016e	40		 inc	 eax
  0016f	69 c0 a0 00 00
	00		 imul	 eax, eax, 160
  00175	8b 4d f8	 mov	 ecx, DWORD PTR _index$[ebp]
  00178	c6 44 01 04 00	 mov	 BYTE PTR [ecx+eax+4], 0

; 1223 : 	inlineConvertPackFilename(index->filename);

  0017d	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  00180	83 c0 04	 add	 eax, 4
  00183	50		 push	 eax
  00184	e8 00 00 00 00	 call	 ?inlineConvertPackFilename@@YAXPAD@Z ; inlineConvertPackFilename
  00189	59		 pop	 ecx

; 1224 : 
; 1225 : 	index->filename_crc	= GetCRC32(index->filename, strlen(index->filename));

  0018a	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  0018d	83 c0 04	 add	 eax, 4
  00190	50		 push	 eax
  00191	e8 00 00 00 00	 call	 _strlen
  00196	59		 pop	 ecx
  00197	50		 push	 eax
  00198	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  0019b	83 c0 04	 add	 eax, 4
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  001a4	59		 pop	 ecx
  001a5	59		 pop	 ecx
  001a6	8b 4d f8	 mov	 ecx, DWORD PTR _index$[ebp]
  001a9	89 81 a8 00 00
	00		 mov	 DWORD PTR [ecx+168], eax

; 1226 : 
; 1227 : 	m_DataPositionMap.insert(TDataPositionMap::value_type(index->filename_crc, index));

  001af	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]
  001b2	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  001b7	89 45 b0	 mov	 DWORD PTR __Val1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  001ba	8b 45 b0	 mov	 eax, DWORD PTR __Val1$[ebp]
  001bd	89 45 ac	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001c0	8b 45 ac	 mov	 eax, DWORD PTR $T8[ebp]
  001c3	8b 00		 mov	 eax, DWORD PTR [eax]
  001c5	89 45 90	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  001c8	8d 45 f8	 lea	 eax, DWORD PTR _index$[ebp]
  001cb	89 45 a8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  001ce	8b 45 a8	 mov	 eax, DWORD PTR $T7[ebp]
  001d1	8b 00		 mov	 eax, DWORD PTR [eax]
  001d3	89 45 94	 mov	 DWORD PTR $T2[ebp+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 213  :          { return static_cast<typename ::boost::move_detail::remove_reference<T>::type &&>(t); }

  001d6	8d 45 90	 lea	 eax, DWORD PTR $T2[ebp]
  001d9	89 45 d8	 mov	 DWORD PTR $T17[ebp], eax

; 249  :          {  return static_cast<T&&>(t);   }

  001dc	8b 45 d8	 mov	 eax, DWORD PTR $T17[ebp]
  001df	89 45 a4	 mov	 DWORD PTR $T6[ebp], eax
  001e2	8b 45 d8	 mov	 eax, DWORD PTR $T17[ebp]
  001e5	89 45 a0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 226  :         return table_.emplace_unique(

  001e8	ff 75 a4	 push	 DWORD PTR $T6[ebp]
  001eb	ff 75 a0	 push	 DWORD PTR $T5[ebp]
  001ee	8d 45 88	 lea	 eax, DWORD PTR $T1[ebp]
  001f1	50		 push	 eax
  001f2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001f5	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  001fb	e8 00 00 00 00	 call	 ??$emplace_unique@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK$$QAU?$pair@$$CBKPAUSEterPackIndex@@@5@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_unique<std::pair<unsigned long const ,SEterPackIndex *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1228 : 	return index;

  00200	8b 45 f8	 mov	 eax, DWORD PTR _index$[ebp]

; 1229 : }

  00203	c9		 leave
  00204	c2 0c 00	 ret	 12			; 0000000cH
?NewIndex@CEterPack@@AAEPAUSEterPackIndex@@AAVCFileBase@@PBDJ@Z ENDP ; CEterPack::NewIndex
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetNewIndexPosition@CEterPack@@AAEJAAVCFileBase@@@Z
_TEXT	SEGMENT
_pos$ = -8						; size = 4
_this$ = -4						; size = 4
_file$ = 8						; size = 4
?GetNewIndexPosition@CEterPack@@AAEJAAVCFileBase@@@Z PROC ; CEterPack::GetNewIndexPosition, COMDAT
; _this$ = ecx

; 1185 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1186 : 	long pos = (file.Size() - eterpack::c_HeaderSize) / sizeof(TEterPackIndex);

  00008	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0000b	e8 00 00 00 00	 call	 ?Size@CFileBase@@QAEKXZ	; CFileBase::Size
  00010	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00013	33 d2		 xor	 edx, edx
  00015	b9 c0 00 00 00	 mov	 ecx, 192		; 000000c0H
  0001a	f7 f1		 div	 ecx
  0001c	89 45 f8	 mov	 DWORD PTR _pos$[ebp], eax

; 1187 : 	++m_indexCount;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 80 50 01 00
	00		 mov	 eax, DWORD PTR [eax+336]
  00028	40		 inc	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	89 81 50 01 00
	00		 mov	 DWORD PTR [ecx+336], eax

; 1188 : 	return (pos);

  00032	8b 45 f8	 mov	 eax, DWORD PTR _pos$[ebp]

; 1189 : }

  00035	c9		 leave
  00036	c2 04 00	 ret	 4
?GetNewIndexPosition@CEterPack@@AAEJAAVCFileBase@@@Z ENDP ; CEterPack::GetNewIndexPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
_this$ = -20						; size = 4
_filename_crc$ = -16					; size = 4
_i$ = -12						; size = 4
tv129 = -8						; size = 4
$T3 = -1						; size = 1
_filename$ = 8						; size = 4
?FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z PROC	; CEterPack::FindIndex, COMDAT
; _this$ = ecx

; 1232 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1233 : 	static char tmpFilename[MAX_PATH + 1];
; 1234 : 	strncpy(tmpFilename, filename, MAX_PATH);

  00009	68 04 01 00 00	 push	 260			; 00000104H
  0000e	ff 75 08	 push	 DWORD PTR _filename$[ebp]
  00011	68 00 00 00 00	 push	 OFFSET ?tmpFilename@?1??FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z@4PADA
  00016	e8 00 00 00 00	 call	 _strncpy
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1235 : 	inlineConvertPackFilename(tmpFilename);

  0001e	68 00 00 00 00	 push	 OFFSET ?tmpFilename@?1??FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z@4PADA
  00023	e8 00 00 00 00	 call	 ?inlineConvertPackFilename@@YAXPAD@Z ; inlineConvertPackFilename
  00028	59		 pop	 ecx

; 1236 : 
; 1237 : 	DWORD filename_crc = GetCRC32(tmpFilename, strlen(tmpFilename));

  00029	68 00 00 00 00	 push	 OFFSET ?tmpFilename@?1??FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z@4PADA
  0002e	e8 00 00 00 00	 call	 _strlen
  00033	59		 pop	 ecx
  00034	50		 push	 eax
  00035	68 00 00 00 00	 push	 OFFSET ?tmpFilename@?1??FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z@4PADA
  0003a	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  0003f	59		 pop	 ecx
  00040	59		 pop	 ecx
  00041	89 45 f0	 mov	 DWORD PTR _filename_crc$[ebp], eax

; 1238 : 	TDataPositionMap::iterator i = m_DataPositionMap.find(filename_crc);

  00044	8d 45 f0	 lea	 eax, DWORD PTR _filename_crc$[ebp]
  00047	50		 push	 eax
  00048	8d 45 f4	 lea	 eax, DWORD PTR _i$[ebp]
  0004b	50		 push	 eax
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  00055	e8 00 00 00 00	 call	 ?find@?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::find
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2368 :         iterator() BOOST_NOEXCEPT : node_() {}

  0005a	83 65 e8 00	 and	 DWORD PTR $T2[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 200  :       iterator end() BOOST_NOEXCEPT { return iterator(); }

  0005e	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  00061	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2394 :           return node_ == x.node_;

  00064	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00067	8b 4d f4	 mov	 ecx, DWORD PTR _i$[ebp]
  0006a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0006c	75 09		 jne	 SHORT $LN18@FindIndex
  0006e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv129[ebp], 1
  00075	eb 04		 jmp	 SHORT $LN19@FindIndex
$LN18@FindIndex:
  00077	83 65 f8 00	 and	 DWORD PTR tv129[ebp], 0
$LN19@FindIndex:
  0007b	8a 45 f8	 mov	 al, BYTE PTR tv129[ebp]
  0007e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1240 : 	if (i == m_DataPositionMap.end())

  00081	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00085	85 c0		 test	 eax, eax
  00087	74 04		 je	 SHORT $LN21@FindIndex

; 1241 : 		return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	eb 06		 jmp	 SHORT $LN1@FindIndex
$LN21@FindIndex:

; 1242 : 
; 1243 : 	return (i->second);

  0008d	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  00090	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
$LN1@FindIndex:

; 1244 : }

  00093	c9		 leave
  00094	c2 04 00	 ret	 4
?FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z ENDP	; CEterPack::FindIndex
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?CreateIndexFile@CEterPack@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_fp$ = -4						; size = 4
?CreateIndexFile@CEterPack@@AAE_NXZ PROC		; CEterPack::CreateIndexFile, COMDAT
; _this$ = ecx

; 1107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1108 : 	FILE * fp;
; 1109 : 
; 1110 : 	if (NULL != (fp = fopen(m_indexFileName, "rb")))

  00008	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb@
  0000d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00010	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _fopen
  0001b	59		 pop	 ecx
  0001c	59		 pop	 ecx
  0001d	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax
  00020	83 7d fc 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00024	74 12		 je	 SHORT $LN2@CreateInde

; 1111 : 	{
; 1112 : 		fclose(fp);

  00026	ff 75 fc	 push	 DWORD PTR _fp$[ebp]
  00029	e8 00 00 00 00	 call	 _fclose
  0002e	59		 pop	 ecx

; 1113 : 		return true;

  0002f	b0 01		 mov	 al, 1
  00031	e9 81 00 00 00	 jmp	 $LN1@CreateInde

; 1114 : 	}

  00036	eb 12		 jmp	 SHORT $LN3@CreateInde
$LN2@CreateInde:

; 1115 : 	else if (m_bReadOnly)

  00038	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	0f b6 80 64 03
	00 00		 movzx	 eax, BYTE PTR [eax+868]
  00042	85 c0		 test	 eax, eax
  00044	74 04		 je	 SHORT $LN3@CreateInde

; 1116 : 		return false;

  00046	32 c0		 xor	 al, al
  00048	eb 6d		 jmp	 SHORT $LN1@CreateInde
$LN3@CreateInde:

; 1117 : 
; 1118 : 	//
; 1119 : 	//    .
; 1120 : 	//
; 1121 : 	fp = fopen(m_indexFileName, "wb");

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0004f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00052	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 _fopen
  0005d	59		 pop	 ecx
  0005e	59		 pop	 ecx
  0005f	89 45 fc	 mov	 DWORD PTR _fp$[ebp], eax

; 1122 : 	
; 1123 : 	if (!fp)

  00062	83 7d fc 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00066	75 04		 jne	 SHORT $LN5@CreateInde

; 1124 : 		return false;

  00068	32 c0		 xor	 al, al
  0006a	eb 4b		 jmp	 SHORT $LN1@CreateInde
$LN5@CreateInde:

; 1125 : 
; 1126 : 	fwrite(&eterpack::c_IndexCC, sizeof(DWORD), 1, fp);

  0006c	ff 75 fc	 push	 DWORD PTR _fp$[ebp]
  0006f	6a 01		 push	 1
  00071	6a 04		 push	 4
  00073	68 00 00 00 00	 push	 OFFSET ?c_IndexCC@eterpack@@3KB
  00078	e8 00 00 00 00	 call	 _fwrite
  0007d	83 c4 10	 add	 esp, 16			; 00000010H

; 1127 : 	fwrite(&eterpack::c_Version, sizeof(DWORD), 1, fp);

  00080	ff 75 fc	 push	 DWORD PTR _fp$[ebp]
  00083	6a 01		 push	 1
  00085	6a 04		 push	 4
  00087	68 00 00 00 00	 push	 OFFSET ?c_Version@eterpack@@3KB
  0008c	e8 00 00 00 00	 call	 _fwrite
  00091	83 c4 10	 add	 esp, 16			; 00000010H

; 1128 : 	fwrite(&m_indexCount, sizeof(long), 1, fp);

  00094	ff 75 fc	 push	 DWORD PTR _fp$[ebp]
  00097	6a 01		 push	 1
  00099	6a 04		 push	 4
  0009b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	05 50 01 00 00	 add	 eax, 336		; 00000150H
  000a3	50		 push	 eax
  000a4	e8 00 00 00 00	 call	 _fwrite
  000a9	83 c4 10	 add	 esp, 16			; 00000010H

; 1129 : 
; 1130 : 	fclose(fp);

  000ac	ff 75 fc	 push	 DWORD PTR _fp$[ebp]
  000af	e8 00 00 00 00	 call	 _fclose
  000b4	59		 pop	 ecx

; 1131 : 	return true;

  000b5	b0 01		 mov	 al, 1
$LN1@CreateInde:

; 1132 : }

  000b7	c9		 leave
  000b8	c3		 ret	 0
?CreateIndexFile@CEterPack@@AAE_NXZ ENDP		; CEterPack::CreateIndexFile
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z
_TEXT	SEGMENT
$T2 = -120						; size = 8
$T3 = -112						; size = 8
$T4 = -104						; size = 4
$T5 = -100						; size = 4
$T6 = -96						; size = 4
$T7 = -92						; size = 4
__Val1$ = -88						; size = 4
$T8 = -84						; size = 4
_ver$ = -80						; size = 4
$T9 = -76						; size = 4
_zObj$ = -72						; size = 20
$T10 = -52						; size = 4
_uiFileSize$ = -48					; size = 4
_fourcc$ = -44						; size = 4
_i$11 = -40						; size = 4
_pvData$ = -36						; size = 4
$T12 = -32						; size = 1
$T13 = -31						; size = 1
$T14 = -30						; size = 1
$T15 = -29						; size = 1
$T16 = -28						; size = 1
$T17 = -27						; size = 1
$T18 = -26						; size = 1
$T19 = -25						; size = 1
_pbData$ = -24						; size = 4
_index$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_file$ = 0						; size = 324
__$ArrayPad$ = 324					; size = 4
_rkFileDict$ = 336					; size = 4
_bOverwrite$ = 340					; size = 1
?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z PROC ; CEterPack::__BuildIndex, COMDAT
; _this$ = ecx

; 395  : {

  00000	55		 push	 ebp
  00001	8d ac 24 b8 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-328]
  00008	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 6c	 sub	 esp, 108		; 0000006cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 44 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 	//DWORD dwBeginTime = ELTimer_GetMSec();
; 397  : 	CMappedFile file;

  00039	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 398  : 	LPCVOID pvData;
; 399  : 	CLZObject zObj;

  00045	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00048	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  0004d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 400  : 
; 401  : 	if (NULL == file.Create(m_indexFileName, &pvData, 0, 0))

  00051	6a 00		 push	 0
  00053	6a 00		 push	 0
  00055	8d 45 dc	 lea	 eax, DWORD PTR _pvData$[ebp]
  00058	50		 push	 eax
  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00061	50		 push	 eax
  00062	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00065	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  0006a	85 c0		 test	 eax, eax
  0006c	75 39		 jne	 SHORT $LN5@BuildIndex

; 402  : 	{
; 403  : 		TraceError("Cannot open pack index file! %s", m_dbName);

  0006e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	05 55 01 00 00	 add	 eax, 341		; 00000155H
  00076	50		 push	 eax
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@IACKDODI@Cannot?5open?5pack?5index?5file?$CB?5?$CFs@
  0007c	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00081	59		 pop	 ecx
  00082	59		 pop	 ecx

; 404  : 		return false;

  00083	c6 45 e7 00	 mov	 BYTE PTR $T19[ebp], 0
  00087	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0008b	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0008e	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00093	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00097	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0009a	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0009f	8a 45 e7	 mov	 al, BYTE PTR $T19[ebp]
  000a2	e9 91 03 00 00	 jmp	 $LN1@BuildIndex
$LN5@BuildIndex:

; 405  : 	}
; 406  : 
; 407  : 	if (file.Size() < eterpack::c_HeaderSize)

  000a7	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000aa	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000af	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  000b2	73 39		 jae	 SHORT $LN6@BuildIndex

; 408  : 	{
; 409  : 		TraceError("Pack index file header error! %s", m_dbName);

  000b4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	05 55 01 00 00	 add	 eax, 341		; 00000155H
  000bc	50		 push	 eax
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KNLDPAAC@Pack?5index?5file?5header?5error?$CB?5?$CF@
  000c2	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000c7	59		 pop	 ecx
  000c8	59		 pop	 ecx

; 410  : 		return false;

  000c9	c6 45 e6 00	 mov	 BYTE PTR $T18[ebp], 0
  000cd	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000d1	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  000d4	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  000d9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000dd	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000e0	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000e5	8a 45 e6	 mov	 al, BYTE PTR $T18[ebp]
  000e8	e9 4b 03 00 00	 jmp	 $LN1@BuildIndex
$LN6@BuildIndex:

; 411  : 	}
; 412  : 
; 413  : 	DWORD fourcc = *(DWORD *) pvData;

  000ed	8b 45 dc	 mov	 eax, DWORD PTR _pvData$[ebp]
  000f0	8b 00		 mov	 eax, DWORD PTR [eax]
  000f2	89 45 d4	 mov	 DWORD PTR _fourcc$[ebp], eax

; 414  : 
; 415  : 	BYTE * pbData;
; 416  : 	UINT uiFileSize;
; 417  : 
; 418  : 	if (fourcc == eterpack::c_IndexCC)

  000f5	81 7d d4 45 50
	4b 44		 cmp	 DWORD PTR _fourcc$[ebp], 1145786437 ; 444b5045H
  000fc	75 16		 jne	 SHORT $LN7@BuildIndex

; 419  : 	{
; 420  : 		pbData = (BYTE *) pvData;

  000fe	8b 45 dc	 mov	 eax, DWORD PTR _pvData$[ebp]
  00101	89 45 e8	 mov	 DWORD PTR _pbData$[ebp], eax

; 421  : 		uiFileSize = file.Size();

  00104	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00107	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  0010c	89 45 d0	 mov	 DWORD PTR _uiFileSize$[ebp], eax

; 422  : 	}

  0010f	e9 dd 00 00 00	 jmp	 $LN8@BuildIndex
$LN7@BuildIndex:

; 423  : 	else if (fourcc == CLZObject::ms_dwFourCC)

  00114	8b 45 d4	 mov	 eax, DWORD PTR _fourcc$[ebp]
  00117	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?ms_dwFourCC@CLZObject@@2KA ; CLZObject::ms_dwFourCC
  0011d	0f 85 95 00 00
	00		 jne	 $LN9@BuildIndex

; 424  : 	{
; 425  : 		m_bEncrypted = true;

  00123	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00126	c6 80 54 01 00
	00 01		 mov	 BYTE PTR [eax+340], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0012d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  00132	89 45 b4	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 427  : 		if (!CLZO::Instance().Decompress(zObj, (const BYTE *) pvData, s_adwEterPackKey))

  00135	68 00 00 00 00	 push	 OFFSET ?s_adwEterPackKey@@3PAKA
  0013a	ff 75 dc	 push	 DWORD PTR _pvData$[ebp]
  0013d	8d 45 b8	 lea	 eax, DWORD PTR _zObj$[ebp]
  00140	50		 push	 eax
  00141	8b 4d b4	 mov	 ecx, DWORD PTR $T9[ebp]
  00144	e8 00 00 00 00	 call	 ?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z ; CLZO::Decompress
  00149	0f b6 c0	 movzx	 eax, al
  0014c	85 c0		 test	 eax, eax
  0014e	75 24		 jne	 SHORT $LN11@BuildIndex

; 428  : 			return false;

  00150	c6 45 e5 00	 mov	 BYTE PTR $T17[ebp], 0
  00154	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00158	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0015b	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00160	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00164	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00167	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0016c	8a 45 e5	 mov	 al, BYTE PTR $T17[ebp]
  0016f	e9 c4 02 00 00	 jmp	 $LN1@BuildIndex
$LN11@BuildIndex:

; 429  : 
; 430  : 		if (zObj.GetSize() < eterpack::c_HeaderSize)

  00174	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00177	e8 00 00 00 00	 call	 ?GetSize@CLZObject@@QAEKXZ ; CLZObject::GetSize
  0017c	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  0017f	73 24		 jae	 SHORT $LN12@BuildIndex

; 431  : 			return false;

  00181	c6 45 e4 00	 mov	 BYTE PTR $T16[ebp], 0
  00185	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00189	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0018c	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00191	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00195	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00198	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0019d	8a 45 e4	 mov	 al, BYTE PTR $T16[ebp]
  001a0	e9 93 02 00 00	 jmp	 $LN1@BuildIndex
$LN12@BuildIndex:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  001a5	8b 45 b8	 mov	 eax, DWORD PTR _zObj$[ebp]
  001a8	89 45 e8	 mov	 DWORD PTR _pbData$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 434  : 		uiFileSize = zObj.GetSize();

  001ab	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  001ae	e8 00 00 00 00	 call	 ?GetSize@CLZObject@@QAEKXZ ; CLZObject::GetSize
  001b3	89 45 d0	 mov	 DWORD PTR _uiFileSize$[ebp], eax

; 435  : 	}

  001b6	eb 39		 jmp	 SHORT $LN8@BuildIndex
$LN9@BuildIndex:

; 436  : 	else
; 437  : 	{
; 438  : 		TraceError("Pack index file fourcc error! %s", m_dbName);

  001b8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001bb	05 55 01 00 00	 add	 eax, 341		; 00000155H
  001c0	50		 push	 eax
  001c1	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@HPBCEBAA@Pack?5index?5file?5fourcc?5error?$CB?5?$CF@
  001c6	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  001cb	59		 pop	 ecx
  001cc	59		 pop	 ecx

; 439  : 		return false;

  001cd	c6 45 e3 00	 mov	 BYTE PTR $T15[ebp], 0
  001d1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001d5	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  001d8	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  001dd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001e1	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  001e4	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  001e9	8a 45 e3	 mov	 al, BYTE PTR $T15[ebp]
  001ec	e9 47 02 00 00	 jmp	 $LN1@BuildIndex
$LN8@BuildIndex:

; 440  : 	}
; 441  : 
; 442  : 	pbData += sizeof(DWORD);

  001f1	8b 45 e8	 mov	 eax, DWORD PTR _pbData$[ebp]
  001f4	83 c0 04	 add	 eax, 4
  001f7	89 45 e8	 mov	 DWORD PTR _pbData$[ebp], eax

; 443  : 
; 444  : 	DWORD ver = *(DWORD *) pbData;

  001fa	8b 45 e8	 mov	 eax, DWORD PTR _pbData$[ebp]
  001fd	8b 00		 mov	 eax, DWORD PTR [eax]
  001ff	89 45 b0	 mov	 DWORD PTR _ver$[ebp], eax

; 445  : 	pbData += sizeof(DWORD);

  00202	8b 45 e8	 mov	 eax, DWORD PTR _pbData$[ebp]
  00205	83 c0 04	 add	 eax, 4
  00208	89 45 e8	 mov	 DWORD PTR _pbData$[ebp], eax

; 446  : 
; 447  : 	if (ver != eterpack::c_Version)

  0020b	83 7d b0 02	 cmp	 DWORD PTR _ver$[ebp], 2
  0020f	74 39		 je	 SHORT $LN13@BuildIndex

; 448  : 	{
; 449  : 		TraceError("Pack index file version error! %s", m_dbName);

  00211	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00214	05 55 01 00 00	 add	 eax, 341		; 00000155H
  00219	50		 push	 eax
  0021a	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KGHAJIDH@Pack?5index?5file?5version?5error?$CB?5@
  0021f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00224	59		 pop	 ecx
  00225	59		 pop	 ecx

; 450  : 		return false;

  00226	c6 45 e2 00	 mov	 BYTE PTR $T14[ebp], 0
  0022a	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0022e	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00231	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00236	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0023a	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0023d	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00242	8a 45 e2	 mov	 al, BYTE PTR $T14[ebp]
  00245	e9 ee 01 00 00	 jmp	 $LN1@BuildIndex
$LN13@BuildIndex:

; 451  : 	}
; 452  : 
; 453  : 	m_indexCount = *(long *) pbData;

  0024a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0024d	8b 4d e8	 mov	 ecx, DWORD PTR _pbData$[ebp]
  00250	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00252	89 88 50 01 00
	00		 mov	 DWORD PTR [eax+336], ecx

; 454  : 	pbData += sizeof(long);

  00258	8b 45 e8	 mov	 eax, DWORD PTR _pbData$[ebp]
  0025b	83 c0 04	 add	 eax, 4
  0025e	89 45 e8	 mov	 DWORD PTR _pbData$[ebp], eax

; 455  : 
; 456  : 	if (uiFileSize < eterpack::c_HeaderSize + sizeof(TEterPackIndex) * m_indexCount)

  00261	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00264	69 80 50 01 00
	00 c0 00 00 00	 imul	 eax, DWORD PTR [eax+336], 192
  0026e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00271	39 45 d0	 cmp	 DWORD PTR _uiFileSize$[ebp], eax
  00274	73 43		 jae	 SHORT $LN14@BuildIndex

; 457  : 	{
; 458  : 		TraceError("Pack index file size error! %s, indexCount %d", m_dbName, m_indexCount);

  00276	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00279	ff b0 50 01 00
	00		 push	 DWORD PTR [eax+336]
  0027f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00282	05 55 01 00 00	 add	 eax, 341		; 00000155H
  00287	50		 push	 eax
  00288	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@JMMFBMPC@Pack?5index?5file?5size?5error?$CB?5?$CFs?0@
  0028d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00292	83 c4 0c	 add	 esp, 12			; 0000000cH

; 459  : 		return false;

  00295	c6 45 e1 00	 mov	 BYTE PTR $T13[ebp], 0
  00299	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0029d	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  002a0	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  002a5	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  002a9	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  002ac	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  002b1	8a 45 e1	 mov	 al, BYTE PTR $T13[ebp]
  002b4	e9 7f 01 00 00	 jmp	 $LN1@BuildIndex
$LN14@BuildIndex:

; 460  : 	}
; 461  : 
; 462  : 	//Tracef("Loading Pack file %s elements: %d ... ", m_dbName, m_indexCount);
; 463  : 
; 464  : 	m_indexData = new TEterPackIndex[m_indexCount];

  002b9	33 c9		 xor	 ecx, ecx
  002bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002be	8b 80 50 01 00
	00		 mov	 eax, DWORD PTR [eax+336]
  002c4	ba c0 00 00 00	 mov	 edx, 192		; 000000c0H
  002c9	f7 e2		 mul	 edx
  002cb	0f 90 c1	 seto	 cl
  002ce	f7 d9		 neg	 ecx
  002d0	0b c8		 or	 ecx, eax
  002d2	51		 push	 ecx
  002d3	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  002d8	59		 pop	 ecx
  002d9	89 45 ac	 mov	 DWORD PTR $T8[ebp], eax
  002dc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002df	8b 4d ac	 mov	 ecx, DWORD PTR $T8[ebp]
  002e2	89 88 5c 03 00
	00		 mov	 DWORD PTR [eax+860], ecx

; 465  : 	memcpy(m_indexData, pbData, sizeof(TEterPackIndex) * m_indexCount);

  002e8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002eb	69 80 50 01 00
	00 c0 00 00 00	 imul	 eax, DWORD PTR [eax+336], 192
  002f5	50		 push	 eax
  002f6	ff 75 e8	 push	 DWORD PTR _pbData$[ebp]
  002f9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  002fc	ff b0 5c 03 00
	00		 push	 DWORD PTR [eax+860]
  00302	e8 00 00 00 00	 call	 _memcpy
  00307	83 c4 0c	 add	 esp, 12			; 0000000cH

; 466  : 
; 467  : 	TEterPackIndex * index = m_indexData;

  0030a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0030d	8b 80 5c 03 00
	00		 mov	 eax, DWORD PTR [eax+860]
  00313	89 45 ec	 mov	 DWORD PTR _index$[ebp], eax

; 468  : 
; 469  : 	for (int i = 0; i < m_indexCount; ++i, ++index)

  00316	83 65 d8 00	 and	 DWORD PTR _i$11[ebp], 0
  0031a	eb 12		 jmp	 SHORT $LN4@BuildIndex
$LN2@BuildIndex:
  0031c	8b 45 d8	 mov	 eax, DWORD PTR _i$11[ebp]
  0031f	40		 inc	 eax
  00320	89 45 d8	 mov	 DWORD PTR _i$11[ebp], eax
  00323	8b 45 ec	 mov	 eax, DWORD PTR _index$[ebp]
  00326	05 c0 00 00 00	 add	 eax, 192		; 000000c0H
  0032b	89 45 ec	 mov	 DWORD PTR _index$[ebp], eax
$LN4@BuildIndex:
  0032e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00331	8b 4d d8	 mov	 ecx, DWORD PTR _i$11[ebp]
  00334	3b 88 50 01 00
	00		 cmp	 ecx, DWORD PTR [eax+336]
  0033a	0f 8d d9 00 00
	00		 jge	 $LN3@BuildIndex

; 470  : 	{
; 471  : 		if (!index->filename_crc)

  00340	8b 45 ec	 mov	 eax, DWORD PTR _index$[ebp]
  00343	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [eax+168], 0
  0034a	75 10		 jne	 SHORT $LN15@BuildIndex

; 472  : 		{
; 473  : 			PushFreeIndex(index);

  0034c	ff 75 ec	 push	 DWORD PTR _index$[ebp]
  0034f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00352	e8 00 00 00 00	 call	 ?PushFreeIndex@CEterPack@@AAEXPAUSEterPackIndex@@@Z ; CEterPack::PushFreeIndex

; 474  : 		}

  00357	e9 b8 00 00 00	 jmp	 $LN16@BuildIndex
$LN15@BuildIndex:

; 475  : 		else
; 476  : 		{
; 477  : 			if (index->real_data_size > index->data_size)

  0035c	8b 45 ec	 mov	 eax, DWORD PTR _index$[ebp]
  0035f	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  00362	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  00368	3b 81 b0 00 00
	00		 cmp	 eax, DWORD PTR [ecx+176]
  0036e	7e 24		 jle	 SHORT $LN17@BuildIndex

; 478  : 				m_FragmentSize += index->real_data_size - index->data_size;

  00370	8b 45 ec	 mov	 eax, DWORD PTR _index$[ebp]
  00373	8b 4d ec	 mov	 ecx, DWORD PTR _index$[ebp]
  00376	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  0037c	2b 81 b0 00 00
	00		 sub	 eax, DWORD PTR [ecx+176]
  00382	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	03 81 60 03 00
	00		 add	 eax, DWORD PTR [ecx+864]
  0038b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0038e	89 81 60 03 00
	00		 mov	 DWORD PTR [ecx+864], eax
$LN17@BuildIndex:

; 479  : 
; 480  : 			m_DataPositionMap.insert(TDataPositionMap::value_type(index->filename_crc, index));

  00394	8b 45 ec	 mov	 eax, DWORD PTR _index$[ebp]
  00397	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  0039c	89 45 a8	 mov	 DWORD PTR __Val1$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0039f	8b 45 a8	 mov	 eax, DWORD PTR __Val1$[ebp]
  003a2	89 45 a4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  003a5	8b 45 a4	 mov	 eax, DWORD PTR $T7[ebp]
  003a8	8b 00		 mov	 eax, DWORD PTR [eax]
  003aa	89 45 90	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  003ad	8d 45 ec	 lea	 eax, DWORD PTR _index$[ebp]
  003b0	89 45 a0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  003b3	8b 45 a0	 mov	 eax, DWORD PTR $T6[ebp]
  003b6	8b 00		 mov	 eax, DWORD PTR [eax]
  003b8	89 45 94	 mov	 DWORD PTR $T3[ebp+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 213  :          { return static_cast<typename ::boost::move_detail::remove_reference<T>::type &&>(t); }

  003bb	8d 45 90	 lea	 eax, DWORD PTR $T3[ebp]
  003be	89 45 cc	 mov	 DWORD PTR $T10[ebp], eax

; 249  :          {  return static_cast<T&&>(t);   }

  003c1	8b 45 cc	 mov	 eax, DWORD PTR $T10[ebp]
  003c4	89 45 9c	 mov	 DWORD PTR $T5[ebp], eax
  003c7	8b 45 cc	 mov	 eax, DWORD PTR $T10[ebp]
  003ca	89 45 98	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 226  :         return table_.emplace_unique(

  003cd	ff 75 9c	 push	 DWORD PTR $T5[ebp]
  003d0	ff 75 98	 push	 DWORD PTR $T4[ebp]
  003d3	8d 45 88	 lea	 eax, DWORD PTR $T2[ebp]
  003d6	50		 push	 eax
  003d7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  003da	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  003e0	e8 00 00 00 00	 call	 ??$emplace_unique@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@_N@std@@ABK$$QAU?$pair@$$CBKPAUSEterPackIndex@@@5@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_unique<std::pair<unsigned long const ,SEterPackIndex *> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 482  : 			if (bOverwrite) //        

  003e5	0f b6 85 54 01
	00 00		 movzx	 eax, BYTE PTR _bOverwrite$[ebp]
  003ec	85 c0		 test	 eax, eax
  003ee	74 13		 je	 SHORT $LN18@BuildIndex

; 483  : 				rkFileDict.UpdateItem(this, index);

  003f0	ff 75 ec	 push	 DWORD PTR _index$[ebp]
  003f3	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  003f6	8b 8d 50 01 00
	00		 mov	 ecx, DWORD PTR _rkFileDict$[ebp]
  003fc	e8 00 00 00 00	 call	 ?UpdateItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z ; CEterFileDict::UpdateItem
  00401	eb 11		 jmp	 SHORT $LN16@BuildIndex
$LN18@BuildIndex:

; 484  : 			else
; 485  : 				rkFileDict.InsertItem(this, index);

  00403	ff 75 ec	 push	 DWORD PTR _index$[ebp]
  00406	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  00409	8b 8d 50 01 00
	00		 mov	 ecx, DWORD PTR _rkFileDict$[ebp]
  0040f	e8 00 00 00 00	 call	 ?InsertItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z ; CEterFileDict::InsertItem
$LN16@BuildIndex:

; 486  : 		}
; 487  : 	}

  00414	e9 03 ff ff ff	 jmp	 $LN2@BuildIndex
$LN3@BuildIndex:

; 488  : 
; 489  : 	//Tracef("Done. (spent %dms)\n", ELTimer_GetMSec() - dwBeginTime);
; 490  : 	return true;

  00419	c6 45 e0 01	 mov	 BYTE PTR $T12[ebp], 1
  0041d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00421	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00424	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00429	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0042d	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00430	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00435	8a 45 e0	 mov	 al, BYTE PTR $T12[ebp]
$LN1@BuildIndex:

; 491  : }

  00438	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0043b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00442	59		 pop	 ecx
  00443	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00449	33 cd		 xor	 ecx, ebp
  0044b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00450	81 c5 48 01 00
	00		 add	 ebp, 328		; 00000148H
  00456	c9		 leave
  00457	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z$1:
  00008	8d 4d b8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z ENDP ; CEterPack::__BuildIndex
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetPackPolicy_HybridCrypt@CEterPack@@QBEPAVEterPackPolicy_CSHybridCrypt@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPackPolicy_HybridCrypt@CEterPack@@QBEPAVEterPackPolicy_CSHybridCrypt@@XZ PROC ; CEterPack::GetPackPolicy_HybridCrypt, COMDAT
; _this$ = ecx

; 1546 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1547 : 	return  m_pCSHybridCryptPolicy;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 d0 13 00
	00		 mov	 eax, DWORD PTR [eax+5072]

; 1548 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetPackPolicy_HybridCrypt@CEterPack@@QBEPAVEterPackPolicy_CSHybridCrypt@@XZ ENDP ; CEterPack::GetPackPolicy_HybridCrypt
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
_TEXT	SEGMENT
_zObj$ = -84						; size = 20
$T2 = -64						; size = 4
_data$ = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
$T6 = -44						; size = 4
_index$7 = -40						; size = 4
tv82 = -36						; size = 4
_this$ = -32						; size = 4
$T8 = -28						; size = 4
_this$ = -24						; size = 4
_i$9 = -20						; size = 4
$T10 = -15						; size = 1
$T11 = -14						; size = 1
$T12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_dataMapFile$ = 0					; size = 324
$T13 = 324						; size = 24
__$ArrayPad$ = 348					; size = 4
_retNames$ = 360					; size = 4
?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z PROC ; CEterPack::GetNames, COMDAT
; _this$ = ecx

; 851  : {

  00000	55		 push	 ebp
  00001	8d ac 24 a0 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-352]
  00008	81 ec 60 01 00
	00		 sub	 esp, 352		; 00000160H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 48	 sub	 esp, 72			; 00000048H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 5c 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 852  : 	CMappedFile dataMapFile;

  00039	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 853  : 	LPCVOID		data;
; 854  : 
; 855  : 	if (!dataMapFile.Create(m_stDataFileName.c_str(), &data, 0, 0))

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8d 45 c4	 lea	 eax, DWORD PTR _data$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  00056	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0005b	50		 push	 eax
  0005c	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  0005f	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  00064	85 c0		 test	 eax, eax
  00066	75 18		 jne	 SHORT $LN5@GetNames

; 856  : 		return false;

  00068	c6 45 f3 00	 mov	 BYTE PTR $T12[ebp], 0
  0006c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00070	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  00073	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00078	8a 45 f3	 mov	 al, BYTE PTR $T12[ebp]
  0007b	e9 fb 00 00 00	 jmp	 $LN1@GetNames
$LN5@GetNames:

; 857  : 
; 858  : 	CLZObject zObj;

  00080	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00083	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  00088	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 193  :       iterator begin() BOOST_NOEXCEPT { return iterator(table_.begin()); }

  0008c	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	05 80 03 00 00	 add	 eax, 896		; 00000380H
  00094	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  00097	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0009a	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0009e	74 22		 je	 SHORT $LN30@GetNames

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  000a0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  000ac	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000af	89 45 d4	 mov	 DWORD PTR $T6[ebp], eax

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  000b2	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  000b5	89 45 e4	 mov	 DWORD PTR $T8[ebp], eax

; 2964 :           return static_cast<node_pointer>(n->next_);

  000b8	8b 45 d4	 mov	 eax, DWORD PTR $T6[ebp]
  000bb	8b 00		 mov	 eax, DWORD PTR [eax]
  000bd	89 45 e4	 mov	 DWORD PTR $T8[ebp], eax

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  000c0	eb 04		 jmp	 SHORT $LN28@GetNames
$LN30@GetNames:
  000c2	83 65 e4 00	 and	 DWORD PTR $T8[ebp], 0
$LN28@GetNames:

; 2371 :           : node_(static_cast<node_pointer>(x))

  000c6	8b 45 e4	 mov	 eax, DWORD PTR $T8[ebp]
  000c9	89 45 ec	 mov	 DWORD PTR _i$9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 860  : 	for (TDataPositionMap::iterator i = m_DataPositionMap.begin();

  000cc	eb 08		 jmp	 SHORT $LN4@GetNames
$LN2@GetNames:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2381 :           node_ = static_cast<node_pointer>(node_->next_);

  000ce	8b 45 ec	 mov	 eax, DWORD PTR _i$9[ebp]
  000d1	8b 00		 mov	 eax, DWORD PTR [eax]
  000d3	89 45 ec	 mov	 DWORD PTR _i$9[ebp], eax
$LN4@GetNames:

; 2368 :         iterator() BOOST_NOEXCEPT : node_() {}

  000d6	83 65 d0 00	 and	 DWORD PTR $T5[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 200  :       iterator end() BOOST_NOEXCEPT { return iterator(); }

  000da	8d 45 d0	 lea	 eax, DWORD PTR $T5[ebp]
  000dd	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2399 :           return node_ != x.node_;

  000e0	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR _i$9[ebp]
  000e6	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000e8	74 09		 je	 SHORT $LN53@GetNames
  000ea	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  000f1	eb 04		 jmp	 SHORT $LN54@GetNames
$LN53@GetNames:
  000f3	83 65 dc 00	 and	 DWORD PTR tv82[ebp], 0
$LN54@GetNames:
  000f7	8a 45 dc	 mov	 al, BYTE PTR tv82[ebp]
  000fa	88 45 f2	 mov	 BYTE PTR $T11[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 861  : 		i != m_DataPositionMap.end();

  000fd	0f b6 45 f2	 movzx	 eax, BYTE PTR $T11[ebp]
  00101	85 c0		 test	 eax, eax
  00103	74 57		 je	 SHORT $LN3@GetNames

; 862  : 		++i)
; 863  : 	{
; 864  : 		TEterPackIndex* index = i->second;

  00105	8b 45 ec	 mov	 eax, DWORD PTR _i$9[ebp]
  00108	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0010b	89 45 d8	 mov	 DWORD PTR _index$7[ebp], eax

; 865  : 		
; 866  : 		inlinePathCreate(index->filename);

  0010e	8b 45 d8	 mov	 eax, DWORD PTR _index$7[ebp]
  00111	83 c0 04	 add	 eax, 4
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 ?inlinePathCreate@@YAXPBD@Z ; inlinePathCreate
  0011a	59		 pop	 ecx

; 868  : 		retNames->push_back(index->filename);

  0011b	8b 45 d8	 mov	 eax, DWORD PTR _index$7[ebp]
  0011e	83 c0 04	 add	 eax, 4
  00121	50		 push	 eax
  00122	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR $T13[ebp]
  00128	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0012d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00131	8d 85 44 01 00
	00		 lea	 eax, DWORD PTR $T13[ebp]
  00137	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 721  :         emplace_back(_STD move(_Val));

  0013a	ff 75 c8	 push	 DWORD PTR $T3[ebp]
  0013d	8b 8d 68 01 00
	00		 mov	 ecx, DWORD PTR _retNames$[ebp]
  00143	e8 00 00 00 00	 call	 ??$emplace_back@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEX$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::emplace_back<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 868  : 		retNames->push_back(index->filename);

  00148	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0014c	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR $T13[ebp]
  00152	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 869  : 	}

  00157	e9 72 ff ff ff	 jmp	 $LN2@GetNames
$LN3@GetNames:

; 870  : 	return true;

  0015c	c6 45 f1 01	 mov	 BYTE PTR $T10[ebp], 1
  00160	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00164	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00167	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  0016c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00170	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  00173	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00178	8a 45 f1	 mov	 al, BYTE PTR $T10[ebp]
$LN1@GetNames:

; 871  : }

  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00185	59		 pop	 ecx
  00186	8b 8d 5c 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018c	33 cd		 xor	 ecx, ebp
  0018e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00193	81 c5 60 01 00
	00		 add	 ebp, 352		; 00000160H
  00199	c9		 leave
  0019a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$1:
  00008	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
__unwindfunclet$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z$2:
  00010	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR $T13[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001b	cc		 int	 3
  0001c	cc		 int	 3
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
__ehhandler$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z:
  00020	90		 npad	 1
  00021	90		 npad	 1
  00022	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00026	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00029	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  0002c	33 c8		 xor	 ecx, eax
  0002e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00033	8b 8a 68 01 00
	00		 mov	 ecx, DWORD PTR [edx+360]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetNames@CEterPack@@QAE_NPAV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@Z ENDP ; CEterPack::GetNames
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?DeleteUnreferencedData@CEterPack@@QAEKXZ
_TEXT	SEGMENT
$T2 = -64						; size = 4
$T3 = -60						; size = 4
_tmp$4 = -56						; size = 4
_x$ = -52						; size = 4
$T5 = -48						; size = 4
$T6 = -44						; size = 4
_x$ = -40						; size = 4
tv67 = -36						; size = 4
_dwCount$ = -32						; size = 4
_this$ = -28						; size = 4
_pIndex$7 = -24						; size = 4
_i$ = -20						; size = 4
$T8 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?DeleteUnreferencedData@CEterPack@@QAEKXZ PROC		; CEterPack::DeleteUnreferencedData, COMDAT
; _this$ = ecx

; 1339 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?DeleteUnreferencedData@CEterPack@@QAEKXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 193  :       iterator begin() BOOST_NOEXCEPT { return iterator(table_.begin()); }

  00028	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0002c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  00035	e8 00 00 00 00	 call	 ?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@234@XZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
  0003a	89 45 d8	 mov	 DWORD PTR _x$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2371 :           : node_(static_cast<node_pointer>(x))

  0003d	8b 45 d8	 mov	 eax, DWORD PTR _x$[ebp]
  00040	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 193  :       iterator begin() BOOST_NOEXCEPT { return iterator(table_.begin()); }

  00043	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1341 : 	DWORD dwCount = 0;

  00047	83 65 e0 00	 and	 DWORD PTR _dwCount$[ebp], 0
$LN2@DeleteUnre:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2368 :         iterator() BOOST_NOEXCEPT : node_() {}

  0004b	83 65 d4 00	 and	 DWORD PTR $T6[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 200  :       iterator end() BOOST_NOEXCEPT { return iterator(); }

  0004f	8d 45 d4	 lea	 eax, DWORD PTR $T6[ebp]
  00052	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2399 :           return node_ != x.node_;

  00055	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  00058	8b 4d ec	 mov	 ecx, DWORD PTR _i$[ebp]
  0005b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0005d	74 09		 je	 SHORT $LN32@DeleteUnre
  0005f	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00066	eb 04		 jmp	 SHORT $LN33@DeleteUnre
$LN32@DeleteUnre:
  00068	83 65 dc 00	 and	 DWORD PTR tv67[ebp], 0
$LN33@DeleteUnre:
  0006c	8a 45 dc	 mov	 al, BYTE PTR tv67[ebp]
  0006f	88 45 f3	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1343 : 	while (i != m_DataPositionMap.end())

  00072	0f b6 45 f3	 movzx	 eax, BYTE PTR $T8[ebp]
  00076	85 c0		 test	 eax, eax
  00078	74 6c		 je	 SHORT $LN3@DeleteUnre
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2387 :           iterator tmp(node_);

  0007a	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0007d	89 45 cc	 mov	 DWORD PTR _x$[ebp], eax

; 2371 :           : node_(static_cast<node_pointer>(x))

  00080	8b 45 cc	 mov	 eax, DWORD PTR _x$[ebp]
  00083	89 45 c8	 mov	 DWORD PTR _tmp$4[ebp], eax

; 2388 :           node_ = static_cast<node_pointer>(node_->next_);

  00086	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00089	8b 00		 mov	 eax, DWORD PTR [eax]
  0008b	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax

; 2389 :           return tmp;

  0008e	8b 45 c8	 mov	 eax, DWORD PTR _tmp$4[ebp]
  00091	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1345 : 		TEterPackIndex * pIndex = (i++)->second;

  00094	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00097	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0009a	89 45 e8	 mov	 DWORD PTR _pIndex$7[ebp], eax

; 1346 : 
; 1347 : 		if (0 == m_map_indexRefCount[pIndex->id])

  0009d	8b 45 e8	 mov	 eax, DWORD PTR _pIndex$7[ebp]
  000a0	8b 00		 mov	 eax, DWORD PTR [eax]
  000a2	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
  000a5	8d 45 c0	 lea	 eax, DWORD PTR $T2[ebp]
  000a8	50		 push	 eax
  000a9	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  000b2	e8 00 00 00 00	 call	 ??A?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAEAAKABK@Z ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
  000b7	83 38 00	 cmp	 DWORD PTR [eax], 0
  000ba	75 25		 jne	 SHORT $LN4@DeleteUnre

; 1348 : 		{
; 1349 : 			printf("Unref File %s\n", pIndex->filename);

  000bc	8b 45 e8	 mov	 eax, DWORD PTR _pIndex$7[ebp]
  000bf	83 c0 04	 add	 eax, 4
  000c2	50		 push	 eax
  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_0P@MDGHMGJK@Unref?5File?5?$CFs?6@
  000c8	e8 00 00 00 00	 call	 _printf
  000cd	59		 pop	 ecx
  000ce	59		 pop	 ecx

; 1350 : 			Delete(pIndex);

  000cf	ff 75 e8	 push	 DWORD PTR _pIndex$7[ebp]
  000d2	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z ; CEterPack::Delete

; 1351 : 			++dwCount;

  000da	8b 45 e0	 mov	 eax, DWORD PTR _dwCount$[ebp]
  000dd	40		 inc	 eax
  000de	89 45 e0	 mov	 DWORD PTR _dwCount$[ebp], eax
$LN4@DeleteUnre:

; 1352 : 		}
; 1353 : 	}

  000e1	e9 65 ff ff ff	 jmp	 $LN2@DeleteUnre
$LN3@DeleteUnre:

; 1354 : 
; 1355 : 	return dwCount;

  000e6	8b 45 e0	 mov	 eax, DWORD PTR _dwCount$[ebp]

; 1356 : }

  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ec	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f3	59		 pop	 ecx
  000f4	c9		 leave
  000f5	c3		 ret	 0
  000f6	cc		 int	 3
  000f7	cc		 int	 3
  000f8	cc		 int	 3
  000f9	cc		 int	 3
  000fa	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?DeleteUnreferencedData@CEterPack@@QAEKXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DeleteUnreferencedData@CEterPack@@QAEKXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DeleteUnreferencedData@CEterPack@@QAEKXZ ENDP		; CEterPack::DeleteUnreferencedData
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?DecryptIndexFile@CEterPack@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -14						; size = 1
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_file$ = 0						; size = 280
__$ArrayPad$ = 280					; size = 4
?DecryptIndexFile@CEterPack@@QAE_NXZ PROC		; CEterPack::DecryptIndexFile, COMDAT
; _this$ = ecx

; 305  : {

  00000	55		 push	 ebp
  00001	8d ac 24 e4 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-284]
  00008	81 ec 1c 01 00
	00		 sub	 esp, 284		; 0000011cH
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?DecryptIndexFile@CEterPack@@QAE_NXZ
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	51		 push	 ecx
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 85 18 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002b	50		 push	 eax
  0002c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00035	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 306  : 	if (!m_bEncrypted)

  00038	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	0f b6 80 54 01
	00 00		 movzx	 eax, BYTE PTR [eax+340]
  00042	85 c0		 test	 eax, eax
  00044	75 07		 jne	 SHORT $LN2@DecryptInd

; 307  : 		return true;

  00046	b0 01		 mov	 al, 1
  00048	e9 ad 00 00 00	 jmp	 $LN1@DecryptInd
$LN2@DecryptInd:

; 308  : 
; 309  : 	CFileBase file;

  0004d	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00050	e8 00 00 00 00	 call	 ??0CFileBase@@QAE@XZ	; CFileBase::CFileBase
  00055	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 310  : 	
; 311  : 	if (!file.Create(m_indexFileName, CFileBase::FILEMODE_WRITE))

  00059	6a 02		 push	 2
  0005b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00063	50		 push	 eax
  00064	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00067	e8 00 00 00 00	 call	 ?Create@CFileBase@@QAEHPBDW4EFileMode@1@@Z ; CFileBase::Create
  0006c	85 c0		 test	 eax, eax
  0006e	75 15		 jne	 SHORT $LN3@DecryptInd

; 312  : 		return false;

  00070	c6 45 f3 00	 mov	 BYTE PTR $T3[ebp], 0
  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0007b	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  00080	8a 45 f3	 mov	 al, BYTE PTR $T3[ebp]
  00083	eb 75		 jmp	 SHORT $LN1@DecryptInd
$LN3@DecryptInd:

; 313  : 
; 314  : 	file.Write(&eterpack::c_IndexCC, sizeof(DWORD));

  00085	6a 04		 push	 4
  00087	68 00 00 00 00	 push	 OFFSET ?c_IndexCC@eterpack@@3KB
  0008c	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0008f	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write

; 315  : 	file.Write(&eterpack::c_Version, sizeof(DWORD));

  00094	6a 04		 push	 4
  00096	68 00 00 00 00	 push	 OFFSET ?c_Version@eterpack@@3KB
  0009b	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0009e	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write

; 316  : 	file.Write(&m_indexCount, sizeof(long));

  000a3	6a 04		 push	 4
  000a5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	05 50 01 00 00	 add	 eax, 336		; 00000150H
  000ad	50		 push	 eax
  000ae	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000b1	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write

; 317  : 	file.Write(m_indexData, sizeof(TEterPackIndex) * m_indexCount);

  000b6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	69 80 50 01 00
	00 c0 00 00 00	 imul	 eax, DWORD PTR [eax+336], 192
  000c3	50		 push	 eax
  000c4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	ff b0 5c 03 00
	00		 push	 DWORD PTR [eax+860]
  000cd	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000d0	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write

; 318  : 
; 319  : 	file.Close();

  000d5	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000d8	e8 00 00 00 00	 call	 ?Close@CFileBase@@QAEXXZ ; CFileBase::Close

; 320  : 
; 321  : 	m_bEncrypted = false;

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	c6 80 54 01 00
	00 00		 mov	 BYTE PTR [eax+340], 0

; 322  : 	return true;

  000e7	c6 45 f2 01	 mov	 BYTE PTR $T2[ebp], 1
  000eb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000ef	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000f2	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  000f7	8a 45 f2	 mov	 al, BYTE PTR $T2[ebp]
$LN1@DecryptInd:

; 323  : }

  000fa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000fd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00104	59		 pop	 ecx
  00105	8b 8d 18 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010b	33 cd		 xor	 ecx, ebp
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	81 c5 1c 01 00
	00		 add	 ebp, 284		; 0000011cH
  00118	c9		 leave
  00119	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?DecryptIndexFile@CEterPack@@QAE_NXZ$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?DecryptIndexFile@CEterPack@@QAE_NXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 24 01 00
	00		 mov	 ecx, DWORD PTR [edx+292]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?DecryptIndexFile@CEterPack@@QAE_NXZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?DecryptIndexFile@CEterPack@@QAE_NXZ ENDP		; CEterPack::DecryptIndexFile
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?EncryptIndexFile@CEterPack@@QAE_NXZ
_TEXT	SEGMENT
_zObj$ = -84						; size = 20
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
_pvData$ = -40						; size = 4
$T8 = -36						; size = 4
_fp$ = -32						; size = 4
$T9 = -25						; size = 1
$T10 = -24						; size = 1
$T11 = -23						; size = 1
$T12 = -22						; size = 1
$T13 = -21						; size = 1
_this$ = -20						; size = 4
_pbData$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_file$ = 0						; size = 324
__$ArrayPad$ = 324					; size = 4
?EncryptIndexFile@CEterPack@@QAE_NXZ PROC		; CEterPack::EncryptIndexFile, COMDAT
; _this$ = ecx

; 342  : {

  00000	55		 push	 ebp
  00001	8d ac 24 b8 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-328]
  00008	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?EncryptIndexFile@CEterPack@@QAE_NXZ
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 48	 sub	 esp, 72			; 00000048H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 44 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 343  : 	CMappedFile file;

  00039	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 344  : 	LPCVOID pvData;
; 345  : 
; 346  : 	if (NULL == file.Create(m_indexFileName, &pvData, 0, 0))

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8d 45 d8	 lea	 eax, DWORD PTR _pvData$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00050	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00055	50		 push	 eax
  00056	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00059	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  0005e	85 c0		 test	 eax, eax
  00060	75 2d		 jne	 SHORT $LN4@EncryptInd

; 347  : 	{
; 348  : 		TraceError("EncryptIndex: Cannot open pack index file! %s", m_dbName);

  00062	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00065	05 55 01 00 00	 add	 eax, 341		; 00000155H
  0006a	50		 push	 eax
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@LCLPMBOA@EncryptIndex?3?5Cannot?5open?5pack?5@
  00070	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00075	59		 pop	 ecx
  00076	59		 pop	 ecx

; 349  : 		return false;

  00077	c6 45 eb 00	 mov	 BYTE PTR $T13[ebp], 0
  0007b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007f	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00082	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00087	8a 45 eb	 mov	 al, BYTE PTR $T13[ebp]
  0008a	e9 03 02 00 00	 jmp	 $LN1@EncryptInd
$LN4@EncryptInd:

; 350  : 	}
; 351  : 
; 352  : 	BYTE * pbData = new BYTE[file.Size()];

  0008f	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00092	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  0009d	59		 pop	 ecx
  0009e	89 45 dc	 mov	 DWORD PTR $T8[ebp], eax
  000a1	8b 45 dc	 mov	 eax, DWORD PTR $T8[ebp]
  000a4	89 45 f0	 mov	 DWORD PTR _pbData$[ebp], eax

; 353  : 	memcpy(pbData, pvData, file.Size());

  000a7	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000aa	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000af	50		 push	 eax
  000b0	ff 75 d8	 push	 DWORD PTR _pvData$[ebp]
  000b3	ff 75 f0	 push	 DWORD PTR _pbData$[ebp]
  000b6	e8 00 00 00 00	 call	 _memcpy
  000bb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 354  : 
; 355  : 	CLZObject zObj;

  000be	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  000c1	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  000c6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  000ca	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  000cf	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 357  : 	if (!CLZO::Instance().CompressEncryptedMemory(zObj, pbData, file.Size(), s_adwEterPackKey))

  000d2	68 00 00 00 00	 push	 OFFSET ?s_adwEterPackKey@@3PAKA
  000d7	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  000da	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000df	50		 push	 eax
  000e0	ff 75 f0	 push	 DWORD PTR _pbData$[ebp]
  000e3	8d 45 ac	 lea	 eax, DWORD PTR _zObj$[ebp]
  000e6	50		 push	 eax
  000e7	8b 4d d4	 mov	 ecx, DWORD PTR $T7[ebp]
  000ea	e8 00 00 00 00	 call	 ?CompressEncryptedMemory@CLZO@@QAE_NAAVCLZObject@@PBXIPAK@Z ; CLZO::CompressEncryptedMemory
  000ef	0f b6 c0	 movzx	 eax, al
  000f2	85 c0		 test	 eax, eax
  000f4	75 52		 jne	 SHORT $LN5@EncryptInd

; 358  : 	{
; 359  : 		TraceError("EncryptIndex: Cannot encrypt! %s", m_dbName);

  000f6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	05 55 01 00 00	 add	 eax, 341		; 00000155H
  000fe	50		 push	 eax
  000ff	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@BKLKOCID@EncryptIndex?3?5Cannot?5encrypt?$CB?5?$CF@
  00104	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00109	59		 pop	 ecx
  0010a	59		 pop	 ecx

; 360  : 		SAFE_DELETE_ARRAY(pbData);

  0010b	83 7d f0 00	 cmp	 DWORD PTR _pbData$[ebp], 0
  0010f	74 13		 je	 SHORT $LN6@EncryptInd
  00111	8b 45 f0	 mov	 eax, DWORD PTR _pbData$[ebp]
  00114	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax
  00117	ff 75 d0	 push	 DWORD PTR $T6[ebp]
  0011a	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0011f	59		 pop	 ecx
  00120	83 65 f0 00	 and	 DWORD PTR _pbData$[ebp], 0
$LN6@EncryptInd:

; 361  : 		return false;

  00124	c6 45 ea 00	 mov	 BYTE PTR $T12[ebp], 0
  00128	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0012c	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0012f	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00134	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00138	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0013b	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00140	8a 45 ea	 mov	 al, BYTE PTR $T12[ebp]
  00143	e9 4a 01 00 00	 jmp	 $LN1@EncryptInd
$LN5@EncryptInd:

; 362  : 	}
; 363  : 
; 364  : 	file.Destroy();

  00148	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0014b	e8 00 00 00 00	 call	 ?Destroy@CMappedFile@@QAEXXZ ; CMappedFile::Destroy
$LN2@EncryptInd:

; 365  : 
; 366  : 	while (!DeleteFile(m_indexFileName));

  00150	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00153	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00158	50		 push	 eax
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
  0015f	85 c0		 test	 eax, eax
  00161	75 02		 jne	 SHORT $LN3@EncryptInd
  00163	eb eb		 jmp	 SHORT $LN2@EncryptInd
$LN3@EncryptInd:

; 367  : 
; 368  : 	FILE * fp;
; 369  : 
; 370  : 	fp = fopen(m_indexFileName, "wb");

  00165	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0016a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00172	50		 push	 eax
  00173	e8 00 00 00 00	 call	 _fopen
  00178	59		 pop	 ecx
  00179	59		 pop	 ecx
  0017a	89 45 e0	 mov	 DWORD PTR _fp$[ebp], eax

; 371  : 
; 372  : 	if (!fp)

  0017d	83 7d e0 00	 cmp	 DWORD PTR _fp$[ebp], 0
  00181	75 52		 jne	 SHORT $LN7@EncryptInd

; 373  : 	{
; 374  : 		TraceError("EncryptIndex: Cannot open file for writing! %s", m_dbName);

  00183	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00186	05 55 01 00 00	 add	 eax, 341		; 00000155H
  0018b	50		 push	 eax
  0018c	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@NIHCOGLD@EncryptIndex?3?5Cannot?5open?5file?5@
  00191	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00196	59		 pop	 ecx
  00197	59		 pop	 ecx

; 375  : 		SAFE_DELETE_ARRAY(pbData);

  00198	83 7d f0 00	 cmp	 DWORD PTR _pbData$[ebp], 0
  0019c	74 13		 je	 SHORT $LN8@EncryptInd
  0019e	8b 45 f0	 mov	 eax, DWORD PTR _pbData$[ebp]
  001a1	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
  001a4	ff 75 cc	 push	 DWORD PTR $T5[ebp]
  001a7	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  001ac	59		 pop	 ecx
  001ad	83 65 f0 00	 and	 DWORD PTR _pbData$[ebp], 0
$LN8@EncryptInd:

; 376  : 		return false;

  001b1	c6 45 e9 00	 mov	 BYTE PTR $T11[ebp], 0
  001b5	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001b9	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  001bc	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001c5	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  001c8	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  001cd	8a 45 e9	 mov	 al, BYTE PTR $T11[ebp]
  001d0	e9 bd 00 00 00	 jmp	 $LN1@EncryptInd
$LN7@EncryptInd:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  001d5	8b 45 ac	 mov	 eax, DWORD PTR _zObj$[ebp]
  001d8	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 379  : 	if (1 != fwrite(zObj.GetBuffer(), zObj.GetSize(), 1, fp))

  001db	ff 75 e0	 push	 DWORD PTR _fp$[ebp]
  001de	6a 01		 push	 1
  001e0	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  001e3	e8 00 00 00 00	 call	 ?GetSize@CLZObject@@QAEKXZ ; CLZObject::GetSize
  001e8	50		 push	 eax
  001e9	ff 75 c8	 push	 DWORD PTR $T4[ebp]
  001ec	e8 00 00 00 00	 call	 _fwrite
  001f1	83 c4 10	 add	 esp, 16			; 00000010H
  001f4	83 f8 01	 cmp	 eax, 1
  001f7	74 58		 je	 SHORT $LN9@EncryptInd

; 380  : 	{
; 381  : 		TraceError("Encryptindex: Cannot write to file! %s", m_indexFileName);

  001f9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001fc	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00201	50		 push	 eax
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@FFDEAKBO@Encryptindex?3?5Cannot?5write?5to?5f@
  00207	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0020c	59		 pop	 ecx
  0020d	59		 pop	 ecx

; 382  : 		SAFE_DELETE_ARRAY(pbData);

  0020e	83 7d f0 00	 cmp	 DWORD PTR _pbData$[ebp], 0
  00212	74 13		 je	 SHORT $LN10@EncryptInd
  00214	8b 45 f0	 mov	 eax, DWORD PTR _pbData$[ebp]
  00217	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  0021a	ff 75 c4	 push	 DWORD PTR $T3[ebp]
  0021d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00222	59		 pop	 ecx
  00223	83 65 f0 00	 and	 DWORD PTR _pbData$[ebp], 0
$LN10@EncryptInd:

; 383  : 		fclose(fp);

  00227	ff 75 e0	 push	 DWORD PTR _fp$[ebp]
  0022a	e8 00 00 00 00	 call	 _fclose
  0022f	59		 pop	 ecx

; 384  : 		return false;

  00230	c6 45 e8 00	 mov	 BYTE PTR $T10[ebp], 0
  00234	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00238	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0023b	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00240	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00244	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00247	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0024c	8a 45 e8	 mov	 al, BYTE PTR $T10[ebp]
  0024f	eb 41		 jmp	 SHORT $LN1@EncryptInd
$LN9@EncryptInd:

; 385  : 	}
; 386  : 	
; 387  : 	fclose(fp);

  00251	ff 75 e0	 push	 DWORD PTR _fp$[ebp]
  00254	e8 00 00 00 00	 call	 _fclose
  00259	59		 pop	 ecx

; 388  : 
; 389  : 	m_bEncrypted = true;

  0025a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0025d	c6 80 54 01 00
	00 01		 mov	 BYTE PTR [eax+340], 1

; 390  : 	delete [] pbData;

  00264	8b 45 f0	 mov	 eax, DWORD PTR _pbData$[ebp]
  00267	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
  0026a	ff 75 c0	 push	 DWORD PTR $T2[ebp]
  0026d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00272	59		 pop	 ecx

; 391  : 	return true;

  00273	c6 45 e7 01	 mov	 BYTE PTR $T9[ebp], 1
  00277	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0027b	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0027e	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00283	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00287	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0028a	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0028f	8a 45 e7	 mov	 al, BYTE PTR $T9[ebp]
$LN1@EncryptInd:

; 392  : }

  00292	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00295	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0029c	59		 pop	 ecx
  0029d	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002a3	33 cd		 xor	 ecx, ebp
  002a5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002aa	81 c5 48 01 00
	00		 add	 ebp, 328		; 00000148H
  002b0	c9		 leave
  002b1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?EncryptIndexFile@CEterPack@@QAE_NXZ$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?EncryptIndexFile@CEterPack@@QAE_NXZ$1:
  00008	8d 4d ac	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?EncryptIndexFile@CEterPack@@QAE_NXZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?EncryptIndexFile@CEterPack@@QAE_NXZ
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?EncryptIndexFile@CEterPack@@QAE_NXZ ENDP		; CEterPack::EncryptIndexFile
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetIndexMap@CEterPack@@QAEAAV?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetIndexMap@CEterPack@@QAEAAV?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@XZ PROC ; CEterPack::GetIndexMap, COMDAT
; _this$ = ecx

; 1334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1335 : 	return m_DataPositionMap;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 80 03 00 00	 add	 eax, 896		; 00000380H

; 1336 : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetIndexMap@CEterPack@@QAEAAV?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@XZ ENDP ; CEterPack::GetIndexMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?IsExist@CEterPack@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -1						; size = 1
_filename$ = 8						; size = 4
?IsExist@CEterPack@@QAE_NPBD@Z PROC			; CEterPack::IsExist, COMDAT
; _this$ = ecx

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1248 : 	return FindIndex(filename) ? true : false;

  00008	ff 75 08	 push	 DWORD PTR _filename$[ebp]
  0000b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z ; CEterPack::FindIndex
  00013	85 c0		 test	 eax, eax
  00015	74 06		 je	 SHORT $LN3@IsExist
  00017	c6 45 ff 01	 mov	 BYTE PTR tv68[ebp], 1
  0001b	eb 04		 jmp	 SHORT $LN4@IsExist
$LN3@IsExist:
  0001d	c6 45 ff 00	 mov	 BYTE PTR tv68[ebp], 0
$LN4@IsExist:
  00021	8a 45 ff	 mov	 al, BYTE PTR tv68[ebp]

; 1249 : }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?IsExist@CEterPack@@QAE_NPBD@Z ENDP			; CEterPack::IsExist
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetFragmentSize@CEterPack@@QAEJXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetFragmentSize@CEterPack@@QAEJXZ PROC			; CEterPack::GetFragmentSize, COMDAT
; _this$ = ecx

; 1101 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1102 : 	return m_FragmentSize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [eax+864]

; 1103 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetFragmentSize@CEterPack@@QAEJXZ ENDP			; CEterPack::GetFragmentSize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Extract@CEterPack@@QAE_NXZ
_TEXT	SEGMENT
$T2 = -152						; size = 4
$T3 = -148						; size = 4
$T4 = -144						; size = 4
$T5 = -140						; size = 4
tv301 = -136						; size = 4
tv78 = -132						; size = 4
tv296 = -128						; size = 4
tv129 = -124						; size = 4
$T6 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
tv251 = -88						; size = 4
_iSDBSize$14 = -84					; size = 4
_pSDBData$15 = -80					; size = 4
tv228 = -76						; size = 4
tv82 = -72						; size = 4
$T16 = -68						; size = 4
_this$ = -64						; size = 4
_zObj$ = -60						; size = 20
_i$17 = -40						; size = 4
_data$ = -36						; size = 4
_this$ = -32						; size = 4
$T18 = -25						; size = 1
$T19 = -24						; size = 1
$T20 = -23						; size = 1
$T21 = -22						; size = 1
$T22 = -21						; size = 1
$T23 = -20						; size = 1
$T24 = -19						; size = 1
$T25 = -18						; size = 1
$T26 = -17						; size = 1
_index$27 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dataMapFile$ = 0					; size = 324
_writeFile$28 = 324					; size = 280
$T29 = 604						; size = 24
$T30 = 628						; size = 24
__$ArrayPad$ = 652					; size = 4
?Extract@CEterPack@@QAE_NXZ PROC			; CEterPack::Extract, COMDAT
; _this$ = ecx

; 763  : {

  00000	55		 push	 ebp
  00001	8d ac 24 70 fd
	ff ff		 lea	 ebp, DWORD PTR [esp-656]
  00008	81 ec 90 02 00
	00		 sub	 esp, 656		; 00000290H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?Extract@CEterPack@@QAE_NXZ
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	89 85 8c 02 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 764  : 	CMappedFile dataMapFile;

  0003c	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  0003f	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  00044	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 765  : 	LPCVOID		data;
; 766  : 
; 767  : 	if (!dataMapFile.Create(m_stDataFileName.c_str(), &data, 0, 0))

  00048	6a 00		 push	 0
  0004a	6a 00		 push	 0
  0004c	8d 45 dc	 lea	 eax, DWORD PTR _data$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  00059	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0005e	50		 push	 eax
  0005f	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  00062	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  00067	85 c0		 test	 eax, eax
  00069	75 18		 jne	 SHORT $LN5@Extract

; 768  : 		return false;

  0006b	c6 45 e7 00	 mov	 BYTE PTR $T18[ebp], 0
  0006f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00073	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  00076	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0007b	8a 45 e7	 mov	 al, BYTE PTR $T18[ebp]
  0007e	e9 f7 04 00 00	 jmp	 $LN1@Extract
$LN5@Extract:

; 769  : 
; 770  : 	CLZObject zObj;

  00083	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00086	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  0008b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 193  :       iterator begin() BOOST_NOEXCEPT { return iterator(table_.begin()); }

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00092	05 80 03 00 00	 add	 eax, 896		; 00000380H
  00097	89 45 c0	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  0009a	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000a1	74 2b		 je	 SHORT $LN52@Extract

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  000a3	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000a9	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  000af	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b2	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  000b8	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  000be	89 45 bc	 mov	 DWORD PTR $T16[ebp], eax

; 2964 :           return static_cast<node_pointer>(n->next_);

  000c1	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  000c7	8b 00		 mov	 eax, DWORD PTR [eax]
  000c9	89 45 bc	 mov	 DWORD PTR $T16[ebp], eax

; 3041 :           return size_ ? next_node(get_previous_start()) : node_pointer();

  000cc	eb 04		 jmp	 SHORT $LN50@Extract
$LN52@Extract:
  000ce	83 65 bc 00	 and	 DWORD PTR $T16[ebp], 0
$LN50@Extract:

; 2371 :           : node_(static_cast<node_pointer>(x))

  000d2	8b 45 bc	 mov	 eax, DWORD PTR $T16[ebp]
  000d5	89 45 d8	 mov	 DWORD PTR _i$17[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 772  : 	for (TDataPositionMap::iterator i = m_DataPositionMap.begin();

  000d8	eb 08		 jmp	 SHORT $LN4@Extract
$LN2@Extract:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2381 :           node_ = static_cast<node_pointer>(node_->next_);

  000da	8b 45 d8	 mov	 eax, DWORD PTR _i$17[ebp]
  000dd	8b 00		 mov	 eax, DWORD PTR [eax]
  000df	89 45 d8	 mov	 DWORD PTR _i$17[ebp], eax
$LN4@Extract:

; 2368 :         iterator() BOOST_NOEXCEPT : node_() {}

  000e2	83 65 a4 00	 and	 DWORD PTR $T13[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 200  :       iterator end() BOOST_NOEXCEPT { return iterator(); }

  000e6	8d 45 a4	 lea	 eax, DWORD PTR $T13[ebp]
  000e9	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2399 :           return node_ != x.node_;

  000ec	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  000ef	8b 4d d8	 mov	 ecx, DWORD PTR _i$17[ebp]
  000f2	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000f4	74 09		 je	 SHORT $LN75@Extract
  000f6	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  000fd	eb 04		 jmp	 SHORT $LN76@Extract
$LN75@Extract:
  000ff	83 65 b8 00	 and	 DWORD PTR tv82[ebp], 0
$LN76@Extract:
  00103	8a 45 b8	 mov	 al, BYTE PTR tv82[ebp]
  00106	88 45 ef	 mov	 BYTE PTR $T26[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 773  : 		i != m_DataPositionMap.end();

  00109	0f b6 45 ef	 movzx	 eax, BYTE PTR $T26[ebp]
  0010d	85 c0		 test	 eax, eax
  0010f	0f 84 46 04 00
	00		 je	 $LN3@Extract

; 774  : 		++i)
; 775  : 	{
; 776  : 		TEterPackIndex* index = i->second;

  00115	8b 45 d8	 mov	 eax, DWORD PTR _i$17[ebp]
  00118	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0011b	89 45 f0	 mov	 DWORD PTR _index$27[ebp], eax

; 777  : 		CFileBase writeFile;

  0011e	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  00124	e8 00 00 00 00	 call	 ??0CFileBase@@QAE@XZ	; CFileBase::CFileBase
  00129	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 778  : 		
; 779  : 		inlinePathCreate(index->filename);

  0012d	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00130	83 c0 04	 add	 eax, 4
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ?inlinePathCreate@@YAXPBD@Z ; inlinePathCreate
  00139	59		 pop	 ecx

; 780  : 		printf("%s\n", index->filename);

  0013a	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  0013d	83 c0 04	 add	 eax, 4
  00140	50		 push	 eax
  00141	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6@
  00146	e8 00 00 00 00	 call	 _printf
  0014b	59		 pop	 ecx
  0014c	59		 pop	 ecx

; 781  : 		
; 782  : 		writeFile.Create(index->filename, CFileBase::FILEMODE_WRITE);

  0014d	6a 02		 push	 2
  0014f	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00152	83 c0 04	 add	 eax, 4
  00155	50		 push	 eax
  00156	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  0015c	e8 00 00 00 00	 call	 ?Create@CFileBase@@QAEHPBDW4EFileMode@1@@Z ; CFileBase::Create

; 783  : 
; 784  : 		if (COMPRESSED_TYPE_COMPRESS == index->compressed_type)

  00161	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00164	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  0016b	83 f8 01	 cmp	 eax, 1
  0016e	0f 85 92 00 00
	00		 jne	 $LN6@Extract
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00174	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  00179	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 786  : 			if (!CLZO::Instance().Decompress(zObj, (const BYTE *) data + index->data_position))

  0017c	6a 00		 push	 0
  0017e	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00181	8b 4d dc	 mov	 ecx, DWORD PTR _data$[ebp]
  00184	03 88 b8 00 00
	00		 add	 ecx, DWORD PTR [eax+184]
  0018a	51		 push	 ecx
  0018b	8d 45 c4	 lea	 eax, DWORD PTR _zObj$[ebp]
  0018e	50		 push	 eax
  0018f	8b 4d 9c	 mov	 ecx, DWORD PTR $T11[ebp]
  00192	e8 00 00 00 00	 call	 ?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z ; CLZO::Decompress
  00197	0f b6 c0	 movzx	 eax, al
  0019a	85 c0		 test	 eax, eax
  0019c	75 3e		 jne	 SHORT $LN8@Extract

; 787  : 			{
; 788  : 				printf("cannot decompress");

  0019e	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OILLCEPM@cannot?5decompress@
  001a3	e8 00 00 00 00	 call	 _printf
  001a8	59		 pop	 ecx

; 789  : 				return false;

  001a9	c6 45 ee 00	 mov	 BYTE PTR $T25[ebp], 0
  001ad	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001b1	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  001b7	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  001bc	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001c0	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  001c3	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  001c8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001cc	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  001cf	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  001d4	8a 45 ee	 mov	 al, BYTE PTR $T25[ebp]
  001d7	e9 9e 03 00 00	 jmp	 $LN1@Extract
$LN8@Extract:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  001dc	8b 45 c4	 mov	 eax, DWORD PTR _zObj$[ebp]
  001df	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 792  : 			writeFile.Write(zObj.GetBuffer(), zObj.GetSize());

  001e2	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  001e5	e8 00 00 00 00	 call	 ?GetSize@CLZObject@@QAEKXZ ; CLZObject::GetSize
  001ea	50		 push	 eax
  001eb	ff 75 98	 push	 DWORD PTR $T10[ebp]
  001ee	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  001f4	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write

; 793  : 			zObj.Clear();

  001f9	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  001fc	e8 00 00 00 00	 call	 ?Clear@CLZObject@@QAEXXZ ; CLZObject::Clear

; 794  : 		}

  00201	e9 36 03 00 00	 jmp	 $LN7@Extract
$LN6@Extract:

; 795  : 		else if (COMPRESSED_TYPE_SECURITY == index->compressed_type)

  00206	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00209	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00210	83 f8 02	 cmp	 eax, 2
  00213	0f 85 95 00 00
	00		 jne	 $LN9@Extract
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00219	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  0021e	89 45 94	 mov	 DWORD PTR $T9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 797  : 			if (!CLZO::Instance().Decompress(zObj, (const BYTE *) data + index->data_position, s_adwEterPackSecurityKey))

  00221	68 00 00 00 00	 push	 OFFSET ?s_adwEterPackSecurityKey@@3PAKA
  00226	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00229	8b 4d dc	 mov	 ecx, DWORD PTR _data$[ebp]
  0022c	03 88 b8 00 00
	00		 add	 ecx, DWORD PTR [eax+184]
  00232	51		 push	 ecx
  00233	8d 45 c4	 lea	 eax, DWORD PTR _zObj$[ebp]
  00236	50		 push	 eax
  00237	8b 4d 94	 mov	 ecx, DWORD PTR $T9[ebp]
  0023a	e8 00 00 00 00	 call	 ?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z ; CLZO::Decompress
  0023f	0f b6 c0	 movzx	 eax, al
  00242	85 c0		 test	 eax, eax
  00244	75 3e		 jne	 SHORT $LN11@Extract

; 798  : 			{
; 799  : 				printf("cannot decompress");

  00246	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OILLCEPM@cannot?5decompress@
  0024b	e8 00 00 00 00	 call	 _printf
  00250	59		 pop	 ecx

; 800  : 				return false;

  00251	c6 45 ed 00	 mov	 BYTE PTR $T24[ebp], 0
  00255	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00259	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  0025f	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  00264	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00268	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0026b	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00270	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00274	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  00277	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0027c	8a 45 ed	 mov	 al, BYTE PTR $T24[ebp]
  0027f	e9 f6 02 00 00	 jmp	 $LN1@Extract
$LN11@Extract:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  00284	8b 45 c4	 mov	 eax, DWORD PTR _zObj$[ebp]
  00287	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 803  : 			writeFile.Write(zObj.GetBuffer(), zObj.GetSize());

  0028a	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0028d	e8 00 00 00 00	 call	 ?GetSize@CLZObject@@QAEKXZ ; CLZObject::GetSize
  00292	50		 push	 eax
  00293	ff 75 90	 push	 DWORD PTR $T8[ebp]
  00296	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  0029c	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write

; 804  : 			zObj.Clear();

  002a1	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  002a4	e8 00 00 00 00	 call	 ?Clear@CLZObject@@QAEXXZ ; CLZObject::Clear

; 805  : 		}

  002a9	e9 8e 02 00 00	 jmp	 $LN7@Extract
$LN9@Extract:

; 806  : 		else if (COMPRESSED_TYPE_PANAMA == index->compressed_type)

  002ae	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  002b1	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  002b8	83 f8 03	 cmp	 eax, 3
  002bb	75 53		 jne	 SHORT $LN12@Extract

; 807  : 		{
; 808  : 			__Decrypt_Panama(index->filename, (const BYTE *) data + index->data_position, index->data_size, zObj);

  002bd	8d 45 c4	 lea	 eax, DWORD PTR _zObj$[ebp]
  002c0	50		 push	 eax
  002c1	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  002c4	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  002ca	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  002cd	8b 4d dc	 mov	 ecx, DWORD PTR _data$[ebp]
  002d0	03 88 b8 00 00
	00		 add	 ecx, DWORD PTR [eax+184]
  002d6	51		 push	 ecx
  002d7	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  002da	83 c0 04	 add	 eax, 4
  002dd	50		 push	 eax
  002de	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  002e1	e8 00 00 00 00	 call	 ?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z ; CEterPack::__Decrypt_Panama
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 40   : 		DWORD			GetBufferSize() { return m_dwBufferSize; }

  002e6	8b 45 c8	 mov	 eax, DWORD PTR _zObj$[ebp+4]
  002e9	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  002ec	8b 45 c4	 mov	 eax, DWORD PTR _zObj$[ebp]
  002ef	89 45 88	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 809  : 			writeFile.Write(zObj.GetBuffer(), zObj.GetBufferSize());

  002f2	ff 75 8c	 push	 DWORD PTR $T7[ebp]
  002f5	ff 75 88	 push	 DWORD PTR $T6[ebp]
  002f8	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  002fe	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write

; 810  : 			zObj.Clear();

  00303	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00306	e8 00 00 00 00	 call	 ?Clear@CLZObject@@QAEXXZ ; CLZObject::Clear

; 811  : 		}

  0030b	e9 2c 02 00 00	 jmp	 $LN7@Extract
$LN12@Extract:

; 812  : 		else if (COMPRESSED_TYPE_HYBRIDCRYPT == index->compressed_type || COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB == index->compressed_type)

  00310	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00313	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  0031a	83 f8 04	 cmp	 eax, 4
  0031d	74 13		 je	 SHORT $LN16@Extract
  0031f	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00322	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00329	83 f8 05	 cmp	 eax, 5
  0032c	0f 85 db 01 00
	00		 jne	 $LN14@Extract
$LN16@Extract:

; 817  : 			if( !m_pCSHybridCryptPolicy->DecryptMemory(string(index->filename), (const BYTE *) data + index->data_position, index->data_size, zObj) )

  00332	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00335	83 c0 04	 add	 eax, 4
  00338	50		 push	 eax
  00339	8d 8d 74 02 00
	00		 lea	 ecx, DWORD PTR $T30[ebp]
  0033f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00344	89 45 84	 mov	 DWORD PTR tv129[ebp], eax
  00347	8b 45 84	 mov	 eax, DWORD PTR tv129[ebp]
  0034a	89 45 80	 mov	 DWORD PTR tv296[ebp], eax
  0034d	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00351	8d 45 c4	 lea	 eax, DWORD PTR _zObj$[ebp]
  00354	50		 push	 eax
  00355	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00358	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  0035e	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00361	8b 4d dc	 mov	 ecx, DWORD PTR _data$[ebp]
  00364	03 88 b8 00 00
	00		 add	 ecx, DWORD PTR [eax+184]
  0036a	51		 push	 ecx
  0036b	ff 75 80	 push	 DWORD PTR tv296[ebp]
  0036e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00371	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  00377	e8 00 00 00 00	 call	 ?DecryptMemory@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEHAAVCLZObject@@@Z ; EterPackPolicy_CSHybridCrypt::DecryptMemory
  0037c	0f b6 c0	 movzx	 eax, al
  0037f	85 c0		 test	 eax, eax
  00381	75 09		 jne	 SHORT $LN23@Extract
  00383	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR tv228[ebp], 1
  0038a	eb 04		 jmp	 SHORT $LN24@Extract
$LN23@Extract:
  0038c	83 65 b4 00	 and	 DWORD PTR tv228[ebp], 0
$LN24@Extract:
  00390	8a 45 b4	 mov	 al, BYTE PTR tv228[ebp]
  00393	88 45 ec	 mov	 BYTE PTR $T23[ebp], al
  00396	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0039a	8d 8d 74 02 00
	00		 lea	 ecx, DWORD PTR $T30[ebp]
  003a0	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 817  : 			if( !m_pCSHybridCryptPolicy->DecryptMemory(string(index->filename), (const BYTE *) data + index->data_position, index->data_size, zObj) )

  003a5	0f b6 45 ec	 movzx	 eax, BYTE PTR $T23[ebp]
  003a9	85 c0		 test	 eax, eax
  003ab	74 33		 je	 SHORT $LN17@Extract

; 818  : 				return false;

  003ad	c6 45 eb 00	 mov	 BYTE PTR $T22[ebp], 0
  003b1	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  003b5	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  003bb	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  003c0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  003c4	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  003c7	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  003cc	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  003d0	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  003d3	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  003d8	8a 45 eb	 mov	 al, BYTE PTR $T22[ebp]
  003db	e9 9a 01 00 00	 jmp	 $LN1@Extract
$LN17@Extract:

; 819  : 
; 820  : 			if( COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB == index->compressed_type)

  003e0	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  003e3	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  003ea	83 f8 05	 cmp	 eax, 5
  003ed	0f 85 e7 00 00
	00		 jne	 $LN18@Extract

; 821  : 			{
; 822  : 				dataMapFile.BindLZObjectWithBufferedSize(&zObj);

  003f3	8d 45 c4	 lea	 eax, DWORD PTR _zObj$[ebp]
  003f6	50		 push	 eax
  003f7	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  003fa	e8 00 00 00 00	 call	 ?BindLZObjectWithBufferedSize@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObjectWithBufferedSize

; 827  : 				if( !m_pCSHybridCryptPolicy->GetSupplementaryDataBlock(string(index->filename), pSDBData, iSDBSize) )

  003ff	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00402	83 c0 04	 add	 eax, 4
  00405	50		 push	 eax
  00406	8d 8d 5c 02 00
	00		 lea	 ecx, DWORD PTR $T29[ebp]
  0040c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00411	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv78[ebp], eax
  00417	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv78[ebp]
  0041d	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv301[ebp], eax
  00423	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00427	8d 45 ac	 lea	 eax, DWORD PTR _iSDBSize$14[ebp]
  0042a	50		 push	 eax
  0042b	8d 45 b0	 lea	 eax, DWORD PTR _pSDBData$15[ebp]
  0042e	50		 push	 eax
  0042f	ff b5 78 ff ff
	ff		 push	 DWORD PTR tv301[ebp]
  00435	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00438	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  0043e	e8 00 00 00 00	 call	 ?GetSupplementaryDataBlock@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAEAAH@Z ; EterPackPolicy_CSHybridCrypt::GetSupplementaryDataBlock
  00443	0f b6 c0	 movzx	 eax, al
  00446	85 c0		 test	 eax, eax
  00448	75 09		 jne	 SHORT $LN25@Extract
  0044a	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv251[ebp], 1
  00451	eb 04		 jmp	 SHORT $LN26@Extract
$LN25@Extract:
  00453	83 65 a8 00	 and	 DWORD PTR tv251[ebp], 0
$LN26@Extract:
  00457	8a 45 a8	 mov	 al, BYTE PTR tv251[ebp]
  0045a	88 45 ea	 mov	 BYTE PTR $T21[ebp], al
  0045d	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00461	8d 8d 5c 02 00
	00		 lea	 ecx, DWORD PTR $T29[ebp]
  00467	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 827  : 				if( !m_pCSHybridCryptPolicy->GetSupplementaryDataBlock(string(index->filename), pSDBData, iSDBSize) )

  0046c	0f b6 45 ea	 movzx	 eax, BYTE PTR $T21[ebp]
  00470	85 c0		 test	 eax, eax
  00472	74 33		 je	 SHORT $LN20@Extract

; 828  : 					return false;

  00474	c6 45 e9 00	 mov	 BYTE PTR $T20[ebp], 0
  00478	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0047c	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  00482	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  00487	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0048b	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0048e	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00493	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00497	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  0049a	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0049f	8a 45 e9	 mov	 al, BYTE PTR $T20[ebp]
  004a2	e9 d3 00 00 00	 jmp	 $LN1@Extract
$LN20@Extract:

; 829  : 
; 830  : 				dataMapFile.AppendDataBlock( pSDBData, iSDBSize );

  004a7	ff 75 ac	 push	 DWORD PTR _iSDBSize$14[ebp]
  004aa	ff 75 b0	 push	 DWORD PTR _pSDBData$15[ebp]
  004ad	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  004b0	e8 00 00 00 00	 call	 ?AppendDataBlock@CMappedFile@@QAEPAEPBXK@Z ; CMappedFile::AppendDataBlock

; 831  : 				writeFile.Write(dataMapFile.AppendDataBlock( pSDBData, iSDBSize ),dataMapFile.Size());

  004b5	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  004b8	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  004bd	50		 push	 eax
  004be	ff 75 ac	 push	 DWORD PTR _iSDBSize$14[ebp]
  004c1	ff 75 b0	 push	 DWORD PTR _pSDBData$15[ebp]
  004c4	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  004c7	e8 00 00 00 00	 call	 ?AppendDataBlock@CMappedFile@@QAEPAEPBXK@Z ; CMappedFile::AppendDataBlock
  004cc	50		 push	 eax
  004cd	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  004d3	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write

; 832  : 			}

  004d8	eb 29		 jmp	 SHORT $LN19@Extract
$LN18@Extract:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 40   : 		DWORD			GetBufferSize() { return m_dwBufferSize; }

  004da	8b 45 c8	 mov	 eax, DWORD PTR _zObj$[ebp+4]
  004dd	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  004e3	8b 45 c4	 mov	 eax, DWORD PTR _zObj$[ebp]
  004e6	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 835  : 				writeFile.Write(zObj.GetBuffer(), zObj.GetBufferSize());

  004ec	ff b5 74 ff ff
	ff		 push	 DWORD PTR $T5[ebp]
  004f2	ff b5 70 ff ff
	ff		 push	 DWORD PTR $T4[ebp]
  004f8	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  004fe	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write
$LN19@Extract:

; 836  : 			}
; 837  : 			zObj.Clear();

  00503	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00506	e8 00 00 00 00	 call	 ?Clear@CLZObject@@QAEXXZ ; CLZObject::Clear

; 838  : #ifdef __THEMIDA__
; 839  : 			VM_END
; 840  : #endif
; 841  : 		}

  0050b	eb 2f		 jmp	 SHORT $LN7@Extract
$LN14@Extract:

; 842  : 		else if (COMPRESSED_TYPE_NONE == index->compressed_type)

  0050d	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00510	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00517	85 c0		 test	 eax, eax
  00519	75 21		 jne	 SHORT $LN7@Extract

; 843  : 			writeFile.Write((const char *) data + index->data_position, index->data_size);

  0051b	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  0051e	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  00524	8b 45 f0	 mov	 eax, DWORD PTR _index$27[ebp]
  00527	8b 4d dc	 mov	 ecx, DWORD PTR _data$[ebp]
  0052a	03 88 b8 00 00
	00		 add	 ecx, DWORD PTR [eax+184]
  00530	51		 push	 ecx
  00531	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  00537	e8 00 00 00 00	 call	 ?Write@CFileBase@@UAEHPBXH@Z ; CFileBase::Write
$LN7@Extract:

; 844  : 		
; 845  : 		writeFile.Destroy();

  0053c	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  00542	e8 00 00 00 00	 call	 ?Destroy@CFileBase@@QAEXXZ ; CFileBase::Destroy

; 846  : 	}

  00547	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0054b	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  00551	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  00556	e9 7f fb ff ff	 jmp	 $LN2@Extract
$LN3@Extract:

; 847  : 	return true;

  0055b	c6 45 e8 01	 mov	 BYTE PTR $T19[ebp], 1
  0055f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00563	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00566	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  0056b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0056f	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  00572	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00577	8a 45 e8	 mov	 al, BYTE PTR $T19[ebp]
$LN1@Extract:

; 848  : }

  0057a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0057d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00584	59		 pop	 ecx
  00585	8b 8d 8c 02 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0058b	33 cd		 xor	 ecx, ebp
  0058d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00592	81 c5 90 02 00
	00		 add	 ebp, 656		; 00000290H
  00598	c9		 leave
  00599	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _dataMapFile$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$1:
  00008	8d 4d c4	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$2:
  00010	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR _writeFile$28[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$3:
  0001b	8d 8d 74 02 00
	00		 lea	 ecx, DWORD PTR $T30[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Extract@CEterPack@@QAE_NXZ$4:
  00026	8d 8d 5c 02 00
	00		 lea	 ecx, DWORD PTR $T29[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00031	cc		 int	 3
  00032	cc		 int	 3
  00033	cc		 int	 3
  00034	cc		 int	 3
  00035	cc		 int	 3
__ehhandler$?Extract@CEterPack@@QAE_NXZ:
  00036	90		 npad	 1
  00037	90		 npad	 1
  00038	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003f	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00045	33 c8		 xor	 ecx, eax
  00047	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004c	8b 8a 98 02 00
	00		 mov	 ecx, DWORD PTR [edx+664]
  00052	33 c8		 xor	 ecx, eax
  00054	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00059	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Extract@CEterPack@@QAE_NXZ
  0005e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Extract@CEterPack@@QAE_NXZ ENDP			; CEterPack::Extract
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Delete@CEterPack@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pIndex$ = -4						; size = 4
_filename$ = 8						; size = 4
?Delete@CEterPack@@QAE_NPBD@Z PROC			; CEterPack::Delete, COMDAT
; _this$ = ecx

; 753  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 	TEterPackIndex * pIndex = FindIndex(filename);

  00008	ff 75 08	 push	 DWORD PTR _filename$[ebp]
  0000b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z ; CEterPack::FindIndex
  00013	89 45 fc	 mov	 DWORD PTR _pIndex$[ebp], eax

; 755  : 
; 756  : 	if (!pIndex)

  00016	83 7d fc 00	 cmp	 DWORD PTR _pIndex$[ebp], 0
  0001a	75 04		 jne	 SHORT $LN2@Delete

; 757  : 		return false;

  0001c	32 c0		 xor	 al, al
  0001e	eb 0b		 jmp	 SHORT $LN1@Delete
$LN2@Delete:

; 758  : 
; 759  : 	return Delete(pIndex);

  00020	ff 75 fc	 push	 DWORD PTR _pIndex$[ebp]
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Delete@CEterPack@@AAE_NPAUSEterPackIndex@@@Z ; CEterPack::Delete
$LN1@Delete:

; 760  : }

  0002b	c9		 leave
  0002c	c2 04 00	 ret	 4
?Delete@CEterPack@@QAE_NPBD@Z ENDP			; CEterPack::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Put@CEterPack@@QAE_NPBDPBXJE@Z
_TEXT	SEGMENT
$T2 = -104						; size = 4
$T3 = -100						; size = 4
$T4 = -96						; size = 4
tv293 = -92						; size = 4
tv95 = -88						; size = 4
$T5 = -84						; size = 4
$T6 = -80						; size = 4
$T7 = -76						; size = 4
_this$ = -72						; size = 4
tv263 = -68						; size = 4
tv210 = -64						; size = 4
tv191 = -60						; size = 4
_zObj$ = -56						; size = 20
_data_crc$ = -36					; size = 4
$T8 = -29						; size = 1
$T9 = -28						; size = 1
$T10 = -27						; size = 1
$T11 = -26						; size = 1
$T12 = -25						; size = 1
$T13 = -24						; size = 1
$T14 = -23						; size = 1
$T15 = -22						; size = 1
$T16 = -21						; size = 1
_this$ = -20						; size = 4
_pIndex$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_fileData$ = 0						; size = 280
_fileIndex$ = 280					; size = 280
$T17 = 560						; size = 24
_encryptStr$ = 584					; size = 24
__$ArrayPad$ = 608					; size = 4
_filename$ = 620					; size = 4
_data$ = 624						; size = 4
_len$ = 628						; size = 4
_packType$ = 632					; size = 1
?Put@CEterPack@@QAE_NPBDPBXJE@Z PROC			; CEterPack::Put, COMDAT
; _this$ = ecx

; 938  : {

  00000	55		 push	 ebp
  00001	8d ac 24 9c fd
	ff ff		 lea	 ebp, DWORD PTR [esp-612]
  00008	81 ec 64 02 00
	00		 sub	 esp, 612		; 00000264H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?Put@CEterPack@@QAE_NPBDPBXJE@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 5c	 sub	 esp, 92			; 0000005cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 60 02 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 939  : 	if (m_bEncrypted)

  00039	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	0f b6 80 54 01
	00 00		 movzx	 eax, BYTE PTR [eax+340]
  00043	85 c0		 test	 eax, eax
  00045	74 23		 je	 SHORT $LN2@Put

; 940  : 	{
; 941  : 		TraceError("EterPack::Put : Cannot put to encrypted pack (filename: %s, DB: %s)", filename, m_dbName);

  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	05 55 01 00 00	 add	 eax, 341		; 00000155H
  0004f	50		 push	 eax
  00050	ff b5 6c 02 00
	00		 push	 DWORD PTR _filename$[ebp]
  00056	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@JIDJMBKL@EterPack?3?3Put?5?3?5Cannot?5put?5to?5e@
  0005b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 942  : 		return false;

  00063	32 c0		 xor	 al, al
  00065	e9 c7 05 00 00	 jmp	 $LN1@Put
$LN2@Put:

; 943  : 	}
; 944  : 
; 945  : 	CFileBase fileIndex;

  0006a	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  00070	e8 00 00 00 00	 call	 ??0CFileBase@@QAE@XZ	; CFileBase::CFileBase
  00075	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 946  : 
; 947  : 	if (!fileIndex.Create(m_indexFileName, CFileBase::FILEMODE_WRITE))

  00079	6a 02		 push	 2
  0007b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007e	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00083	50		 push	 eax
  00084	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  0008a	e8 00 00 00 00	 call	 ?Create@CFileBase@@QAEHPBDW4EFileMode@1@@Z ; CFileBase::Create
  0008f	85 c0		 test	 eax, eax
  00091	75 1b		 jne	 SHORT $LN3@Put

; 948  : 	{
; 949  : 		return false;

  00093	c6 45 eb 00	 mov	 BYTE PTR $T16[ebp], 0
  00097	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0009b	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  000a1	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  000a6	8a 45 eb	 mov	 al, BYTE PTR $T16[ebp]
  000a9	e9 83 05 00 00	 jmp	 $LN1@Put
$LN3@Put:

; 950  : 	}
; 951  : 
; 952  : 	CFileBase fileData;

  000ae	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  000b1	e8 00 00 00 00	 call	 ??0CFileBase@@QAE@XZ	; CFileBase::CFileBase
  000b6	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 953  : 
; 954  : 	if (!fileData.Create(m_stDataFileName.c_str(), CFileBase::FILEMODE_WRITE))

  000ba	6a 02		 push	 2
  000bc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  000c5	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000ca	50		 push	 eax
  000cb	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  000ce	e8 00 00 00 00	 call	 ?Create@CFileBase@@QAEHPBDW4EFileMode@1@@Z ; CFileBase::Create
  000d3	85 c0		 test	 eax, eax
  000d5	75 27		 jne	 SHORT $LN4@Put

; 955  : 	{
; 956  : 		return false;

  000d7	c6 45 ea 00	 mov	 BYTE PTR $T15[ebp], 0
  000db	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000df	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  000e2	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  000e7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000eb	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  000f1	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  000f6	8a 45 ea	 mov	 al, BYTE PTR $T15[ebp]
  000f9	e9 33 05 00 00	 jmp	 $LN1@Put
$LN4@Put:

; 957  : 	}
; 958  : 
; 959  : 	TEterPackIndex * pIndex;
; 960  : 	pIndex = FindIndex(filename);

  000fe	ff b5 6c 02 00
	00		 push	 DWORD PTR _filename$[ebp]
  00104	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00107	e8 00 00 00 00	 call	 ?FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z ; CEterPack::FindIndex
  0010c	89 45 f0	 mov	 DWORD PTR _pIndex$[ebp], eax

; 961  : 
; 962  : 	CLZObject zObj;

  0010f	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00112	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  00117	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0011b	8d 85 48 02 00
	00		 lea	 eax, DWORD PTR _encryptStr$[ebp]
  00121	89 45 b8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00124	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  0012c	8d 8d 48 02 00
	00		 lea	 ecx, DWORD PTR _encryptStr$[ebp]
  00132	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 963  : 	std::string encryptStr;

  00137	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 964  : 
; 965  : 	if (packType == COMPRESSED_TYPE_SECURITY || 

  0013b	0f b6 85 78 02
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  00142	83 f8 02	 cmp	 eax, 2
  00145	74 10		 je	 SHORT $LN7@Put
  00147	0f b6 85 78 02
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  0014e	83 f8 01	 cmp	 eax, 1
  00151	0f 85 01 01 00
	00		 jne	 $LN5@Put
$LN7@Put:

; 966  : 		packType == COMPRESSED_TYPE_COMPRESS)
; 967  : 	{
; 968  : 		if (packType == COMPRESSED_TYPE_SECURITY)

  00157	0f b6 85 78 02
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  0015e	83 f8 02	 cmp	 eax, 2
  00161	75 70		 jne	 SHORT $LN8@Put
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00163	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  00168	89 45 b4	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 970  : 			if (!CLZO::Instance().CompressEncryptedMemory(zObj, data, len, s_adwEterPackSecurityKey))

  0016b	68 00 00 00 00	 push	 OFFSET ?s_adwEterPackSecurityKey@@3PAKA
  00170	ff b5 74 02 00
	00		 push	 DWORD PTR _len$[ebp]
  00176	ff b5 70 02 00
	00		 push	 DWORD PTR _data$[ebp]
  0017c	8d 45 c8	 lea	 eax, DWORD PTR _zObj$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d b4	 mov	 ecx, DWORD PTR $T7[ebp]
  00183	e8 00 00 00 00	 call	 ?CompressEncryptedMemory@CLZO@@QAE_NAAVCLZObject@@PBXIPAK@Z ; CLZO::CompressEncryptedMemory
  00188	0f b6 c0	 movzx	 eax, al
  0018b	85 c0		 test	 eax, eax
  0018d	75 42		 jne	 SHORT $LN10@Put

; 972  : 				return false;

  0018f	c6 45 e9 00	 mov	 BYTE PTR $T14[ebp], 0
  00193	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00197	8d 8d 48 02 00
	00		 lea	 ecx, DWORD PTR _encryptStr$[ebp]
  0019d	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 972  : 				return false;

  001a2	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001a6	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  001a9	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  001ae	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001b2	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  001b5	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  001ba	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001be	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  001c4	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  001c9	8a 45 e9	 mov	 al, BYTE PTR $T14[ebp]
  001cc	e9 60 04 00 00	 jmp	 $LN1@Put
$LN10@Put:

; 973  : 			}
; 974  : 		}

  001d1	eb 69		 jmp	 SHORT $LN9@Put
$LN8@Put:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  001d3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  001d8	89 45 b0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 977  : 			if (!CLZO::Instance().CompressMemory(zObj, data, len))

  001db	ff b5 74 02 00
	00		 push	 DWORD PTR _len$[ebp]
  001e1	ff b5 70 02 00
	00		 push	 DWORD PTR _data$[ebp]
  001e7	8d 45 c8	 lea	 eax, DWORD PTR _zObj$[ebp]
  001ea	50		 push	 eax
  001eb	8b 4d b0	 mov	 ecx, DWORD PTR $T6[ebp]
  001ee	e8 00 00 00 00	 call	 ?CompressMemory@CLZO@@QAE_NAAVCLZObject@@PBXI@Z ; CLZO::CompressMemory
  001f3	0f b6 c0	 movzx	 eax, al
  001f6	85 c0		 test	 eax, eax
  001f8	75 42		 jne	 SHORT $LN9@Put

; 979  : 				return false;

  001fa	c6 45 e8 00	 mov	 BYTE PTR $T13[ebp], 0
  001fe	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00202	8d 8d 48 02 00
	00		 lea	 ecx, DWORD PTR _encryptStr$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 979  : 				return false;

  0020d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00211	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00214	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00219	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0021d	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  00220	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  00225	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00229	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  0022f	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  00234	8a 45 e8	 mov	 al, BYTE PTR $T13[ebp]
  00237	e9 f5 03 00 00	 jmp	 $LN1@Put
$LN9@Put:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  0023c	8b 45 c8	 mov	 eax, DWORD PTR _zObj$[ebp]
  0023f	89 85 70 02 00
	00		 mov	 DWORD PTR _data$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 984  : 		len = zObj.GetSize();

  00245	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00248	e8 00 00 00 00	 call	 ?GetSize@CLZObject@@QAEKXZ ; CLZObject::GetSize
  0024d	89 85 74 02 00
	00		 mov	 DWORD PTR _len$[ebp], eax

; 985  : 	}

  00253	e9 7a 01 00 00	 jmp	 $LN6@Put
$LN5@Put:

; 986  : 	else if (packType == COMPRESSED_TYPE_PANAMA)

  00258	0f b6 85 78 02
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  0025f	83 f8 03	 cmp	 eax, 3
  00262	0f 85 84 00 00
	00		 jne	 $LN12@Put

; 987  : 	{
; 988  : 		if (!__Encrypt_Panama(filename, (const BYTE *) data, len, zObj))

  00268	8d 45 c8	 lea	 eax, DWORD PTR _zObj$[ebp]
  0026b	50		 push	 eax
  0026c	ff b5 74 02 00
	00		 push	 DWORD PTR _len$[ebp]
  00272	ff b5 70 02 00
	00		 push	 DWORD PTR _data$[ebp]
  00278	ff b5 6c 02 00
	00		 push	 DWORD PTR _filename$[ebp]
  0027e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00281	e8 00 00 00 00	 call	 ?__Encrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z ; CEterPack::__Encrypt_Panama
  00286	0f b6 c0	 movzx	 eax, al
  00289	85 c0		 test	 eax, eax
  0028b	75 42		 jne	 SHORT $LN14@Put

; 990  : 			return false;

  0028d	c6 45 e7 00	 mov	 BYTE PTR $T12[ebp], 0
  00291	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00295	8d 8d 48 02 00
	00		 lea	 ecx, DWORD PTR _encryptStr$[ebp]
  0029b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 990  : 			return false;

  002a0	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  002a4	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  002a7	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  002ac	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  002b0	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  002b3	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  002b8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  002bc	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  002c2	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  002c7	8a 45 e7	 mov	 al, BYTE PTR $T12[ebp]
  002ca	e9 62 03 00 00	 jmp	 $LN1@Put
$LN14@Put:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  002cf	8b 45 c8	 mov	 eax, DWORD PTR _zObj$[ebp]
  002d2	89 85 70 02 00
	00		 mov	 DWORD PTR _data$[ebp], eax

; 40   : 		DWORD			GetBufferSize() { return m_dwBufferSize; }

  002d8	8b 45 cc	 mov	 eax, DWORD PTR _zObj$[ebp+4]
  002db	89 45 ac	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 994  : 		len = zObj.GetBufferSize();

  002de	8b 45 ac	 mov	 eax, DWORD PTR $T5[ebp]
  002e1	89 85 74 02 00
	00		 mov	 DWORD PTR _len$[ebp], eax

; 995  : 	}

  002e7	e9 e6 00 00 00	 jmp	 $LN6@Put
$LN12@Put:

; 996  : 	else if (packType == COMPRESSED_TYPE_HYBRIDCRYPT || packType == COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB )

  002ec	0f b6 85 78 02
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  002f3	83 f8 04	 cmp	 eax, 4
  002f6	74 10		 je	 SHORT $LN16@Put
  002f8	0f b6 85 78 02
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  002ff	83 f8 05	 cmp	 eax, 5
  00302	0f 85 ca 00 00
	00		 jne	 $LN6@Put
$LN16@Put:

; 1002 : 		if( !m_pCSHybridCryptPolicy->EncryptMemory( string(filename), (const BYTE *)data, len, zObj ) )

  00308	ff b5 6c 02 00
	00		 push	 DWORD PTR _filename$[ebp]
  0030e	8d 8d 30 02 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  00314	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00319	89 45 a8	 mov	 DWORD PTR tv95[ebp], eax
  0031c	8b 45 a8	 mov	 eax, DWORD PTR tv95[ebp]
  0031f	89 45 a4	 mov	 DWORD PTR tv293[ebp], eax
  00322	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00326	8d 45 c8	 lea	 eax, DWORD PTR _zObj$[ebp]
  00329	50		 push	 eax
  0032a	ff b5 74 02 00
	00		 push	 DWORD PTR _len$[ebp]
  00330	ff b5 70 02 00
	00		 push	 DWORD PTR _data$[ebp]
  00336	ff 75 a4	 push	 DWORD PTR tv293[ebp]
  00339	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0033c	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  00342	e8 00 00 00 00	 call	 ?EncryptMemory@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEHAAVCLZObject@@@Z ; EterPackPolicy_CSHybridCrypt::EncryptMemory
  00347	0f b6 c0	 movzx	 eax, al
  0034a	85 c0		 test	 eax, eax
  0034c	75 09		 jne	 SHORT $LN23@Put
  0034e	c7 45 c4 01 00
	00 00		 mov	 DWORD PTR tv191[ebp], 1
  00355	eb 04		 jmp	 SHORT $LN24@Put
$LN23@Put:
  00357	83 65 c4 00	 and	 DWORD PTR tv191[ebp], 0
$LN24@Put:
  0035b	8a 45 c4	 mov	 al, BYTE PTR tv191[ebp]
  0035e	88 45 e6	 mov	 BYTE PTR $T11[ebp], al
  00361	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00365	8d 8d 30 02 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  0036b	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1002 : 		if( !m_pCSHybridCryptPolicy->EncryptMemory( string(filename), (const BYTE *)data, len, zObj ) )

  00370	0f b6 45 e6	 movzx	 eax, BYTE PTR $T11[ebp]
  00374	85 c0		 test	 eax, eax
  00376	74 42		 je	 SHORT $LN17@Put

; 1004 : 			return false;

  00378	c6 45 e5 00	 mov	 BYTE PTR $T10[ebp], 0
  0037c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00380	8d 8d 48 02 00
	00		 lea	 ecx, DWORD PTR _encryptStr$[ebp]
  00386	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1004 : 			return false;

  0038b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0038f	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00392	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00397	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0039b	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  0039e	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  003a3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  003a7	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  003ad	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  003b2	8a 45 e5	 mov	 al, BYTE PTR $T10[ebp]
  003b5	e9 77 02 00 00	 jmp	 $LN1@Put
$LN17@Put:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  003ba	8b 45 c8	 mov	 eax, DWORD PTR _zObj$[ebp]
  003bd	89 85 70 02 00
	00		 mov	 DWORD PTR _data$[ebp], eax

; 40   : 		DWORD			GetBufferSize() { return m_dwBufferSize; }

  003c3	8b 45 cc	 mov	 eax, DWORD PTR _zObj$[ebp+4]
  003c6	89 45 a0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1008 : 		len = zObj.GetBufferSize();

  003c9	8b 45 a0	 mov	 eax, DWORD PTR $T4[ebp]
  003cc	89 85 74 02 00
	00		 mov	 DWORD PTR _len$[ebp], eax
$LN6@Put:

; 1009 : #ifdef __THEMIDA__
; 1010 : 		VM_END
; 1011 : #endif
; 1012 : 
; 1013 : 	}
; 1014 : 
; 1015 : 
; 1016 : #ifdef CHECKSUM_CHECK_MD5
; 1017 : 	MD5_CTX context;
; 1018 : 	GenerateMD5Hash( (BYTE*)(data), len, context );
; 1019 : #else
; 1020 : 	DWORD data_crc;
; 1021 : 	data_crc = GetCRC32((const char *) data, len);

  003d2	ff b5 74 02 00
	00		 push	 DWORD PTR _len$[ebp]
  003d8	ff b5 70 02 00
	00		 push	 DWORD PTR _data$[ebp]
  003de	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  003e3	59		 pop	 ecx
  003e4	59		 pop	 ecx
  003e5	89 45 dc	 mov	 DWORD PTR _data_crc$[ebp], eax

; 1022 : #endif
; 1023 : 
; 1024 : 	//   ..
; 1025 : 	if (pIndex)

  003e8	83 7d f0 00	 cmp	 DWORD PTR _pIndex$[ebp], 0
  003ec	0f 84 31 01 00
	00		 je	 $LN18@Put

; 1026 : 	{
; 1027 : 		//  data       
; 1028 : 		if (pIndex->real_data_size >= len)

  003f2	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  003f5	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]
  003fb	3b 85 74 02 00
	00		 cmp	 eax, DWORD PTR _len$[ebp]
  00401	0f 8c ff 00 00
	00		 jl	 $LN19@Put

; 1029 : 		{
; 1030 : 			++m_map_indexRefCount[pIndex->id];

  00407	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  0040a	8b 00		 mov	 eax, DWORD PTR [eax]
  0040c	89 45 9c	 mov	 DWORD PTR $T3[ebp], eax
  0040f	8d 45 9c	 lea	 eax, DWORD PTR $T3[ebp]
  00412	50		 push	 eax
  00413	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00416	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  0041c	e8 00 00 00 00	 call	 ??A?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAEAAKABK@Z ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
  00421	89 45 c0	 mov	 DWORD PTR tv210[ebp], eax
  00424	8b 45 c0	 mov	 eax, DWORD PTR tv210[ebp]
  00427	8b 00		 mov	 eax, DWORD PTR [eax]
  00429	40		 inc	 eax
  0042a	8b 4d c0	 mov	 ecx, DWORD PTR tv210[ebp]
  0042d	89 01		 mov	 DWORD PTR [ecx], eax

; 1031 : 
; 1032 : 			//  , checksum    .
; 1033 : 			if ( (pIndex->data_size != len) || 

  0042f	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00432	8b 80 b0 00 00
	00		 mov	 eax, DWORD PTR [eax+176]
  00438	3b 85 74 02 00
	00		 cmp	 eax, DWORD PTR _len$[ebp]
  0043e	75 0e		 jne	 SHORT $LN21@Put
  00440	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00443	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  00449	3b 45 dc	 cmp	 eax, DWORD PTR _data_crc$[ebp]
  0044c	74 76		 je	 SHORT $LN20@Put
$LN21@Put:

; 1034 : #ifdef CHECKSUM_CHECK_MD5
; 1035 : 				(memcmp( pIndex->MD5Digest, context.digest, 16 ) != 0) )
; 1036 : #else
; 1037 : 				(pIndex->data_crc != data_crc) )
; 1038 : #endif
; 1039 : 			{
; 1040 : #ifdef __MAKE_PACK__
; 1041 : 				if (ms_PackLogFile)
; 1042 : 					fprintf(ms_PackLogFile, "Overwrite[%d/%d] %s\n", bCompress, bSecurity, pIndex->filename);
; 1043 : 				printf("Overwrite[%d/%d] %s\n", bCompress, bSecurity, pIndex->filename);
; 1044 : #endif
; 1045 : 				pIndex->data_size = len;

  0044e	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00451	8b 8d 74 02 00
	00		 mov	 ecx, DWORD PTR _len$[ebp]
  00457	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx

; 1046 : #ifdef CHECKSUM_CHECK_MD5
; 1047 : 				memcpy( pIndex->MD5Digest, context.digest, 16 );
; 1048 : 
; 1049 : #else
; 1050 : 				pIndex->data_crc = data_crc;

  0045d	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00460	8b 4d dc	 mov	 ecx, DWORD PTR _data_crc$[ebp]
  00463	89 88 b4 00 00
	00		 mov	 DWORD PTR [eax+180], ecx

; 1051 : #endif
; 1052 : 
; 1053 : 				pIndex->compressed_type = packType;

  00469	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  0046c	8a 8d 78 02 00
	00		 mov	 cl, BYTE PTR _packType$[ebp]
  00472	88 88 bc 00 00
	00		 mov	 BYTE PTR [eax+188], cl

; 1054 : 
; 1055 : 				CMakePackLog::GetSingleton().Writef("Overwrite[type:%u] %s\n", pIndex->compressed_type, pIndex->filename);

  00478	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  0047b	83 c0 04	 add	 eax, 4
  0047e	50		 push	 eax
  0047f	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00482	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00489	50		 push	 eax
  0048a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@IGHIDEHN@Overwrite?$FLtype?3?$CFu?$FN?5?$CFs?6@
  0048f	e8 00 00 00 00	 call	 ?GetSingleton@CMakePackLog@@SAAAV1@XZ ; CMakePackLog::GetSingleton
  00494	50		 push	 eax
  00495	e8 00 00 00 00	 call	 ?Writef@CMakePackLog@@QAAXPBDZZ ; CMakePackLog::Writef
  0049a	83 c4 10	 add	 esp, 16			; 00000010H

; 1056 : 
; 1057 : 				WriteIndex(fileIndex, pIndex);

  0049d	ff 75 f0	 push	 DWORD PTR _pIndex$[ebp]
  004a0	8d 85 18 01 00
	00		 lea	 eax, DWORD PTR _fileIndex$[ebp]
  004a6	50		 push	 eax
  004a7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004aa	e8 00 00 00 00	 call	 ?WriteIndex@CEterPack@@AAEXAAVCFileBase@@PAUSEterPackIndex@@@Z ; CEterPack::WriteIndex

; 1058 : 				WriteData(fileData, pIndex, data);

  004af	ff b5 70 02 00
	00		 push	 DWORD PTR _data$[ebp]
  004b5	ff 75 f0	 push	 DWORD PTR _pIndex$[ebp]
  004b8	8d 45 00	 lea	 eax, DWORD PTR _fileData$[ebp]
  004bb	50		 push	 eax
  004bc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  004bf	e8 00 00 00 00	 call	 ?WriteData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z ; CEterPack::WriteData
$LN20@Put:

; 1061 : 			return true;

  004c4	c6 45 e4 01	 mov	 BYTE PTR $T9[ebp], 1
  004c8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  004cc	8d 8d 48 02 00
	00		 lea	 ecx, DWORD PTR _encryptStr$[ebp]
  004d2	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1061 : 			return true;

  004d7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  004db	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  004de	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  004e3	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  004e7	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  004ea	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  004ef	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  004f3	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  004f9	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  004fe	8a 45 e4	 mov	 al, BYTE PTR $T9[ebp]
  00501	e9 2b 01 00 00	 jmp	 $LN1@Put
$LN19@Put:

; 1062 : 		}
; 1063 : 
; 1064 : 		//        ,   
; 1065 : 		//  .     .
; 1066 : 		PushFreeIndex(pIndex);

  00506	ff 75 f0	 push	 DWORD PTR _pIndex$[ebp]
  00509	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0050c	e8 00 00 00 00	 call	 ?PushFreeIndex@CEterPack@@AAEXPAUSEterPackIndex@@@Z ; CEterPack::PushFreeIndex

; 1067 : 		WriteIndex(fileIndex, pIndex);

  00511	ff 75 f0	 push	 DWORD PTR _pIndex$[ebp]
  00514	8d 85 18 01 00
	00		 lea	 eax, DWORD PTR _fileIndex$[ebp]
  0051a	50		 push	 eax
  0051b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0051e	e8 00 00 00 00	 call	 ?WriteIndex@CEterPack@@AAEXAAVCFileBase@@PAUSEterPackIndex@@@Z ; CEterPack::WriteIndex
$LN18@Put:

; 1068 : 	}
; 1069 : 
; 1070 : 	//  
; 1071 : 	pIndex = NewIndex(fileIndex, filename, len);

  00523	ff b5 74 02 00
	00		 push	 DWORD PTR _len$[ebp]
  00529	ff b5 6c 02 00
	00		 push	 DWORD PTR _filename$[ebp]
  0052f	8d 85 18 01 00
	00		 lea	 eax, DWORD PTR _fileIndex$[ebp]
  00535	50		 push	 eax
  00536	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00539	e8 00 00 00 00	 call	 ?NewIndex@CEterPack@@AAEPAUSEterPackIndex@@AAVCFileBase@@PBDJ@Z ; CEterPack::NewIndex
  0053e	89 45 f0	 mov	 DWORD PTR _pIndex$[ebp], eax

; 1072 : 	pIndex->data_size = len;

  00541	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00544	8b 8d 74 02 00
	00		 mov	 ecx, DWORD PTR _len$[ebp]
  0054a	89 88 b0 00 00
	00		 mov	 DWORD PTR [eax+176], ecx

; 1073 : 
; 1074 : #ifdef CHECKSUM_CHECK_MD5
; 1075 : 		memcpy( pIndex->MD5Digest, context.digest, 16 );
; 1076 : #else
; 1077 : 		pIndex->data_crc = data_crc;

  00550	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00553	8b 4d dc	 mov	 ecx, DWORD PTR _data_crc$[ebp]
  00556	89 88 b4 00 00
	00		 mov	 DWORD PTR [eax+180], ecx

; 1078 : #endif
; 1079 : 
; 1080 : 
; 1081 : 	pIndex->data_position = GetNewDataPosition(fileData);

  0055c	8d 45 00	 lea	 eax, DWORD PTR _fileData$[ebp]
  0055f	50		 push	 eax
  00560	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00563	e8 00 00 00 00	 call	 ?GetNewDataPosition@CEterPack@@AAEJAAVCFileBase@@@Z ; CEterPack::GetNewDataPosition
  00568	8b 4d f0	 mov	 ecx, DWORD PTR _pIndex$[ebp]
  0056b	89 81 b8 00 00
	00		 mov	 DWORD PTR [ecx+184], eax

; 1082 : 	pIndex->compressed_type = packType;

  00571	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  00574	8a 8d 78 02 00
	00		 mov	 cl, BYTE PTR _packType$[ebp]
  0057a	88 88 bc 00 00
	00		 mov	 BYTE PTR [eax+188], cl

; 1083 : 
; 1084 : 	WriteIndex(fileIndex, pIndex);

  00580	ff 75 f0	 push	 DWORD PTR _pIndex$[ebp]
  00583	8d 85 18 01 00
	00		 lea	 eax, DWORD PTR _fileIndex$[ebp]
  00589	50		 push	 eax
  0058a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0058d	e8 00 00 00 00	 call	 ?WriteIndex@CEterPack@@AAEXAAVCFileBase@@PAUSEterPackIndex@@@Z ; CEterPack::WriteIndex

; 1085 : 	WriteNewData(fileData, pIndex, data);

  00592	ff b5 70 02 00
	00		 push	 DWORD PTR _data$[ebp]
  00598	ff 75 f0	 push	 DWORD PTR _pIndex$[ebp]
  0059b	8d 45 00	 lea	 eax, DWORD PTR _fileData$[ebp]
  0059e	50		 push	 eax
  0059f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  005a2	e8 00 00 00 00	 call	 ?WriteNewData@CEterPack@@AAE_NAAVCFileBase@@PAUSEterPackIndex@@PBX@Z ; CEterPack::WriteNewData

; 1086 : 
; 1087 : 	++m_map_indexRefCount[pIndex->id];

  005a7	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  005aa	8b 00		 mov	 eax, DWORD PTR [eax]
  005ac	89 45 98	 mov	 DWORD PTR $T2[ebp], eax
  005af	8d 45 98	 lea	 eax, DWORD PTR $T2[ebp]
  005b2	50		 push	 eax
  005b3	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  005b6	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  005bc	e8 00 00 00 00	 call	 ??A?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAEAAKABK@Z ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::operator[]
  005c1	89 45 bc	 mov	 DWORD PTR tv263[ebp], eax
  005c4	8b 45 bc	 mov	 eax, DWORD PTR tv263[ebp]
  005c7	8b 00		 mov	 eax, DWORD PTR [eax]
  005c9	40		 inc	 eax
  005ca	8b 4d bc	 mov	 ecx, DWORD PTR tv263[ebp]
  005cd	89 01		 mov	 DWORD PTR [ecx], eax

; 1088 : 
; 1089 : #ifdef __MAKE_PACK__
; 1090 : 	if (ms_PackLogFile)
; 1091 : 		fprintf(ms_PackLogFile, "Write[%d/%d] %s\n", bCompress, bSecurity, pIndex->filename);
; 1092 : 	printf("Write[%d/%d] %s, position %ld realsize %ld size %ld\n",
; 1093 : 			bCompress, bSecurity, pIndex->filename, pIndex->data_position, pIndex->real_data_size, pIndex->data_size);
; 1094 : #endif
; 1095 : 	CMakePackLog::GetSingleton().Writef("Write[type:%u] %s\n", pIndex->compressed_type, pIndex->filename);

  005cf	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  005d2	83 c0 04	 add	 eax, 4
  005d5	50		 push	 eax
  005d6	8b 45 f0	 mov	 eax, DWORD PTR _pIndex$[ebp]
  005d9	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  005e0	50		 push	 eax
  005e1	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JEPAOIH@Write?$FLtype?3?$CFu?$FN?5?$CFs?6@
  005e6	e8 00 00 00 00	 call	 ?GetSingleton@CMakePackLog@@SAAAV1@XZ ; CMakePackLog::GetSingleton
  005eb	50		 push	 eax
  005ec	e8 00 00 00 00	 call	 ?Writef@CMakePackLog@@QAAXPBDZZ ; CMakePackLog::Writef
  005f1	83 c4 10	 add	 esp, 16			; 00000010H

; 1097 : 	return true;

  005f4	c6 45 e3 01	 mov	 BYTE PTR $T8[ebp], 1
  005f8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  005fc	8d 8d 48 02 00
	00		 lea	 ecx, DWORD PTR _encryptStr$[ebp]
  00602	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1097 : 	return true;

  00607	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0060b	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  0060e	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00613	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00617	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  0061a	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  0061f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00623	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  00629	e8 00 00 00 00	 call	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
  0062e	8a 45 e3	 mov	 al, BYTE PTR $T8[ebp]
$LN1@Put:

; 1098 : }

  00631	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00634	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0063b	59		 pop	 ecx
  0063c	8b 8d 60 02 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00642	33 cd		 xor	 ecx, ebp
  00644	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00649	81 c5 64 02 00
	00		 add	 ebp, 612		; 00000264H
  0064f	c9		 leave
  00650	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$0:
  00000	8d 8d 18 01 00
	00		 lea	 ecx, DWORD PTR _fileIndex$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$1:
  0000b	8d 4d 00	 lea	 ecx, DWORD PTR _fileData$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1CFileBase@@UAE@XZ	; CFileBase::~CFileBase
__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$2:
  00013	8d 4d c8	 lea	 ecx, DWORD PTR _zObj$[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$3:
  0001b	8d 8d 48 02 00
	00		 lea	 ecx, DWORD PTR _encryptStr$[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Put@CEterPack@@QAE_NPBDPBXJE@Z$4:
  00026	8d 8d 30 02 00
	00		 lea	 ecx, DWORD PTR $T17[ebp]
  0002c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00031	cc		 int	 3
  00032	cc		 int	 3
  00033	cc		 int	 3
  00034	cc		 int	 3
  00035	cc		 int	 3
__ehhandler$?Put@CEterPack@@QAE_NPBDPBXJE@Z:
  00036	90		 npad	 1
  00037	90		 npad	 1
  00038	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0003f	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00042	33 c8		 xor	 ecx, eax
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b 8a 6c 02 00
	00		 mov	 ecx, DWORD PTR [edx+620]
  0004f	33 c8		 xor	 ecx, eax
  00051	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00056	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Put@CEterPack@@QAE_NPBDPBXJE@Z
  0005b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Put@CEterPack@@QAE_NPBDPBXJE@Z ENDP			; CEterPack::Put
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv164 = -56						; size = 4
tv143 = -52						; size = 4
tv162 = -48						; size = 4
tv65 = -44						; size = 4
_pMappedData$ = -40					; size = 4
_iMappedDataSize$ = -36					; size = 4
tv148 = -32						; size = 4
_this$ = -28						; size = 4
_data$ = -24						; size = 4
$T2 = -17						; size = 1
$T3 = -16						; size = 1
$T4 = -15						; size = 1
$T5 = -14						; size = 1
$T6 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_mapFile$ = 0						; size = 324
$T7 = 324						; size = 24
$T8 = 348						; size = 24
__$ArrayPad$ = 372					; size = 4
_filename$ = 384					; size = 4
_sourceFilename$ = 388					; size = 4
_packType$ = 392					; size = 1
_strRelateMapName$ = 396				; size = 4
?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CEterPack::Put, COMDAT
; _this$ = ecx

; 874  : {

  00000	55		 push	 ebp
  00001	8d ac 24 88 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-376]
  00008	81 ec 78 01 00
	00		 sub	 esp, 376		; 00000178H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 2c	 sub	 esp, 44			; 0000002cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 74 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 875  : 	CMappedFile mapFile;

  00039	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 876  : 	LPCVOID		data;
; 877  : 
; 878  : 	if (sourceFilename)

  00045	83 bd 84 01 00
	00 00		 cmp	 DWORD PTR _sourceFilename$[ebp], 0
  0004c	74 34		 je	 SHORT $LN2@Put

; 879  : 	{
; 880  : 		if (!mapFile.Create(sourceFilename, &data, 0, 0))

  0004e	6a 00		 push	 0
  00050	6a 00		 push	 0
  00052	8d 45 e8	 lea	 eax, DWORD PTR _data$[ebp]
  00055	50		 push	 eax
  00056	ff b5 84 01 00
	00		 push	 DWORD PTR _sourceFilename$[ebp]
  0005c	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  0005f	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  00064	85 c0		 test	 eax, eax
  00066	75 18		 jne	 SHORT $LN4@Put

; 881  : 		{
; 882  : 			return false;

  00068	c6 45 f3 00	 mov	 BYTE PTR $T6[ebp], 0
  0006c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00070	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  00073	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00078	8a 45 f3	 mov	 al, BYTE PTR $T6[ebp]
  0007b	e9 6a 01 00 00	 jmp	 $LN1@Put
$LN4@Put:

; 883  : 		}
; 884  : 	}

  00080	eb 32		 jmp	 SHORT $LN3@Put
$LN2@Put:

; 885  : 	else if (!mapFile.Create(filename, &data, 0, 0))

  00082	6a 00		 push	 0
  00084	6a 00		 push	 0
  00086	8d 45 e8	 lea	 eax, DWORD PTR _data$[ebp]
  00089	50		 push	 eax
  0008a	ff b5 80 01 00
	00		 push	 DWORD PTR _filename$[ebp]
  00090	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  00093	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  00098	85 c0		 test	 eax, eax
  0009a	75 18		 jne	 SHORT $LN3@Put

; 886  : 	{
; 887  : 		return false;

  0009c	c6 45 f2 00	 mov	 BYTE PTR $T5[ebp], 0
  000a0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000a4	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  000a7	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000ac	8a 45 f2	 mov	 al, BYTE PTR $T5[ebp]
  000af	e9 36 01 00 00	 jmp	 $LN1@Put
$LN3@Put:

; 888  : 	}
; 889  : 
; 890  : 	BYTE*  pMappedData    = (BYTE*)data;

  000b4	8b 45 e8	 mov	 eax, DWORD PTR _data$[ebp]
  000b7	89 45 d8	 mov	 DWORD PTR _pMappedData$[ebp], eax

; 891  : 	int	   iMappedDataSize = mapFile.Size();

  000ba	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  000bd	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  000c2	89 45 dc	 mov	 DWORD PTR _iMappedDataSize$[ebp], eax

; 892  : 
; 893  : 	if( packType == COMPRESSED_TYPE_HYBRIDCRYPT || packType == COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB )

  000c5	0f b6 85 88 01
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  000cc	83 f8 04	 cmp	 eax, 4
  000cf	74 10		 je	 SHORT $LN7@Put
  000d1	0f b6 85 88 01
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  000d8	83 f8 05	 cmp	 eax, 5
  000db	0f 85 dd 00 00
	00		 jne	 $LN6@Put
$LN7@Put:

; 894  : 	{
; 895  : #ifdef __THEMIDA__
; 896  : 		VM_START
; 897  : #endif
; 898  : 		m_pCSHybridCryptPolicy->GenerateCryptKey( string(filename) );

  000e1	ff b5 80 01 00
	00		 push	 DWORD PTR _filename$[ebp]
  000e7	8d 8d 5c 01 00
	00		 lea	 ecx, DWORD PTR $T8[ebp]
  000ed	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f2	89 45 d4	 mov	 DWORD PTR tv65[ebp], eax
  000f5	8b 45 d4	 mov	 eax, DWORD PTR tv65[ebp]
  000f8	89 45 d0	 mov	 DWORD PTR tv162[ebp], eax
  000fb	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000ff	ff 75 d0	 push	 DWORD PTR tv162[ebp]
  00102	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00105	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  0010b	e8 00 00 00 00	 call	 ?GenerateCryptKey@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; EterPackPolicy_CSHybridCrypt::GenerateCryptKey
  00110	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00114	8d 8d 5c 01 00
	00		 lea	 ecx, DWORD PTR $T8[ebp]
  0011a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 900  : 		if( packType == COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB )

  0011f	0f b6 85 88 01
	00 00		 movzx	 eax, BYTE PTR _packType$[ebp]
  00126	83 f8 05	 cmp	 eax, 5
  00129	0f 85 8f 00 00
	00		 jne	 $LN6@Put

; 902  : 			if( !m_pCSHybridCryptPolicy->GenerateSupplementaryDataBlock( string(filename), strRelateMapName, (const BYTE*)data, mapFile.Size(), pMappedData, iMappedDataSize ))

  0012f	ff b5 80 01 00
	00		 push	 DWORD PTR _filename$[ebp]
  00135	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR $T7[ebp]
  0013b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00140	89 45 cc	 mov	 DWORD PTR tv143[ebp], eax
  00143	8b 45 cc	 mov	 eax, DWORD PTR tv143[ebp]
  00146	89 45 c8	 mov	 DWORD PTR tv164[ebp], eax
  00149	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0014d	8d 45 dc	 lea	 eax, DWORD PTR _iMappedDataSize$[ebp]
  00150	50		 push	 eax
  00151	8d 45 d8	 lea	 eax, DWORD PTR _pMappedData$[ebp]
  00154	50		 push	 eax
  00155	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  00158	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  0015d	50		 push	 eax
  0015e	ff 75 e8	 push	 DWORD PTR _data$[ebp]
  00161	ff b5 8c 01 00
	00		 push	 DWORD PTR _strRelateMapName$[ebp]
  00167	ff 75 c8	 push	 DWORD PTR tv164[ebp]
  0016a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  00173	e8 00 00 00 00	 call	 ?GenerateSupplementaryDataBlock@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@PBEHAAPAEAAH@Z ; EterPackPolicy_CSHybridCrypt::GenerateSupplementaryDataBlock
  00178	0f b6 c0	 movzx	 eax, al
  0017b	85 c0		 test	 eax, eax
  0017d	75 09		 jne	 SHORT $LN11@Put
  0017f	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv148[ebp], 1
  00186	eb 04		 jmp	 SHORT $LN12@Put
$LN11@Put:
  00188	83 65 e0 00	 and	 DWORD PTR tv148[ebp], 0
$LN12@Put:
  0018c	8a 45 e0	 mov	 al, BYTE PTR tv148[ebp]
  0018f	88 45 f1	 mov	 BYTE PTR $T4[ebp], al
  00192	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00196	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR $T7[ebp]
  0019c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 902  : 			if( !m_pCSHybridCryptPolicy->GenerateSupplementaryDataBlock( string(filename), strRelateMapName, (const BYTE*)data, mapFile.Size(), pMappedData, iMappedDataSize ))

  001a1	0f b6 45 f1	 movzx	 eax, BYTE PTR $T4[ebp]
  001a5	85 c0		 test	 eax, eax
  001a7	74 15		 je	 SHORT $LN6@Put

; 903  : 			{
; 904  : 				return false;

  001a9	c6 45 f0 00	 mov	 BYTE PTR $T3[ebp], 0
  001ad	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001b1	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  001b4	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  001b9	8a 45 f0	 mov	 al, BYTE PTR $T3[ebp]
  001bc	eb 2c		 jmp	 SHORT $LN1@Put
$LN6@Put:

; 905  : 			}
; 906  : 		}
; 907  : #ifdef __THEMIDA__
; 908  : 		VM_END
; 909  : #endif
; 910  : 	}
; 911  : 
; 912  : 	return Put(filename, pMappedData, iMappedDataSize, packType);

  001be	ff b5 88 01 00
	00		 push	 DWORD PTR _packType$[ebp]
  001c4	ff 75 dc	 push	 DWORD PTR _iMappedDataSize$[ebp]
  001c7	ff 75 d8	 push	 DWORD PTR _pMappedData$[ebp]
  001ca	ff b5 80 01 00
	00		 push	 DWORD PTR _filename$[ebp]
  001d0	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	e8 00 00 00 00	 call	 ?Put@CEterPack@@QAE_NPBDPBXJE@Z ; CEterPack::Put
  001d8	88 45 ef	 mov	 BYTE PTR $T2[ebp], al
  001db	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001df	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  001e2	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  001e7	8a 45 ef	 mov	 al, BYTE PTR $T2[ebp]
$LN1@Put:

; 913  : }

  001ea	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ed	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001f4	59		 pop	 ecx
  001f5	8b 8d 74 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001fb	33 cd		 xor	 ecx, ebp
  001fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00202	81 c5 78 01 00
	00		 add	 ebp, 376		; 00000178H
  00208	c9		 leave
  00209	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _mapFile$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
  00008	8d 8d 5c 01 00
	00		 lea	 ecx, DWORD PTR $T8[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
  00013	8d 8d 44 01 00
	00		 lea	 ecx, DWORD PTR $T7[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
__ehhandler$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  00023	90		 npad	 1
  00024	90		 npad	 1
  00025	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00029	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002c	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	8b 8a 80 01 00
	00		 mov	 ecx, DWORD PTR [edx+384]
  0003c	33 c8		 xor	 ecx, eax
  0003e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00043	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00048	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Put@CEterPack@@QAE_NPBD0EABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CEterPack::Put
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z
_TEXT	SEGMENT
$T2 = -120						; size = 4
$T3 = -116						; size = 4
_pSDBData$4 = -112					; size = 4
$T5 = -108						; size = 4
$T6 = -104						; size = 4
tv275 = -100						; size = 4
_iSDBSize$7 = -96					; size = 4
tv288 = -92						; size = 4
tv289 = -88						; size = 4
tv286 = -84						; size = 4
_dwCrc32$8 = -80					; size = 4
$T9 = -76						; size = 4
$T10 = -72						; size = 4
$T11 = -68						; size = 4
$T12 = -64						; size = 4
$T13 = -60						; size = 4
$T14 = -56						; size = 4
$T15 = -52						; size = 4
$T16 = -48						; size = 4
$T17 = -44						; size = 4
tv81 = -40						; size = 4
tv267 = -36						; size = 4
tv245 = -32						; size = 4
tv230 = -28						; size = 4
$T18 = -24						; size = 4
tv203 = -20						; size = 4
$T19 = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv184 = 0						; size = 4
tv170 = 4						; size = 4
$T20 = 8						; size = 4
tv151 = 12						; size = 4
tv137 = 16						; size = 4
_zObj$21 = 20						; size = 4
_zObj$22 = 24						; size = 4
_this$ = 28						; size = 4
_zObj$23 = 32						; size = 4
$T24 = 36						; size = 4
_zObj$25 = 40						; size = 4
$T26 = 44						; size = 4
$T27 = 49						; size = 1
$T28 = 50						; size = 1
_bIsSecurityCheckRequired$ = 51				; size = 1
$T29 = 52						; size = 24
$T30 = 76						; size = 24
__$ArrayPad$ = 100					; size = 4
_out_file$ = 112					; size = 4
_filename$ = 116					; size = 4
_index$ = 120						; size = 4
_data$ = 124						; size = 4
?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z PROC ; CEterPack::Get2, COMDAT
; _this$ = ecx

; 625  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 98	 lea	 ebp, DWORD PTR [esp-104]
  00005	83 ec 68	 sub	 esp, 104		; 00000068H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 64	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d 1c	 mov	 DWORD PTR _this$[ebp], ecx

; 626  : 	if (!index)

  00030	83 7d 78 00	 cmp	 DWORD PTR _index$[ebp], 0
  00034	75 07		 jne	 SHORT $LN2@Get2

; 627  : 	{
; 628  : 		return false;

  00036	32 c0		 xor	 al, al
  00038	e9 44 04 00 00	 jmp	 $LN1@Get2
$LN2@Get2:

; 629  : 	}
; 630  : 
; 631  : 	//UpdateLastAccessTime();
; 632  : 	//if (!m_bIsDataLoaded)
; 633  : 	//{
; 634  : 	//	if (!m_file.Create(m_stDataFileName.c_str(), (const void**)&m_file_data, 0, 0))
; 635  : 	//		return false;
; 636  : 	//	
; 637  : 	//	m_bIsDataLoaded = true;
; 638  : 	//}
; 639  : 	out_file.Create(m_stDataFileName.c_str(), data, index->data_position, index->data_size);

  0003d	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  00040	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  00046	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  00049	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  0004f	ff 75 7c	 push	 DWORD PTR _data$[ebp]
  00052	8b 4d 1c	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  0005b	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00060	50		 push	 eax
  00061	8b 4d 70	 mov	 ecx, DWORD PTR _out_file$[ebp]
  00064	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create

; 640  : 
; 641  : 	bool bIsSecurityCheckRequired = ( index->compressed_type == COMPRESSED_TYPE_SECURITY ||

  00069	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  0006c	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00073	83 f8 02	 cmp	 eax, 2
  00076	74 15		 je	 SHORT $LN20@Get2
  00078	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  0007b	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00082	83 f8 03	 cmp	 eax, 3
  00085	74 06		 je	 SHORT $LN20@Get2
  00087	83 65 d8 00	 and	 DWORD PTR tv81[ebp], 0
  0008b	eb 07		 jmp	 SHORT $LN21@Get2
$LN20@Get2:
  0008d	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
$LN21@Get2:
  00094	8a 45 d8	 mov	 al, BYTE PTR tv81[ebp]
  00097	88 45 33	 mov	 BYTE PTR _bIsSecurityCheckRequired$[ebp], al

; 642  : 									  index->compressed_type == COMPRESSED_TYPE_PANAMA );
; 643  : 
; 644  : 	if( bIsSecurityCheckRequired )

  0009a	0f b6 45 33	 movzx	 eax, BYTE PTR _bIsSecurityCheckRequired$[ebp]
  0009e	85 c0		 test	 eax, eax
  000a0	74 2d		 je	 SHORT $LN3@Get2

; 645  : 	{
; 646  : #ifdef CHECKSUM_CHECK_MD5
; 647  : 		MD5_CTX context;
; 648  : 		GenerateMD5Hash( (BYTE*)(*data), index->data_size, context );
; 649  : 
; 650  : 		if( memcmp( index->MD5Digest, context.digest, 16 ) != 0 )
; 651  : 		{
; 652  : 			return false;
; 653  : 		}	
; 654  : #else
; 655  : 		DWORD dwCrc32 = GetCRC32((const char*)(*data), index->data_size);

  000a2	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  000a5	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  000ab	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  000ae	ff 30		 push	 DWORD PTR [eax]
  000b0	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  000b5	59		 pop	 ecx
  000b6	59		 pop	 ecx
  000b7	89 45 b0	 mov	 DWORD PTR _dwCrc32$8[ebp], eax

; 656  : 
; 657  : 		if( index->data_crc != dwCrc32 )

  000ba	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  000bd	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  000c3	3b 45 b0	 cmp	 eax, DWORD PTR _dwCrc32$8[ebp]
  000c6	74 07		 je	 SHORT $LN3@Get2

; 658  : 		{
; 659  : 			return false;

  000c8	32 c0		 xor	 al, al
  000ca	e9 b2 03 00 00	 jmp	 $LN1@Get2
$LN3@Get2:

; 660  : 		}
; 661  : #endif
; 662  : 	}
; 663  : 
; 664  : 
; 665  : 	if (COMPRESSED_TYPE_COMPRESS == index->compressed_type)

  000cf	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  000d2	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  000d9	83 f8 01	 cmp	 eax, 1
  000dc	0f 85 c7 00 00
	00		 jne	 $LN5@Get2

; 666  : 	{
; 667  : 		CLZObject * zObj = new CLZObject;

  000e2	6a 14		 push	 20			; 00000014H
  000e4	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e9	59		 pop	 ecx
  000ea	89 45 d4	 mov	 DWORD PTR $T17[ebp], eax
  000ed	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000f1	83 7d d4 00	 cmp	 DWORD PTR $T17[ebp], 0
  000f5	74 0d		 je	 SHORT $LN22@Get2
  000f7	8b 4d d4	 mov	 ecx, DWORD PTR $T17[ebp]
  000fa	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  000ff	89 45 10	 mov	 DWORD PTR tv137[ebp], eax
  00102	eb 04		 jmp	 SHORT $LN23@Get2
$LN22@Get2:
  00104	83 65 10 00	 and	 DWORD PTR tv137[ebp], 0
$LN23@Get2:
  00108	8b 45 10	 mov	 eax, DWORD PTR tv137[ebp]
  0010b	89 45 94	 mov	 DWORD PTR $T5[ebp], eax
  0010e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00112	8b 45 94	 mov	 eax, DWORD PTR $T5[ebp]
  00115	89 45 28	 mov	 DWORD PTR _zObj$25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00118	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  0011d	89 45 d0	 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 669  : 		if (!CLZO::Instance().Decompress(*zObj, static_cast<const BYTE *>(*data)))

  00120	6a 00		 push	 0
  00122	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  00125	ff 30		 push	 DWORD PTR [eax]
  00127	ff 75 28	 push	 DWORD PTR _zObj$25[ebp]
  0012a	8b 4d d0	 mov	 ecx, DWORD PTR $T16[ebp]
  0012d	e8 00 00 00 00	 call	 ?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z ; CLZO::Decompress
  00132	0f b6 c0	 movzx	 eax, al
  00135	85 c0		 test	 eax, eax
  00137	75 50		 jne	 SHORT $LN7@Get2

; 670  : 		{
; 671  : 			TraceError("Failed to decompress : %s", filename);

  00139	ff 75 74	 push	 DWORD PTR _filename$[ebp]
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CFBHFFAK@Failed?5to?5decompress?5?3?5?$CFs@
  00141	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00146	59		 pop	 ecx
  00147	59		 pop	 ecx

; 672  : 			delete zObj;

  00148	8b 45 28	 mov	 eax, DWORD PTR _zObj$25[ebp]
  0014b	89 45 2c	 mov	 DWORD PTR $T26[ebp], eax
  0014e	83 7d 2c 00	 cmp	 DWORD PTR $T26[ebp], 0
  00152	74 2a		 je	 SHORT $LN24@Get2
  00154	8b 45 8c	 mov	 eax, DWORD PTR $T3[ebp]
  00157	89 45 0c	 mov	 DWORD PTR tv151[ebp], eax
  0015a	8b 4d 2c	 mov	 ecx, DWORD PTR $T26[ebp]
  0015d	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00162	33 c0		 xor	 eax, eax
  00164	40		 inc	 eax
  00165	83 e0 01	 and	 eax, 1
  00168	74 0c		 je	 SHORT $LN62@Get2
  0016a	6a 14		 push	 20			; 00000014H
  0016c	ff 75 2c	 push	 DWORD PTR $T26[ebp]
  0016f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00174	59		 pop	 ecx
  00175	59		 pop	 ecx
$LN62@Get2:
  00176	8b 45 2c	 mov	 eax, DWORD PTR $T26[ebp]
  00179	89 45 0c	 mov	 DWORD PTR tv151[ebp], eax
  0017c	eb 04		 jmp	 SHORT $LN25@Get2
$LN24@Get2:
  0017e	83 65 0c 00	 and	 DWORD PTR tv151[ebp], 0
$LN25@Get2:

; 673  : 			return false;

  00182	32 c0		 xor	 al, al
  00184	e9 f8 02 00 00	 jmp	 $LN1@Get2
$LN7@Get2:

; 674  : 		}
; 675  : 
; 676  : 		out_file.BindLZObject(zObj);

  00189	ff 75 28	 push	 DWORD PTR _zObj$25[ebp]
  0018c	8b 4d 70	 mov	 ecx, DWORD PTR _out_file$[ebp]
  0018f	e8 00 00 00 00	 call	 ?BindLZObject@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObject
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  00194	8b 45 28	 mov	 eax, DWORD PTR _zObj$25[ebp]
  00197	8b 00		 mov	 eax, DWORD PTR [eax]
  00199	89 45 cc	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 677  : 		*data = zObj->GetBuffer();

  0019c	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  0019f	8b 4d cc	 mov	 ecx, DWORD PTR $T15[ebp]
  001a2	89 08		 mov	 DWORD PTR [eax], ecx

; 678  : 	}

  001a4	e9 d6 02 00 00	 jmp	 $LN6@Get2
$LN5@Get2:

; 679  : 	else if (COMPRESSED_TYPE_SECURITY == index->compressed_type)

  001a9	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  001ac	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  001b3	83 f8 02	 cmp	 eax, 2
  001b6	0f 85 cd 00 00
	00		 jne	 $LN8@Get2

; 680  : 	{
; 681  : 		CLZObject * zObj = new CLZObject;

  001bc	6a 14		 push	 20			; 00000014H
  001be	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001c3	59		 pop	 ecx
  001c4	89 45 08	 mov	 DWORD PTR $T20[ebp], eax
  001c7	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  001ce	83 7d 08 00	 cmp	 DWORD PTR $T20[ebp], 0
  001d2	74 0d		 je	 SHORT $LN26@Get2
  001d4	8b 4d 08	 mov	 ecx, DWORD PTR $T20[ebp]
  001d7	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  001dc	89 45 04	 mov	 DWORD PTR tv170[ebp], eax
  001df	eb 04		 jmp	 SHORT $LN27@Get2
$LN26@Get2:
  001e1	83 65 04 00	 and	 DWORD PTR tv170[ebp], 0
$LN27@Get2:
  001e5	8b 45 04	 mov	 eax, DWORD PTR tv170[ebp]
  001e8	89 45 c8	 mov	 DWORD PTR $T14[ebp], eax
  001eb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001ef	8b 45 c8	 mov	 eax, DWORD PTR $T14[ebp]
  001f2	89 45 20	 mov	 DWORD PTR _zObj$23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  001f5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  001fa	89 45 c4	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 683  : 		if (!CLZO::Instance().Decompress(*zObj, static_cast<const BYTE *>(*data), s_adwEterPackSecurityKey))

  001fd	68 00 00 00 00	 push	 OFFSET ?s_adwEterPackSecurityKey@@3PAKA
  00202	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  00205	ff 30		 push	 DWORD PTR [eax]
  00207	ff 75 20	 push	 DWORD PTR _zObj$23[ebp]
  0020a	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  0020d	e8 00 00 00 00	 call	 ?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z ; CLZO::Decompress
  00212	0f b6 c0	 movzx	 eax, al
  00215	85 c0		 test	 eax, eax
  00217	75 50		 jne	 SHORT $LN10@Get2

; 684  : 		{
; 685  : 			TraceError("Failed to encrypt : %s", filename);

  00219	ff 75 74	 push	 DWORD PTR _filename$[ebp]
  0021c	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFAPLGOA@Failed?5to?5encrypt?5?3?5?$CFs@
  00221	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00226	59		 pop	 ecx
  00227	59		 pop	 ecx

; 686  : 			delete zObj;

  00228	8b 45 20	 mov	 eax, DWORD PTR _zObj$23[ebp]
  0022b	89 45 24	 mov	 DWORD PTR $T24[ebp], eax
  0022e	83 7d 24 00	 cmp	 DWORD PTR $T24[ebp], 0
  00232	74 2a		 je	 SHORT $LN28@Get2
  00234	8b 45 88	 mov	 eax, DWORD PTR $T2[ebp]
  00237	89 45 00	 mov	 DWORD PTR tv184[ebp], eax
  0023a	8b 4d 24	 mov	 ecx, DWORD PTR $T24[ebp]
  0023d	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00242	33 c0		 xor	 eax, eax
  00244	40		 inc	 eax
  00245	83 e0 01	 and	 eax, 1
  00248	74 0c		 je	 SHORT $LN70@Get2
  0024a	6a 14		 push	 20			; 00000014H
  0024c	ff 75 24	 push	 DWORD PTR $T24[ebp]
  0024f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00254	59		 pop	 ecx
  00255	59		 pop	 ecx
$LN70@Get2:
  00256	8b 45 24	 mov	 eax, DWORD PTR $T24[ebp]
  00259	89 45 00	 mov	 DWORD PTR tv184[ebp], eax
  0025c	eb 04		 jmp	 SHORT $LN29@Get2
$LN28@Get2:
  0025e	83 65 00 00	 and	 DWORD PTR tv184[ebp], 0
$LN29@Get2:

; 687  : 			return false;

  00262	32 c0		 xor	 al, al
  00264	e9 18 02 00 00	 jmp	 $LN1@Get2
$LN10@Get2:

; 688  : 		}
; 689  : 
; 690  : 		out_file.BindLZObject(zObj);

  00269	ff 75 20	 push	 DWORD PTR _zObj$23[ebp]
  0026c	8b 4d 70	 mov	 ecx, DWORD PTR _out_file$[ebp]
  0026f	e8 00 00 00 00	 call	 ?BindLZObject@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObject
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  00274	8b 45 20	 mov	 eax, DWORD PTR _zObj$23[ebp]
  00277	8b 00		 mov	 eax, DWORD PTR [eax]
  00279	89 45 c0	 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 691  : 		*data = zObj->GetBuffer();

  0027c	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  0027f	8b 4d c0	 mov	 ecx, DWORD PTR $T12[ebp]
  00282	89 08		 mov	 DWORD PTR [eax], ecx

; 692  : 	}

  00284	e9 f6 01 00 00	 jmp	 $LN6@Get2
$LN8@Get2:

; 693  : 	else if (COMPRESSED_TYPE_PANAMA == index->compressed_type)

  00289	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  0028c	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00293	83 f8 03	 cmp	 eax, 3
  00296	75 75		 jne	 SHORT $LN11@Get2

; 694  : 	{
; 695  : 		CLZObject * zObj = new CLZObject;

  00298	6a 14		 push	 20			; 00000014H
  0029a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0029f	59		 pop	 ecx
  002a0	89 45 f0	 mov	 DWORD PTR $T19[ebp], eax
  002a3	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  002aa	83 7d f0 00	 cmp	 DWORD PTR $T19[ebp], 0
  002ae	74 0d		 je	 SHORT $LN30@Get2
  002b0	8b 4d f0	 mov	 ecx, DWORD PTR $T19[ebp]
  002b3	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  002b8	89 45 ec	 mov	 DWORD PTR tv203[ebp], eax
  002bb	eb 04		 jmp	 SHORT $LN31@Get2
$LN30@Get2:
  002bd	83 65 ec 00	 and	 DWORD PTR tv203[ebp], 0
$LN31@Get2:
  002c1	8b 45 ec	 mov	 eax, DWORD PTR tv203[ebp]
  002c4	89 45 bc	 mov	 DWORD PTR $T11[ebp], eax
  002c7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  002cb	8b 45 bc	 mov	 eax, DWORD PTR $T11[ebp]
  002ce	89 45 18	 mov	 DWORD PTR _zObj$22[ebp], eax

; 696  : 		__Decrypt_Panama(filename, static_cast<const BYTE*>(*data), index->data_size, *zObj);

  002d1	ff 75 18	 push	 DWORD PTR _zObj$22[ebp]
  002d4	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  002d7	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  002dd	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  002e0	ff 30		 push	 DWORD PTR [eax]
  002e2	ff 75 74	 push	 DWORD PTR _filename$[ebp]
  002e5	8b 4d 1c	 mov	 ecx, DWORD PTR _this$[ebp]
  002e8	e8 00 00 00 00	 call	 ?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z ; CEterPack::__Decrypt_Panama

; 697  : 		out_file.BindLZObjectWithBufferedSize(zObj);

  002ed	ff 75 18	 push	 DWORD PTR _zObj$22[ebp]
  002f0	8b 4d 70	 mov	 ecx, DWORD PTR _out_file$[ebp]
  002f3	e8 00 00 00 00	 call	 ?BindLZObjectWithBufferedSize@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObjectWithBufferedSize
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  002f8	8b 45 18	 mov	 eax, DWORD PTR _zObj$22[ebp]
  002fb	8b 00		 mov	 eax, DWORD PTR [eax]
  002fd	89 45 b8	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 698  : 		*data = zObj->GetBuffer();

  00300	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  00303	8b 4d b8	 mov	 ecx, DWORD PTR $T10[ebp]
  00306	89 08		 mov	 DWORD PTR [eax], ecx

; 699  : 	}

  00308	e9 72 01 00 00	 jmp	 $LN6@Get2
$LN11@Get2:

; 700  : 	else if (COMPRESSED_TYPE_HYBRIDCRYPT == index->compressed_type || COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB == index->compressed_type)

  0030d	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  00310	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00317	83 f8 04	 cmp	 eax, 4
  0031a	74 13		 je	 SHORT $LN14@Get2
  0031c	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  0031f	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00326	83 f8 05	 cmp	 eax, 5
  00329	0f 85 50 01 00
	00		 jne	 $LN6@Get2
$LN14@Get2:

; 701  : 	{
; 702  : #ifdef __THEMIDA__
; 703  : 		VM_START
; 704  : #endif
; 705  : 
; 706  : 		CLZObject * zObj = new CLZObject;

  0032f	6a 14		 push	 20			; 00000014H
  00331	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00336	59		 pop	 ecx
  00337	89 45 e8	 mov	 DWORD PTR $T18[ebp], eax
  0033a	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00341	83 7d e8 00	 cmp	 DWORD PTR $T18[ebp], 0
  00345	74 0d		 je	 SHORT $LN32@Get2
  00347	8b 4d e8	 mov	 ecx, DWORD PTR $T18[ebp]
  0034a	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  0034f	89 45 e4	 mov	 DWORD PTR tv230[ebp], eax
  00352	eb 04		 jmp	 SHORT $LN33@Get2
$LN32@Get2:
  00354	83 65 e4 00	 and	 DWORD PTR tv230[ebp], 0
$LN33@Get2:
  00358	8b 45 e4	 mov	 eax, DWORD PTR tv230[ebp]
  0035b	89 45 b4	 mov	 DWORD PTR $T9[ebp], eax
  0035e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00362	8b 45 b4	 mov	 eax, DWORD PTR $T9[ebp]
  00365	89 45 14	 mov	 DWORD PTR _zObj$21[ebp], eax

; 708  : 		if( !m_pCSHybridCryptPolicy->DecryptMemory(string(filename), static_cast<const BYTE*>(*data), index->data_size, *zObj) )

  00368	ff 75 74	 push	 DWORD PTR _filename$[ebp]
  0036b	8d 4d 34	 lea	 ecx, DWORD PTR $T29[ebp]
  0036e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00373	89 45 9c	 mov	 DWORD PTR tv275[ebp], eax
  00376	8b 45 9c	 mov	 eax, DWORD PTR tv275[ebp]
  00379	89 45 ac	 mov	 DWORD PTR tv286[ebp], eax
  0037c	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00383	ff 75 14	 push	 DWORD PTR _zObj$21[ebp]
  00386	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  00389	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  0038f	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  00392	ff 30		 push	 DWORD PTR [eax]
  00394	ff 75 ac	 push	 DWORD PTR tv286[ebp]
  00397	8b 45 1c	 mov	 eax, DWORD PTR _this$[ebp]
  0039a	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  003a0	e8 00 00 00 00	 call	 ?DecryptMemory@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEHAAVCLZObject@@@Z ; EterPackPolicy_CSHybridCrypt::DecryptMemory
  003a5	0f b6 c0	 movzx	 eax, al
  003a8	85 c0		 test	 eax, eax
  003aa	75 09		 jne	 SHORT $LN34@Get2
  003ac	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv245[ebp], 1
  003b3	eb 04		 jmp	 SHORT $LN35@Get2
$LN34@Get2:
  003b5	83 65 e0 00	 and	 DWORD PTR tv245[ebp], 0
$LN35@Get2:
  003b9	8a 45 e0	 mov	 al, BYTE PTR tv245[ebp]
  003bc	88 45 32	 mov	 BYTE PTR $T28[ebp], al
  003bf	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  003c3	8d 4d 34	 lea	 ecx, DWORD PTR $T29[ebp]
  003c6	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 708  : 		if( !m_pCSHybridCryptPolicy->DecryptMemory(string(filename), static_cast<const BYTE*>(*data), index->data_size, *zObj) )

  003cb	0f b6 45 32	 movzx	 eax, BYTE PTR $T28[ebp]
  003cf	85 c0		 test	 eax, eax
  003d1	74 07		 je	 SHORT $LN15@Get2

; 709  : 		{
; 710  : 			return false;

  003d3	32 c0		 xor	 al, al
  003d5	e9 a7 00 00 00	 jmp	 $LN1@Get2
$LN15@Get2:

; 711  : 		}
; 712  : 
; 713  : 		out_file.BindLZObjectWithBufferedSize(zObj);

  003da	ff 75 14	 push	 DWORD PTR _zObj$21[ebp]
  003dd	8b 4d 70	 mov	 ecx, DWORD PTR _out_file$[ebp]
  003e0	e8 00 00 00 00	 call	 ?BindLZObjectWithBufferedSize@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObjectWithBufferedSize

; 714  : 
; 715  : 		if( COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB == index->compressed_type)

  003e5	8b 45 78	 mov	 eax, DWORD PTR _index$[ebp]
  003e8	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  003ef	83 f8 05	 cmp	 eax, 5
  003f2	75 7b		 jne	 SHORT $LN16@Get2

; 720  : 			if( !m_pCSHybridCryptPolicy->GetSupplementaryDataBlock(string(filename), pSDBData, iSDBSize) )

  003f4	ff 75 74	 push	 DWORD PTR _filename$[ebp]
  003f7	8d 4d 4c	 lea	 ecx, DWORD PTR $T30[ebp]
  003fa	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003ff	89 45 a8	 mov	 DWORD PTR tv289[ebp], eax
  00402	8b 45 a8	 mov	 eax, DWORD PTR tv289[ebp]
  00405	89 45 a4	 mov	 DWORD PTR tv288[ebp], eax
  00408	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  0040f	8d 45 a0	 lea	 eax, DWORD PTR _iSDBSize$7[ebp]
  00412	50		 push	 eax
  00413	8d 45 90	 lea	 eax, DWORD PTR _pSDBData$4[ebp]
  00416	50		 push	 eax
  00417	ff 75 a4	 push	 DWORD PTR tv288[ebp]
  0041a	8b 45 1c	 mov	 eax, DWORD PTR _this$[ebp]
  0041d	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  00423	e8 00 00 00 00	 call	 ?GetSupplementaryDataBlock@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAEAAH@Z ; EterPackPolicy_CSHybridCrypt::GetSupplementaryDataBlock
  00428	0f b6 c0	 movzx	 eax, al
  0042b	85 c0		 test	 eax, eax
  0042d	75 09		 jne	 SHORT $LN36@Get2
  0042f	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv267[ebp], 1
  00436	eb 04		 jmp	 SHORT $LN37@Get2
$LN36@Get2:
  00438	83 65 dc 00	 and	 DWORD PTR tv267[ebp], 0
$LN37@Get2:
  0043c	8a 45 dc	 mov	 al, BYTE PTR tv267[ebp]
  0043f	88 45 31	 mov	 BYTE PTR $T27[ebp], al
  00442	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00446	8d 4d 4c	 lea	 ecx, DWORD PTR $T30[ebp]
  00449	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 720  : 			if( !m_pCSHybridCryptPolicy->GetSupplementaryDataBlock(string(filename), pSDBData, iSDBSize) )

  0044e	0f b6 45 31	 movzx	 eax, BYTE PTR $T27[ebp]
  00452	85 c0		 test	 eax, eax
  00454	74 04		 je	 SHORT $LN18@Get2

; 721  : 			{
; 722  : 				return false;

  00456	32 c0		 xor	 al, al
  00458	eb 27		 jmp	 SHORT $LN1@Get2
$LN18@Get2:

; 723  : 			}
; 724  : 
; 725  : 			*data = out_file.AppendDataBlock( pSDBData, iSDBSize );

  0045a	ff 75 a0	 push	 DWORD PTR _iSDBSize$7[ebp]
  0045d	ff 75 90	 push	 DWORD PTR _pSDBData$4[ebp]
  00460	8b 4d 70	 mov	 ecx, DWORD PTR _out_file$[ebp]
  00463	e8 00 00 00 00	 call	 ?AppendDataBlock@CMappedFile@@QAEPAEPBXK@Z ; CMappedFile::AppendDataBlock
  00468	8b 4d 7c	 mov	 ecx, DWORD PTR _data$[ebp]
  0046b	89 01		 mov	 DWORD PTR [ecx], eax

; 726  : 		}

  0046d	eb 10		 jmp	 SHORT $LN6@Get2
$LN16@Get2:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  0046f	8b 45 14	 mov	 eax, DWORD PTR _zObj$21[ebp]
  00472	8b 00		 mov	 eax, DWORD PTR [eax]
  00474	89 45 98	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 729  : 			*data = zObj->GetBuffer();

  00477	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  0047a	8b 4d 98	 mov	 ecx, DWORD PTR $T6[ebp]
  0047d	89 08		 mov	 DWORD PTR [eax], ecx
$LN6@Get2:

; 730  : 		}
; 731  : #ifdef __THEMIDA__
; 732  : 		VM_END
; 733  : #endif
; 734  : 	}
; 735  : 
; 736  : 	return true;

  0047f	b0 01		 mov	 al, 1
$LN1@Get2:

; 737  : }

  00481	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00484	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0048b	59		 pop	 ecx
  0048c	8b 4d 64	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0048f	33 cd		 xor	 ecx, ebp
  00491	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00496	83 c5 68	 add	 ebp, 104		; 00000068H
  00499	c9		 leave
  0049a	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	ff 75 d4	 push	 DWORD PTR $T17[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$1:
  0000d	6a 14		 push	 20			; 00000014H
  0000f	ff 75 08	 push	 DWORD PTR $T20[ebp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	59		 pop	 ecx
  00018	59		 pop	 ecx
  00019	c3		 ret	 0
__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$2:
  0001a	6a 14		 push	 20			; 00000014H
  0001c	ff 75 f0	 push	 DWORD PTR $T19[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
  00026	c3		 ret	 0
__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$3:
  00027	6a 14		 push	 20			; 00000014H
  00029	ff 75 e8	 push	 DWORD PTR $T18[ebp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	59		 pop	 ecx
  00032	59		 pop	 ecx
  00033	c3		 ret	 0
__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$4:
  00034	8d 4d 34	 lea	 ecx, DWORD PTR $T29[ebp]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z$5:
  0003c	8d 4d 4c	 lea	 ecx, DWORD PTR $T30[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
__ehhandler$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z:
  00049	90		 npad	 1
  0004a	90		 npad	 1
  0004b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00052	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00055	33 c8		 xor	 ecx, eax
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b 4a 70	 mov	 ecx, DWORD PTR [edx+112]
  0005f	33 c8		 xor	 ecx, eax
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z
  0006b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Get2@CEterPack@@QAE_NAAVCMappedFile@@PBDPAUSEterPackIndex@@PAPBX@Z ENDP ; CEterPack::Get2
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z
_TEXT	SEGMENT
$T2 = -120						; size = 4
$T3 = -116						; size = 4
_pSDBData$4 = -112					; size = 4
$T5 = -108						; size = 4
$T6 = -104						; size = 4
tv278 = -100						; size = 4
_iSDBSize$7 = -96					; size = 4
tv291 = -92						; size = 4
tv292 = -88						; size = 4
tv289 = -84						; size = 4
_dwCrc32$8 = -80					; size = 4
$T9 = -76						; size = 4
$T10 = -72						; size = 4
$T11 = -68						; size = 4
$T12 = -64						; size = 4
$T13 = -60						; size = 4
$T14 = -56						; size = 4
$T15 = -52						; size = 4
$T16 = -48						; size = 4
$T17 = -44						; size = 4
tv84 = -40						; size = 4
tv270 = -36						; size = 4
tv248 = -32						; size = 4
tv233 = -28						; size = 4
$T18 = -24						; size = 4
tv206 = -20						; size = 4
$T19 = -16						; size = 4
__$EHRec$ = -12						; size = 12
tv187 = 0						; size = 4
tv173 = 4						; size = 4
$T20 = 8						; size = 4
tv154 = 12						; size = 4
tv140 = 16						; size = 4
_zObj$21 = 20						; size = 4
_zObj$22 = 24						; size = 4
_zObj$23 = 28						; size = 4
$T24 = 32						; size = 4
_zObj$25 = 36						; size = 4
$T26 = 40						; size = 4
_this$ = 44						; size = 4
$T27 = 49						; size = 1
$T28 = 50						; size = 1
_bIsSecurityCheckRequired$ = 51				; size = 1
_index$ = 52						; size = 4
$T29 = 56						; size = 24
$T30 = 80						; size = 24
__$ArrayPad$ = 104					; size = 4
_out_file$ = 116					; size = 4
_filename$ = 120					; size = 4
_data$ = 124						; size = 4
?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z PROC	; CEterPack::Get, COMDAT
; _this$ = ecx

; 507  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 94	 lea	 ebp, DWORD PTR [esp-108]
  00005	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 68	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d 2c	 mov	 DWORD PTR _this$[ebp], ecx

; 508  : 	TEterPackIndex * index = FindIndex(filename);

  00030	ff 75 78	 push	 DWORD PTR _filename$[ebp]
  00033	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?FindIndex@CEterPack@@AAEPAUSEterPackIndex@@PBD@Z ; CEterPack::FindIndex
  0003b	89 45 34	 mov	 DWORD PTR _index$[ebp], eax

; 509  : 	
; 510  : 	if (!index)

  0003e	83 7d 34 00	 cmp	 DWORD PTR _index$[ebp], 0
  00042	75 07		 jne	 SHORT $LN2@Get

; 511  : 	{
; 512  : 		return false;

  00044	32 c0		 xor	 al, al
  00046	e9 44 04 00 00	 jmp	 $LN1@Get
$LN2@Get:

; 513  : 	}
; 514  : 
; 515  : 	//UpdateLastAccessTime();
; 516  : 	//if (!m_bIsDataLoaded)
; 517  : 	//{
; 518  : 	//	if (!m_file.Create(m_stDataFileName.c_str(), (const void**)&m_file_data, 0, 0))
; 519  : 	//		return false;
; 520  : 	//	
; 521  : 	//	m_bIsDataLoaded = true;
; 522  : 	//}
; 523  : 	
; 524  : 	//  CEterPack epk memory map ,       ,
; 525  : 	//   ,   memory map ,    .
; 526  : 	out_file.Create(m_stDataFileName.c_str(), data, index->data_position, index->data_size);

  0004b	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  0004e	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  00054	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  00057	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  0005d	ff 75 7c	 push	 DWORD PTR _data$[ebp]
  00060	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  00069	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0006e	50		 push	 eax
  0006f	8b 4d 74	 mov	 ecx, DWORD PTR _out_file$[ebp]
  00072	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create

; 527  : 	
; 528  : 	bool bIsSecurityCheckRequired = ( index->compressed_type == COMPRESSED_TYPE_SECURITY ||

  00077	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  0007a	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00081	83 f8 02	 cmp	 eax, 2
  00084	74 15		 je	 SHORT $LN20@Get
  00086	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  00089	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00090	83 f8 03	 cmp	 eax, 3
  00093	74 06		 je	 SHORT $LN20@Get
  00095	83 65 d8 00	 and	 DWORD PTR tv84[ebp], 0
  00099	eb 07		 jmp	 SHORT $LN21@Get
$LN20@Get:
  0009b	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
$LN21@Get:
  000a2	8a 45 d8	 mov	 al, BYTE PTR tv84[ebp]
  000a5	88 45 33	 mov	 BYTE PTR _bIsSecurityCheckRequired$[ebp], al

; 529  : 									  index->compressed_type == COMPRESSED_TYPE_PANAMA );
; 530  : 
; 531  : 	if( bIsSecurityCheckRequired )

  000a8	0f b6 45 33	 movzx	 eax, BYTE PTR _bIsSecurityCheckRequired$[ebp]
  000ac	85 c0		 test	 eax, eax
  000ae	74 2d		 je	 SHORT $LN3@Get

; 532  : 	{
; 533  : #ifdef CHECKSUM_CHECK_MD5
; 534  : 		MD5_CTX context;
; 535  : 		GenerateMD5Hash( (BYTE*)(*data), index->data_size, context );
; 536  : 
; 537  : 		if( memcmp( index->MD5Digest, context.digest, 16 ) != 0 )
; 538  : 		{
; 539  : 			return false;
; 540  : 		}	
; 541  : #else
; 542  : 		DWORD dwCrc32 = GetCRC32((const char*)(*data), index->data_size);

  000b0	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  000b3	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  000b9	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  000bc	ff 30		 push	 DWORD PTR [eax]
  000be	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  000c3	59		 pop	 ecx
  000c4	59		 pop	 ecx
  000c5	89 45 b0	 mov	 DWORD PTR _dwCrc32$8[ebp], eax

; 543  : 
; 544  : 		if( index->data_crc != dwCrc32 )

  000c8	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  000cb	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [eax+180]
  000d1	3b 45 b0	 cmp	 eax, DWORD PTR _dwCrc32$8[ebp]
  000d4	74 07		 je	 SHORT $LN3@Get

; 545  : 		{
; 546  : 			return false;

  000d6	32 c0		 xor	 al, al
  000d8	e9 b2 03 00 00	 jmp	 $LN1@Get
$LN3@Get:

; 547  : 		}
; 548  : #endif
; 549  : 	}
; 550  : 
; 551  : 
; 552  : 	if (COMPRESSED_TYPE_COMPRESS == index->compressed_type)

  000dd	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  000e0	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  000e7	83 f8 01	 cmp	 eax, 1
  000ea	0f 85 c7 00 00
	00		 jne	 $LN5@Get

; 553  : 	{
; 554  : 		CLZObject * zObj = new CLZObject;

  000f0	6a 14		 push	 20			; 00000014H
  000f2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000f7	59		 pop	 ecx
  000f8	89 45 d4	 mov	 DWORD PTR $T17[ebp], eax
  000fb	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000ff	83 7d d4 00	 cmp	 DWORD PTR $T17[ebp], 0
  00103	74 0d		 je	 SHORT $LN22@Get
  00105	8b 4d d4	 mov	 ecx, DWORD PTR $T17[ebp]
  00108	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  0010d	89 45 10	 mov	 DWORD PTR tv140[ebp], eax
  00110	eb 04		 jmp	 SHORT $LN23@Get
$LN22@Get:
  00112	83 65 10 00	 and	 DWORD PTR tv140[ebp], 0
$LN23@Get:
  00116	8b 45 10	 mov	 eax, DWORD PTR tv140[ebp]
  00119	89 45 94	 mov	 DWORD PTR $T5[ebp], eax
  0011c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00120	8b 45 94	 mov	 eax, DWORD PTR $T5[ebp]
  00123	89 45 24	 mov	 DWORD PTR _zObj$25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00126	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  0012b	89 45 d0	 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 556  : 		if (!CLZO::Instance().Decompress(*zObj, static_cast<const BYTE *>(*data)))

  0012e	6a 00		 push	 0
  00130	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  00133	ff 30		 push	 DWORD PTR [eax]
  00135	ff 75 24	 push	 DWORD PTR _zObj$25[ebp]
  00138	8b 4d d0	 mov	 ecx, DWORD PTR $T16[ebp]
  0013b	e8 00 00 00 00	 call	 ?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z ; CLZO::Decompress
  00140	0f b6 c0	 movzx	 eax, al
  00143	85 c0		 test	 eax, eax
  00145	75 50		 jne	 SHORT $LN7@Get

; 557  : 		{
; 558  : 			TraceError("Failed to decompress : %s", filename);

  00147	ff 75 78	 push	 DWORD PTR _filename$[ebp]
  0014a	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@CFBHFFAK@Failed?5to?5decompress?5?3?5?$CFs@
  0014f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00154	59		 pop	 ecx
  00155	59		 pop	 ecx

; 559  : 			delete zObj;

  00156	8b 45 24	 mov	 eax, DWORD PTR _zObj$25[ebp]
  00159	89 45 28	 mov	 DWORD PTR $T26[ebp], eax
  0015c	83 7d 28 00	 cmp	 DWORD PTR $T26[ebp], 0
  00160	74 2a		 je	 SHORT $LN24@Get
  00162	8b 45 8c	 mov	 eax, DWORD PTR $T3[ebp]
  00165	89 45 0c	 mov	 DWORD PTR tv154[ebp], eax
  00168	8b 4d 28	 mov	 ecx, DWORD PTR $T26[ebp]
  0016b	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00170	33 c0		 xor	 eax, eax
  00172	40		 inc	 eax
  00173	83 e0 01	 and	 eax, 1
  00176	74 0c		 je	 SHORT $LN62@Get
  00178	6a 14		 push	 20			; 00000014H
  0017a	ff 75 28	 push	 DWORD PTR $T26[ebp]
  0017d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00182	59		 pop	 ecx
  00183	59		 pop	 ecx
$LN62@Get:
  00184	8b 45 28	 mov	 eax, DWORD PTR $T26[ebp]
  00187	89 45 0c	 mov	 DWORD PTR tv154[ebp], eax
  0018a	eb 04		 jmp	 SHORT $LN25@Get
$LN24@Get:
  0018c	83 65 0c 00	 and	 DWORD PTR tv154[ebp], 0
$LN25@Get:

; 560  : 			return false;

  00190	32 c0		 xor	 al, al
  00192	e9 f8 02 00 00	 jmp	 $LN1@Get
$LN7@Get:

; 561  : 		}
; 562  : 
; 563  : 		out_file.BindLZObject(zObj);

  00197	ff 75 24	 push	 DWORD PTR _zObj$25[ebp]
  0019a	8b 4d 74	 mov	 ecx, DWORD PTR _out_file$[ebp]
  0019d	e8 00 00 00 00	 call	 ?BindLZObject@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObject
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  001a2	8b 45 24	 mov	 eax, DWORD PTR _zObj$25[ebp]
  001a5	8b 00		 mov	 eax, DWORD PTR [eax]
  001a7	89 45 cc	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 564  : 		*data = zObj->GetBuffer();

  001aa	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  001ad	8b 4d cc	 mov	 ecx, DWORD PTR $T15[ebp]
  001b0	89 08		 mov	 DWORD PTR [eax], ecx

; 565  : 	}

  001b2	e9 d6 02 00 00	 jmp	 $LN6@Get
$LN5@Get:

; 566  : 	else if (COMPRESSED_TYPE_SECURITY == index->compressed_type)

  001b7	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  001ba	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  001c1	83 f8 02	 cmp	 eax, 2
  001c4	0f 85 cd 00 00
	00		 jne	 $LN8@Get

; 567  : 	{
; 568  : 		CLZObject * zObj = new CLZObject;

  001ca	6a 14		 push	 20			; 00000014H
  001cc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001d1	59		 pop	 ecx
  001d2	89 45 08	 mov	 DWORD PTR $T20[ebp], eax
  001d5	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  001dc	83 7d 08 00	 cmp	 DWORD PTR $T20[ebp], 0
  001e0	74 0d		 je	 SHORT $LN26@Get
  001e2	8b 4d 08	 mov	 ecx, DWORD PTR $T20[ebp]
  001e5	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  001ea	89 45 04	 mov	 DWORD PTR tv173[ebp], eax
  001ed	eb 04		 jmp	 SHORT $LN27@Get
$LN26@Get:
  001ef	83 65 04 00	 and	 DWORD PTR tv173[ebp], 0
$LN27@Get:
  001f3	8b 45 04	 mov	 eax, DWORD PTR tv173[ebp]
  001f6	89 45 c8	 mov	 DWORD PTR $T14[ebp], eax
  001f9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  001fd	8b 45 c8	 mov	 eax, DWORD PTR $T14[ebp]
  00200	89 45 1c	 mov	 DWORD PTR _zObj$23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00203	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCLZO@@@@0PAVCLZO@@A ; CSingleton<CLZO>::ms_singleton
  00208	89 45 c4	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 570  : 		if (!CLZO::Instance().Decompress(*zObj, static_cast<const BYTE *>(*data), s_adwEterPackSecurityKey))

  0020b	68 00 00 00 00	 push	 OFFSET ?s_adwEterPackSecurityKey@@3PAKA
  00210	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  00213	ff 30		 push	 DWORD PTR [eax]
  00215	ff 75 1c	 push	 DWORD PTR _zObj$23[ebp]
  00218	8b 4d c4	 mov	 ecx, DWORD PTR $T13[ebp]
  0021b	e8 00 00 00 00	 call	 ?Decompress@CLZO@@QAE_NAAVCLZObject@@PBEPAK@Z ; CLZO::Decompress
  00220	0f b6 c0	 movzx	 eax, al
  00223	85 c0		 test	 eax, eax
  00225	75 50		 jne	 SHORT $LN10@Get

; 571  : 		{
; 572  : 			TraceError("Failed to encrypt : %s", filename);

  00227	ff 75 78	 push	 DWORD PTR _filename$[ebp]
  0022a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CFAPLGOA@Failed?5to?5encrypt?5?3?5?$CFs@
  0022f	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00234	59		 pop	 ecx
  00235	59		 pop	 ecx

; 573  : 			delete zObj;

  00236	8b 45 1c	 mov	 eax, DWORD PTR _zObj$23[ebp]
  00239	89 45 20	 mov	 DWORD PTR $T24[ebp], eax
  0023c	83 7d 20 00	 cmp	 DWORD PTR $T24[ebp], 0
  00240	74 2a		 je	 SHORT $LN28@Get
  00242	8b 45 88	 mov	 eax, DWORD PTR $T2[ebp]
  00245	89 45 00	 mov	 DWORD PTR tv187[ebp], eax
  00248	8b 4d 20	 mov	 ecx, DWORD PTR $T24[ebp]
  0024b	e8 00 00 00 00	 call	 ??1CLZObject@@QAE@XZ	; CLZObject::~CLZObject
  00250	33 c0		 xor	 eax, eax
  00252	40		 inc	 eax
  00253	83 e0 01	 and	 eax, 1
  00256	74 0c		 je	 SHORT $LN70@Get
  00258	6a 14		 push	 20			; 00000014H
  0025a	ff 75 20	 push	 DWORD PTR $T24[ebp]
  0025d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00262	59		 pop	 ecx
  00263	59		 pop	 ecx
$LN70@Get:
  00264	8b 45 20	 mov	 eax, DWORD PTR $T24[ebp]
  00267	89 45 00	 mov	 DWORD PTR tv187[ebp], eax
  0026a	eb 04		 jmp	 SHORT $LN29@Get
$LN28@Get:
  0026c	83 65 00 00	 and	 DWORD PTR tv187[ebp], 0
$LN29@Get:

; 574  : 			return false;

  00270	32 c0		 xor	 al, al
  00272	e9 18 02 00 00	 jmp	 $LN1@Get
$LN10@Get:

; 575  : 		}
; 576  : 
; 577  : 		out_file.BindLZObject(zObj);

  00277	ff 75 1c	 push	 DWORD PTR _zObj$23[ebp]
  0027a	8b 4d 74	 mov	 ecx, DWORD PTR _out_file$[ebp]
  0027d	e8 00 00 00 00	 call	 ?BindLZObject@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObject
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  00282	8b 45 1c	 mov	 eax, DWORD PTR _zObj$23[ebp]
  00285	8b 00		 mov	 eax, DWORD PTR [eax]
  00287	89 45 c0	 mov	 DWORD PTR $T12[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 578  : 		*data = zObj->GetBuffer();

  0028a	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  0028d	8b 4d c0	 mov	 ecx, DWORD PTR $T12[ebp]
  00290	89 08		 mov	 DWORD PTR [eax], ecx

; 579  : 	}

  00292	e9 f6 01 00 00	 jmp	 $LN6@Get
$LN8@Get:

; 580  : 	else if (COMPRESSED_TYPE_PANAMA == index->compressed_type)

  00297	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  0029a	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  002a1	83 f8 03	 cmp	 eax, 3
  002a4	75 75		 jne	 SHORT $LN11@Get

; 581  : 	{
; 582  : 		CLZObject * zObj = new CLZObject;

  002a6	6a 14		 push	 20			; 00000014H
  002a8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  002ad	59		 pop	 ecx
  002ae	89 45 f0	 mov	 DWORD PTR $T19[ebp], eax
  002b1	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  002b8	83 7d f0 00	 cmp	 DWORD PTR $T19[ebp], 0
  002bc	74 0d		 je	 SHORT $LN30@Get
  002be	8b 4d f0	 mov	 ecx, DWORD PTR $T19[ebp]
  002c1	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  002c6	89 45 ec	 mov	 DWORD PTR tv206[ebp], eax
  002c9	eb 04		 jmp	 SHORT $LN31@Get
$LN30@Get:
  002cb	83 65 ec 00	 and	 DWORD PTR tv206[ebp], 0
$LN31@Get:
  002cf	8b 45 ec	 mov	 eax, DWORD PTR tv206[ebp]
  002d2	89 45 bc	 mov	 DWORD PTR $T11[ebp], eax
  002d5	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  002d9	8b 45 bc	 mov	 eax, DWORD PTR $T11[ebp]
  002dc	89 45 18	 mov	 DWORD PTR _zObj$22[ebp], eax

; 583  : 		__Decrypt_Panama(filename, static_cast<const BYTE*>(*data), index->data_size, *zObj);

  002df	ff 75 18	 push	 DWORD PTR _zObj$22[ebp]
  002e2	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  002e5	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  002eb	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  002ee	ff 30		 push	 DWORD PTR [eax]
  002f0	ff 75 78	 push	 DWORD PTR _filename$[ebp]
  002f3	8b 4d 2c	 mov	 ecx, DWORD PTR _this$[ebp]
  002f6	e8 00 00 00 00	 call	 ?__Decrypt_Panama@CEterPack@@AAE_NPBDPBEKAAVCLZObject@@@Z ; CEterPack::__Decrypt_Panama

; 584  : 		out_file.BindLZObjectWithBufferedSize(zObj);

  002fb	ff 75 18	 push	 DWORD PTR _zObj$22[ebp]
  002fe	8b 4d 74	 mov	 ecx, DWORD PTR _out_file$[ebp]
  00301	e8 00 00 00 00	 call	 ?BindLZObjectWithBufferedSize@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObjectWithBufferedSize
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  00306	8b 45 18	 mov	 eax, DWORD PTR _zObj$22[ebp]
  00309	8b 00		 mov	 eax, DWORD PTR [eax]
  0030b	89 45 b8	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 585  : 		*data = zObj->GetBuffer();

  0030e	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  00311	8b 4d b8	 mov	 ecx, DWORD PTR $T10[ebp]
  00314	89 08		 mov	 DWORD PTR [eax], ecx

; 586  : 	}

  00316	e9 72 01 00 00	 jmp	 $LN6@Get
$LN11@Get:

; 587  : 	else if (COMPRESSED_TYPE_HYBRIDCRYPT == index->compressed_type || COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB == index->compressed_type)

  0031b	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  0031e	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00325	83 f8 04	 cmp	 eax, 4
  00328	74 13		 je	 SHORT $LN14@Get
  0032a	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  0032d	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  00334	83 f8 05	 cmp	 eax, 5
  00337	0f 85 50 01 00
	00		 jne	 $LN6@Get
$LN14@Get:

; 588  : 	{
; 589  : #ifdef __THEMIDA__
; 590  : 		VM_START
; 591  : #endif
; 592  : 	
; 593  : 		CLZObject * zObj = new CLZObject;

  0033d	6a 14		 push	 20			; 00000014H
  0033f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00344	59		 pop	 ecx
  00345	89 45 e8	 mov	 DWORD PTR $T18[ebp], eax
  00348	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  0034f	83 7d e8 00	 cmp	 DWORD PTR $T18[ebp], 0
  00353	74 0d		 je	 SHORT $LN32@Get
  00355	8b 4d e8	 mov	 ecx, DWORD PTR $T18[ebp]
  00358	e8 00 00 00 00	 call	 ??0CLZObject@@QAE@XZ	; CLZObject::CLZObject
  0035d	89 45 e4	 mov	 DWORD PTR tv233[ebp], eax
  00360	eb 04		 jmp	 SHORT $LN33@Get
$LN32@Get:
  00362	83 65 e4 00	 and	 DWORD PTR tv233[ebp], 0
$LN33@Get:
  00366	8b 45 e4	 mov	 eax, DWORD PTR tv233[ebp]
  00369	89 45 b4	 mov	 DWORD PTR $T9[ebp], eax
  0036c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00370	8b 45 b4	 mov	 eax, DWORD PTR $T9[ebp]
  00373	89 45 14	 mov	 DWORD PTR _zObj$21[ebp], eax

; 595  : 		if( !m_pCSHybridCryptPolicy->DecryptMemory(string(filename), static_cast<const BYTE*>(*data), index->data_size, *zObj) )

  00376	ff 75 78	 push	 DWORD PTR _filename$[ebp]
  00379	8d 4d 38	 lea	 ecx, DWORD PTR $T29[ebp]
  0037c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00381	89 45 9c	 mov	 DWORD PTR tv278[ebp], eax
  00384	8b 45 9c	 mov	 eax, DWORD PTR tv278[ebp]
  00387	89 45 ac	 mov	 DWORD PTR tv289[ebp], eax
  0038a	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  00391	ff 75 14	 push	 DWORD PTR _zObj$21[ebp]
  00394	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  00397	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  0039d	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  003a0	ff 30		 push	 DWORD PTR [eax]
  003a2	ff 75 ac	 push	 DWORD PTR tv289[ebp]
  003a5	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  003a8	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  003ae	e8 00 00 00 00	 call	 ?DecryptMemory@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBEHAAVCLZObject@@@Z ; EterPackPolicy_CSHybridCrypt::DecryptMemory
  003b3	0f b6 c0	 movzx	 eax, al
  003b6	85 c0		 test	 eax, eax
  003b8	75 09		 jne	 SHORT $LN34@Get
  003ba	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv248[ebp], 1
  003c1	eb 04		 jmp	 SHORT $LN35@Get
$LN34@Get:
  003c3	83 65 e0 00	 and	 DWORD PTR tv248[ebp], 0
$LN35@Get:
  003c7	8a 45 e0	 mov	 al, BYTE PTR tv248[ebp]
  003ca	88 45 32	 mov	 BYTE PTR $T28[ebp], al
  003cd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  003d1	8d 4d 38	 lea	 ecx, DWORD PTR $T29[ebp]
  003d4	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 595  : 		if( !m_pCSHybridCryptPolicy->DecryptMemory(string(filename), static_cast<const BYTE*>(*data), index->data_size, *zObj) )

  003d9	0f b6 45 32	 movzx	 eax, BYTE PTR $T28[ebp]
  003dd	85 c0		 test	 eax, eax
  003df	74 07		 je	 SHORT $LN15@Get

; 596  : 		{
; 597  : 			return false;

  003e1	32 c0		 xor	 al, al
  003e3	e9 a7 00 00 00	 jmp	 $LN1@Get
$LN15@Get:

; 598  : 		}
; 599  : 
; 600  : 		out_file.BindLZObjectWithBufferedSize(zObj);

  003e8	ff 75 14	 push	 DWORD PTR _zObj$21[ebp]
  003eb	8b 4d 74	 mov	 ecx, DWORD PTR _out_file$[ebp]
  003ee	e8 00 00 00 00	 call	 ?BindLZObjectWithBufferedSize@CMappedFile@@QAEXPAVCLZObject@@@Z ; CMappedFile::BindLZObjectWithBufferedSize

; 601  : 		if( COMPRESSED_TYPE_HYBRIDCRYPT_WITHSDB == index->compressed_type)

  003f3	8b 45 34	 mov	 eax, DWORD PTR _index$[ebp]
  003f6	0f be 80 bc 00
	00 00		 movsx	 eax, BYTE PTR [eax+188]
  003fd	83 f8 05	 cmp	 eax, 5
  00400	75 7b		 jne	 SHORT $LN16@Get

; 606  : 			if( !m_pCSHybridCryptPolicy->GetSupplementaryDataBlock(string(filename), pSDBData, iSDBSize) )

  00402	ff 75 78	 push	 DWORD PTR _filename$[ebp]
  00405	8d 4d 50	 lea	 ecx, DWORD PTR $T30[ebp]
  00408	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0040d	89 45 a8	 mov	 DWORD PTR tv292[ebp], eax
  00410	8b 45 a8	 mov	 eax, DWORD PTR tv292[ebp]
  00413	89 45 a4	 mov	 DWORD PTR tv291[ebp], eax
  00416	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5
  0041d	8d 45 a0	 lea	 eax, DWORD PTR _iSDBSize$7[ebp]
  00420	50		 push	 eax
  00421	8d 45 90	 lea	 eax, DWORD PTR _pSDBData$4[ebp]
  00424	50		 push	 eax
  00425	ff 75 a4	 push	 DWORD PTR tv291[ebp]
  00428	8b 45 2c	 mov	 eax, DWORD PTR _this$[ebp]
  0042b	8b 88 d0 13 00
	00		 mov	 ecx, DWORD PTR [eax+5072]
  00431	e8 00 00 00 00	 call	 ?GetSupplementaryDataBlock@EterPackPolicy_CSHybridCrypt@@QAE_NAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAEAAH@Z ; EterPackPolicy_CSHybridCrypt::GetSupplementaryDataBlock
  00436	0f b6 c0	 movzx	 eax, al
  00439	85 c0		 test	 eax, eax
  0043b	75 09		 jne	 SHORT $LN36@Get
  0043d	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv270[ebp], 1
  00444	eb 04		 jmp	 SHORT $LN37@Get
$LN36@Get:
  00446	83 65 dc 00	 and	 DWORD PTR tv270[ebp], 0
$LN37@Get:
  0044a	8a 45 dc	 mov	 al, BYTE PTR tv270[ebp]
  0044d	88 45 31	 mov	 BYTE PTR $T27[ebp], al
  00450	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00454	8d 4d 50	 lea	 ecx, DWORD PTR $T30[ebp]
  00457	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 606  : 			if( !m_pCSHybridCryptPolicy->GetSupplementaryDataBlock(string(filename), pSDBData, iSDBSize) )

  0045c	0f b6 45 31	 movzx	 eax, BYTE PTR $T27[ebp]
  00460	85 c0		 test	 eax, eax
  00462	74 04		 je	 SHORT $LN18@Get

; 607  : 			{
; 608  : 				return false;

  00464	32 c0		 xor	 al, al
  00466	eb 27		 jmp	 SHORT $LN1@Get
$LN18@Get:

; 609  : 			}
; 610  : 
; 611  : 			*data = out_file.AppendDataBlock( pSDBData, iSDBSize );

  00468	ff 75 a0	 push	 DWORD PTR _iSDBSize$7[ebp]
  0046b	ff 75 90	 push	 DWORD PTR _pSDBData$4[ebp]
  0046e	8b 4d 74	 mov	 ecx, DWORD PTR _out_file$[ebp]
  00471	e8 00 00 00 00	 call	 ?AppendDataBlock@CMappedFile@@QAEPAEPBXK@Z ; CMappedFile::AppendDataBlock
  00476	8b 4d 7c	 mov	 ecx, DWORD PTR _data$[ebp]
  00479	89 01		 mov	 DWORD PTR [ecx], eax

; 612  : 		}

  0047b	eb 10		 jmp	 SHORT $LN6@Get
$LN16@Get:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterBase\lzo.h

; 37   : 		BYTE *			GetBuffer() { return m_pbBuffer; }

  0047d	8b 45 14	 mov	 eax, DWORD PTR _zObj$21[ebp]
  00480	8b 00		 mov	 eax, DWORD PTR [eax]
  00482	89 45 98	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 615  : 			*data = zObj->GetBuffer();

  00485	8b 45 7c	 mov	 eax, DWORD PTR _data$[ebp]
  00488	8b 4d 98	 mov	 ecx, DWORD PTR $T6[ebp]
  0048b	89 08		 mov	 DWORD PTR [eax], ecx
$LN6@Get:

; 616  : 		}
; 617  : #ifdef __THEMIDA__
; 618  : 		VM_END
; 619  : #endif
; 620  : 	}
; 621  : 	return true;

  0048d	b0 01		 mov	 al, 1
$LN1@Get:

; 622  : }

  0048f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00492	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00499	59		 pop	 ecx
  0049a	8b 4d 68	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0049d	33 cd		 xor	 ecx, ebp
  0049f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004a4	83 c5 6c	 add	 ebp, 108		; 0000006cH
  004a7	c9		 leave
  004a8	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$0:
  00000	6a 14		 push	 20			; 00000014H
  00002	ff 75 d4	 push	 DWORD PTR $T17[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$1:
  0000d	6a 14		 push	 20			; 00000014H
  0000f	ff 75 08	 push	 DWORD PTR $T20[ebp]
  00012	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00017	59		 pop	 ecx
  00018	59		 pop	 ecx
  00019	c3		 ret	 0
__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$2:
  0001a	6a 14		 push	 20			; 00000014H
  0001c	ff 75 f0	 push	 DWORD PTR $T19[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
  00026	c3		 ret	 0
__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$3:
  00027	6a 14		 push	 20			; 00000014H
  00029	ff 75 e8	 push	 DWORD PTR $T18[ebp]
  0002c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00031	59		 pop	 ecx
  00032	59		 pop	 ecx
  00033	c3		 ret	 0
__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$4:
  00034	8d 4d 38	 lea	 ecx, DWORD PTR $T29[ebp]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z$5:
  0003c	8d 4d 50	 lea	 ecx, DWORD PTR $T30[ebp]
  0003f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00044	cc		 int	 3
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
__ehhandler$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z:
  00049	90		 npad	 1
  0004a	90		 npad	 1
  0004b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0004f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00052	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00055	33 c8		 xor	 ecx, eax
  00057	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005c	8b 4a 74	 mov	 ecx, DWORD PTR [edx+116]
  0005f	33 c8		 xor	 ecx, eax
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z
  0006b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Get@CEterPack@@QAE_NAAVCMappedFile@@PBDPAPBX@Z ENDP	; CEterPack::Get
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetDBName@CEterPack@@QAEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDBName@CEterPack@@QAEPBDXZ PROC			; CEterPack::GetDBName, COMDAT
; _this$ = ecx

; 1359 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1360 : 	return m_dbName;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 55 01 00 00	 add	 eax, 341		; 00000155H

; 1361 : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetDBName@CEterPack@@QAEPBDXZ ENDP			; CEterPack::GetDBName
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetPathName@CEterPack@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPathName@CEterPack@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; CEterPack::GetPathName, COMDAT
; _this$ = ecx

; 238  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 	return m_stPathName;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 b8 13 00 00	 add	 eax, 5048		; 000013b8H

; 240  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetPathName@CEterPack@@QAEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; CEterPack::GetPathName
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?DecryptIV@CEterPack@@QAE_NK@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
_ivs$ = -12						; size = 4
_this$ = -8						; size = 4
_i$3 = -4						; size = 4
_dwPanamaKey$ = 8					; size = 4
?DecryptIV@CEterPack@@QAE_NK@Z PROC			; CEterPack::DecryptIV, COMDAT
; _this$ = ecx

; 287  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 80 e4 13 00
	00		 mov	 eax, DWORD PTR [eax+5092]
  00012	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 288  : 	if (m_stIV_Panama.length() != 32)

  00015	83 7d f0 20	 cmp	 DWORD PTR $T2[ebp], 32	; 00000020H
  00019	74 04		 je	 SHORT $LN5@DecryptIV

; 289  : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	eb 73		 jmp	 SHORT $LN1@DecryptIV
$LN5@DecryptIV:

; 290  : 
; 291  : 	if (m_bDecrypedIV) //      

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	0f b6 80 65 03
	00 00		 movzx	 eax, BYTE PTR [eax+869]
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN6@DecryptIV

; 292  : 		return true;

  0002d	b0 01		 mov	 al, 1
  0002f	eb 61		 jmp	 SHORT $LN1@DecryptIV
$LN6@DecryptIV:

; 293  : 
; 294  : 	DWORD* ivs = (DWORD*)&m_stIV_Panama[0];

  00031	6a 00		 push	 0
  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	81 c1 d4 13 00
	00		 add	 ecx, 5076		; 000013d4H
  0003c	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00041	89 45 f4	 mov	 DWORD PTR _ivs$[ebp], eax

; 295  : 	for (int i = 0; i != m_stIV_Panama.length() / sizeof(DWORD); ++i)

  00044	83 65 fc 00	 and	 DWORD PTR _i$3[ebp], 0
  00048	eb 07		 jmp	 SHORT $LN4@DecryptIV
$LN2@DecryptIV:
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _i$3[ebp]
  0004d	40		 inc	 eax
  0004e	89 45 fc	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@DecryptIV:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00051	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00054	8b 80 e4 13 00
	00		 mov	 eax, DWORD PTR [eax+5092]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 295  : 	for (int i = 0; i != m_stIV_Panama.length() / sizeof(DWORD); ++i)

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	c1 e8 02	 shr	 eax, 2
  00063	39 45 fc	 cmp	 DWORD PTR _i$3[ebp], eax
  00066	74 1e		 je	 SHORT $LN3@DecryptIV

; 296  : 	{
; 297  : 		ivs[i] ^= dwPanamaKey + i * 16777619;		

  00068	69 45 fc 93 01
	00 01		 imul	 eax, DWORD PTR _i$3[ebp], 16777619
  0006f	03 45 08	 add	 eax, DWORD PTR _dwPanamaKey$[ebp]
  00072	8b 4d fc	 mov	 ecx, DWORD PTR _i$3[ebp]
  00075	8b 55 f4	 mov	 edx, DWORD PTR _ivs$[ebp]
  00078	33 04 8a	 xor	 eax, DWORD PTR [edx+ecx*4]
  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _i$3[ebp]
  0007e	8b 55 f4	 mov	 edx, DWORD PTR _ivs$[ebp]
  00081	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 298  : 	}

  00084	eb c4		 jmp	 SHORT $LN2@DecryptIV
$LN3@DecryptIV:

; 299  : 
; 300  : 	m_bDecrypedIV = true;

  00086	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00089	c6 80 65 03 00
	00 01		 mov	 BYTE PTR [eax+869], 1

; 301  : 	return true;

  00090	b0 01		 mov	 al, 1
$LN1@DecryptIV:

; 302  : }

  00092	c9		 leave
  00093	c2 04 00	 ret	 4
?DecryptIV@CEterPack@@QAE_NK@Z ENDP			; CEterPack::DecryptIV
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Create@CEterPack@@QAE_NAAVCEterFileDict@@PBD1_NPBE@Z
_TEXT	SEGMENT
_bOverwrite$ = -36					; size = 1
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
tv132 = -8						; size = 4
_this$ = -4						; size = 4
_rkFileDict$ = 8					; size = 4
_dbname$ = 12						; size = 4
_pathName$ = 16						; size = 4
_bReadOnly$ = 20					; size = 1
_iv$ = 24						; size = 4
?Create@CEterPack@@QAE_NAAVCEterFileDict@@PBD1_NPBE@Z PROC ; CEterPack::Create, COMDAT
; _this$ = ecx

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 244  : 	if (iv)

  00009	83 7d 18 00	 cmp	 DWORD PTR _iv$[ebp], 0
  0000d	74 1d		 je	 SHORT $LN2@Create

; 245  : 	{
; 246  : 		m_stIV_Panama.assign((const char*) iv, 32);

  0000f	6a 20		 push	 32			; 00000020H
  00011	ff 75 18	 push	 DWORD PTR _iv$[ebp]
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	81 c1 d4 13 00
	00		 add	 ecx, 5076		; 000013d4H
  0001d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 247  : 		m_bDecrypedIV = false;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	c6 80 65 03 00
	00 00		 mov	 BYTE PTR [eax+869], 0
$LN2@Create:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002c	ff 75 10	 push	 DWORD PTR _pathName$[ebp]
  0002f	e8 00 00 00 00	 call	 _strlen
  00034	59		 pop	 ecx
  00035	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00038	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  0003b	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0003e	ff 75 f0	 push	 DWORD PTR $T5[ebp]
  00041	ff 75 10	 push	 DWORD PTR _pathName$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 250  : 	m_stPathName = pathName;

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	81 c1 b8 13 00
	00		 add	 ecx, 5048		; 000013b8H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0004d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 252  : 	strncpy(m_dbName, dbname, DBNAME_MAX_LEN);

  00052	68 ff 00 00 00	 push	 255			; 000000ffH
  00057	ff 75 0c	 push	 DWORD PTR _dbname$[ebp]
  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	05 55 01 00 00	 add	 eax, 341		; 00000155H
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _strncpy
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH

; 253  : 	
; 254  : 	strncpy(m_indexFileName, dbname, MAX_PATH);

  0006b	68 04 01 00 00	 push	 260			; 00000104H
  00070	ff 75 0c	 push	 DWORD PTR _dbname$[ebp]
  00073	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00076	05 55 02 00 00	 add	 eax, 597		; 00000255H
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _strncpy
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 255  : 	strcat(m_indexFileName, ".eix");

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_04OLDEJNOH@?4eix@
  00089	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	05 55 02 00 00	 add	 eax, 597		; 00000255H
  00091	50		 push	 eax
  00092	e8 00 00 00 00	 call	 _strcat
  00097	59		 pop	 ecx
  00098	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00099	ff 75 0c	 push	 DWORD PTR _dbname$[ebp]
  0009c	e8 00 00 00 00	 call	 _strlen
  000a1	59		 pop	 ecx
  000a2	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000a5	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  000a8	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000ab	ff 75 e8	 push	 DWORD PTR $T3[ebp]
  000ae	ff 75 0c	 push	 DWORD PTR _dbname$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 257  : 	m_stDataFileName = dbname;

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000ba	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_04JJCMEEIK@?4epk@
  000c4	e8 00 00 00 00	 call	 _strlen
  000c9	59		 pop	 ecx
  000ca	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000cd	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  000d0	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000d3	ff 75 e0	 push	 DWORD PTR $T1[ebp]
  000d6	68 00 00 00 00	 push	 OFFSET ??_C@_04JJCMEEIK@?4epk@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 258  : 	m_stDataFileName += ".epk";

  000db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000e4	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 260  : 	m_bReadOnly = bReadOnly;

  000e9	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	8a 4d 14	 mov	 cl, BYTE PTR _bReadOnly$[ebp]
  000ef	88 88 64 03 00
	00		 mov	 BYTE PTR [eax+868], cl

; 261  : 
; 262  : 	// bReadOnly       
; 263  : 	if (!CreateIndexFile())

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f8	e8 00 00 00 00	 call	 ?CreateIndexFile@CEterPack@@AAE_NXZ ; CEterPack::CreateIndexFile
  000fd	0f b6 c0	 movzx	 eax, al
  00100	85 c0		 test	 eax, eax
  00102	75 04		 jne	 SHORT $LN3@Create

; 264  : 		return false;

  00104	32 c0		 xor	 al, al
  00106	eb 54		 jmp	 SHORT $LN1@Create
$LN3@Create:

; 265  : 
; 266  : 	if (!CreateDataFile())

  00108	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	e8 00 00 00 00	 call	 ?CreateDataFile@CEterPack@@AAE_NXZ ; CEterPack::CreateDataFile
  00110	0f b6 c0	 movzx	 eax, al
  00113	85 c0		 test	 eax, eax
  00115	75 04		 jne	 SHORT $LN4@Create

; 267  : 		return false;

  00117	32 c0		 xor	 al, al
  00119	eb 41		 jmp	 SHORT $LN1@Create
$LN4@Create:

; 268  : 
; 269  : 	bool bOverwrite = (iv != NULL);

  0011b	83 7d 18 00	 cmp	 DWORD PTR _iv$[ebp], 0
  0011f	74 09		 je	 SHORT $LN8@Create
  00121	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv132[ebp], 1
  00128	eb 04		 jmp	 SHORT $LN9@Create
$LN8@Create:
  0012a	83 65 f8 00	 and	 DWORD PTR tv132[ebp], 0
$LN9@Create:
  0012e	8a 45 f8	 mov	 al, BYTE PTR tv132[ebp]
  00131	88 45 dc	 mov	 BYTE PTR _bOverwrite$[ebp], al

; 270  : 	__BuildIndex(rkFileDict, bOverwrite);

  00134	ff 75 dc	 push	 DWORD PTR _bOverwrite$[ebp]
  00137	ff 75 08	 push	 DWORD PTR _rkFileDict$[ebp]
  0013a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013d	e8 00 00 00 00	 call	 ?__BuildIndex@CEterPack@@AAE_NAAVCEterFileDict@@_N@Z ; CEterPack::__BuildIndex

; 271  : 
; 272  : 	if (m_bReadOnly)

  00142	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00145	0f b6 80 64 03
	00 00		 movzx	 eax, BYTE PTR [eax+868]
  0014c	85 c0		 test	 eax, eax
  0014e	74 02		 je	 SHORT $LN5@Create

; 273  : 	{
; 274  : 		//m_bIsDataLoaded = true;		
; 275  : 		//if (!m_file.Create(m_stDataFileName.c_str(), (const void**)&m_file_data, 0, 0))
; 276  : 		//	return false;
; 277  : 	}

  00150	eb 08		 jmp	 SHORT $LN6@Create
$LN5@Create:

; 278  : 	else
; 279  : 	{
; 280  : 		DecryptIndexFile();

  00152	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	e8 00 00 00 00	 call	 ?DecryptIndexFile@CEterPack@@QAE_NXZ ; CEterPack::DecryptIndexFile
$LN6@Create:

; 281  : 	}
; 282  : 
; 283  : 	return true;

  0015a	b0 01		 mov	 al, 1
$LN1@Create:

; 284  : }

  0015c	c9		 leave
  0015d	c2 14 00	 ret	 20			; 00000014H
?Create@CEterPack@@QAE_NAAVCEterFileDict@@PBD1_NPBE@Z ENDP ; CEterPack::Create
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?Destroy@CEterPack@@QAEXXZ
_TEXT	SEGMENT
$T2 = -24						; size = 4
_i$3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?Destroy@CEterPack@@QAEXXZ PROC				; CEterPack::Destroy, COMDAT
; _this$ = ecx

; 220  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Destroy@CEterPack@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 221  : 	m_bReadOnly = false;

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c6 80 64 03 00
	00 00		 mov	 BYTE PTR [eax+868], 0

; 222  : 	m_bEncrypted = false;

  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c6 80 54 01 00
	00 00		 mov	 BYTE PTR [eax+340], 0

; 223  : 	m_indexCount = 0;

  0003c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	83 a0 50 01 00
	00 00		 and	 DWORD PTR [eax+336], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 722  :       void clear() BOOST_NOEXCEPT { table_.clear_impl(); }

  00046	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  00053	e8 00 00 00 00	 call	 ?clear_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@std@@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,SEterPackIndex *> >,unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::clear_impl
  00058	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 226  : 	for (int i = 0; i < FREE_INDEX_MAX_SIZE + 1; ++i)

  0005c	83 65 ec 00	 and	 DWORD PTR _i$3[ebp], 0
  00060	eb 07		 jmp	 SHORT $LN4@Destroy
$LN2@Destroy:
  00062	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  00065	40		 inc	 eax
  00066	89 45 ec	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@Destroy:
  00069	81 7d ec 01 02
	00 00		 cmp	 DWORD PTR _i$3[ebp], 513 ; 00000201H
  00070	7d 14		 jge	 SHORT $LN3@Destroy

; 227  : 		m_FreeIndexList[i].clear();

  00072	8b 45 ec	 mov	 eax, DWORD PTR _i$3[ebp]
  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	8d 8c c1 98 03
	00 00		 lea	 ecx, DWORD PTR [ecx+eax*8+920]
  0007f	e8 00 00 00 00	 call	 ?clear@?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAEXXZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::clear
  00084	eb dc		 jmp	 SHORT $LN2@Destroy
$LN3@Destroy:

; 228  : 
; 229  : 	SAFE_DELETE_ARRAY(m_indexData);

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	83 b8 5c 03 00
	00 00		 cmp	 DWORD PTR [eax+860], 0
  00090	74 1f		 je	 SHORT $LN5@Destroy
  00092	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 80 5c 03 00
	00		 mov	 eax, DWORD PTR [eax+860]
  0009b	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  0009e	ff 75 e8	 push	 DWORD PTR $T2[ebp]
  000a1	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000a6	59		 pop	 ecx
  000a7	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000aa	83 a0 5c 03 00
	00 00		 and	 DWORD PTR [eax+860], 0
$LN5@Destroy:

; 230  : 
; 231  : 	m_FragmentSize = 0;

  000b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	83 a0 60 03 00
	00 00		 and	 DWORD PTR [eax+864], 0

; 232  : 
; 233  : 	memset(m_dbName, 0, sizeof(m_dbName));

  000bb	68 00 01 00 00	 push	 256			; 00000100H
  000c0	6a 00		 push	 0
  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	05 55 01 00 00	 add	 eax, 341		; 00000155H
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 _memset
  000d0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 234  : 	memset(m_indexFileName, 0, sizeof(m_indexFileName));	

  000d3	68 05 01 00 00	 push	 261			; 00000105H
  000d8	6a 00		 push	 0
  000da	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	05 55 02 00 00	 add	 eax, 597		; 00000255H
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 _memset
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 235  : }

  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	c9		 leave
  000f7	c3		 ret	 0
  000f8	cc		 int	 3
  000f9	cc		 int	 3
  000fa	cc		 int	 3
  000fb	cc		 int	 3
  000fc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?Destroy@CEterPack@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Destroy@CEterPack@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Destroy@CEterPack@@QAEXXZ ENDP				; CEterPack::Destroy
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ??1CEterPack@@UAE@XZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv88 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CEterPack@@UAE@XZ PROC				; CEterPack::~CEterPack, COMDAT
; _this$ = ecx

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CEterPack@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEterPack@@6B@

; 213  : 	Destroy();

  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?Destroy@CEterPack@@QAEXXZ ; CEterPack::Destroy

; 214  : 	
; 215  : 	delete m_pCSHybridCryptPolicy;

  00039	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 80 d0 13 00
	00		 mov	 eax, DWORD PTR [eax+5072]
  00042	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00045	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00049	74 2a		 je	 SHORT $LN3@CEterPack
  0004b	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv88[ebp], eax
  00051	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00054	e8 00 00 00 00	 call	 ??1EterPackPolicy_CSHybridCrypt@@QAE@XZ ; EterPackPolicy_CSHybridCrypt::~EterPackPolicy_CSHybridCrypt
  00059	33 c0		 xor	 eax, eax
  0005b	40		 inc	 eax
  0005c	83 e0 01	 and	 eax, 1
  0005f	74 0c		 je	 SHORT $LN6@CEterPack
  00061	6a 30		 push	 48			; 00000030H
  00063	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00066	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx
$LN6@CEterPack:
  0006d	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00070	89 45 e8	 mov	 DWORD PTR tv88[ebp], eax
  00073	eb 04		 jmp	 SHORT $LN4@CEterPack
$LN3@CEterPack:
  00075	83 65 e8 00	 and	 DWORD PTR tv88[ebp], 0
$LN4@CEterPack:

; 216  : 	m_pCSHybridCryptPolicy = NULL;

  00079	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	83 a0 d0 13 00
	00 00		 and	 DWORD PTR [eax+5072], 0

; 217  : }

  00083	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	81 c1 d4 13 00
	00		 add	 ecx, 5076		; 000013d4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0008c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 217  : }

  00091	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	81 c1 b8 13 00
	00		 add	 ecx, 5048		; 000013b8H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0009a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 217  : }

  0009f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000a8	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 217  : }

  000ad	68 00 00 00 00	 push	 OFFSET ??1?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::~list<SEterPackIndex *,std::allocator<SEterPackIndex *> >
  000b2	68 01 02 00 00	 push	 513			; 00000201H
  000b7	6a 08		 push	 8
  000b9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	05 98 03 00 00	 add	 eax, 920		; 00000398H
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000c7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ca	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  000d0	e8 00 00 00 00	 call	 ??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::~unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >
  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  000de	e8 00 00 00 00	 call	 ??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::~unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >
  000e3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e6	83 c1 04	 add	 ecx, 4
  000e9	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f8	59		 pop	 ecx
  000f9	c9		 leave
  000fa	c3		 ret	 0
  000fb	cc		 int	 3
  000fc	cc		 int	 3
  000fd	cc		 int	 3
  000fe	cc		 int	 3
  000ff	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CEterPack@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CEterPack@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CEterPack@@UAE@XZ ENDP				; CEterPack::~CEterPack
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ??0CEterPack@@QAE@XZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv156 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CEterPack@@QAE@XZ PROC				; CEterPack::CEterPack, COMDAT
; _this$ = ecx

; 206  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CEterPack@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CEterPack@@6B@
  00031	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 04	 add	 ecx, 4
  00037	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  0003c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 205  : CEterPack::CEterPack() : m_indexCount(0), m_indexData(NULL), m_FragmentSize(0), m_bEncrypted(false), m_bReadOnly(false), m_bDecrypedIV(false)

  00040	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 a0 50 01 00
	00 00		 and	 DWORD PTR [eax+336], 0
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	c6 80 54 01 00
	00 00		 mov	 BYTE PTR [eax+340], 0
  00054	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00057	83 a0 5c 03 00
	00 00		 and	 DWORD PTR [eax+860], 0
  0005e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00061	83 a0 60 03 00
	00 00		 and	 DWORD PTR [eax+864], 0
  00068	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c6 80 64 03 00
	00 00		 mov	 BYTE PTR [eax+868], 0
  00072	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c6 80 65 03 00
	00 00		 mov	 BYTE PTR [eax+869], 0

; 206  : {

  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  00085	e8 00 00 00 00	 call	 ??0?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >
  0008a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0008e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  00097	e8 00 00 00 00	 call	 ??0?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >
  0009c	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  000a0	68 00 00 00 00	 push	 OFFSET ??1?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::~list<SEterPackIndex *,std::allocator<SEterPackIndex *> >
  000a5	68 00 00 00 00	 push	 OFFSET ??0?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >
  000aa	68 01 02 00 00	 push	 513			; 00000201H
  000af	6a 08		 push	 8
  000b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	05 98 03 00 00	 add	 eax, 920		; 00000398H
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  000bf	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000c3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  000cc	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000d1	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	81 c1 b8 13 00
	00		 add	 ecx, 5048		; 000013b8H
  000de	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000e3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000e7	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	81 c1 d4 13 00
	00		 add	 ecx, 5076		; 000013d4H
  000f0	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f5	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 207  : 	m_pCSHybridCryptPolicy = new EterPackPolicy_CSHybridCrypt;

  000f9	6a 30		 push	 48			; 00000030H
  000fb	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00100	59		 pop	 ecx
  00101	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00104	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00108	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  0010c	74 23		 je	 SHORT $LN3@CEterPack
  0010e	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00111	e8 00 00 00 00	 call	 ??0?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >
  00116	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  0011a	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0011d	83 c1 18	 add	 ecx, 24			; 00000018H
  00120	e8 00 00 00 00	 call	 ??0?$unordered_map@KUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSSupplementaryDataBlockInfo@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> > >::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SSupplementaryDataBlockInfo> > >
  00125	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00129	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0012c	89 45 e8	 mov	 DWORD PTR tv156[ebp], eax
  0012f	eb 04		 jmp	 SHORT $LN4@CEterPack
$LN3@CEterPack:
  00131	83 65 e8 00	 and	 DWORD PTR tv156[ebp], 0
$LN4@CEterPack:
  00135	8b 45 e8	 mov	 eax, DWORD PTR tv156[ebp]
  00138	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0013b	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0013f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00142	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00145	89 88 d0 13 00
	00		 mov	 DWORD PTR [eax+5072], ecx

; 208  : 	
; 209  : }

  0014b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0014f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00152	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00155	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015c	59		 pop	 ecx
  0015d	c9		 leave
  0015e	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CEterPack@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
__unwindfunclet$??0CEterPack@@QAE@XZ$1:
  0000b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	81 c1 68 03 00
	00		 add	 ecx, 872		; 00000368H
  00014	e9 00 00 00 00	 jmp	 ??1?$unordered_map@KKU?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@4@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >::~unordered_map<unsigned long,unsigned long,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> > >
__unwindfunclet$??0CEterPack@@QAE@XZ$2:
  00019	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	81 c1 80 03 00
	00		 add	 ecx, 896		; 00000380H
  00022	e9 00 00 00 00	 jmp	 ??1?$unordered_map@KPAUSEterPackIndex@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKPAUSEterPackIndex@@@std@@@5@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >::~unordered_map<unsigned long,SEterPackIndex *,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,SEterPackIndex *> > >
__unwindfunclet$??0CEterPack@@QAE@XZ$3:
  00027	68 00 00 00 00	 push	 OFFSET ??1?$list@PAUSEterPackIndex@@V?$allocator@PAUSEterPackIndex@@@std@@@std@@QAE@XZ ; std::list<SEterPackIndex *,std::allocator<SEterPackIndex *> >::~list<SEterPackIndex *,std::allocator<SEterPackIndex *> >
  0002c	68 01 02 00 00	 push	 513			; 00000201H
  00031	6a 08		 push	 8
  00033	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00036	05 98 03 00 00	 add	 eax, 920		; 00000398H
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00041	c3		 ret	 0
__unwindfunclet$??0CEterPack@@QAE@XZ$4:
  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	81 c1 a0 13 00
	00		 add	 ecx, 5024		; 000013a0H
  0004b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CEterPack@@QAE@XZ$5:
  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	81 c1 b8 13 00
	00		 add	 ecx, 5048		; 000013b8H
  00059	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CEterPack@@QAE@XZ$6:
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	81 c1 d4 13 00
	00		 add	 ecx, 5076		; 000013d4H
  00067	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CEterPack@@QAE@XZ$7:
  0006c	6a 30		 push	 48			; 00000030H
  0006e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00071	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00076	59		 pop	 ecx
  00077	59		 pop	 ecx
  00078	c3		 ret	 0
__unwindfunclet$??0CEterPack@@QAE@XZ$32:
  00079	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0007c	e9 00 00 00 00	 jmp	 ??1?$unordered_map@KUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUSCSHybridCryptKey@EterPackPolicy_CSHybridCrypt@@@std@@@6@@unordered@boost@@QAE@XZ ; boost::unordered::unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >::~unordered_map<unsigned long,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,EterPackPolicy_CSHybridCrypt::SCSHybridCryptKey> > >
  00081	cc		 int	 3
  00082	cc		 int	 3
  00083	cc		 int	 3
  00084	cc		 int	 3
  00085	cc		 int	 3
__ehhandler$??0CEterPack@@QAE@XZ:
  00086	90		 npad	 1
  00087	90		 npad	 1
  00088	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0008c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0008f	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00092	33 c8		 xor	 ecx, eax
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CEterPack@@QAE@XZ
  0009e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CEterPack@@QAE@XZ ENDP				; CEterPack::CEterPack
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ?equal_range@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@U1234@@std@@ABK@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
_this$ = -20						; size = 4
$T7 = -16						; size = 4
tv196 = -12						; size = 4
_n$ = -8						; size = 4
_n1$8 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_k$ = 12						; size = 4
?equal_range@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@U1234@@std@@ABK@Z PROC ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::equal_range, COMDAT
; _this$ = ecx

; 2332 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2333 :       node_pointer n = table_.find_node(k);

  00009	ff 75 0c	 push	 DWORD PTR _k$[ebp]
  0000c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@ABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
  00014	89 45 f8	 mov	 DWORD PTR _n$[ebp], eax

; 2334 :       return std::make_pair(

  00017	83 7d f8 00	 cmp	 DWORD PTR _n$[ebp], 0
  0001b	74 3c		 je	 SHORT $LN3@equal_rang
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2978 :           node_pointer n1 = n;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00020	89 45 fc	 mov	 DWORD PTR _n1$8[ebp], eax
$LN90@equal_rang:

; 2964 :           return static_cast<node_pointer>(n->next_);

  00023	8b 45 fc	 mov	 eax, DWORD PTR _n1$8[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	89 45 fc	 mov	 DWORD PTR _n1$8[ebp], eax

; 2981 :           } while (n1 && !n1->is_first_in_group());

  0002b	83 7d fc 00	 cmp	 DWORD PTR _n1$8[ebp], 0
  0002f	74 20		 je	 SHORT $LN87@equal_rang

; 4878 :           return !(bucket_info_ & ~((std::size_t)-1 >> 1));

  00031	8b 45 fc	 mov	 eax, DWORD PTR _n1$8[ebp]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0003c	75 09		 jne	 SHORT $LN97@equal_rang
  0003e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv196[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN95@equal_rang
$LN97@equal_rang:
  00047	83 65 f4 00	 and	 DWORD PTR tv196[ebp], 0
$LN95@equal_rang:

; 2981 :           } while (n1 && !n1->is_first_in_group());

  0004b	83 7d f4 00	 cmp	 DWORD PTR tv196[ebp], 0
  0004f	74 d2		 je	 SHORT $LN90@equal_rang
$LN87@equal_rang:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 2334 :       return std::make_pair(

  00051	8b 45 fc	 mov	 eax, DWORD PTR _n1$8[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
  00057	eb 06		 jmp	 SHORT $LN4@equal_rang
$LN3@equal_rang:
  00059	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  0005c	89 45 f0	 mov	 DWORD PTR $T7[ebp], eax
$LN4@equal_rang:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2371 :           : node_(static_cast<node_pointer>(x))

  0005f	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00062	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
  00065	8b 45 f8	 mov	 eax, DWORD PTR _n$[ebp]
  00068	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006b	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
  0006e	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  00071	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  00074	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
  00077	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0007a	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0007d	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00085	89 01		 mov	 DWORD PTR [ecx], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00087	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  0008a	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0008d	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp]
  00090	8b 00		 mov	 eax, DWORD PTR [eax]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00095	89 41 04	 mov	 DWORD PTR [ecx+4], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 2334 :       return std::make_pair(

  00098	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2335 :         iterator(n), iterator(n ? table_.next_group(n) : n));
; 2336 :     }

  0009b	c9		 leave
  0009c	c2 08 00	 ret	 8
?equal_range@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@U1234@@std@@ABK@Z ENDP ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::equal_range
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
;	COMDAT ?find@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z
_TEXT	SEGMENT
_x$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_k$ = 12						; size = 4
?find@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z PROC ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::find, COMDAT
; _this$ = ecx

; 2287 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2288 :       return iterator(table_.find_node(k));

  00008	ff 75 0c	 push	 DWORD PTR _k$[ebp]
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@ABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
  00013	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2371 :           : node_(static_cast<node_pointer>(x))

  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0001c	89 08		 mov	 DWORD PTR [eax], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 2288 :       return iterator(table_.find_node(k));

  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2289 :     }

  00021	c9		 leave
  00022	c2 08 00	 ret	 8
?find@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z ENDP ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z
_TEXT	SEGMENT
_a$ = -60						; size = 8
$T2 = -52						; size = 4
_x$ = -48						; size = 4
_p$3 = -44						; size = 4
_position$ = -40					; size = 4
_v$4 = -36						; size = 4
_key_hash$ = -32					; size = 4
_k$ = -28						; size = 4
$T5 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_n$ = 12						; size = 4
?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_equiv, COMDAT
; _this$ = ecx

; 4256 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 03	 add	 eax, 3
  0002e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00031	74 09		 je	 SHORT $LN8@emplace_eq
  00033	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00036	40		 inc	 eax
  00037	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
  0003a	eb 04		 jmp	 SHORT $LN4@emplace_eq
$LN8@emplace_eq:
  0003c	83 65 e8 00	 and	 DWORD PTR $T5[ebp], 0
$LN4@emplace_eq:

; 1999 :         explicit node_tmp(node_pointer n, NodeAlloc& a) : alloc_(a), node_(n) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00043	89 45 c4	 mov	 DWORD PTR _a$[ebp], eax
  00046	8b 45 0c	 mov	 eax, DWORD PTR _n$[ebp]
  00049	89 45 c8	 mov	 DWORD PTR _a$[ebp+4], eax

; 4257 :           node_tmp a(n, this->node_alloc());

  0004c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 4703 :         static key_type const& extract(value_type const& v) { return v.first; }

  00050	8b 45 c8	 mov	 eax, DWORD PTR _a$[ebp+4]
  00053	83 c0 08	 add	 eax, 8

; 4258 :           const_key_type& k = this->get_key(a.node_);

  00056	89 45 e4	 mov	 DWORD PTR _k$[ebp], eax

; 2791 :           return *static_cast<function_pair const*>(

  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0005f	83 e0 01	 and	 eax, 1
  00062	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00069	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 2599 :           return hf(x);

  0006c	8b 45 e4	 mov	 eax, DWORD PTR _k$[ebp]
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	89 45 dc	 mov	 DWORD PTR _v$4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp

; 621  :     BOOST_HASH_SPECIALIZE(unsigned long)

  00074	ff 75 dc	 push	 DWORD PTR _v$4[ebp]
  00077	e8 00 00 00 00	 call	 ??$hash_value@K@boost@@YAIK@Z ; boost::hash_value<unsigned long>
  0007c	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4259 :           std::size_t key_hash = this->hash(k);

  0007d	89 45 e0	 mov	 DWORD PTR _key_hash$[ebp], eax

; 4260 :           node_pointer position = this->find_node(key_hash, k);

  00080	ff 75 e4	 push	 DWORD PTR _k$[ebp]
  00083	ff 75 e0	 push	 DWORD PTR _key_hash$[ebp]
  00086	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00089	e8 00 00 00 00	 call	 ?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@IABK@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
  0008e	89 45 d8	 mov	 DWORD PTR _position$[ebp], eax

; 4261 :           this->reserve_for_insert(this->size_ + 1);

  00091	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00094	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00097	40		 inc	 eax
  00098	50		 push	 eax
  00099	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert

; 2006 :           node_pointer p = node_;

  000a1	8b 45 c8	 mov	 eax, DWORD PTR _a$[ebp+4]
  000a4	89 45 d4	 mov	 DWORD PTR _p$3[ebp], eax

; 2007 :           node_ = node_pointer();

  000a7	83 65 c8 00	 and	 DWORD PTR _a$[ebp+4], 0

; 4262 :           return iterator(

  000ab	ff 75 d8	 push	 DWORD PTR _position$[ebp]
  000ae	ff 75 e0	 push	 DWORD PTR _key_hash$[ebp]
  000b1	ff 75 d4	 push	 DWORD PTR _p$3[ebp]
  000b4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?add_node_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAU5234@I0@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_equiv
  000bc	89 45 d0	 mov	 DWORD PTR _x$[ebp], eax

; 2371 :           : node_(static_cast<node_pointer>(x))

  000bf	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000c2	8b 4d d0	 mov	 ecx, DWORD PTR _x$[ebp]
  000c5	89 08		 mov	 DWORD PTR [eax], ecx

; 4262 :           return iterator(

  000c7	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000cb	8d 4d c4	 lea	 ecx, DWORD PTR _a$[ebp]
  000ce	e8 00 00 00 00	 call	 ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
  000d3	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4263 :             this->add_node_equiv(a.release(), key_hash, position));
; 4264 :         }

  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e0	59		 pop	 ecx
  000e1	c9		 leave
  000e2	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z$0:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR _a$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_tmp@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_tmp<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a cc	 mov	 ecx, DWORD PTR [edx-52]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?emplace_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@34@PAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::emplace_equiv
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?add_node_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAU5234@I0@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
_next_bucket$5 = -20					; size = 4
_bucket_index$ = -16					; size = 4
_b$6 = -12						; size = 4
_start_node$7 = -8					; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
_key_hash$ = 12						; size = 4
_pos$ = 16						; size = 4
?add_node_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAU5234@I0@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_equiv, COMDAT
; _this$ = ecx

; 4199 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2604 :           return hash % bucket_count;

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	8b 45 0c	 mov	 eax, DWORD PTR _key_hash$[ebp]
  0000f	33 d2		 xor	 edx, edx
  00011	f7 71 04	 div	 DWORD PTR [ecx+4]

; 4200 :           std::size_t bucket_index = this->hash_to_bucket(key_hash);

  00014	89 55 f0	 mov	 DWORD PTR _bucket_index$[ebp], edx

; 4201 :           n->bucket_info_ = bucket_index;

  00017	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  0001a	8b 4d f0	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  0001d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4202 : 
; 4203 :           if (pos) {

  00020	83 7d 10 00	 cmp	 DWORD PTR _pos$[ebp], 0
  00024	74 5d		 je	 SHORT $LN2@add_node_e

; 4888 :           bucket_info_ = bucket_info_ | ~((std::size_t)-1 >> 1);

  00026	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  00031	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00034	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 4204 :             n->reset_first_in_group();
; 4205 :             n->next_ = pos->next_;

  00037	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  0003a	8b 4d 10	 mov	 ecx, DWORD PTR _pos$[ebp]
  0003d	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003f	89 08		 mov	 DWORD PTR [eax], ecx

; 4206 :             pos->next_ = n;

  00041	8b 45 10	 mov	 eax, DWORD PTR _pos$[ebp]
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00047	89 08		 mov	 DWORD PTR [eax], ecx

; 4207 :             if (n->next_) {

  00049	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  0004c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004f	74 2d		 je	 SHORT $LN4@add_node_e

; 2964 :           return static_cast<node_pointer>(n->next_);

  00051	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  00059	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  0005c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0005f	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 4208 :               std::size_t next_bucket = this->node_bucket(next_node(n));

  00064	89 45 ec	 mov	 DWORD PTR _next_bucket$5[ebp], eax

; 4209 :               if (next_bucket != bucket_index) {

  00067	8b 45 ec	 mov	 eax, DWORD PTR _next_bucket$5[ebp]
  0006a	3b 45 f0	 cmp	 eax, DWORD PTR _bucket_index$[ebp]
  0006d	74 0f		 je	 SHORT $LN4@add_node_e

; 4210 :                 this->get_bucket_pointer(next_bucket)->next_ = n;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00072	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00075	8b 4d ec	 mov	 ecx, DWORD PTR _next_bucket$5[ebp]
  00078	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  0007b	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN4@add_node_e:

; 4211 :               }
; 4212 :             }
; 4213 :           } else {

  0007e	e9 9f 00 00 00	 jmp	 $LN3@add_node_e
$LN2@add_node_e:

; 4883 :           bucket_info_ = bucket_info_ & ((std::size_t)-1 >> 1);

  00083	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00086	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00089	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  0008e	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00091	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00094	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  0009d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 4214 :             n->set_first_in_group();
; 4215 :             bucket_pointer b = this->get_bucket_pointer(bucket_index);

  000a0	89 45 f4	 mov	 DWORD PTR _b$6[ebp], eax

; 4216 : 
; 4217 :             if (!b->next_) {

  000a3	8b 45 f4	 mov	 eax, DWORD PTR _b$6[ebp]
  000a6	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a9	75 61		 jne	 SHORT $LN6@add_node_e

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  000b7	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000ba	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 4218 :               link_pointer start_node = this->get_previous_start();

  000bd	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  000c0	89 45 f8	 mov	 DWORD PTR _start_node$7[ebp], eax

; 4219 : 
; 4220 :               if (start_node->next_) {

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _start_node$7[ebp]
  000c6	83 38 00	 cmp	 DWORD PTR [eax], 0
  000c9	74 25		 je	 SHORT $LN8@add_node_e

; 2964 :           return static_cast<node_pointer>(n->next_);

  000cb	8b 45 f8	 mov	 eax, DWORD PTR _start_node$7[ebp]
  000ce	8b 00		 mov	 eax, DWORD PTR [eax]
  000d0	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax

; 4873 :           return bucket_info_ & ((std::size_t)-1 >> 1);

  000d3	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  000d6	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d9	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH

; 2999 :           return n->get_bucket();

  000de	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax

; 4221 :                 this

  000e1	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  000e7	8b 4d dc	 mov	 ecx, DWORD PTR $T1[ebp]
  000ea	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  000ed	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN8@add_node_e:

; 4222 :                   ->get_bucket_pointer(this->node_bucket(next_node(start_node)))
; 4223 :                   ->next_ = n;
; 4224 :               }
; 4225 : 
; 4226 :               b->next_ = start_node;

  000f0	8b 45 f4	 mov	 eax, DWORD PTR _b$6[ebp]
  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _start_node$7[ebp]
  000f6	89 08		 mov	 DWORD PTR [eax], ecx

; 4227 :               n->next_ = start_node->next_;

  000f8	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  000fb	8b 4d f8	 mov	 ecx, DWORD PTR _start_node$7[ebp]
  000fe	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00100	89 08		 mov	 DWORD PTR [eax], ecx

; 4228 :               start_node->next_ = n;

  00102	8b 45 f8	 mov	 eax, DWORD PTR _start_node$7[ebp]
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00108	89 08		 mov	 DWORD PTR [eax], ecx

; 4229 :             } else {

  0010a	eb 16		 jmp	 SHORT $LN3@add_node_e
$LN6@add_node_e:

; 4230 :               n->next_ = b->next_->next_;

  0010c	8b 45 f4	 mov	 eax, DWORD PTR _b$6[ebp]
  0010f	8b 00		 mov	 eax, DWORD PTR [eax]
  00111	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00114	8b 00		 mov	 eax, DWORD PTR [eax]
  00116	89 01		 mov	 DWORD PTR [ecx], eax

; 4231 :               b->next_->next_ = n;

  00118	8b 45 f4	 mov	 eax, DWORD PTR _b$6[ebp]
  0011b	8b 00		 mov	 eax, DWORD PTR [eax]
  0011d	8b 4d 08	 mov	 ecx, DWORD PTR _n$[ebp]
  00120	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@add_node_e:

; 4232 :             }
; 4233 :           }
; 4234 :           ++this->size_;

  00122	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00125	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00128	40		 inc	 eax
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4235 :           return n;

  0012f	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]

; 4236 :         }

  00132	c9		 leave
  00133	c2 0c 00	 ret	 12			; 0000000cH
?add_node_equiv@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAU5234@I0@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::add_node_equiv
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
$T2 = -76						; size = 4
_next$3 = -72						; size = 4
_next$4 = -68						; size = 4
_key_hash$5 = -64					; size = 4
tv129 = -60						; size = 4
_v$6 = -56						; size = 4
$T7 = -52						; size = 4
tv221 = -48						; size = 4
_bucket_index$8 = -44					; size = 4
_next$9 = -40						; size = 4
_n$10 = -36						; size = 4
_b$11 = -32						; size = 4
_prev$ = -28						; size = 4
_this$ = -24						; size = 4
_n$12 = -20						; size = 4
__$EHRec$ = -16						; size = 16
_num_buckets$ = 8					; size = 4
?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl, COMDAT
; _this$ = ecx

; 4577 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 4578 :         BOOST_ASSERT(this->buckets_);
; 4579 : 
; 4580 :         this->create_buckets(num_buckets);

  0002f	ff 75 08	 push	 DWORD PTR _num_buckets$[ebp]
  00032	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  0003a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00040	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00046	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00049	89 45 cc	 mov	 DWORD PTR $T7[ebp], eax

; 4581 :         link_pointer prev = this->get_previous_start();

  0004c	8b 45 cc	 mov	 eax, DWORD PTR $T7[ebp]
  0004f	89 45 e4	 mov	 DWORD PTR _prev$[ebp], eax

; 4582 :         BOOST_TRY

  00052	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
$LN2@rehash_imp:

; 4583 :         {
; 4584 :           while (prev->next_) {

  00056	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00059	83 38 00	 cmp	 DWORD PTR [eax], 0
  0005c	0f 84 04 01 00
	00		 je	 $LN3@rehash_imp

; 2964 :           return static_cast<node_pointer>(n->next_);

  00062	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 ec	 mov	 DWORD PTR _n$12[ebp], eax

; 2791 :           return *static_cast<function_pair const*>(

  0006a	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00070	83 e0 01	 and	 eax, 1
  00073	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  0007a	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 2599 :           return hf(x);

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00080	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00083	89 45 c8	 mov	 DWORD PTR _v$6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp

; 621  :     BOOST_HASH_SPECIALIZE(unsigned long)

  00086	ff 75 c8	 push	 DWORD PTR _v$6[ebp]
  00089	e8 00 00 00 00	 call	 ??$hash_value@K@boost@@YAIK@Z ; boost::hash_value<unsigned long>
  0008e	59		 pop	 ecx
  0008f	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4586 :             std::size_t key_hash = this->hash(this->get_key(n));

  00092	8b 45 c4	 mov	 eax, DWORD PTR tv129[ebp]
  00095	89 45 c0	 mov	 DWORD PTR _key_hash$5[ebp], eax

; 2604 :           return hash % bucket_count;

  00098	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 45 c0	 mov	 eax, DWORD PTR _key_hash$5[ebp]
  0009e	33 d2		 xor	 edx, edx
  000a0	f7 71 04	 div	 DWORD PTR [ecx+4]

; 4587 :             std::size_t bucket_index = this->hash_to_bucket(key_hash);

  000a3	89 55 d4	 mov	 DWORD PTR _bucket_index$8[ebp], edx

; 4588 : 
; 4589 :             n->bucket_info_ = bucket_index;

  000a6	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000a9	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  000ac	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4883 :           bucket_info_ = bucket_info_ & ((std::size_t)-1 >> 1);

  000af	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000b2	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000b5	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  000bd	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN6@rehash_imp:

; 2964 :           return static_cast<node_pointer>(n->next_);

  000c0	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000c3	8b 00		 mov	 eax, DWORD PTR [eax]
  000c5	89 45 d8	 mov	 DWORD PTR _next$9[ebp], eax

; 4590 :             n->set_first_in_group();
; 4591 : 
; 4592 :             // Iterator through the rest of the group of equal nodes,
; 4593 :             // setting the bucket.
; 4594 :             for (;;) {
; 4595 :               node_pointer next = next_node(n);
; 4596 :               if (!next || next->is_first_in_group()) {

  000c8	83 7d d8 00	 cmp	 DWORD PTR _next$9[ebp], 0
  000cc	74 20		 je	 SHORT $LN11@rehash_imp

; 4878 :           return !(bucket_info_ & ~((std::size_t)-1 >> 1));

  000ce	8b 45 d8	 mov	 eax, DWORD PTR _next$9[ebp]
  000d1	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000d4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000d9	75 09		 jne	 SHORT $LN61@rehash_imp
  000db	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv221[ebp], 1
  000e2	eb 04		 jmp	 SHORT $LN59@rehash_imp
$LN61@rehash_imp:
  000e4	83 65 d0 00	 and	 DWORD PTR tv221[ebp], 0
$LN59@rehash_imp:

; 4590 :             n->set_first_in_group();
; 4591 : 
; 4592 :             // Iterator through the rest of the group of equal nodes,
; 4593 :             // setting the bucket.
; 4594 :             for (;;) {
; 4595 :               node_pointer next = next_node(n);
; 4596 :               if (!next || next->is_first_in_group()) {

  000e8	83 7d d0 00	 cmp	 DWORD PTR tv221[ebp], 0
  000ec	74 02		 je	 SHORT $LN10@rehash_imp
$LN11@rehash_imp:

; 4597 :                 break;

  000ee	eb 22		 jmp	 SHORT $LN65@rehash_imp
$LN10@rehash_imp:

; 4598 :               }
; 4599 :               n = next;

  000f0	8b 45 d8	 mov	 eax, DWORD PTR _next$9[ebp]
  000f3	89 45 ec	 mov	 DWORD PTR _n$12[ebp], eax

; 4600 :               n->bucket_info_ = bucket_index;

  000f6	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  000f9	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  000fc	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4888 :           bucket_info_ = bucket_info_ | ~((std::size_t)-1 >> 1);

  000ff	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00102	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00105	0d 00 00 00 80	 or	 eax, -2147483648	; 80000000H
  0010a	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  0010d	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 4601 :               n->reset_first_in_group();
; 4602 :             }

  00110	eb ae		 jmp	 SHORT $LN6@rehash_imp
$LN65@rehash_imp:

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00112	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00115	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00118	8b 4d d4	 mov	 ecx, DWORD PTR _bucket_index$8[ebp]
  0011b	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 4603 : 
; 4604 :             // n is now the last node in the group
; 4605 :             bucket_pointer b = this->get_bucket_pointer(bucket_index);

  0011e	89 45 e0	 mov	 DWORD PTR _b$11[ebp], eax

; 4606 :             if (!b->next_) {

  00121	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00124	83 38 00	 cmp	 DWORD PTR [eax], 0
  00127	75 10		 jne	 SHORT $LN12@rehash_imp

; 4607 :               b->next_ = prev;

  00129	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  0012c	8b 4d e4	 mov	 ecx, DWORD PTR _prev$[ebp]
  0012f	89 08		 mov	 DWORD PTR [eax], ecx

; 4608 :               prev = n;

  00131	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  00134	89 45 e4	 mov	 DWORD PTR _prev$[ebp], eax

; 4609 :             } else {

  00137	eb 28		 jmp	 SHORT $LN13@rehash_imp
$LN12@rehash_imp:

; 4610 :               link_pointer next = n->next_;

  00139	8b 45 ec	 mov	 eax, DWORD PTR _n$12[ebp]
  0013c	8b 00		 mov	 eax, DWORD PTR [eax]
  0013e	89 45 bc	 mov	 DWORD PTR _next$4[ebp], eax

; 4611 :               n->next_ = b->next_->next_;

  00141	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00144	8b 00		 mov	 eax, DWORD PTR [eax]
  00146	8b 4d ec	 mov	 ecx, DWORD PTR _n$12[ebp]
  00149	8b 00		 mov	 eax, DWORD PTR [eax]
  0014b	89 01		 mov	 DWORD PTR [ecx], eax

; 4612 :               b->next_->next_ = prev->next_;

  0014d	8b 45 e0	 mov	 eax, DWORD PTR _b$11[ebp]
  00150	8b 00		 mov	 eax, DWORD PTR [eax]
  00152	8b 4d e4	 mov	 ecx, DWORD PTR _prev$[ebp]
  00155	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00157	89 08		 mov	 DWORD PTR [eax], ecx

; 4613 :               prev->next_ = next;

  00159	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  0015c	8b 4d bc	 mov	 ecx, DWORD PTR _next$4[ebp]
  0015f	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@rehash_imp:

; 4614 :             }
; 4615 :           }

  00161	e9 f0 fe ff ff	 jmp	 $LN2@rehash_imp
$LN3@rehash_imp:

; 4616 :         }

  00166	eb 53		 jmp	 SHORT $LN15@rehash_imp
__catch$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0:

; 4617 :         BOOST_CATCH(...)
; 4618 :         {
; 4619 :           node_pointer n = next_node(prev);

  00168	ff 75 e4	 push	 DWORD PTR _prev$[ebp]
  0016b	e8 00 00 00 00	 call	 ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
  00170	59		 pop	 ecx
  00171	89 45 dc	 mov	 DWORD PTR _n$10[ebp], eax

; 4620 :           prev->next_ = node_pointer();

  00174	8b 45 e4	 mov	 eax, DWORD PTR _prev$[ebp]
  00177	83 20 00	 and	 DWORD PTR [eax], 0
$LN7@rehash_imp:

; 4621 :           while (n) {

  0017a	83 7d dc 00	 cmp	 DWORD PTR _n$10[ebp], 0
  0017e	74 2c		 je	 SHORT $LN8@rehash_imp

; 4622 :             node_pointer next = next_node(n);

  00180	ff 75 dc	 push	 DWORD PTR _n$10[ebp]
  00183	e8 00 00 00 00	 call	 ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
  00188	59		 pop	 ecx
  00189	89 45 b8	 mov	 DWORD PTR _next$3[ebp], eax

; 4623 :             destroy_node(n);

  0018c	ff 75 dc	 push	 DWORD PTR _n$10[ebp]
  0018f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00192	e8 00 00 00 00	 call	 ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node

; 4624 :             --size_;

  00197	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0019a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0019d	48		 dec	 eax
  0019e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 4625 :             n = next;

  001a4	8b 45 b8	 mov	 eax, DWORD PTR _next$3[ebp]
  001a7	89 45 dc	 mov	 DWORD PTR _n$10[ebp], eax

; 4626 :           }

  001aa	eb ce		 jmp	 SHORT $LN7@rehash_imp
$LN8@rehash_imp:

; 4627 :           BOOST_RETHROW

  001ac	6a 00		 push	 0
  001ae	6a 00		 push	 0
  001b0	e8 00 00 00 00	 call	 __CxxThrowException@8

; 4628 :         }

  001b5	b8 00 00 00 00	 mov	 eax, $LN18@rehash_imp
  001ba	c3		 ret	 0
$LN15@rehash_imp:
  001bb	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001bf	eb 04		 jmp	 SHORT $LN14@rehash_imp
$LN18@rehash_imp:
  001c1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
$LN14@rehash_imp:

; 4629 :         BOOST_CATCH_END
; 4630 :       }

  001c5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001c8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001cf	59		 pop	 ecx
  001d0	5f		 pop	 edi
  001d1	5e		 pop	 esi
  001d2	5b		 pop	 ebx
  001d3	c9		 leave
  001d4	c2 04 00	 ret	 4
  001d7	cc		 int	 3
  001d8	cc		 int	 3
  001d9	cc		 int	 3
  001da	cc		 int	 3
  001db	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
_num_buckets$5 = -28					; size = 4
tv73 = -24						; size = 4
$T6 = -20						; size = 4
tv137 = -16						; size = 4
__Left$ = -12						; size = 4
$T7 = -8						; size = 4
_this$ = -4						; size = 4
_size$ = 8						; size = 4
?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert, COMDAT
; _this$ = ecx

; 4541 :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4542 :         if (!buckets_) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	75 4a		 jne	 SHORT $LN2@reserve_fo

; 4543 :           create_buckets((std::max)(bucket_count_, min_buckets_for_size(size)));

  00012	ff 75 08	 push	 DWORD PTR _size$[ebp]
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
  0001d	89 45 f8	 mov	 DWORD PTR $T7[ebp], eax
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 f4	 mov	 DWORD PTR __Left$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00029	8b 45 f4	 mov	 eax, DWORD PTR __Left$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	3b 45 f8	 cmp	 eax, DWORD PTR $T7[ebp]
  00031	73 08		 jae	 SHORT $LN55@reserve_fo
  00033	8d 45 f8	 lea	 eax, DWORD PTR $T7[ebp]
  00036	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
  00039	eb 06		 jmp	 SHORT $LN56@reserve_fo
$LN55@reserve_fo:
  0003b	8b 45 f4	 mov	 eax, DWORD PTR __Left$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
$LN56@reserve_fo:
  00041	8b 45 f0	 mov	 eax, DWORD PTR tv137[ebp]
  00044	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
  00047	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0004a	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4543 :           create_buckets((std::max)(bucket_count_, min_buckets_for_size(size)));

  0004d	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00050	ff 30		 push	 DWORD PTR [eax]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
  0005a	eb 64		 jmp	 SHORT $LN1@reserve_fo
$LN2@reserve_fo:

; 4544 :         } else if (size > max_load_) {

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _size$[ebp]
  00062	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  00065	76 59		 jbe	 SHORT $LN1@reserve_fo

; 4545 :           std::size_t num_buckets =

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	03 41 08	 add	 eax, DWORD PTR [ecx+8]
  00075	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00078	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0007b	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  0007e	73 08		 jae	 SHORT $LN60@reserve_fo
  00080	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00083	89 45 e8	 mov	 DWORD PTR tv73[ebp], eax
  00086	eb 06		 jmp	 SHORT $LN61@reserve_fo
$LN60@reserve_fo:
  00088	8d 45 08	 lea	 eax, DWORD PTR _size$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv73[ebp], eax
$LN61@reserve_fo:
  0008e	8b 45 e8	 mov	 eax, DWORD PTR tv73[ebp]
  00091	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  00094	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00097	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4545 :           std::size_t num_buckets =

  0009a	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp]
  0009d	ff 30		 push	 DWORD PTR [eax]
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
  000a7	89 45 e4	 mov	 DWORD PTR _num_buckets$5[ebp], eax

; 4546 :             min_buckets_for_size((std::max)(size, size_ + (size_ >> 1)));
; 4547 : 
; 4548 :           if (num_buckets != bucket_count_)

  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 4d e4	 mov	 ecx, DWORD PTR _num_buckets$5[ebp]
  000b0	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000b3	74 0b		 je	 SHORT $LN1@reserve_fo

; 4549 :             this->rehash_impl(num_buckets);

  000b5	ff 75 e4	 push	 DWORD PTR _num_buckets$5[ebp]
  000b8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bb	e8 00 00 00 00	 call	 ?rehash_impl@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::rehash_impl
$LN1@reserve_fo:

; 4550 :         }
; 4551 :       }

  000c0	c9		 leave
  000c1	c2 04 00	 ret	 4
?reserve_for_insert@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::reserve_for_insert
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@ABK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_v$3 = -8						; size = 4
_this$ = -4						; size = 4
_k$ = 8							; size = 4
?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@ABK@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node, COMDAT
; _this$ = ecx

; 3580 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2791 :           return *static_cast<function_pair const*>(

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000f	83 e0 01	 and	 eax, 1
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00019	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 2599 :           return hf(x);

  0001c	8b 45 08	 mov	 eax, DWORD PTR _k$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 f8	 mov	 DWORD PTR _v$3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp

; 621  :     BOOST_HASH_SPECIALIZE(unsigned long)

  00024	ff 75 f8	 push	 DWORD PTR _v$3[ebp]
  00027	e8 00 00 00 00	 call	 ??$hash_value@K@boost@@YAIK@Z ; boost::hash_value<unsigned long>
  0002c	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3569 :           return policy::apply_hash(this->hash_function(), k);

  0002d	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax

; 3581 :           return this->find_node_impl(hash(k), k, this->key_eq());

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::key_eq
  00038	50		 push	 eax
  00039	ff 75 08	 push	 DWORD PTR _k$[ebp]
  0003c	ff 75 f4	 push	 DWORD PTR $T2[ebp]
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@IABKABU?$equal_to@K@std@@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >

; 3582 :         }

  00047	c9		 leave
  00048	c2 04 00	 ret	 4
?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@ABK@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@IABK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_key_hash$ = 8						; size = 4
_k$ = 12						; size = 4
?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@IABK@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node, COMDAT
; _this$ = ecx

; 3575 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3576 :           return this->find_node_impl(key_hash, k, this->key_eq());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::key_eq
  0000f	50		 push	 eax
  00010	ff 75 0c	 push	 DWORD PTR _k$[ebp]
  00013	ff 75 08	 push	 DWORD PTR _key_hash$[ebp]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$find_node_impl@KU?$equal_to@K@std@@@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@123@IABKABU?$equal_to@K@std@@@Z ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node_impl<unsigned long,std::equal_to<unsigned long> >

; 3577 :         }

  0001e	c9		 leave
  0001f	c2 08 00	 ret	 8
?find_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@IABK@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::find_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
__Ptr$ = -20						; size = 4
__Count$ = -16						; size = 4
_end$ = -12						; size = 4
_it$2 = -8						; size = 4
_this$ = -4						; size = 4
?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets, COMDAT
; _this$ = ecx

; 3370 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3026 :           return buckets_ + static_cast<std::ptrdiff_t>(bucket_index);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  00015	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 3371 :           bucket_pointer end = get_bucket_pointer(bucket_count_ + 1);

  00019	89 45 f4	 mov	 DWORD PTR _end$[ebp], eax

; 3372 :           for (bucket_pointer it = buckets_; it != end; ++it) {

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00022	89 45 f8	 mov	 DWORD PTR _it$2[ebp], eax
  00025	eb 09		 jmp	 SHORT $LN4@destroy_bu
$LN2@destroy_bu:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  0002a	83 c0 04	 add	 eax, 4
  0002d	89 45 f8	 mov	 DWORD PTR _it$2[ebp], eax
$LN4@destroy_bu:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  00033	3b 45 f4	 cmp	 eax, DWORD PTR _end$[ebp]
  00036	74 08		 je	 SHORT $LN13@destroy_bu
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00038	8b 45 f8	 mov	 eax, DWORD PTR _it$2[ebp]
  0003b	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3374 :           }

  0003e	eb e7		 jmp	 SHORT $LN2@destroy_bu
$LN13@destroy_bu:

; 3375 : 
; 3376 :           bucket_allocator_traits::deallocate(

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00046	40		 inc	 eax
  00047	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	c1 e0 02	 shl	 eax, 2
  00059	50		 push	 eax
  0005a	ff 75 ec	 push	 DWORD PTR __Ptr$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3378 :         }

  00064	c9		 leave
  00065	c3		 ret	 0
?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node, COMDAT
; _this$ = ecx

; 3336 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 03	 add	 eax, 3
  0000f	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00012	74 09		 je	 SHORT $LN11@destroy_no
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	40		 inc	 eax
  00018	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
  0001b	eb 04		 jmp	 SHORT $LN15@destroy_no
$LN11@destroy_no:
  0001d	83 65 f0 00	 and	 DWORD PTR $T3[ebp], 0
$LN15@destroy_no:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  00021	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00024	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 c0 03	 add	 eax, 3
  0002d	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  00030	74 09		 je	 SHORT $LN26@destroy_no
  00032	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00035	40		 inc	 eax
  00036	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00039	eb 04		 jmp	 SHORT $LN22@destroy_no
$LN26@destroy_no:
  0003b	83 65 ec 00	 and	 DWORD PTR $T2[ebp], 0
$LN22@destroy_no:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0003f	33 c0		 xor	 eax, eax
  00041	40		 inc	 eax
  00042	6b c0 14	 imul	 eax, eax, 20
  00045	50		 push	 eax
  00046	ff 75 08	 push	 DWORD PTR _n$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0004e	59		 pop	 ecx
  0004f	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3341 :         }

  00050	c9		 leave
  00051	c2 04 00	 ret	 4
?destroy_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
_TEXT	SEGMENT
_a$2 = -116						; size = 8
__Max_possible$3 = -108					; size = 4
__Max_possible$4 = -104					; size = 4
__Max_possible$5 = -100					; size = 4
$T6 = -96						; size = 4
$T7 = -92						; size = 4
$T8 = -88						; size = 4
$T9 = -84						; size = 4
$T10 = -80						; size = 4
$T11 = -76						; size = 4
_p$12 = -72						; size = 4
$T13 = -68						; size = 4
$T14 = -64						; size = 4
_new_buckets$15 = -60					; size = 4
$T16 = -56						; size = 4
_end$ = -52						; size = 4
__Count$ = -48						; size = 4
__Count$ = -44						; size = 4
$T17 = -40						; size = 4
_this$ = -36						; size = 4
__Count$ = -32						; size = 4
_dummy_node$ = -28					; size = 4
_i$18 = -24						; size = 4
_this$ = -20						; size = 4
__Overflow_is_possible$19 = -15				; size = 1
__Overflow_is_possible$20 = -14				; size = 1
__Overflow_is_possible$21 = -13				; size = 1
__$EHRec$ = -12						; size = 12
_new_count$ = 8						; size = 4
?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets, COMDAT
; _this$ = ecx

; 3178 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3179 :           link_pointer dummy_node;
; 3180 : 
; 3181 :           // Construct the new buckets and dummy node, and destroy the old
; 3182 :           // buckets
; 3183 :           if (buckets_) {

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  0002f	74 5d		 je	 SHORT $LN5@create_buc

; 3184 :             dummy_node =

  00031	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00037	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 49 14	 mov	 ecx, DWORD PTR [ecx+20]
  0003d	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00040	89 45 e4	 mov	 DWORD PTR _dummy_node$[ebp], eax

; 3185 :               (buckets_ + static_cast<std::ptrdiff_t>(bucket_count_))->next_;
; 3186 :             bucket_pointer new_buckets =

  00043	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  00046	40		 inc	 eax
  00047	89 45 e0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0004a	c6 45 f3 01	 mov	 BYTE PTR __Overflow_is_possible$21[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0004e	c7 45 9c ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$5[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00055	81 7d e0 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0005c	76 05		 jbe	 SHORT $LN20@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0005e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN20@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00063	8b 45 e0	 mov	 eax, DWORD PTR __Count$[ebp]
  00066	c1 e0 02	 shl	 eax, 2
  00069	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  0006c	ff 75 c8	 push	 DWORD PTR $T16[ebp]
  0006f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00074	59		 pop	 ecx
  00075	89 45 c4	 mov	 DWORD PTR _new_buckets$15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3188 :             destroy_buckets();

  00078	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?destroy_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::destroy_buckets

; 3189 :             buckets_ = new_buckets;

  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d c4	 mov	 ecx, DWORD PTR _new_buckets$15[ebp]
  00086	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  00089	e9 d4 00 00 00	 jmp	 $LN6@create_buc
$LN5@create_buc:

; 3190 :           } else if (bucket::extra_node) {

  0008e	33 c0		 xor	 eax, eax
  00090	0f 84 8a 00 00
	00		 je	 $LN7@create_buc

; 3014 :         node_allocator& node_alloc() { return allocators_.second(); }

  00096	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 03	 add	 eax, 3
  0009c	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax

; 430  :         second_type& second() { return static_cast<base2*>(this)->get(); }

  0009f	74 09		 je	 SHORT $LN48@create_buc
  000a1	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	40		 inc	 eax
  000a5	89 45 d8	 mov	 DWORD PTR $T17[ebp], eax
  000a8	eb 04		 jmp	 SHORT $LN44@create_buc
$LN48@create_buc:
  000aa	83 65 d8 00	 and	 DWORD PTR $T17[ebp], 0
$LN44@create_buc:

; 1946 :         node_constructor(node_allocator& n) : alloc_(n), node_() {}

  000ae	8b 45 d8	 mov	 eax, DWORD PTR $T17[ebp]
  000b1	89 45 8c	 mov	 DWORD PTR _a$2[ebp], eax
  000b4	83 65 90 00	 and	 DWORD PTR _a$2[ebp+4], 0

; 3191 :             node_constructor a(node_alloc());

  000b8	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 3192 :             a.create_node();

  000bc	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  000bf	e8 00 00 00 00	 call	 ?create_node@?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::create_node

; 3193 :             buckets_ =

  000c4	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  000c7	40		 inc	 eax
  000c8	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000cb	c6 45 f2 01	 mov	 BYTE PTR __Overflow_is_possible$20[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000cf	c7 45 98 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$4[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000d6	81 7d d4 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  000dd	76 05		 jbe	 SHORT $LN63@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000df	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN63@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000e4	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  000e7	c1 e0 02	 shl	 eax, 2
  000ea	89 45 c0	 mov	 DWORD PTR $T14[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  000ed	ff 75 c0	 push	 DWORD PTR $T14[ebp]
  000f0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000f5	59		 pop	 ecx
  000f6	89 45 bc	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3193 :             buckets_ =

  000f9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	8b 4d bc	 mov	 ecx, DWORD PTR $T13[ebp]
  000ff	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 1956 :           node_pointer p = node_;

  00102	8b 45 90	 mov	 eax, DWORD PTR _a$2[ebp+4]
  00105	89 45 b8	 mov	 DWORD PTR _p$12[ebp], eax

; 1957 :           node_ = node_pointer();

  00108	83 65 90 00	 and	 DWORD PTR _a$2[ebp+4], 0

; 3194 :               bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);
; 3195 :             dummy_node = a.release();

  0010c	8b 45 b8	 mov	 eax, DWORD PTR _p$12[ebp]
  0010f	89 45 e4	 mov	 DWORD PTR _dummy_node$[ebp], eax

; 3196 :           } else {

  00112	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00116	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  00119	e8 00 00 00 00	 call	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
  0011e	eb 42		 jmp	 SHORT $LN6@create_buc
$LN7@create_buc:

; 3197 :             dummy_node = link_pointer();

  00120	83 65 e4 00	 and	 DWORD PTR _dummy_node$[ebp], 0

; 3198 :             buckets_ =

  00124	8b 45 08	 mov	 eax, DWORD PTR _new_count$[ebp]
  00127	40		 inc	 eax
  00128	89 45 d0	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0012b	c6 45 f1 01	 mov	 BYTE PTR __Overflow_is_possible$19[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0012f	c7 45 94 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$3[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00136	81 7d d0 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0013d	76 05		 jbe	 SHORT $LN77@create_buc

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0013f	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN77@create_buc:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00144	8b 45 d0	 mov	 eax, DWORD PTR __Count$[ebp]
  00147	c1 e0 02	 shl	 eax, 2
  0014a	89 45 b4	 mov	 DWORD PTR $T11[ebp], eax

; 686  :         return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));

  0014d	ff 75 b4	 push	 DWORD PTR $T11[ebp]
  00150	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00155	59		 pop	 ecx
  00156	89 45 b0	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 3198 :             buckets_ =

  00159	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0015c	8b 4d b0	 mov	 ecx, DWORD PTR $T10[ebp]
  0015f	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN6@create_buc:

; 3199 :               bucket_allocator_traits::allocate(bucket_alloc(), new_count + 1);
; 3200 :           }
; 3201 : 
; 3202 :           // nothrow from here...
; 3203 :           bucket_count_ = new_count;

  00162	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00165	8b 4d 08	 mov	 ecx, DWORD PTR _new_count$[ebp]
  00168	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 3204 :           recalculate_max_load();

  0016b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load

; 3205 : 
; 3206 :           bucket_pointer end =

  00173	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00176	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00179	8b 4d 08	 mov	 ecx, DWORD PTR _new_count$[ebp]
  0017c	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0017f	89 45 cc	 mov	 DWORD PTR _end$[ebp], eax

; 3207 :             buckets_ + static_cast<std::ptrdiff_t>(new_count);
; 3208 :           for (bucket_pointer i = buckets_; i != end; ++i) {

  00182	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00185	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00188	89 45 e8	 mov	 DWORD PTR _i$18[ebp], eax
  0018b	eb 09		 jmp	 SHORT $LN4@create_buc
$LN2@create_buc:
  0018d	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  00190	83 c0 04	 add	 eax, 4
  00193	89 45 e8	 mov	 DWORD PTR _i$18[ebp], eax
$LN4@create_buc:
  00196	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  00199	3b 45 cc	 cmp	 eax, DWORD PTR _end$[ebp]
  0019c	74 14		 je	 SHORT $LN3@create_buc
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  0019e	8b 45 e8	 mov	 eax, DWORD PTR _i$18[ebp]
  001a1	89 45 ac	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001a4	8b 45 ac	 mov	 eax, DWORD PTR $T9[ebp]
  001a7	89 45 a8	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2579 :         ptr_bucket() : next_(0) {}

  001aa	8b 45 a8	 mov	 eax, DWORD PTR $T8[ebp]
  001ad	83 20 00	 and	 DWORD PTR [eax], 0

; 3209 :             new ((void*)boost::to_address(i)) bucket();
; 3210 :           }

  001b0	eb db		 jmp	 SHORT $LN2@create_buc
$LN3@create_buc:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\core\pointer_traits.hpp

; 186  :     return v;

  001b2	8b 45 cc	 mov	 eax, DWORD PTR _end$[ebp]
  001b5	89 45 a4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001b8	8b 45 a4	 mov	 eax, DWORD PTR $T7[ebp]
  001bb	89 45 a0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2580 :         ptr_bucket(link_pointer n) : next_(n) {}

  001be	8b 45 a0	 mov	 eax, DWORD PTR $T6[ebp]
  001c1	8b 4d e4	 mov	 ecx, DWORD PTR _dummy_node$[ebp]
  001c4	89 08		 mov	 DWORD PTR [eax], ecx
$LN23@create_buc:

; 3211 :           new ((void*)boost::to_address(end)) bucket(dummy_node);
; 3212 :         }

  001c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d0	59		 pop	 ecx
  001d1	c9		 leave
  001d2	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z$0:
  00000	8d 4d 8c	 lea	 ecx, DWORD PTR _a$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$node_constructor@V?$allocator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@std@@@detail@unordered@boost@@QAE@XZ ; boost::unordered::detail::node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >::~node_constructor<std::allocator<boost::unordered::detail::ptr_node<std::pair<unsigned long const ,CEterFileDict::Item> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?create_buckets@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXI@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::create_buckets
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z
_TEXT	SEGMENT
tv91 = -40						; size = 8
_f$ = -32						; size = 8
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
tv81 = -12						; size = 4
tv87 = -8						; size = 4
$T3 = -4						; size = 4
_size$ = 8						; size = 4
?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size, COMDAT
; _this$ = ecx

; 3095 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3096 :           BOOST_ASSERT(mlf_ >= minimum_max_load_factor);
; 3097 : 
; 3098 :           using namespace std;
; 3099 : 
; 3100 :           // From insert/emplace requirements:
; 3101 :           //
; 3102 :           // size <= mlf_ * count
; 3103 :           // => count >= size / mlf_
; 3104 :           //
; 3105 :           // Or from rehash post-condition:
; 3106 :           //
; 3107 :           // count >= size / mlf_
; 3108 : 
; 3109 :           return policy::new_bucket_count(

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	f3 0f 5a 40 0c	 cvtss2sd xmm0, DWORD PTR [eax+12]
  00011	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR tv87[ebp], eax
  00017	f2 0f 2a 4d f8	 cvtsi2sd xmm1, DWORD PTR tv87[ebp]
  0001c	8b 45 f8	 mov	 eax, DWORD PTR tv87[ebp]
  0001f	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00022	f2 0f 58 0c c5
	00 00 00 00	 addsd	 xmm1, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0002b	f2 0f 5e c8	 divsd	 xmm1, xmm0
  0002f	51		 push	 ecx
  00030	51		 push	 ecx
  00031	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00036	e8 00 00 00 00	 call	 _floor
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
  0003d	dd 5d d8	 fstp	 QWORD PTR tv91[ebp]
  00040	f2 0f 10 45 d8	 movsd	 xmm0, QWORD PTR tv91[ebp]
  00045	f2 0f 58 05 00
	00 00 00	 addsd	 xmm0, QWORD PTR __real@3ff0000000000000
  0004d	f2 0f 11 45 e0	 movsd	 QWORD PTR _f$[ebp], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00052	83 4d ec ff	 or	 DWORD PTR $T2[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00056	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00059	89 45 f4	 mov	 DWORD PTR tv81[ebp], eax
  0005c	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR tv81[ebp]
  00061	8b 45 f4	 mov	 eax, DWORD PTR tv81[ebp]
  00064	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00067	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00070	f2 0f 10 4d e0	 movsd	 xmm1, QWORD PTR _f$[ebp]
  00075	66 0f 2f c8	 comisd	 xmm1, xmm0
  00079	72 0c		 jb	 SHORT $LN5@min_bucket
  0007b	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  0007e	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00081	83 4d fc ff	 or	 DWORD PTR $T3[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00085	eb 0d		 jmp	 SHORT $LN6@min_bucket
$LN5@min_bucket:
  00087	f2 0f 10 45 e0	 movsd	 xmm0, QWORD PTR _f$[ebp]
  0008c	e8 00 00 00 00	 call	 __dtoui3
  00091	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
$LN6@min_bucket:

; 2609 :           return boost::unordered::detail::next_prime(min);

  00094	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  00097	e8 00 00 00 00	 call	 ?next_prime@detail@unordered@boost@@YAII@Z ; boost::unordered::detail::next_prime
  0009c	59		 pop	 ecx

; 3110 :             boost::unordered::detail::double_to_size(
; 3111 :               floor(static_cast<double>(size) / static_cast<double>(mlf_)) +
; 3112 :               1));
; 3113 :         }

  0009d	c9		 leave
  0009e	c2 04 00	 ret	 4
?min_buckets_for_size@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEII@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::min_buckets_for_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ
_TEXT	SEGMENT
_f$ = -36						; size = 8
$T1 = -28						; size = 4
$T2 = -24						; size = 4
tv76 = -20						; size = 4
tv92 = -16						; size = 4
tv83 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load, COMDAT
; _this$ = ecx

; 3076 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3077 :           using namespace std;
; 3078 : 
; 3079 :           // From 6.3.1/13:
; 3080 :           // Only resize when size >= mlf_ * count
; 3081 :           max_load_ = buckets_ ? boost::unordered::detail::double_to_size(

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 00	 cmp	 DWORD PTR [eax+20], 0
  00010	0f 84 84 00 00
	00		 je	 $LN3@recalculat
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001c	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
  0001f	f2 0f 2a 45 f4	 cvtsi2sd xmm0, DWORD PTR tv83[ebp]
  00024	8b 45 f4	 mov	 eax, DWORD PTR tv83[ebp]
  00027	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0002a	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	f3 0f 5a 48 0c	 cvtss2sd xmm1, DWORD PTR [eax+12]
  0003b	f2 0f 59 c8	 mulsd	 xmm1, xmm0
  0003f	51		 push	 ecx
  00040	51		 push	 ecx
  00041	f2 0f 11 0c 24	 movsd	 QWORD PTR [esp], xmm1
  00046	e8 00 00 00 00	 call	 _ceil
  0004b	59		 pop	 ecx
  0004c	59		 pop	 ecx
  0004d	dd 5d dc	 fstp	 QWORD PTR _f$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  00050	83 4d e8 ff	 or	 DWORD PTR $T2[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00054	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00057	89 45 f0	 mov	 DWORD PTR tv92[ebp], eax
  0005a	f2 0f 2a 45 f0	 cvtsi2sd xmm0, DWORD PTR tv92[ebp]
  0005f	8b 45 f0	 mov	 eax, DWORD PTR tv92[ebp]
  00062	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00065	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0006e	f2 0f 10 4d dc	 movsd	 xmm1, QWORD PTR _f$[ebp]
  00073	66 0f 2f c8	 comisd	 xmm1, xmm0
  00077	72 0c		 jb	 SHORT $LN7@recalculat
  00079	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0007c	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 740  :         return UINT_MAX;

  0007f	83 4d f8 ff	 or	 DWORD PTR tv82[ebp], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2893 :         return f >= static_cast<double>(

  00083	eb 0d		 jmp	 SHORT $LN8@recalculat
$LN7@recalculat:
  00085	f2 0f 10 45 dc	 movsd	 xmm0, QWORD PTR _f$[ebp]
  0008a	e8 00 00 00 00	 call	 __dtoui3
  0008f	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
$LN8@recalculat:

; 3077 :           using namespace std;
; 3078 : 
; 3079 :           // From 6.3.1/13:
; 3080 :           // Only resize when size >= mlf_ * count
; 3081 :           max_load_ = buckets_ ? boost::unordered::detail::double_to_size(

  00092	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00095	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  00098	eb 04		 jmp	 SHORT $LN4@recalculat
$LN3@recalculat:
  0009a	83 65 ec 00	 and	 DWORD PTR tv76[ebp], 0
$LN4@recalculat:
  0009e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  000a4	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3082 :                                    ceil(static_cast<double>(mlf_) *
; 3083 :                                         static_cast<double>(bucket_count_)))
; 3084 :                                : 0;
; 3085 :         }

  000a7	c9		 leave
  000a8	c3		 ret	 0
?recalculate_max_load@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QAEXXZ ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::recalculate_max_load
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@I@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_prev$ = -12						; size = 4
_this$ = -8						; size = 4
tv72 = -4						; size = 4
_bucket_index$ = 8					; size = 4
?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@I@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin, COMDAT
; _this$ = ecx

; 3045 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3046 :           if (!size_)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	75 04		 jne	 SHORT $LN8@begin

; 3047 :             return node_pointer();

  00012	33 c0		 xor	 eax, eax
  00014	eb 2c		 jmp	 SHORT $LN1@begin
$LN8@begin:

; 3036 :           return get_bucket_pointer(bucket_index)->next_;

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _bucket_index$[ebp]
  0001f	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00022	89 45 f4	 mov	 DWORD PTR _prev$[ebp], eax

; 3048 :           link_pointer prev = get_previous_start(bucket_index);
; 3049 :           return prev ? next_node(prev) : node_pointer();

  00025	83 7d f4 00	 cmp	 DWORD PTR _prev$[ebp], 0
  00029	74 10		 je	 SHORT $LN4@begin
  0002b	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  0002e	89 45 fc	 mov	 DWORD PTR tv72[ebp], eax

; 2964 :           return static_cast<node_pointer>(n->next_);

  00031	8b 45 f4	 mov	 eax, DWORD PTR _prev$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 fc	 mov	 DWORD PTR tv72[ebp], eax

; 3048 :           link_pointer prev = get_previous_start(bucket_index);
; 3049 :           return prev ? next_node(prev) : node_pointer();

  00039	eb 04		 jmp	 SHORT $LN5@begin
$LN4@begin:
  0003b	83 65 fc 00	 and	 DWORD PTR tv72[ebp], 0
$LN5@begin:
  0003f	8b 45 fc	 mov	 eax, DWORD PTR tv72[ebp]
$LN1@begin:

; 3050 :         }

  00042	c9		 leave
  00043	c2 04 00	 ret	 4
?begin@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@QBEPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@I@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z
_TEXT	SEGMENT
tv84 = -8						; size = 4
_n2$ = -4						; size = 4
_n$ = 8							; size = 4
?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find, COMDAT

; 2968 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 2969 :           node_pointer n2 = static_cast<node_pointer>(n);

  00005	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR _n2$[ebp], eax
$LN4@next_for_f:

; 2964 :           return static_cast<node_pointer>(n->next_);

  0000b	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]
  0000e	8b 00		 mov	 eax, DWORD PTR [eax]
  00010	89 45 fc	 mov	 DWORD PTR _n2$[ebp], eax

; 2970 :           do {
; 2971 :             n2 = next_node(n2);
; 2972 :           } while (n2 && !n2->is_first_in_group());

  00013	83 7d fc 00	 cmp	 DWORD PTR _n2$[ebp], 0
  00017	74 20		 je	 SHORT $LN3@next_for_f

; 4878 :           return !(bucket_info_ & ~((std::size_t)-1 >> 1));

  00019	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00024	75 09		 jne	 SHORT $LN11@next_for_f
  00026	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv84[ebp], 1
  0002d	eb 04		 jmp	 SHORT $LN9@next_for_f
$LN11@next_for_f:
  0002f	83 65 f8 00	 and	 DWORD PTR tv84[ebp], 0
$LN9@next_for_f:

; 2970 :           do {
; 2971 :             n2 = next_node(n2);
; 2972 :           } while (n2 && !n2->is_first_in_group());

  00033	83 7d f8 00	 cmp	 DWORD PTR tv84[ebp], 0
  00037	74 d2		 je	 SHORT $LN4@next_for_f
$LN3@next_for_f:

; 2973 :           return n2;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _n2$[ebp]

; 2974 :         }

  0003c	c9		 leave
  0003d	c3		 ret	 0
?next_for_find@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_for_find
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z
_TEXT	SEGMENT
_n$ = 8							; size = 4
?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z PROC ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node, COMDAT

; 2963 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2964 :           return static_cast<node_pointer>(n->next_);

  00003	8b 45 08	 mov	 eax, DWORD PTR _n$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 2965 :         }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?next_node@?$table@U?$map@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@std@@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@2@@detail@unordered@boost@@@detail@unordered@boost@@SAPAU?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@234@PAUptr_bucket@234@@Z ENDP ; boost::unordered::detail::table<boost::unordered::detail::map<std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> >,unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long> > >::next_node
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ PROC ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::key_eq, COMDAT
; _this$ = ecx

; 2787 :         P const& key_eq() const { return current_functions().second(); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2791 :           return *static_cast<function_pair const*>(

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0000f	83 e0 01	 and	 eax, 1
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8d 44 01 01	 lea	 eax, DWORD PTR [ecx+eax+1]
  00019	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax

; 434  :           return static_cast<base2 const*>(this)->get();

  0001c	83 7d f8 00	 cmp	 DWORD PTR $T2[ebp], 0
  00020	74 09		 je	 SHORT $LN9@key_eq
  00022	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00025	40		 inc	 eax
  00026	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00029	eb 04		 jmp	 SHORT $LN7@key_eq
$LN9@key_eq:
  0002b	83 65 f4 00	 and	 DWORD PTR $T1[ebp], 0
$LN7@key_eq:

; 2787 :         P const& key_eq() const { return current_functions().second(); }

  0002f	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  00032	c9		 leave
  00033	c3		 ret	 0
?key_eq@?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QBEABU?$equal_to@K@std@@XZ ENDP ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::key_eq
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ??1?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QAE@XZ PROC ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::~functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >, COMDAT
; _this$ = ecx

; 2780 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2781 :           BOOST_ASSERT(!(current_ & 2));
; 2782 :           destroy_functions(current_);
; 2783 :         }

  00007	c9		 leave
  00008	c3		 ret	 0
??1?$functions@U?$hash@K@boost@@U?$equal_to@K@std@@@detail@unordered@boost@@QAE@XZ ENDP ; boost::unordered::detail::functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >::~functions<boost::hash<unsigned long>,std::equal_to<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?GetItem@CEterFileDict@@QAEPAUItem@1@KPBD@Z
_TEXT	SEGMENT
_iter_pair$ = -28					; size = 8
_this$ = -20						; size = 4
_item$1 = -16						; size = 4
tv86 = -12						; size = 4
_iter$ = -8						; size = 4
$T2 = -1						; size = 1
_dwFileNameHash$ = 8					; size = 4
_c_pszFileName$ = 12					; size = 4
?GetItem@CEterFileDict@@QAEPAUItem@1@KPBD@Z PROC	; CEterFileDict::GetItem, COMDAT
; _this$ = ecx

; 1588 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1589 : 	std::pair<TDict::iterator, TDict::iterator> iter_pair = m_dict.equal_range(dwFileNameHash);

  00009	8d 45 08	 lea	 eax, DWORD PTR _dwFileNameHash$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 e4	 lea	 eax, DWORD PTR _iter_pair$[ebp]
  00010	50		 push	 eax
  00011	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?equal_range@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$pair@U?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@unordered@boost@@U1234@@std@@ABK@Z ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::equal_range

; 1590 : 
; 1591 : 	TDict::iterator iter = iter_pair.first;

  00019	8b 45 e4	 mov	 eax, DWORD PTR _iter_pair$[ebp]
  0001c	89 45 f8	 mov	 DWORD PTR _iter$[ebp], eax
$LN2@GetItem:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2399 :           return node_ != x.node_;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _iter$[ebp]
  00022	3b 45 e8	 cmp	 eax, DWORD PTR _iter_pair$[ebp+4]
  00025	74 09		 je	 SHORT $LN8@GetItem
  00027	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv86[ebp], 1
  0002e	eb 04		 jmp	 SHORT $LN9@GetItem
$LN8@GetItem:
  00030	83 65 f4 00	 and	 DWORD PTR tv86[ebp], 0
$LN9@GetItem:
  00034	8a 45 f4	 mov	 al, BYTE PTR tv86[ebp]
  00037	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1593 : 	while (iter != iter_pair.second)

  0003a	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  0003e	85 c0		 test	 eax, eax
  00040	74 30		 je	 SHORT $LN3@GetItem

; 1594 : 	{
; 1595 : 		Item& item = iter->second;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _iter$[ebp]
  00045	83 c0 0c	 add	 eax, 12			; 0000000cH
  00048	89 45 f0	 mov	 DWORD PTR _item$1[ebp], eax

; 1596 : 
; 1597 : 		if (0 == strcmp(c_pszFileName, item.pkInfo->filename))

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _item$1[ebp]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00051	83 c0 04	 add	 eax, 4
  00054	50		 push	 eax
  00055	ff 75 0c	 push	 DWORD PTR _c_pszFileName$[ebp]
  00058	e8 00 00 00 00	 call	 _strcmp
  0005d	59		 pop	 ecx
  0005e	59		 pop	 ecx
  0005f	85 c0		 test	 eax, eax
  00061	75 05		 jne	 SHORT $LN4@GetItem

; 1598 : 			return &item;

  00063	8b 45 f0	 mov	 eax, DWORD PTR _item$1[ebp]
  00066	eb 0c		 jmp	 SHORT $LN1@GetItem
$LN4@GetItem:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2381 :           node_ = static_cast<node_pointer>(node_->next_);

  00068	8b 45 f8	 mov	 eax, DWORD PTR _iter$[ebp]
  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	89 45 f8	 mov	 DWORD PTR _iter$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1601 : 	}

  00070	eb ad		 jmp	 SHORT $LN2@GetItem
$LN3@GetItem:

; 1602 : 
; 1603 : 	return NULL;

  00072	33 c0		 xor	 eax, eax
$LN1@GetItem:

; 1604 : }

  00074	c9		 leave
  00075	c2 08 00	 ret	 8
?GetItem@CEterFileDict@@QAEPAUItem@1@KPBD@Z ENDP	; CEterFileDict::GetItem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?UpdateItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z
_TEXT	SEGMENT
$T1 = -64						; size = 12
_item$ = -52						; size = 8
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -24						; size = 4
$T8 = -20						; size = 4
_this$ = -16						; size = 4
tv64 = -12						; size = 4
_f$ = -8						; size = 4
$T9 = -1						; size = 1
_pkPack$ = 8						; size = 4
_pkInfo$ = 12						; size = 4
?UpdateItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z PROC ; CEterFileDict::UpdateItem, COMDAT
; _this$ = ecx

; 1564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.h

; 76   : 		Item() : pkPack(NULL), pkInfo(NULL) {}

  00009	83 65 cc 00	 and	 DWORD PTR _item$[ebp], 0
  0000d	83 65 d0 00	 and	 DWORD PTR _item$[ebp+4], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1567 : 	item.pkPack = pkPack;

  00011	8b 45 08	 mov	 eax, DWORD PTR _pkPack$[ebp]
  00014	89 45 cc	 mov	 DWORD PTR _item$[ebp], eax

; 1568 : 	item.pkInfo = pkInfo;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  0001a	89 45 d0	 mov	 DWORD PTR _item$[ebp+4], eax

; 1569 : 
; 1570 : 	TDict::iterator f = m_dict.find(pkInfo->filename_crc);

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  00020	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  00025	50		 push	 eax
  00026	8d 45 f8	 lea	 eax, DWORD PTR _f$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?find@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@23@ABK@Z ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::find
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2368 :         iterator() BOOST_NOEXCEPT : node_() {}

  00032	83 65 ec 00	 and	 DWORD PTR $T8[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1070 :       iterator end() BOOST_NOEXCEPT { return iterator(); }

  00036	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00039	89 45 e8	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 2394 :           return node_ == x.node_;

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T7[ebp]
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _f$[ebp]
  00042	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00044	75 09		 jne	 SHORT $LN17@UpdateItem
  00046	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv64[ebp], 1
  0004d	eb 04		 jmp	 SHORT $LN18@UpdateItem
$LN17@UpdateItem:
  0004f	83 65 f4 00	 and	 DWORD PTR tv64[ebp], 0
$LN18@UpdateItem:
  00053	8a 45 f4	 mov	 al, BYTE PTR tv64[ebp]
  00056	88 45 ff	 mov	 BYTE PTR $T9[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1571 : 	if (f == m_dict.end())	

  00059	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  0005d	85 c0		 test	 eax, eax
  0005f	74 3e		 je	 SHORT $LN132@UpdateItem

; 1572 : 		m_dict.insert(TDict::value_type(pkInfo->filename_crc, item));

  00061	8b 45 0c	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  00064	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00069	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0006c	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  0006f	8b 00		 mov	 eax, DWORD PTR [eax]
  00071	89 45 c0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00074	8d 45 cc	 lea	 eax, DWORD PTR _item$[ebp]
  00077	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  0007a	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  0007d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00082	89 4d c4	 mov	 DWORD PTR $T1[ebp+4], ecx
  00085	89 45 c8	 mov	 DWORD PTR $T1[ebp+8], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 213  :          { return static_cast<typename ::boost::move_detail::remove_reference<T>::type &&>(t); }

  00088	8d 45 c0	 lea	 eax, DWORD PTR $T1[ebp]
  0008b	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1248 :         return this->emplace(boost::move(x));

  0008e	ff 75 dc	 push	 DWORD PTR $T4[ebp]
  00091	8d 45 d4	 lea	 eax, DWORD PTR $T2[ebp]
  00094	50		 push	 eax
  00095	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ??$emplace@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@12@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@std@@@Z ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::emplace<std::pair<unsigned long const ,CEterFileDict::Item> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1572 : 		m_dict.insert(TDict::value_type(pkInfo->filename_crc, item));

  0009d	eb 54		 jmp	 SHORT $LN1@UpdateItem
$LN132@UpdateItem:
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 4869 :         value_type* value_ptr() { return value_base_.value_ptr(); }

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  000a2	83 c0 08	 add	 eax, 8

; 2377 :         value_type* operator->() const { return node_->value_ptr(); }

  000a5	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1575 : 		if (strcmp(f->second.pkInfo->filename, item.pkInfo->filename) == 0)

  000a8	8b 45 d0	 mov	 eax, DWORD PTR _item$[ebp+4]
  000ab	83 c0 04	 add	 eax, 4
  000ae	50		 push	 eax
  000af	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  000b2	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b5	83 c0 04	 add	 eax, 4
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 _strcmp
  000be	59		 pop	 ecx
  000bf	59		 pop	 ecx
  000c0	85 c0		 test	 eax, eax
  000c2	75 11		 jne	 SHORT $LN142@UpdateItem

; 1576 : 		{
; 1577 : 			f->second = item;

  000c4	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  000c7	8b 4d cc	 mov	 ecx, DWORD PTR _item$[ebp]
  000ca	8b 55 d0	 mov	 edx, DWORD PTR _item$[ebp+4]
  000cd	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  000d0	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1578 : 		}

  000d3	eb 1e		 jmp	 SHORT $LN1@UpdateItem
$LN142@UpdateItem:

; 1579 : 		else
; 1580 : 		{
; 1581 : 			TraceError("NAME_COLLISION: OLD: %s NEW: %s", f->second.pkInfo->filename, item.pkInfo->filename);			

  000d5	8b 45 d0	 mov	 eax, DWORD PTR _item$[ebp+4]
  000d8	83 c0 04	 add	 eax, 4
  000db	50		 push	 eax
  000dc	8b 45 f8	 mov	 eax, DWORD PTR _f$[ebp]
  000df	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000e2	83 c0 04	 add	 eax, 4
  000e5	50		 push	 eax
  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@GEOIKNCG@NAME_COLLISION?3?5OLD?3?5?$CFs?5NEW?3?5?$CFs@
  000eb	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@UpdateItem:

; 1582 : 		}
; 1583 : 		
; 1584 : 	}
; 1585 : }

  000f3	c9		 leave
  000f4	c2 08 00	 ret	 8
?UpdateItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z ENDP ; CEterFileDict::UpdateItem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp
;	COMDAT ?InsertItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 12
_item$ = -28						; size = 8
$T2 = -20						; size = 4
_this$ = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
$T5 = -4						; size = 4
_pkPack$ = 8						; size = 4
_pkInfo$ = 12						; size = 4
?InsertItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z PROC ; CEterFileDict::InsertItem, COMDAT
; _this$ = ecx

; 1554 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.h

; 76   : 		Item() : pkPack(NULL), pkInfo(NULL) {}

  00009	83 65 e4 00	 and	 DWORD PTR _item$[ebp], 0
  0000d	83 65 e8 00	 and	 DWORD PTR _item$[ebp+4], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1557 : 	item.pkPack = pkPack;

  00011	8b 45 08	 mov	 eax, DWORD PTR _pkPack$[ebp]
  00014	89 45 e4	 mov	 DWORD PTR _item$[ebp], eax

; 1558 : 	item.pkInfo = pkInfo;

  00017	8b 45 0c	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  0001a	89 45 e8	 mov	 DWORD PTR _item$[ebp+4], eax

; 1559 : 
; 1560 : 	m_dict.insert(TDict::value_type(pkInfo->filename_crc, item));

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _pkInfo$[ebp]
  00020	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00028	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00030	8d 45 e4	 lea	 eax, DWORD PTR _item$[ebp]
  00033	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 190  :         : first(_STD forward<_Other1>(_Val1)), second(_STD forward<_Other2>(_Val2)) {}

  00036	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 4d dc	 mov	 DWORD PTR $T1[ebp+4], ecx
  00041	89 45 e0	 mov	 DWORD PTR $T1[ebp+8], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\move\utility_core.hpp

; 213  :          { return static_cast<typename ::boost::move_detail::remove_reference<T>::type &&>(t); }

  00044	8d 45 d8	 lea	 eax, DWORD PTR $T1[ebp]
  00047	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\unordered_map.hpp

; 1248 :         return this->emplace(boost::move(x));

  0004a	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0004d	8d 45 ec	 lea	 eax, DWORD PTR $T2[ebp]
  00050	50		 push	 eax
  00051	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ??$emplace@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@?$unordered_multimap@KUItem@CEterFileDict@@U?$hash@K@boost@@U?$equal_to@K@std@@V?$allocator@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@6@@unordered@boost@@QAE?AU?$iterator@U?$ptr_node@U?$pair@$$CBKUItem@CEterFileDict@@@std@@@detail@unordered@boost@@@iterator_detail@12@$$QAU?$pair@$$CBKUItem@CEterFileDict@@@std@@@Z ; boost::unordered::unordered_multimap<unsigned long,CEterFileDict::Item,boost::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<std::pair<unsigned long const ,CEterFileDict::Item> > >::emplace<std::pair<unsigned long const ,CEterFileDict::Item> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\EterPack\EterPack.cpp

; 1561 : }

  00059	c9		 leave
  0005a	c2 08 00	 ret	 8
?InsertItem@CEterFileDict@@QAEXPAVCEterPack@@PAUSEterPackIndex@@@Z ENDP ; CEterFileDict::InsertItem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp
;	COMDAT ?next_prime@detail@unordered@boost@@YAII@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
_prime_list_end$ = -12					; size = 4
_prime_list_begin$ = -8					; size = 4
_bound$ = -4						; size = 4
_num$ = 8						; size = 4
?next_prime@detail@unordered@boost@@YAII@Z PROC		; boost::unordered::detail::next_prime, COMDAT

; 327  :       {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 328  :         std::size_t const* const prime_list_begin = prime_list::value;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _prime_list_begin$[ebp], OFFSET ?value@?$prime_list_template@I@detail@unordered@boost@@2QBIB ; boost::unordered::detail::prime_list_template<unsigned int>::value

; 329  :         std::size_t const* const prime_list_end =

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?length@?$prime_list_template@I@detail@unordered@boost@@2HB ; boost::unordered::detail::prime_list_template<unsigned int>::length
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _prime_list_begin$[ebp]
  00015	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00018	89 45 f4	 mov	 DWORD PTR _prime_list_end$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5873 :     return _STD lower_bound(_First, _Last, _Val, less<>{});

  0001b	33 c0		 xor	 eax, eax
  0001d	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	8d 45 08	 lea	 eax, DWORD PTR _num$[ebp]
  00026	50		 push	 eax
  00027	ff 75 f4	 push	 DWORD PTR _prime_list_end$[ebp]
  0002a	ff 75 f8	 push	 DWORD PTR _prime_list_begin$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$lower_bound@PBIIU?$less@X@std@@@std@@YAPBIPBIQBIABIU?$less@X@0@@Z ; std::lower_bound<unsigned int const *,unsigned int,std::less<void> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\unordered\detail\implementation.hpp

; 331  :         std::size_t const* bound =

  00035	89 45 fc	 mov	 DWORD PTR _bound$[ebp], eax

; 332  :           std::lower_bound(prime_list_begin, prime_list_end, num);
; 333  :         if (bound == prime_list_end)

  00038	8b 45 fc	 mov	 eax, DWORD PTR _bound$[ebp]
  0003b	3b 45 f4	 cmp	 eax, DWORD PTR _prime_list_end$[ebp]
  0003e	75 09		 jne	 SHORT $LN2@next_prime

; 334  :           bound--;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _bound$[ebp]
  00043	83 e8 04	 sub	 eax, 4
  00046	89 45 fc	 mov	 DWORD PTR _bound$[ebp], eax
$LN2@next_prime:

; 335  :         return *bound;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _bound$[ebp]
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]

; 336  :       }

  0004e	c9		 leave
  0004f	c3		 ret	 0
?next_prime@detail@unordered@boost@@YAII@Z ENDP		; boost::unordered::detail::next_prime
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\boost\container_hash\hash.hpp
;	COMDAT ??$hash_value@K@boost@@YAIK@Z
_TEXT	SEGMENT
_v$ = 8							; size = 4
??$hash_value@K@boost@@YAIK@Z PROC			; boost::hash_value<unsigned long>, COMDAT

; 359  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 360  :         return static_cast<std::size_t>(v);

  00003	8b 45 08	 mov	 eax, DWORD PTR _v$[ebp]

; 361  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$hash_value@K@boost@@YAIK@Z ENDP			; boost::hash_value<unsigned long>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>, COMDAT

; 582  : _NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 583  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 584  :     return _Static._Storage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 585  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G_Iostream_error_category2@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category2::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0000a	83 e0 01	 and	 eax, 1
  0000d	74 0c		 je	 SHORT $LN2@scalar
  0000f	6a 08		 push	 8
  00011	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx
$LN2@scalar:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category2::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
__Iostream_error_length$1 = -12				; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category2::message, COMDAT
; _this$ = ecx

; 475  :     _NODISCARD virtual string message(int _Errcode) const override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 65 fc 00	 and	 DWORD PTR $T2[ebp], 0

; 476  :         if (_Errcode == static_cast<int>(io_errc::stream)) {

  0000d	83 7d 0c 01	 cmp	 DWORD PTR __Errcode$[ebp], 1
  00011	75 26		 jne	 SHORT $LN2@message

; 477  :             static constexpr char _Iostream_error[] = "iostream stream error";
; 478  :             constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; // TRANSITION, DevCom-906503

  00013	c7 45 f4 15 00
	00 00		 mov	 DWORD PTR __Iostream_error_length$1[ebp], 21 ; 00000015H

; 479  :             return string(_Iostream_error, _Iostream_error_length);

  0001a	6a 15		 push	 21			; 00000015H
  0001c	68 00 00 00 00	 push	 OFFSET ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00029	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0002c	83 c8 01	 or	 eax, 1
  0002f	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	eb 20		 jmp	 SHORT $LN1@message

; 480  :         } else {

  00037	eb 1e		 jmp	 SHORT $LN1@message
$LN2@message:

; 481  :             return _Syserror_map(_Errcode);

  00039	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
  00041	59		 pop	 ecx
  00042	50		 push	 eax
  00043	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00046	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004b	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0004e	83 c8 01	 or	 eax, 1
  00051	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00054	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@message:

; 482  :         }
; 483  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category2::message
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ?name@_Iostream_error_category2@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category2@std@@UBEPBDXZ PROC	; std::_Iostream_error_category2::name, COMDAT
; _this$ = ecx

; 471  :     _NODISCARD virtual const char* name() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 472  :         return "iostream";

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 473  :     }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?name@_Iostream_error_category2@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category2::name
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 14		 push	 20			; 00000014H
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_System_error@std@@6B@
  00024	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00033	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7system_error@std@@6B@
  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	c9		 leave
  00043	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 14		 push	 20			; 00000014H
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_System_error@std@@6B@
  00024	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00027	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0002d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00030	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00033	89 42 10	 mov	 DWORD PTR [edx+16], eax
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c9		 leave
  0003a	c2 04 00	 ret	 4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
tv135 = -36						; size = 4
_this$ = -32						; size = 4
$T4 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 395  :     _System_error(error_code _Errcode, const string& _Message)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	83 65 d4 00	 and	 DWORD PTR $T2[ebp], 0

; 396  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  00017	83 ec 18	 sub	 esp, 24			; 00000018H
  0001a	8b cc		 mov	 ecx, esp
  0001c	89 65 d0	 mov	 DWORD PTR $T1[ebp], esp
  0001f	ff 75 10	 push	 DWORD PTR __Message$[ebp]
  00022	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00027	ff 75 0c	 push	 DWORD PTR __Errcode$[ebp+4]
  0002a	ff 75 08	 push	 DWORD PTR __Errcode$[ebp]
  0002d	8d 45 e4	 lea	 eax, DWORD PTR $T4[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
  00036	83 c4 24	 add	 esp, 36			; 00000024H
  00039	89 45 dc	 mov	 DWORD PTR tv135[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR tv135[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\stdexcept

; 111  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

  00042	8b 4d d8	 mov	 ecx, DWORD PTR $T3[ebp]
  00045	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0004a	50		 push	 eax
  0004b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBD@Z ; std::exception::exception
  00053	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0005c	8d 4d e4	 lea	 ecx, DWORD PTR $T4[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error

; 396  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  00064	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_System_error@std@@6B@
  0006d	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 4d 08	 mov	 ecx, DWORD PTR __Errcode$[ebp]
  00073	8b 55 0c	 mov	 edx, DWORD PTR __Errcode$[ebp+4]
  00076	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00079	89 50 10	 mov	 DWORD PTR [eax+16], edx
  0007c	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	33 cd		 xor	 ecx, ebp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	c9		 leave
  0008a	c2 0c 00	 ret	 12			; 0000000cH
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
tv84 = -72						; size = 4
tv79 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
tv93 = -48						; size = 4
$T6 = -41						; size = 1
$T7 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 385  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	83 65 cc 00	 and	 DWORD PTR $T5[ebp], 0
  0002c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3770 :         return _Mypair._Myval2._Mysize;

  00030	8b 45 24	 mov	 eax, DWORD PTR __Message$[ebp+16]
  00033	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax

; 3848 :         return size() == 0;

  00036	83 7d c8 00	 cmp	 DWORD PTR $T4[ebp], 0
  0003a	75 09		 jne	 SHORT $LN10@Makestr
  0003c	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv93[ebp], 1
  00043	eb 04		 jmp	 SHORT $LN11@Makestr
$LN10@Makestr:
  00045	83 65 d0 00	 and	 DWORD PTR tv93[ebp], 0
$LN11@Makestr:
  00049	8a 45 d0	 mov	 al, BYTE PTR tv93[ebp]
  0004c	88 45 d7	 mov	 BYTE PTR $T6[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error

; 386  :         if (!_Message.empty()) {

  0004f	0f b6 45 d7	 movzx	 eax, BYTE PTR $T6[ebp]
  00053	85 c0		 test	 eax, eax
  00055	75 24		 jne	 SHORT $LN2@Makestr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00057	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  0005c	e8 00 00 00 00	 call	 _strlen
  00061	59		 pop	 ecx
  00062	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00065	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  00068	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0006b	ff 75 c0	 push	 DWORD PTR $T2[ebp]
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00073	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00076	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error

; 390  :         _Message.append(_Errcode.message());

  0007b	8d 45 d8	 lea	 eax, DWORD PTR $T7[ebp]
  0007e	50		 push	 eax
  0007f	8d 4d 0c	 lea	 ecx, DWORD PTR __Errcode$[ebp]
  00082	e8 00 00 00 00	 call	 ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
  00087	89 45 bc	 mov	 DWORD PTR tv79[ebp], eax
  0008a	8b 45 bc	 mov	 eax, DWORD PTR tv79[ebp]
  0008d	89 45 b8	 mov	 DWORD PTR tv84[ebp], eax
  00090	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00094	ff 75 b8	 push	 DWORD PTR tv84[ebp]
  00097	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  0009a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0009f	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000a3	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  000a6	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error

; 391  :         return _Message;

  000ab	8d 45 14	 lea	 eax, DWORD PTR __Message$[ebp]
  000ae	50		 push	 eax
  000af	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000b2	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000b7	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  000ba	83 c8 01	 or	 eax, 1
  000bd	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
  000c0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  000c4	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  000c7	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error

; 391  :         return _Message;

  000cc	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 392  :     }

  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000dd	33 cd		 xor	 ecx, ebp
  000df	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e4	c9		 leave
  000e5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T7[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
tv78 = -12						; size = 4
tv83 = -8						; size = 4
$T5 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 248  :     _NODISCARD friend bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 236  :         return *_Mycat;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0000f	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00012	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 90   :         return _Addr == _Right._Addr;

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0001e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00021	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00024	75 09		 jne	 SHORT $LN13@operator
  00026	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv83[ebp], 1
  0002d	eb 04		 jmp	 SHORT $LN14@operator
$LN13@operator:
  0002f	83 65 f8 00	 and	 DWORD PTR tv83[ebp], 0
$LN14@operator:
  00033	8a 45 f8	 mov	 al, BYTE PTR tv83[ebp]
  00036	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 249  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

  00039	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  0003d	85 c0		 test	 eax, eax
  0003f	74 21		 je	 SHORT $LN3@operator

; 232  :         return _Myval;

  00041	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00044	8b 00		 mov	 eax, DWORD PTR [eax]
  00046	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  00049	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0004c	8b 00		 mov	 eax, DWORD PTR [eax]
  0004e	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 249  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

  00051	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  00054	3b 45 e4	 cmp	 eax, DWORD PTR $T1[ebp]
  00057	75 09		 jne	 SHORT $LN3@operator
  00059	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00060	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00062	83 65 f4 00	 and	 DWORD PTR tv78[ebp], 0
$LN4@operator:
  00066	8a 45 f4	 mov	 al, BYTE PTR tv78[ebp]

; 250  :     }

  00069	c9		 leave
  0006a	c3		 ret	 0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
tv67 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 159  :     _NODISCARD string message() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	83 65 f4 00	 and	 DWORD PTR $T3[ebp], 0

; 160  :         return category().message(value());

  0000d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00010	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax

; 154  :         return *_Mycat;

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00019	89 45 fc	 mov	 DWORD PTR tv67[ebp], eax

; 150  :         return _Myval;

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 00		 mov	 eax, DWORD PTR [eax]
  00021	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 160  :         return category().message(value());

  00024	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  00027	ff 75 08	 push	 DWORD PTR ___$ReturnUdt$[ebp]
  0002a	8b 45 fc	 mov	 eax, DWORD PTR tv67[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR tv67[ebp]
  00032	ff 50 08	 call	 DWORD PTR [eax+8]
  00035	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00038	83 c8 01	 or	 eax, 1
  0003b	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 161  :     }

  00041	c9		 leave
  00042	c2 04 00	 ret	 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
_this$ = -16						; size = 4
tv74 = -12						; size = 4
tv79 = -8						; size = 4
$T3 = -1						; size = 1
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 333  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 154  :         return *_Mycat;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Code$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 90   :         return _Addr == _Right._Addr;

  00012	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00018	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001b	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0001e	75 09		 jne	 SHORT $LN10@equivalent
  00020	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  00027	eb 04		 jmp	 SHORT $LN11@equivalent
$LN10@equivalent:
  00029	83 65 f8 00	 and	 DWORD PTR tv79[ebp], 0
$LN11@equivalent:
  0002d	8a 45 f8	 mov	 al, BYTE PTR tv79[ebp]
  00030	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 334  :     return *this == _Code.category() && _Code.value() == _Errval;

  00033	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00037	85 c0		 test	 eax, eax
  00039	74 19		 je	 SHORT $LN3@equivalent

; 150  :         return _Myval;

  0003b	8b 45 08	 mov	 eax, DWORD PTR __Code$[ebp]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 334  :     return *this == _Code.category() && _Code.value() == _Errval;

  00043	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]
  00046	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  00049	75 09		 jne	 SHORT $LN3@equivalent
  0004b	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00052	eb 04		 jmp	 SHORT $LN4@equivalent
$LN3@equivalent:
  00054	83 65 f4 00	 and	 DWORD PTR tv74[ebp], 0
$LN4@equivalent:
  00058	8a 45 f4	 mov	 al, BYTE PTR tv74[ebp]

; 335  : }

  0005b	c9		 leave
  0005c	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 329  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 330  :     return default_error_condition(_Errval) == _Cond;

  00009	ff 75 0c	 push	 DWORD PTR __Cond$[ebp]
  0000c	ff 75 08	 push	 DWORD PTR __Errval$[ebp]
  0000f	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00012	50		 push	 eax
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	ff 50 0c	 call	 DWORD PTR [eax+12]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ??8std@@YA_NABVerror_condition@0@0@Z ; std::operator==
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx

; 331  : }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 324  : _NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00007	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 325  :     // make error_condition for error code
; 326  :     return error_condition(_Errval, *this);

  00018	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 327  : }

  0001b	c9		 leave
  0001c	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 348  : _NODISCARD inline error_code make_error_code(io_errc _Errno) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 612  :     return _Immortalize_memcpy_image<_Iostream_error_category2>();

  00004	e8 00 00 00 00	 call	 ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
  00009	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax

; 126  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  0000c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Errno$[ebp]
  00012	89 08		 mov	 DWORD PTR [eax], ecx
  00014	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00017	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001a	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 349  :     return error_code(static_cast<int>(_Errno), _STD iostream_category());

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 350  : }

  00020	c9		 leave
  00021	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 64   : [[noreturn]] inline void _Throw_bad_cast() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 65   :     _THROW(bad_cast{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  0000e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 66   : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 135  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_08EPJLHIJG@bad?5cast@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_typeinfo.h

; 135  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@

; 136  :     }

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c9		 leave
  00034	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -4						; size = 2
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 37		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ; std::_Destroy_in_place<wchar_t *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	8b 45 ec	 mov	 eax, DWORD PTR __Count$[ebp]
  00057	d1 e0		 shl	 eax, 1
  00059	50		 push	 eax
  0005a	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00075	33 c0		 xor	 eax, eax
  00077	66 89 45 fc	 mov	 WORD PTR $T4[ebp], ax
  0007b	6a 02		 push	 2
  0007d	58		 pop	 eax
  0007e	6b c0 00	 imul	 eax, eax, 0

; 281  :         _Left = _Right;

  00081	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	66 8b 55 fc	 mov	 dx, WORD PTR $T4[ebp]
  00088	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 4396 :     }

  0008c	c9		 leave
  0008d	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	33 c0		 xor	 eax, eax
  0001b	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
  0001f	6a 02		 push	 2
  00021	58		 pop	 eax
  00022	6b c0 00	 imul	 eax, eax, 0

; 281  :         _Left = _Right;

  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	66 8b 55 fe	 mov	 dx, WORD PTR $T1[ebp]
  0002c	66 89 14 01	 mov	 WORD PTR [ecx+eax], dx

; 4381 :     }

  00030	c9		 leave
  00031	c3		 ret	 0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Left$ = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -2						; size = 2
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 4372 :     void _Eos(const size_type _Newsize) { // set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4373 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00009	33 c0		 xor	 eax, eax
  0000b	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00015	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00023	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00026	89 45 f4	 mov	 DWORD PTR __Left$[ebp], eax

; 281  :         _Left = _Right;

  00029	8b 45 f4	 mov	 eax, DWORD PTR __Left$[ebp]
  0002c	66 8b 4d fe	 mov	 cx, WORD PTR $T1[ebp]
  00030	66 89 08	 mov	 WORD PTR [eax], cx

; 4374 :     }

  00033	c9		 leave
  00034	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 07	 or	 eax, 7
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
__Ptr$ = -40						; size = 4
__Ptr$ = -36						; size = 4
_this$ = -32						; size = 4
__Result$3 = -28					; size = 4
tv137 = -24						; size = 4
__Result$4 = -20					; size = 4
tv95 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare, COMDAT
; _this$ = ecx

; 4212 :     _NODISCARD int compare(const basic_string& _Right) const noexcept { // compare [0, size()) with _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Result$4[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0001c	72 09		 jb	 SHORT $LN9@compare
  0001e	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@compare
$LN9@compare:
  00027	83 65 f0 00	 and	 DWORD PTR tv95[ebp], 0
$LN10@compare:
  0002b	8a 45 f0	 mov	 al, BYTE PTR tv95[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T6[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 ec	 mov	 DWORD PTR __Result$4[ebp], eax
$LN4@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 ec	 mov	 eax, DWORD PTR __Result$4[ebp]
  0004a	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  0004d	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00050	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  00053	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00056	89 45 e4	 mov	 DWORD PTR __Result$3[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00060	72 09		 jb	 SHORT $LN21@compare
  00062	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
  00069	eb 04		 jmp	 SHORT $LN22@compare
$LN21@compare:
  0006b	83 65 e8 00	 and	 DWORD PTR tv137[ebp], 0
$LN22@compare:
  0006f	8a 45 e8	 mov	 al, BYTE PTR tv137[ebp]
  00072	88 45 fe	 mov	 BYTE PTR $T5[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00075	0f b6 45 fe	 movzx	 eax, BYTE PTR $T5[ebp]
  00079	85 c0		 test	 eax, eax
  0007b	74 0e		 je	 SHORT $LN16@compare

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  0007d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	89 45 d8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00085	8b 45 d8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00088	89 45 e4	 mov	 DWORD PTR __Result$3[ebp], eax
$LN16@compare:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  0008b	8b 45 e4	 mov	 eax, DWORD PTR __Result$3[ebp]
  0008e	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax

; 4213 :         return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00091	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00094	ff 70 10	 push	 DWORD PTR [eax+16]
  00097	ff 75 d4	 push	 DWORD PTR $T2[ebp]
  0009a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	ff 70 10	 push	 DWORD PTR [eax+16]
  000a0	ff 75 d0	 push	 DWORD PTR $T1[ebp]
  000a3	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z ; std::_Traits_compare<std::char_traits<wchar_t> >
  000a8	83 c4 10	 add	 esp, 16			; 00000010H

; 4214 :             _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 4215 :     }

  000ab	c9		 leave
  000ac	c2 04 00	 ret	 4
?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::compare
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 1
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
$T7 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::swap, COMDAT
; _this$ = ecx

; 3915 :     void swap(basic_string& _Right) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0002b	89 45 ec	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3916 :         if (this != _STD addressof(_Right)) {

  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	3b 45 ec	 cmp	 eax, DWORD PTR $T7[ebp]
  00034	74 25		 je	 SHORT $LN2@swap

; 4409 :         return _Mypair._Get_first();

  00036	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00039	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax
  00042	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00045	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00048	8b 45 e4	 mov	 eax, DWORD PTR $T5[ebp]
  0004b	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax

; 3917 :             _Pocs(_Getal(), _Right._Getal());

  0004e	ff 75 e0	 push	 DWORD PTR $T4[ebp]
  00051	ff 75 dc	 push	 DWORD PTR $T3[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Pocs@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ; std::_Pocs<std::allocator<wchar_t> >
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx
$LN2@swap:

; 3918 : 
; 3919 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3920 :             const bool _My_large    = _Mypair._Myval2._Large_string_engaged();
; 3921 :             const bool _Right_large = _Right._Mypair._Myval2._Large_string_engaged();
; 3922 :             if (!_My_large) {
; 3923 :                 _Mypair._Myval2._Orphan_all();
; 3924 :             }
; 3925 : 
; 3926 :             if (!_Right_large) {
; 3927 :                 _Right._Mypair._Myval2._Orphan_all();
; 3928 :             }
; 3929 : 
; 3930 :             if (_My_large || _Right_large) {
; 3931 :                 _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
; 3932 :             }
; 3933 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3934 :         }
; 3935 : 
; 3936 :         _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});

  0005b	33 c0		 xor	 eax, eax
  0005d	88 45 d8	 mov	 BYTE PTR $T2[ebp], al
  00060	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  00063	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  00066	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	e8 00 00 00 00	 call	 ?_Swap_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_data

; 3937 :     }

  0006e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00078	59		 pop	 ecx
  00079	c9		 leave
  0007a	c2 04 00	 ret	 4
  0007d	cc		 int	 3
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?swap@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::swap
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Swap_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -40						; size = 4
__Right_data_mem$ = -36					; size = 4
__My_data_mem$ = -32					; size = 4
__Temp_mem$ = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Swap_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_data, COMDAT
; _this$ = ecx

; 3868 :     void _Swap_data(basic_string& _Right, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 3869 :         // exchange _String_val instances with _Right, memcpy optimization
; 3870 :         const auto _My_data_mem =

  00013	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00016	89 45 e0	 mov	 DWORD PTR __My_data_mem$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3872 :         const auto _Right_data_mem =

  00019	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001c	89 45 dc	 mov	 DWORD PTR __Right_data_mem$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3875 :         _CSTD memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);

  0001f	6a 18		 push	 24			; 00000018H
  00021	ff 75 e0	 push	 DWORD PTR __My_data_mem$[ebp]
  00024	8d 45 e4	 lea	 eax, DWORD PTR __Temp_mem$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 _memcpy
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3876 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00030	6a 18		 push	 24			; 00000018H
  00032	ff 75 dc	 push	 DWORD PTR __Right_data_mem$[ebp]
  00035	ff 75 e0	 push	 DWORD PTR __My_data_mem$[ebp]
  00038	e8 00 00 00 00	 call	 _memcpy
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3877 :         _CSTD memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);

  00040	6a 18		 push	 24			; 00000018H
  00042	8d 45 e4	 lea	 eax, DWORD PTR __Temp_mem$[ebp]
  00045	50		 push	 eax
  00046	ff 75 dc	 push	 DWORD PTR __Right_data_mem$[ebp]
  00049	e8 00 00 00 00	 call	 _memcpy
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3878 :     }

  00051	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00054	33 cd		 xor	 ecx, ebp
  00056	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005b	c9		 leave
  0005c	c2 08 00	 ret	 8
?_Swap_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXAAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_data
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR __Alloc_max$[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  0001c	c7 45 fc 08 00
	00 00		 mov	 DWORD PTR $T10[ebp], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00023	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00026	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00029	73 08		 jae	 SHORT $LN14@max_size
  0002b	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002e	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  00031	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00033	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00036	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00039	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  0003c	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003f	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  00042	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00045	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004d	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  00050	48		 dec	 eax
  00051	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00054	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0005b	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005e	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00061	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00064	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00067	73 08		 jae	 SHORT $LN22@max_size
  00069	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  0006c	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006f	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  00071	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00074	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00077	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  0007a	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007d	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  00080	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00083	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00086	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00088	c9		 leave
  00089	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data, COMDAT
; _this$ = ecx

; 3755 :     _NODISCARD _Ret_z_ const _Elem* data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3756 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  0001c	72 09		 jb	 SHORT $LN9@data
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@data
$LN9@data:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@data:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@data

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@data:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3756 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3757 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
__Ptr$2 = -16						; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -2						; size = 2
__Ch$ = 8						; size = 2
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back, COMDAT
; _this$ = ecx

; 3691 :     void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3692 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 3693 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00018	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0001b	73 3a		 jae	 SHORT $LN2@push_back

; 3694 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0001d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00020	40		 inc	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3695 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  0002f	89 45 f0	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 281  :         _Left = _Right;

  00032	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00035	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$2[ebp]
  00038	66 8b 55 08	 mov	 dx, WORD PTR __Ch$[ebp]
  0003c	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx

; 3696 :             _Traits::assign(_Ptr[_Old_size], _Ch);
; 3697 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00040	33 c0		 xor	 eax, eax
  00042	66 89 45 fe	 mov	 WORD PTR $T3[ebp], ax

; 281  :         _Left = _Right;

  00046	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00049	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$2[ebp]
  0004c	66 8b 55 fe	 mov	 dx, WORD PTR $T3[ebp]
  00050	66 89 54 41 02	 mov	 WORD PTR [ecx+eax*2+2], dx

; 3698 :             return;

  00055	eb 15		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 3699 :         }
; 3700 : 
; 3701 :         _Reallocate_grow_by(

  00057	33 c0		 xor	 eax, eax
  00059	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  0005c	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  0005f	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00062	6a 01		 push	 1
  00064	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
$LN1@push_back:

; 3702 :             1,
; 3703 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3704 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3705 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3707 :             },
; 3708 :             _Ch);
; 3709 :     }

  0006c	c9		 leave
  0006d	c2 04 00	 ret	 4
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Max_possible$1 = -88					; size = 4
__Al$ = -84						; size = 4
$T2 = -80						; size = 4
__Ptr$ = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
__First1$ = -52						; size = 4
__New_capacity$ = -48					; size = 4
__Right_ptr$ = -44					; size = 4
__New_array$ = -40					; size = 4
__Count$ = -36						; size = 4
tv144 = -32						; size = 4
$T8 = -28						; size = 4
$T9 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__Right_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$10 = -1				; size = 1
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2728 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2729 :         // assign by copying data stored in _Right
; 2730 :         // pre: this != &_Right
; 2731 :         // pre: *this owns no memory, iterators orphaned (note:
; 2732 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2733 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2734 :         const size_type _Right_size   = _Right_data._Mysize;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2735 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00020	89 45 d4	 mov	 DWORD PTR __Right_ptr$[ebp], eax

; 2736 :         auto& _My_data                = _Mypair._Myval2;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2737 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00029	83 7d f4 08	 cmp	 DWORD PTR __Right_size$[ebp], 8
  0002d	73 32		 jae	 SHORT $LN2@Construct_

; 2738 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00032	89 45 cc	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	6a 08		 push	 8
  00037	58		 pop	 eax
  00038	d1 e0		 shl	 eax, 1
  0003a	50		 push	 eax
  0003b	ff 75 d4	 push	 DWORD PTR __Right_ptr$[ebp]
  0003e	ff 75 cc	 push	 DWORD PTR __First1$[ebp]
  00041	e8 00 00 00 00	 call	 _memcpy
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2739 :             _My_data._Mysize = _Right_size;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004c	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0004f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2740 :             _My_data._Myres  = _BUF_SIZE - 1;

  00052	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00055	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 2741 :             return;

  0005c	e9 c6 00 00 00	 jmp	 $LN61@Construct_
$LN2@Construct_:

; 4409 :         return _Mypair._Get_first();

  00061	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00064	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00067	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  0006a	89 45 ac	 mov	 DWORD PTR __Al$[ebp], eax

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0006d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00075	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
  00078	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  0007b	83 c8 07	 or	 eax, 7
  0007e	89 45 e4	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00081	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  00084	3b 45 e4	 cmp	 eax, DWORD PTR $T8[ebp]
  00087	73 08		 jae	 SHORT $LN52@Construct_
  00089	8d 45 e8	 lea	 eax, DWORD PTR $T9[ebp]
  0008c	89 45 e0	 mov	 DWORD PTR tv144[ebp], eax
  0008f	eb 06		 jmp	 SHORT $LN53@Construct_
$LN52@Construct_:
  00091	8d 45 e4	 lea	 eax, DWORD PTR $T8[ebp]
  00094	89 45 e0	 mov	 DWORD PTR tv144[ebp], eax
$LN53@Construct_:
  00097	8b 45 e0	 mov	 eax, DWORD PTR tv144[ebp]
  0009a	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
  0009d	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000a0	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  000a3	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	89 45 d0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ab	8b 45 d0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  000ae	40		 inc	 eax
  000af	89 45 dc	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000b2	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$10[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000b6	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 60   :         if (_Count > _Max_possible) {

  000bd	81 7d dc ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  000c4	76 05		 jbe	 SHORT $LN58@Construct_

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000c6	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN58@Construct_:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000cb	8b 45 dc	 mov	 eax, DWORD PTR __Count$[ebp]
  000ce	d1 e0		 shl	 eax, 1
  000d0	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000d3	ff 75 bc	 push	 DWORD PTR $T4[ebp]
  000d6	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000db	59		 pop	 ecx
  000dc	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000df	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
  000e2	89 45 d8	 mov	 DWORD PTR __New_array$[ebp], eax

; 2747 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000e5	8d 45 d8	 lea	 eax, DWORD PTR __New_array$[ebp]
  000e8	50		 push	 eax
  000e9	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000ec	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  000f1	59		 pop	 ecx
  000f2	59		 pop	 ecx

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000f3	8b 45 d8	 mov	 eax, DWORD PTR __New_array$[ebp]
  000f6	89 45 b4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f9	8b 45 b4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000fc	89 45 b0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ff	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00102	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00106	50		 push	 eax
  00107	ff 75 d4	 push	 DWORD PTR __Right_ptr$[ebp]
  0010a	ff 75 b0	 push	 DWORD PTR $T2[ebp]
  0010d	e8 00 00 00 00	 call	 _memcpy
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 :         _My_data._Mysize = _Right_size;

  00115	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00118	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0011b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2750 :         _My_data._Myres  = _New_capacity;

  0011e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00121	8b 4d d0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00124	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN61@Construct_:

; 2751 :     }

  00127	c9		 leave
  00128	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z
_TEXT	SEGMENT
__My_data_mem$1 = -36					; size = 4
__Right_data_mem$2 = -32				; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign, COMDAT
; _this$ = ecx

; 2636 :     void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2637 :         _Tidy_deallocate();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 4409 :         return _Mypair._Get_first();

  00011	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00017	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  0001a	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00020	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00023	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00026	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 2638 :         _Pocma(_Getal(), _Right._Getal());

  00029	ff 75 e8	 push	 DWORD PTR $T4[ebp]
  0002c	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ; std::_Pocma<std::allocator<wchar_t> >
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx

; 2639 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00036	33 c0		 xor	 eax, eax
  00038	88 45 ff	 mov	 BYTE PTR $T7[ebp], al
  0003b	8a 45 ff	 mov	 al, BYTE PTR $T7[ebp]
  0003e	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00041	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00044	89 45 dc	 mov	 DWORD PTR __My_data_mem$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00047	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0004a	89 45 e0	 mov	 DWORD PTR __Right_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004d	6a 18		 push	 24			; 00000018H
  0004f	ff 75 e0	 push	 DWORD PTR __Right_data_mem$2[ebp]
  00052	ff 75 dc	 push	 DWORD PTR __My_data_mem$1[ebp]
  00055	e8 00 00 00 00	 call	 _memcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2640 :     }

  00065	c9		 leave
  00066	c2 08 00	 ret	 8
?_Move_assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@U_Equal_allocators@2@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Move_assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S5$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00031	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00052	8d 45 f3	 lea	 eax, DWORD PTR _$S5$[ebp]
  00055	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);

  00058	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents

; 2355 :         _Proxy._Release();
; 2356 :     }

  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran, COMDAT

; 2242 :     [[noreturn]] static void _Xran() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2243 :         _Xout_of_range("invalid string position");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2244 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 08	 cmp	 DWORD PTR [eax+20], 8
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$ = -32						; size = 4
__Count$ = -28						; size = 4
__First1$ = -24						; size = 4
$T1 = -20						; size = 4
__Count$ = -16						; size = 4
$T2 = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT
; _this$ = ecx

; 4359 :     void _Become_small() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4360 :         // release any held storage and return to small string mode
; 4361 :         // pre: *this is in large string mode
; 4362 :         // pre: this is small enough to return to small string mode
; 4363 :         _Mypair._Myval2._Orphan_all();
; 4364 :         const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00017	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  0001a	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax

; 4365 :         auto& _Al          = _Getal();
; 4366 :         _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  0001d	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4367 :         _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00032	40		 inc	 eax
  00033	89 45 f0	 mov	 DWORD PTR __Count$[ebp], eax
  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	89 45 e8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0003c	ff 75 f0	 push	 DWORD PTR __Count$[ebp]
  0003f	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00042	ff 75 e8	 push	 DWORD PTR __First1$[ebp]
  00045	e8 00 00 00 00	 call	 _memcpy
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4368 :         _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00053	40		 inc	 eax
  00054	89 45 e4	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00057	ff 75 e4	 push	 DWORD PTR __Count$[ebp]
  0005a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00062	59		 pop	 ecx
  00063	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4369 :         _Mypair._Myval2._Myres = _BUF_SIZE - 1;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4370 :     }

  0006e	c9		 leave
  0006f	c3		 ret	 0
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
tv131 = -16						; size = 4
__Old_size$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 3817 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap = 0) { // determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3818 :         if (_Mypair._Myval2._Mysize > _Newcap) { // requested capacity is not large enough for current size, ignore

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	3b 45 08	 cmp	 eax, DWORD PTR __Newcap$[ebp]
  00012	76 02		 jbe	 SHORT $LN2@reserve

; 3819 :             return; // nothing to do

  00014	eb 75		 jmp	 SHORT $LN1@reserve
$LN2@reserve:

; 3820 :         }
; 3821 : 
; 3822 :         if (_Mypair._Myval2._Myres == _Newcap) { // we're already at the requested capacity

  00016	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Newcap$[ebp]
  0001f	75 02		 jne	 SHORT $LN3@reserve

; 3823 :             return; // nothing to do

  00021	eb 68		 jmp	 SHORT $LN1@reserve
$LN3@reserve:

; 3824 :         }
; 3825 : 
; 3826 :         if (_Mypair._Myval2._Myres < _Newcap) { // reallocate to grow

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00029	3b 45 08	 cmp	 eax, DWORD PTR __Newcap$[ebp]
  0002c	73 2b		 jae	 SHORT $LN4@reserve

; 3827 :             const size_type _Old_size = _Mypair._Myval2._Mysize;

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00034	89 45 f4	 mov	 DWORD PTR __Old_size$2[ebp], eax

; 3828 :             _Reallocate_grow_by(

  00037	33 c0		 xor	 eax, eax
  00039	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  0003c	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR __Newcap$[ebp]
  00042	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$2[ebp]
  00045	50		 push	 eax
  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >

; 3829 :                 _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
; 3830 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3831 :                 });
; 3832 : 
; 3833 :             _Mypair._Myval2._Mysize = _Old_size;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$2[ebp]
  00054	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3834 :             return;

  00057	eb 32		 jmp	 SHORT $LN1@reserve
$LN4@reserve:

; 3835 :         }
; 3836 : 
; 3837 :         if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {

  00059	83 7d 08 10	 cmp	 DWORD PTR __Newcap$[ebp], 16 ; 00000010H
  0005d	73 2c		 jae	 SHORT $LN1@reserve

; 2227 :         return _BUF_SIZE <= _Myres;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00062	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00066	72 09		 jb	 SHORT $LN9@reserve
  00068	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv131[ebp], 1
  0006f	eb 04		 jmp	 SHORT $LN10@reserve
$LN9@reserve:
  00071	83 65 f0 00	 and	 DWORD PTR tv131[ebp], 0
$LN10@reserve:
  00075	8a 45 f0	 mov	 al, BYTE PTR tv131[ebp]
  00078	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 3835 :         }
; 3836 : 
; 3837 :         if (_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged()) {

  0007b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  0007f	85 c0		 test	 eax, eax
  00081	74 08		 je	 SHORT $LN1@reserve

; 3838 :             // deallocate everything; switch back to "small" mode
; 3839 :             _Become_small();

  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
$LN1@reserve:

; 3840 :             return;
; 3841 :         }
; 3842 : 
; 3843 :         // ignore requests to reserve to [_BUF_SIZE, _Myres)
; 3844 :     }

  0008b	c9		 leave
  0008c	c2 04 00	 ret	 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 3755 :     _NODISCARD _Ret_z_ const _Elem* data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3756 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@data
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@data
$LN9@data:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@data:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@data

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@data:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3756 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3757 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv82 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front, COMDAT
; _this$ = ecx

; 3719 :     _NODISCARD reference front() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3720 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3721 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3722 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3723 : 
; 3724 :         return _Mypair._Myval2._Myptr()[0];

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@front
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@front
$LN9@front:
  00027	83 65 f4 00	 and	 DWORD PTR tv82[ebp], 0
$LN10@front:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv82[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@front

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@front:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3720 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3721 :         _STL_VERIFY(_Mypair._Myval2._Mysize != 0, "front() called on empty string");
; 3722 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3723 : 
; 3724 :         return _Mypair._Myval2._Myptr()[0];

  0004d	33 c0		 xor	 eax, eax
  0004f	40		 inc	 eax
  00050	6b c0 00	 imul	 eax, eax, 0
  00053	03 45 e4	 add	 eax, DWORD PTR $T1[ebp]

; 3725 :     }

  00056	c9		 leave
  00057	c3		 ret	 0
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
__Ptr$2 = -16						; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 3691 :     void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3692 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 3693 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00018	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  0001b	73 32		 jae	 SHORT $LN2@push_back

; 3694 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0001d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00020	40		 inc	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3695 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0002f	89 45 f0	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 428  :         _Left = _Right;

  00032	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$2[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  00038	8a 4d 08	 mov	 cl, BYTE PTR __Ch$[ebp]
  0003b	88 08		 mov	 BYTE PTR [eax], cl

; 3696 :             _Traits::assign(_Ptr[_Old_size], _Ch);
; 3697 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0003d	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$2[ebp]
  00044	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  00047	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  0004a	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 3698 :             return;

  0004d	eb 15		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 3699 :         }
; 3700 : 
; 3701 :         _Reallocate_grow_by(

  0004f	33 c0		 xor	 eax, eax
  00051	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  00054	ff 75 08	 push	 DWORD PTR __Ch$[ebp]
  00057	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0005a	6a 01		 push	 1
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN1@push_back:

; 3702 :             1,
; 3703 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 3704 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3705 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 3706 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 3707 :             },
; 3708 :             _Ch);
; 3709 :     }

  00064	c9		 leave
  00065	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv82 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 3670 :     _NODISCARD reference operator[](const size_type _Off) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3671 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3672 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3673 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3674 :         return _Mypair._Myval2._Myptr()[_Off];

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@operator
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@operator
$LN9@operator:
  00027	83 65 f4 00	 and	 DWORD PTR tv82[ebp], 0
$LN10@operator:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv82[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@operator

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3671 : #if _CONTAINER_DEBUG_LEVEL > 0
; 3672 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 3673 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 3674 :         return _Mypair._Myval2._Myptr()[_Off];

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00050	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]

; 3675 :     }

  00053	c9		 leave
  00054	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV12@II@Z
_TEXT	SEGMENT
__Old_size$ = -60					; size = 4
__My_ptr$ = -56						; size = 4
__Ptr$ = -52						; size = 4
$T1 = -48						; size = 4
$T2 = -44						; size = 4
__Erase_at$ = -40					; size = 4
__New_size$ = -36					; size = 4
__Result$3 = -32					; size = 4
tv133 = -28						; size = 4
tv94 = -24						; size = 4
__Size$ = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T5 = -1						; size = 1
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept, COMDAT
; _this$ = ecx

; 3294 :     basic_string& _Erase_noexcept(const size_type _Off, size_type _Count) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3295 :         _Count                    = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Size$[ebp], eax

; 2248 :         return (_STD min)(_Size, _Mysize - _Off);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001e	3b 45 ec	 cmp	 eax, DWORD PTR __Size$[ebp]
  00021	73 08		 jae	 SHORT $LN8@Erase_noex
  00023	8d 45 f0	 lea	 eax, DWORD PTR $T4[ebp]
  00026	89 45 e8	 mov	 DWORD PTR tv94[ebp], eax
  00029	eb 06		 jmp	 SHORT $LN9@Erase_noex
$LN8@Erase_noex:
  0002b	8d 45 ec	 lea	 eax, DWORD PTR __Size$[ebp]
  0002e	89 45 e8	 mov	 DWORD PTR tv94[ebp], eax
$LN9@Erase_noex:
  00031	8b 45 e8	 mov	 eax, DWORD PTR tv94[ebp]
  00034	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  00037	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  0003a	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2248 :         return (_STD min)(_Size, _Mysize - _Off);

  0003d	8b 45 d0	 mov	 eax, DWORD PTR $T1[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax

; 3296 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0004b	89 45 c4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 3297 :         _Elem* const _My_ptr      = _Mypair._Myval2._Myptr();

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  00054	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00057	89 45 e0	 mov	 DWORD PTR __Result$3[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0005a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00061	72 09		 jb	 SHORT $LN17@Erase_noex
  00063	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv133[ebp], 1
  0006a	eb 04		 jmp	 SHORT $LN18@Erase_noex
$LN17@Erase_noex:
  0006c	83 65 e4 00	 and	 DWORD PTR tv133[ebp], 0
$LN18@Erase_noex:
  00070	8a 45 e4	 mov	 al, BYTE PTR tv133[ebp]
  00073	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  00076	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  0007a	85 c0		 test	 eax, eax
  0007c	74 0e		 je	 SHORT $LN12@Erase_noex

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0007e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	89 45 cc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00086	8b 45 cc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Result$3[ebp], eax
$LN12@Erase_noex:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Result$3[ebp]
  0008f	89 45 c8	 mov	 DWORD PTR __My_ptr$[ebp], eax

; 3298 :         _Elem* const _Erase_at    = _My_ptr + _Off;

  00092	8b 45 c8	 mov	 eax, DWORD PTR __My_ptr$[ebp]
  00095	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]
  00098	89 45 d8	 mov	 DWORD PTR __Erase_at$[ebp], eax

; 3299 :         const size_type _New_size = _Old_size - _Count;

  0009b	8b 45 c4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0009e	2b 45 0c	 sub	 eax, DWORD PTR __Count$[ebp]
  000a1	89 45 dc	 mov	 DWORD PTR __New_size$[ebp], eax

; 3300 :         _Mypair._Myval2._Mysize   = _New_size;

  000a4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8b 4d dc	 mov	 ecx, DWORD PTR __New_size$[ebp]
  000aa	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3301 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000ad	8b 45 dc	 mov	 eax, DWORD PTR __New_size$[ebp]
  000b0	2b 45 08	 sub	 eax, DWORD PTR __Off$[ebp]
  000b3	40		 inc	 eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000b4	50		 push	 eax

; 3301 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  000b5	8b 45 d8	 mov	 eax, DWORD PTR __Erase_at$[ebp]
  000b8	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000bb	50		 push	 eax
  000bc	ff 75 d8	 push	 DWORD PTR __Erase_at$[ebp]
  000bf	e8 00 00 00 00	 call	 _memmove
  000c4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3302 :         return *this;

  000c7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 3303 :     }

  000ca	c9		 leave
  000cb	c2 08 00	 ret	 8
?_Erase_noexcept@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Erase_noexcept
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 1
__First1$ = -20						; size = 4
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 49		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0003a	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR __First1$[ebp], eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00046	ff 75 ec	 push	 DWORD PTR __First1$[ebp]
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00055	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00058	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005e	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  00061	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2943 :             return *this;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2944 :         }
; 2945 : 
; 2946 :         return _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 e8	 mov	 BYTE PTR $T1[ebp], al
  0006e	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00074	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00077	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2947 :             _Count,
; 2948 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2949 :                 const size_type _Count) {
; 2950 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2909 :     basic_string& append(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2910 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	ff 70 10	 push	 DWORD PTR [eax+16]
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00015	50		 push	 eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2911 :     }

  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z
_TEXT	SEGMENT
__Al$ = -72						; size = 4
$T1 = -68						; size = 4
__Ptr$ = -64						; size = 4
$T2 = -60						; size = 4
$T3 = -56						; size = 4
$T4 = -52						; size = 4
__First1$ = -48						; size = 4
__New_capacity$ = -44					; size = 4
__Right_ptr$ = -40					; size = 4
__New_array$ = -36					; size = 4
tv138 = -32						; size = 4
$T5 = -28						; size = 4
$T6 = -24						; size = 4
__Right_data$ = -20					; size = 4
_this$ = -16						; size = 4
__Right_size$ = -12					; size = 4
__My_data$ = -8						; size = 4
__Overflow_is_possible$7 = -1				; size = 1
__Right$ = 8						; size = 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT
; _this$ = ecx

; 2728 :     void _Construct_lv_contents(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2729 :         // assign by copying data stored in _Right
; 2730 :         // pre: this != &_Right
; 2731 :         // pre: *this owns no memory, iterators orphaned (note:
; 2732 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2733 :         auto& _Right_data             = _Right._Mypair._Myval2;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR __Right_data$[ebp], eax

; 2734 :         const size_type _Right_size   = _Right_data._Mysize;

  0000f	8b 45 ec	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f4	 mov	 DWORD PTR __Right_size$[ebp], eax

; 2735 :         const _Elem* const _Right_ptr = _Right_data._Myptr();

  00018	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00020	89 45 d8	 mov	 DWORD PTR __Right_ptr$[ebp], eax

; 2736 :         auto& _My_data                = _Mypair._Myval2;

  00023	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2737 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

  00029	83 7d f4 10	 cmp	 DWORD PTR __Right_size$[ebp], 16 ; 00000010H
  0002d	73 2e		 jae	 SHORT $LN2@Construct_

; 2738 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00032	89 45 d0	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00035	6a 10		 push	 16			; 00000010H
  00037	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  0003a	ff 75 d0	 push	 DWORD PTR __First1$[ebp]
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2739 :             _My_data._Mysize = _Right_size;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  0004b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2740 :             _My_data._Myres  = _BUF_SIZE - 1;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00051	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 2741 :             return;

  00058	e9 9b 00 00 00	 jmp	 $LN1@Construct_
$LN2@Construct_:

; 4409 :         return _Mypair._Get_first();

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00060	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00063	8b 45 cc	 mov	 eax, DWORD PTR $T4[ebp]
  00066	89 45 b8	 mov	 DWORD PTR __Al$[ebp], eax

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00071	89 45 e8	 mov	 DWORD PTR $T6[ebp], eax
  00074	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  00077	83 c8 0f	 or	 eax, 15			; 0000000fH
  0007a	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0007d	8b 45 e8	 mov	 eax, DWORD PTR $T6[ebp]
  00080	3b 45 e4	 cmp	 eax, DWORD PTR $T5[ebp]
  00083	73 08		 jae	 SHORT $LN52@Construct_
  00085	8d 45 e8	 lea	 eax, DWORD PTR $T6[ebp]
  00088	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
  0008b	eb 06		 jmp	 SHORT $LN53@Construct_
$LN52@Construct_:
  0008d	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  00090	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
$LN53@Construct_:
  00093	8b 45 e0	 mov	 eax, DWORD PTR tv138[ebp]
  00096	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  00099	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]
  0009c	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2745 :         const size_type _New_capacity = (_STD min)(_Right_size | _ALLOC_MASK, max_size());

  0009f	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	89 45 d4	 mov	 DWORD PTR __New_capacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000a7	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$7[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000ab	8b 45 d4	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  000ae	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000b5	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2746 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

  000b6	89 45 dc	 mov	 DWORD PTR __New_array$[ebp], eax

; 2747 :         _Construct_in_place(_My_data._Bx._Ptr, _New_array);

  000b9	8d 45 dc	 lea	 eax, DWORD PTR __New_array$[ebp]
  000bc	50		 push	 eax
  000bd	ff 75 f8	 push	 DWORD PTR __My_data$[ebp]
  000c0	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c5	59		 pop	 ecx
  000c6	59		 pop	 ecx

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000c7	8b 45 dc	 mov	 eax, DWORD PTR __New_array$[ebp]
  000ca	89 45 c0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000cd	8b 45 c0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d0	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2748 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000d3	8b 45 f4	 mov	 eax, DWORD PTR __Right_size$[ebp]
  000d6	40		 inc	 eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d7	50		 push	 eax
  000d8	ff 75 d8	 push	 DWORD PTR __Right_ptr$[ebp]
  000db	ff 75 bc	 push	 DWORD PTR $T1[ebp]
  000de	e8 00 00 00 00	 call	 _memcpy
  000e3	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2749 :         _My_data._Mysize = _Right_size;

  000e6	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e9	8b 4d f4	 mov	 ecx, DWORD PTR __Right_size$[ebp]
  000ec	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2750 :         _My_data._Myres  = _New_capacity;

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f2	8b 4d d4	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000f5	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN1@Construct_:

; 2751 :     }

  000f8	c9		 leave
  000f9	c2 04 00	 ret	 4
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
_TEXT	SEGMENT
$T2 = -100						; size = 4
__Alproxy$ = -96					; size = 4
$T3 = -92						; size = 4
__First1$ = -88						; size = 4
__Ptr$ = -84						; size = 4
$T4 = -80						; size = 4
$T5 = -76						; size = 4
$T6 = -72						; size = 4
_this$ = -68						; size = 4
$T7 = -64						; size = 4
__Fancyptr$8 = -60					; size = 4
tv190 = -56						; size = 4
$T9 = -52						; size = 4
_this$ = -48						; size = 4
__Masked$10 = -44					; size = 4
__New_size$ = -40					; size = 4
__Ptr$ = -36						; size = 4
__My_data$ = -32					; size = 4
__Max$ = -28						; size = 4
_this$ = -24						; size = 4
__New_capacity$ = -20					; size = 4
__Overflow_is_possible$11 = -15				; size = 1
_$S13$ = -14						; size = 1
$T12 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 1
__Source_of_al$ = 12					; size = 4
__Left_ptr$ = 16					; size = 4
__Left_size$ = 20					; size = 4
__Right_ptr$ = 24					; size = 4
__Right_size$ = 28					; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2521 :             _One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Source_of_al._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 58	 sub	 esp, 88			; 00000058H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Source_of_al$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 c0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 c0	 mov	 eax, DWORD PTR $T7[ebp]
  00031	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax

; 2199 : 
; 2200 :     // length of internal buffer, [1, 16]:
; 2201 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2202 :     // roundup mask for allocated buffers, [0, 15]:
; 2203 :     static constexpr size_type _ALLOC_MASK =
; 2204 :         sizeof(value_type) <= 1
; 2205 :             ? 15
; 2206 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2207 : 
; 2208 :     value_type* _Myptr() noexcept {
; 2209 :         value_type* _Result = _Bx._Buf;
; 2210 :         if (_Large_string_engaged()) {
; 2211 :             _Result = _Unfancy(_Bx._Ptr);
; 2212 :         }
; 2213 : 
; 2214 :         return _Result;
; 2215 :     }
; 2216 : 
; 2217 :     const value_type* _Myptr() const noexcept {
; 2218 :         const value_type* _Result = _Bx._Buf;
; 2219 :         if (_Large_string_engaged()) {
; 2220 :             _Result = _Unfancy(_Bx._Ptr);
; 2221 :         }
; 2222 : 
; 2223 :         return _Result;
; 2224 :     }
; 2225 : 
; 2226 :     bool _Large_string_engaged() const noexcept {
; 2227 :         return _BUF_SIZE <= _Myres;
; 2228 :     }
; 2229 : 
; 2230 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2231 :         if (_Mysize < _Off) {
; 2232 :             _Xran();
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2237 :         if (_Mysize <= _Off) {
; 2238 :             _Xran();
; 2239 :         }
; 2240 :     }
; 2241 : 
; 2242 :     [[noreturn]] static void _Xran() {
; 2243 :         _Xout_of_range("invalid string position");
; 2244 :     }
; 2245 : 
; 2246 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2247 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2248 :         return (_STD min)(_Size, _Mysize - _Off);
; 2249 :     }
; 2250 : 
; 2251 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2252 :         _Bxty() noexcept {} // user-provided, for fancy pointers
; 2253 : 
; 2254 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2255 : 
; 2256 :         value_type _Buf[_BUF_SIZE];
; 2257 :         pointer _Ptr;
; 2258 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2259 :     } _Bx;
; 2260 : 
; 2261 :     size_type _Mysize; // current length of string
; 2262 :     size_type _Myres; // current storage reserved for string
; 2263 : };
; 2264 : 
; 2265 : // CLASS TEMPLATE basic_string
; 2266 : template <class _Ty>
; 2267 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2268 : 
; 2269 : struct _String_constructor_concat_tag {
; 2270 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2271 :     explicit _String_constructor_concat_tag() = default;
; 2272 : };
; 2273 : 
; 2274 : [[noreturn]] inline void _Xlen_string() {
; 2275 :     _Xlength_error("string too long");
; 2276 : }
; 2277 : 
; 2278 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2279 : class basic_string { // null-terminated transparent array of elements
; 2280 : private:
; 2281 :     friend _Tidy_deallocate_guard<basic_string>;
; 2282 : 
; 2283 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2284 :     using _Alty_traits = allocator_traits<_Alty>;
; 2285 : 
; 2286 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2287 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2288 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2289 : 
; 2290 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2291 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2292 : 
; 2293 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2294 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2295 :         "char_traits character type match the string's character type.");
; 2296 : 
; 2297 :     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
; 2298 :         "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
; 2299 :         "[strings.general]/1.");
; 2300 : 
; 2301 : public:
; 2302 :     using traits_type    = _Traits;
; 2303 :     using allocator_type = _Alloc;
; 2304 : 
; 2305 :     using value_type      = _Elem;
; 2306 :     using size_type       = typename _Alty_traits::size_type;
; 2307 :     using difference_type = typename _Alty_traits::difference_type;
; 2308 :     using pointer         = typename _Alty_traits::pointer;
; 2309 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2310 :     using reference       = value_type&;
; 2311 :     using const_reference = const value_type&;
; 2312 : 
; 2313 :     using iterator       = _String_iterator<_Scary_val>;
; 2314 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2315 : 
; 2316 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2317 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2318 : 
; 2319 : private:
; 2320 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2321 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2322 : 
; 2323 :     // When doing _String_val operations by memcpy, we are touching:
; 2324 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2325 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2326 :     //   _String_val::_Mysize   (type is size_type)
; 2327 :     //   _String_val::_Myres    (type is size_type)
; 2328 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2329 :     // We need to ask if pointer is safe to memcpy.
; 2330 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2331 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2332 :     //   they can observe traits::assign and similar.
; 2333 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2334 :     // This offset skips over the _Container_base members, if any
; 2335 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2336 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2337 : 
; 2338 :     template <class _Iter>
; 2339 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2340 : 
; 2341 : #if _HAS_CXX17
; 2342 :     template <class _StringViewIsh>
; 2343 :     using _Is_string_view_ish =
; 2344 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2345 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2346 :             int>;
; 2347 : #endif // _HAS_CXX17
; 2348 : 
; 2349 : public:
; 2350 :     basic_string(const basic_string& _Right)
; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);
; 2355 :         _Proxy._Release();
; 2356 :     }
; 2357 : 
; 2358 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2359 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2360 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2361 :         _Construct_lv_contents(_Right);
; 2362 :         _Proxy._Release();
; 2363 :     }
; 2364 : 
; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();
; 2368 :     }
; 2369 : 
; 2370 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2371 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2372 :         _Tidy_init();
; 2373 :     }
; 2374 : 
; 2375 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2376 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2379 :         _Tidy_init();
; 2380 :         assign(_Right, _Roff, npos);
; 2381 :         _Proxy._Release();
; 2382 :     }
; 2383 : 
; 2384 :     basic_string(
; 2385 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();
; 2390 :         assign(_Right, _Roff, _Count);
; 2391 :         _Proxy._Release();
; 2392 :     }
; 2393 : 
; 2394 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {
; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();
; 2399 :         assign(_Ptr, _Count);
; 2400 :         _Proxy._Release();
; 2401 :     }
; 2402 : 
; 2403 :     basic_string(
; 2404 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2405 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2406 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2407 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2408 :         _Tidy_init();
; 2409 :         assign(_Ptr, _Count);
; 2410 :         _Proxy._Release();
; 2411 :     }
; 2412 : 
; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();
; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }
; 2420 : 
; 2421 : #if _HAS_CXX17
; 2422 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2423 : #endif // _HAS_CXX17
; 2424 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2425 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2426 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2427 :         _Tidy_init();
; 2428 :         assign(_Ptr);
; 2429 :         _Proxy._Release();
; 2430 :     }
; 2431 : 
; 2432 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2433 :         // construct from _Count * _Ch
; 2434 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2435 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2436 :         _Tidy_init();
; 2437 :         assign(_Count, _Ch);
; 2438 :         _Proxy._Release();
; 2439 :     }
; 2440 : 
; 2441 : #if _HAS_CXX17
; 2442 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2443 : #endif // _HAS_CXX17
; 2444 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2445 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
; 2446 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2447 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2448 :         _Tidy_init();
; 2449 :         assign(_Count, _Ch);
; 2450 :         _Proxy._Release();
; 2451 :     }
; 2452 : 
; 2453 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2454 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2455 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2456 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2457 :         _Tidy_init();
; 2458 :         _Adl_verify_range(_First, _Last);
; 2459 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 2460 :         _Proxy._Release();
; 2461 :     }
; 2462 : 
; 2463 :     template <class _Iter>
; 2464 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2465 :         // initialize from [_First, _Last), input iterators
; 2466 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2467 :         for (; _First != _Last; ++_First) {
; 2468 :             push_back(*_First);
; 2469 :         }
; 2470 : 
; 2471 :         _Guard._Target = nullptr;
; 2472 :     }
; 2473 : 
; 2474 :     template <class _Iter>
; 2475 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2476 :         // initialize from [_First, _Last), forward iterators
; 2477 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2478 :         reserve(_Count);
; 2479 :         _Construct(_First, _Last, input_iterator_tag{});
; 2480 :     }
; 2481 : 
; 2482 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2483 :         // initialize from [_First, _Last), pointers
; 2484 :         if (_First != _Last) {
; 2485 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2486 :         }
; 2487 :     }
; 2488 : 
; 2489 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2490 :         // initialize from [_First, _Last), const pointers
; 2491 :         if (_First != _Last) {
; 2492 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2493 :         }
; 2494 :     }
; 2495 : 
; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2499 :     }
; 2500 : 
; 2501 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2502 :         _Alty_traits::is_always_equal::value) // strengthened
; 2503 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2504 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2505 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2506 :         if _CONSTEXPR_IF (!_Alty_traits::is_always_equal::value) {
; 2507 :             if (_Getal() != _Right._Getal()) {
; 2508 :                 _Construct_lv_contents(_Right);
; 2509 :                 _Proxy._Release();
; 2510 :                 return;
; 2511 :             }
; 2512 :         }
; 2513 : 
; 2514 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2515 :         _Proxy._Release();
; 2516 :     }
; 2517 : 
; 2518 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2519 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2520 :         : _Mypair(

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 bc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2199 : 
; 2200 :     // length of internal buffer, [1, 16]:
; 2201 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2202 :     // roundup mask for allocated buffers, [0, 15]:
; 2203 :     static constexpr size_type _ALLOC_MASK =
; 2204 :         sizeof(value_type) <= 1
; 2205 :             ? 15
; 2206 :             : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;
; 2207 : 
; 2208 :     value_type* _Myptr() noexcept {
; 2209 :         value_type* _Result = _Bx._Buf;
; 2210 :         if (_Large_string_engaged()) {
; 2211 :             _Result = _Unfancy(_Bx._Ptr);
; 2212 :         }
; 2213 : 
; 2214 :         return _Result;
; 2215 :     }
; 2216 : 
; 2217 :     const value_type* _Myptr() const noexcept {
; 2218 :         const value_type* _Result = _Bx._Buf;
; 2219 :         if (_Large_string_engaged()) {
; 2220 :             _Result = _Unfancy(_Bx._Ptr);
; 2221 :         }
; 2222 : 
; 2223 :         return _Result;
; 2224 :     }
; 2225 : 
; 2226 :     bool _Large_string_engaged() const noexcept {
; 2227 :         return _BUF_SIZE <= _Myres;
; 2228 :     }
; 2229 : 
; 2230 :     void _Check_offset(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size()]
; 2231 :         if (_Mysize < _Off) {
; 2232 :             _Xran();
; 2233 :         }
; 2234 :     }
; 2235 : 
; 2236 :     void _Check_offset_exclusive(const size_type _Off) const { // checks whether _Off is in the bounds of [0, size())
; 2237 :         if (_Mysize <= _Off) {
; 2238 :             _Xran();
; 2239 :         }
; 2240 :     }
; 2241 : 
; 2242 :     [[noreturn]] static void _Xran() {
; 2243 :         _Xout_of_range("invalid string position");
; 2244 :     }
; 2245 : 
; 2246 :     size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2247 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2248 :         return (_STD min)(_Size, _Mysize - _Off);
; 2249 :     }
; 2250 : 
; 2251 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2252 :         _Bxty() noexcept {} // user-provided, for fancy pointers
; 2253 : 
; 2254 :         ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2255 : 
; 2256 :         value_type _Buf[_BUF_SIZE];
; 2257 :         pointer _Ptr;
; 2258 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2259 :     } _Bx;
; 2260 : 
; 2261 :     size_type _Mysize; // current length of string
; 2262 :     size_type _Myres; // current storage reserved for string
; 2263 : };
; 2264 : 
; 2265 : // CLASS TEMPLATE basic_string
; 2266 : template <class _Ty>
; 2267 : constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty); // get _Ty's size after being EBCO'd
; 2268 : 
; 2269 : struct _String_constructor_concat_tag {
; 2270 :     // tag to select constructors used by basic_string's concatenation operators (operator+)
; 2271 :     explicit _String_constructor_concat_tag() = default;
; 2272 : };
; 2273 : 
; 2274 : [[noreturn]] inline void _Xlen_string() {
; 2275 :     _Xlength_error("string too long");
; 2276 : }
; 2277 : 
; 2278 : template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
; 2279 : class basic_string { // null-terminated transparent array of elements
; 2280 : private:
; 2281 :     friend _Tidy_deallocate_guard<basic_string>;
; 2282 : 
; 2283 :     using _Alty        = _Rebind_alloc_t<_Alloc, _Elem>;
; 2284 :     using _Alty_traits = allocator_traits<_Alty>;
; 2285 : 
; 2286 :     using _Scary_val = _String_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Elem>,
; 2287 :         _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type,
; 2288 :             typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;
; 2289 : 
; 2290 :     static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v<_Elem, typename _Alloc::value_type>,
; 2291 :         _MISMATCHED_ALLOCATOR_MESSAGE("basic_string<T, Traits, Allocator>", "T"));
; 2292 : 
; 2293 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 2294 :         "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
; 2295 :         "char_traits character type match the string's character type.");
; 2296 : 
; 2297 :     static_assert(!is_array_v<_Elem> && is_trivial_v<_Elem> && is_standard_layout_v<_Elem>,
; 2298 :         "The character type of basic_string must be a non-array trivial standard-layout type. See N4861 "
; 2299 :         "[strings.general]/1.");
; 2300 : 
; 2301 : public:
; 2302 :     using traits_type    = _Traits;
; 2303 :     using allocator_type = _Alloc;
; 2304 : 
; 2305 :     using value_type      = _Elem;
; 2306 :     using size_type       = typename _Alty_traits::size_type;
; 2307 :     using difference_type = typename _Alty_traits::difference_type;
; 2308 :     using pointer         = typename _Alty_traits::pointer;
; 2309 :     using const_pointer   = typename _Alty_traits::const_pointer;
; 2310 :     using reference       = value_type&;
; 2311 :     using const_reference = const value_type&;
; 2312 : 
; 2313 :     using iterator       = _String_iterator<_Scary_val>;
; 2314 :     using const_iterator = _String_const_iterator<_Scary_val>;
; 2315 : 
; 2316 :     using reverse_iterator       = _STD reverse_iterator<iterator>;
; 2317 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 2318 : 
; 2319 : private:
; 2320 :     static constexpr auto _BUF_SIZE   = _Scary_val::_BUF_SIZE;
; 2321 :     static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;
; 2322 : 
; 2323 :     // When doing _String_val operations by memcpy, we are touching:
; 2324 :     //   _String_val::_Bx::_Buf (type is array of _Elem)
; 2325 :     //   _String_val::_Bx::_Ptr (type is pointer)
; 2326 :     //   _String_val::_Mysize   (type is size_type)
; 2327 :     //   _String_val::_Myres    (type is size_type)
; 2328 :     // N4810 21.1 [strings.general]/1 says _Elem must be trivial standard-layout, so memcpy is safe.
; 2329 :     // We need to ask if pointer is safe to memcpy.
; 2330 :     // size_type must be an unsigned integral type so memcpy is safe.
; 2331 :     // We also need to disable memcpy if the user has supplied _Traits, since
; 2332 :     //   they can observe traits::assign and similar.
; 2333 :     static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;
; 2334 :     // This offset skips over the _Container_base members, if any
; 2335 :     static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
; 2336 :     static constexpr size_t _Memcpy_val_size   = sizeof(_Scary_val) - _Memcpy_val_offset;
; 2337 : 
; 2338 :     template <class _Iter>
; 2339 :     using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;
; 2340 : 
; 2341 : #if _HAS_CXX17
; 2342 :     template <class _StringViewIsh>
; 2343 :     using _Is_string_view_ish =
; 2344 :         enable_if_t<conjunction_v<is_convertible<const _StringViewIsh&, basic_string_view<_Elem, _Traits>>,
; 2345 :                         negation<is_convertible<const _StringViewIsh&, const _Elem*>>>,
; 2346 :             int>;
; 2347 : #endif // _HAS_CXX17
; 2348 : 
; 2349 : public:
; 2350 :     basic_string(const basic_string& _Right)
; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);
; 2355 :         _Proxy._Release();
; 2356 :     }
; 2357 : 
; 2358 :     basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2359 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2360 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2361 :         _Construct_lv_contents(_Right);
; 2362 :         _Proxy._Release();
; 2363 :     }
; 2364 : 
; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();
; 2368 :     }
; 2369 : 
; 2370 :     explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2371 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2372 :         _Tidy_init();
; 2373 :     }
; 2374 : 
; 2375 :     basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
; 2376 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, <end>)
; 2377 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2378 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2379 :         _Tidy_init();
; 2380 :         assign(_Right, _Roff, npos);
; 2381 :         _Proxy._Release();
; 2382 :     }
; 2383 : 
; 2384 :     basic_string(
; 2385 :         const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
; 2386 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)
; 2387 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2388 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2389 :         _Tidy_init();
; 2390 :         assign(_Right, _Roff, _Count);
; 2391 :         _Proxy._Release();
; 2392 :     }
; 2393 : 
; 2394 :     basic_string(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count)
; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {
; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();
; 2399 :         assign(_Ptr, _Count);
; 2400 :         _Proxy._Release();
; 2401 :     }
; 2402 : 
; 2403 :     basic_string(
; 2404 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al)
; 2405 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2406 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2407 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2408 :         _Tidy_init();
; 2409 :         assign(_Ptr, _Count);
; 2410 :         _Proxy._Release();
; 2411 :     }
; 2412 : 
; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();
; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }
; 2420 : 
; 2421 : #if _HAS_CXX17
; 2422 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2423 : #endif // _HAS_CXX17
; 2424 :     basic_string(_In_z_ const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2425 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2426 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2427 :         _Tidy_init();
; 2428 :         assign(_Ptr);
; 2429 :         _Proxy._Release();
; 2430 :     }
; 2431 : 
; 2432 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t{}) {
; 2433 :         // construct from _Count * _Ch
; 2434 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2435 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2436 :         _Tidy_init();
; 2437 :         assign(_Count, _Ch);
; 2438 :         _Proxy._Release();
; 2439 :     }
; 2440 : 
; 2441 : #if _HAS_CXX17
; 2442 :     template <class _Alloc2 = _Alloc, enable_if_t<_Is_allocator<_Alloc2>::value, int> = 0>
; 2443 : #endif // _HAS_CXX17
; 2444 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
; 2445 :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Count * _Ch with allocator
; 2446 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2447 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2448 :         _Tidy_init();
; 2449 :         assign(_Count, _Ch);
; 2450 :         _Proxy._Release();
; 2451 :     }
; 2452 : 
; 2453 :     template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
; 2454 :     basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2455 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2456 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2457 :         _Tidy_init();
; 2458 :         _Adl_verify_range(_First, _Last);
; 2459 :         _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
; 2460 :         _Proxy._Release();
; 2461 :     }
; 2462 : 
; 2463 :     template <class _Iter>
; 2464 :     void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag) {
; 2465 :         // initialize from [_First, _Last), input iterators
; 2466 :         _Tidy_deallocate_guard<basic_string> _Guard{this};
; 2467 :         for (; _First != _Last; ++_First) {
; 2468 :             push_back(*_First);
; 2469 :         }
; 2470 : 
; 2471 :         _Guard._Target = nullptr;
; 2472 :     }
; 2473 : 
; 2474 :     template <class _Iter>
; 2475 :     void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag) {
; 2476 :         // initialize from [_First, _Last), forward iterators
; 2477 :         const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));
; 2478 :         reserve(_Count);
; 2479 :         _Construct(_First, _Last, input_iterator_tag{});
; 2480 :     }
; 2481 : 
; 2482 :     void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag) {
; 2483 :         // initialize from [_First, _Last), pointers
; 2484 :         if (_First != _Last) {
; 2485 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2486 :         }
; 2487 :     }
; 2488 : 
; 2489 :     void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag) {
; 2490 :         // initialize from [_First, _Last), const pointers
; 2491 :         if (_First != _Last) {
; 2492 :             assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
; 2493 :         }
; 2494 :     }
; 2495 : 
; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {
; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2499 :     }
; 2500 : 
; 2501 :     basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(
; 2502 :         _Alty_traits::is_always_equal::value) // strengthened
; 2503 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {
; 2504 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2505 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2506 :         if _CONSTEXPR_IF (!_Alty_traits::is_always_equal::value) {
; 2507 :             if (_Getal() != _Right._Getal()) {
; 2508 :                 _Construct_lv_contents(_Right);
; 2509 :                 _Proxy._Release();
; 2510 :                 return;
; 2511 :             }
; 2512 :         }
; 2513 : 
; 2514 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
; 2515 :         _Proxy._Release();
; 2516 :     }
; 2517 : 
; 2518 :     basic_string(_String_constructor_concat_tag, const basic_string& _Source_of_al, const _Elem* const _Left_ptr,
; 2519 :         const size_type _Left_size, const _Elem* const _Right_ptr, const size_type _Right_size)
; 2520 :         : _Mypair(

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2522 :         _STL_INTERNAL_CHECK(_Left_size <= max_size());
; 2523 :         _STL_INTERNAL_CHECK(_Right_size <= max_size());
; 2524 :         _STL_INTERNAL_CHECK(_Right_size <= max_size() - _Left_size);
; 2525 :         const auto _New_size    = static_cast<size_type>(_Left_size + _Right_size);

  00052	8b 45 14	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00055	03 45 1c	 add	 eax, DWORD PTR __Right_size$[ebp]
  00058	89 45 d8	 mov	 DWORD PTR __New_size$[ebp], eax

; 2526 :         size_type _New_capacity = _BUF_SIZE - 1;

  0005b	c7 45 ec 0f 00
	00 00		 mov	 DWORD PTR __New_capacity$[ebp], 15 ; 0000000fH

; 2527 :         auto& _My_data          = _Mypair._Myval2;

  00062	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __My_data$[ebp], eax

; 2528 :         _Elem* _Ptr             = _My_data._Bx._Buf;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0006b	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax

; 2529 :         auto&& _Alproxy         = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0006e	8d 45 f2	 lea	 eax, DWORD PTR _$S13$[ebp]
  00071	89 45 a0	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2530 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data); // throws
; 2531 :         if (_New_capacity < _New_size) {

  00074	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00077	3b 45 d8	 cmp	 eax, DWORD PTR __New_size$[ebp]
  0007a	0f 83 a8 00 00
	00		 jae	 $LN2@basic_stri

; 2532 :             _New_capacity           = _Calculate_growth(_New_size, _BUF_SIZE - 1, max_size());

  00080	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00088	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0008b	8b 45 d8	 mov	 eax, DWORD PTR __New_size$[ebp]
  0008e	83 c8 0f	 or	 eax, 15			; 0000000fH
  00091	89 45 d4	 mov	 DWORD PTR __Masked$10[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00094	8b 45 d4	 mov	 eax, DWORD PTR __Masked$10[ebp]
  00097	3b 45 e4	 cmp	 eax, DWORD PTR __Max$[ebp]
  0009a	76 08		 jbe	 SHORT $LN54@basic_stri

; 4287 :             return _Max;

  0009c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0009f	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
  000a2	eb 4c		 jmp	 SHORT $LN56@basic_stri
$LN54@basic_stri:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  000a4	6a 0f		 push	 15			; 0000000fH
  000a6	58		 pop	 eax
  000a7	d1 e8		 shr	 eax, 1
  000a9	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  000ac	2b c8		 sub	 ecx, eax
  000ae	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  000b1	73 08		 jae	 SHORT $LN55@basic_stri

; 4291 :             return _Max;

  000b3	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  000b6	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
  000b9	eb 35		 jmp	 SHORT $LN56@basic_stri
$LN55@basic_stri:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000bb	6a 0f		 push	 15			; 0000000fH
  000bd	58		 pop	 eax
  000be	d1 e8		 shr	 eax, 1
  000c0	83 c0 0f	 add	 eax, 15			; 0000000fH
  000c3	89 45 cc	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  000c6	8b 45 d4	 mov	 eax, DWORD PTR __Masked$10[ebp]
  000c9	3b 45 cc	 cmp	 eax, DWORD PTR $T9[ebp]
  000cc	73 08		 jae	 SHORT $LN60@basic_stri
  000ce	8d 45 cc	 lea	 eax, DWORD PTR $T9[ebp]
  000d1	89 45 c8	 mov	 DWORD PTR tv190[ebp], eax
  000d4	eb 06		 jmp	 SHORT $LN61@basic_stri
$LN60@basic_stri:
  000d6	8d 45 d4	 lea	 eax, DWORD PTR __Masked$10[ebp]
  000d9	89 45 c8	 mov	 DWORD PTR tv190[ebp], eax
$LN61@basic_stri:
  000dc	8b 45 c8	 mov	 eax, DWORD PTR tv190[ebp]
  000df	89 45 b8	 mov	 DWORD PTR $T6[ebp], eax
  000e2	8b 45 b8	 mov	 eax, DWORD PTR $T6[ebp]
  000e5	89 45 b4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  000e8	8b 45 b4	 mov	 eax, DWORD PTR $T5[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax
$LN56@basic_stri:

; 4409 :         return _Mypair._Get_first();

  000f0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000f3	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  000f6	8b 45 b0	 mov	 eax, DWORD PTR $T4[ebp]
  000f9	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000fc	c6 45 f1 00	 mov	 BYTE PTR __Overflow_is_possible$11[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2533 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  00100	8b 45 ec	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00103	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010a	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2533 :             const pointer _Fancyptr = _Getal().allocate(_New_capacity + 1); // throws

  0010b	89 45 c4	 mov	 DWORD PTR __Fancyptr$8[ebp], eax

; 2534 :             _Ptr                    = _Unfancy(_Fancyptr);

  0010e	8b 45 c4	 mov	 eax, DWORD PTR __Fancyptr$8[ebp]
  00111	89 45 ac	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00114	8b 45 ac	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00117	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2535 :             _Construct_in_place(_My_data._Bx._Ptr, _Fancyptr);

  0011a	8d 45 c4	 lea	 eax, DWORD PTR __Fancyptr$8[ebp]
  0011d	50		 push	 eax
  0011e	ff 75 e0	 push	 DWORD PTR __My_data$[ebp]
  00121	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00126	59		 pop	 ecx
  00127	59		 pop	 ecx
$LN2@basic_stri:

; 2536 :         }
; 2537 : 
; 2538 :         _My_data._Mysize = _New_size;

  00128	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0012b	8b 4d d8	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0012e	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2539 :         _My_data._Myres  = _New_capacity;

  00131	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00134	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00137	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0013a	ff 75 14	 push	 DWORD PTR __Left_size$[ebp]
  0013d	ff 75 10	 push	 DWORD PTR __Left_ptr$[ebp]
  00140	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  00143	e8 00 00 00 00	 call	 _memcpy
  00148	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2540 :         _Traits::copy(_Ptr, _Left_ptr, _Left_size);
; 2541 :         _Traits::copy(_Ptr + static_cast<ptrdiff_t>(_Left_size), _Right_ptr, _Right_size);

  0014b	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0014e	03 45 14	 add	 eax, DWORD PTR __Left_size$[ebp]
  00151	89 45 a8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00154	ff 75 1c	 push	 DWORD PTR __Right_size$[ebp]
  00157	ff 75 18	 push	 DWORD PTR __Right_ptr$[ebp]
  0015a	ff 75 a8	 push	 DWORD PTR __First1$[ebp]
  0015d	e8 00 00 00 00	 call	 _memcpy
  00162	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2542 :         _Traits::assign(_Ptr[_New_size], _Elem());

  00165	c6 45 f3 00	 mov	 BYTE PTR $T12[ebp], 0

; 428  :         _Left = _Right;

  00169	8b 45 dc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0016c	03 45 d8	 add	 eax, DWORD PTR __New_size$[ebp]
  0016f	8a 4d f3	 mov	 cl, BYTE PTR $T12[ebp]
  00172	88 08		 mov	 BYTE PTR [eax], cl

; 2543 :         _Proxy._Release();
; 2544 :     }

  00174	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00178	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00185	59		 pop	 ecx
  00186	c9		 leave
  00187	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z$0:
  00000	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@U_String_constructor_concat_tag@1@ABV01@QBDI2I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
__My_data_mem$2 = -36					; size = 4
__Right_data_mem$3 = -32				; size = 4
_this$ = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T6 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4409 :         return _Mypair._Get_first();

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0000f	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  00012	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00015	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2496 :     basic_string(basic_string&& _Right) noexcept : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2497 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2498 :         _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});

  00035	33 c0		 xor	 eax, eax
  00037	88 45 ff	 mov	 BYTE PTR $T6[ebp], al
  0003a	8a 45 ff	 mov	 al, BYTE PTR $T6[ebp]
  0003d	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al

; 2680 :         const auto _My_data_mem =

  00040	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 dc	 mov	 DWORD PTR __My_data_mem$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2682 :         const auto _Right_data_mem =

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00049	89 45 e0	 mov	 DWORD PTR __Right_data_mem$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2684 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  0004c	6a 18		 push	 24			; 00000018H
  0004e	ff 75 e0	 push	 DWORD PTR __Right_data_mem$3[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __My_data_mem$2[ebp]
  00054	e8 00 00 00 00	 call	 _memcpy
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2703 :         _Right._Tidy_init();

  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2499 :     }

  00064	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	c9		 leave
  00068	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S7$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S7$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
__Alproxy$ = -32					; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S8$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2395 :         : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2396 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S8$[ebp]
  00049	89 45 e0	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2397 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2398 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2399 :         assign(_Ptr, _Count);

  00054	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2400 :         _Proxy._Release();
; 2401 :     }

  00062	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	c9		 leave
  00075	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S10$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00028	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T3[ebp]
  00031	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0003a	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00040	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00047	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2351 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  0004e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2352 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00052	8d 45 f3	 lea	 eax, DWORD PTR _$S10$[ebp]
  00055	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2353 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2354 :         _Construct_lv_contents(_Right);

  00058	ff 75 08	 push	 DWORD PTR __Right$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents

; 2355 :         _Proxy._Release();
; 2356 :     }

  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	c9		 leave
  00076	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 2242 :     [[noreturn]] static void _Xran() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2243 :         _Xout_of_range("invalid string position");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 2244 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx

; 91   :     }

  0001d	c9		 leave
  0001e	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -12					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 59   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 58   :         : _Data()

  00012	33 c0		 xor	 eax, eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	83 c1 04	 add	 ecx, 4
  0001a	89 01		 mov	 DWORD PTR [ecx], eax
  0001c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 60   :         __std_exception_data _InitData = { _Message, true };

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00022	89 45 f4	 mov	 DWORD PTR __InitData$[ebp], eax
  00025	c6 45 f8 01	 mov	 BYTE PTR __InitData$[ebp+4], 1

; 61   :         __std_exception_copy(&_InitData, &_Data);

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 c0 04	 add	 eax, 4
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __InitData$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ___std_exception_copy
  00039	59		 pop	 ecx
  0003a	59		 pop	 ecx

; 62   :     }

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	c9		 leave
  0003f	c2 04 00	 ret	 4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Stream$ = -12						; size = 4
__Format$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Format$[ebp], eax
  00012	6a 01		 push	 1
  00014	e8 00 00 00 00	 call	 ___acrt_iob_func
  00019	59		 pop	 ecx
  0001a	89 45 f4	 mov	 DWORD PTR __Stream$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0001d	ff 75 fc	 push	 DWORD PTR __ArgList$[ebp]
  00020	6a 00		 push	 0
  00022	ff 75 f8	 push	 DWORD PTR __Format$[ebp]
  00025	ff 75 f4	 push	 DWORD PTR __Stream$[ebp]
  00028	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0002d	ff 70 04	 push	 DWORD PTR [eax+4]
  00030	ff 30		 push	 DWORD PTR [eax]
  00032	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00037	83 c4 18	 add	 esp, 24			; 00000018H

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0003a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

  0003d	83 65 fc 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 961  :     }

  00044	c9		 leave
  00045	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_memcpy_s.h
;	COMDAT _memcpy_s
_TEXT	SEGMENT
__Expr_val$1 = -24					; size = 4
__Expr_val$2 = -20					; size = 4
__Expr_val$3 = -16					; size = 4
tv79 = -12						; size = 4
tv75 = -8						; size = 4
tv66 = -4						; size = 4
__Destination$ = 8					; size = 4
__DestinationSize$ = 12					; size = 4
__Source$ = 16						; size = 4
__SourceSize$ = 20					; size = 4
_memcpy_s PROC						; COMDAT

; 41   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 42   :         if (_SourceSize == 0)

  00006	83 7d 14 00	 cmp	 DWORD PTR __SourceSize$[ebp], 0
  0000a	75 07		 jne	 SHORT $LN2@memcpy_s

; 43   :         {
; 44   :             return 0;

  0000c	33 c0		 xor	 eax, eax
  0000e	e9 d7 00 00 00	 jmp	 $LN1@memcpy_s
$LN2@memcpy_s:

; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00013	83 7d 08 00	 cmp	 DWORD PTR __Destination$[ebp], 0
  00017	74 09		 je	 SHORT $LN9@memcpy_s
  00019	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00020	eb 04		 jmp	 SHORT $LN10@memcpy_s
$LN9@memcpy_s:
  00022	83 65 fc 00	 and	 DWORD PTR tv66[ebp], 0
$LN10@memcpy_s:
  00026	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]
  00029	89 45 f0	 mov	 DWORD PTR __Expr_val$3[ebp], eax
  0002c	83 7d f0 00	 cmp	 DWORD PTR __Expr_val$3[ebp], 0
  00030	75 18		 jne	 SHORT $LN3@memcpy_s
  00032	e8 00 00 00 00	 call	 __errno
  00037	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  0003d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00042	6a 16		 push	 22			; 00000016H
  00044	58		 pop	 eax
  00045	e9 a0 00 00 00	 jmp	 $LN1@memcpy_s
$LN3@memcpy_s:

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  0004a	83 7d 10 00	 cmp	 DWORD PTR __Source$[ebp], 0
  0004e	74 08		 je	 SHORT $LN5@memcpy_s
  00050	8b 45 0c	 mov	 eax, DWORD PTR __DestinationSize$[ebp]
  00053	3b 45 14	 cmp	 eax, DWORD PTR __SourceSize$[ebp]
  00056	73 7f		 jae	 SHORT $LN4@memcpy_s
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00058	ff 75 0c	 push	 DWORD PTR __DestinationSize$[ebp]
  0005b	6a 00		 push	 0
  0005d	ff 75 08	 push	 DWORD PTR __Destination$[ebp]
  00060	e8 00 00 00 00	 call	 _memset
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00068	83 7d 10 00	 cmp	 DWORD PTR __Source$[ebp], 0
  0006c	74 09		 je	 SHORT $LN11@memcpy_s
  0006e	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
  00075	eb 04		 jmp	 SHORT $LN12@memcpy_s
$LN11@memcpy_s:
  00077	83 65 f8 00	 and	 DWORD PTR tv75[ebp], 0
$LN12@memcpy_s:
  0007b	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]
  0007e	89 45 ec	 mov	 DWORD PTR __Expr_val$2[ebp], eax
  00081	83 7d ec 00	 cmp	 DWORD PTR __Expr_val$2[ebp], 0
  00085	75 15		 jne	 SHORT $LN6@memcpy_s
  00087	e8 00 00 00 00	 call	 __errno
  0008c	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
  00092	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  00097	6a 16		 push	 22			; 00000016H
  00099	58		 pop	 eax
  0009a	eb 4e		 jmp	 SHORT $LN1@memcpy_s
$LN6@memcpy_s:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  0009c	8b 45 0c	 mov	 eax, DWORD PTR __DestinationSize$[ebp]
  0009f	3b 45 14	 cmp	 eax, DWORD PTR __SourceSize$[ebp]
  000a2	72 09		 jb	 SHORT $LN13@memcpy_s
  000a4	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv79[ebp], 1
  000ab	eb 04		 jmp	 SHORT $LN14@memcpy_s
$LN13@memcpy_s:
  000ad	83 65 f4 00	 and	 DWORD PTR tv79[ebp], 0
$LN14@memcpy_s:
  000b1	8b 45 f4	 mov	 eax, DWORD PTR tv79[ebp]
  000b4	89 45 e8	 mov	 DWORD PTR __Expr_val$1[ebp], eax
  000b7	83 7d e8 00	 cmp	 DWORD PTR __Expr_val$1[ebp], 0
  000bb	75 15		 jne	 SHORT $LN7@memcpy_s
  000bd	e8 00 00 00 00	 call	 __errno
  000c2	c7 00 22 00 00
	00		 mov	 DWORD PTR [eax], 34	; 00000022H
  000c8	e8 00 00 00 00	 call	 __invalid_parameter_noinfo
  000cd	6a 22		 push	 34			; 00000022H
  000cf	58		 pop	 eax
  000d0	eb 18		 jmp	 SHORT $LN1@memcpy_s
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

  000d2	6a 16		 push	 22			; 00000016H
  000d4	58		 pop	 eax
  000d5	eb 13		 jmp	 SHORT $LN1@memcpy_s
$LN4@memcpy_s:

; 57   :         }
; 58   : #pragma warning(suppress:4996) // Deprecation
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  000d7	ff 75 14	 push	 DWORD PTR __SourceSize$[ebp]
  000da	ff 75 10	 push	 DWORD PTR __Source$[ebp]
  000dd	ff 75 08	 push	 DWORD PTR __Destination$[ebp]
  000e0	e8 00 00 00 00	 call	 _memcpy
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   :         return 0;

  000e8	33 c0		 xor	 eax, eax
$LN1@memcpy_s:

; 61   :     }

  000ea	c9		 leave
  000eb	c3		 ret	 0
_memcpy_s ENDP
_TEXT	ENDS
END
