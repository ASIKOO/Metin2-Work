; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?OnChangePosition@CWindow@UI@@UAEXXZ		; UI::CWindow::OnChangePosition
PUBLIC	?SetColor@CWindow@UI@@UAEXK@Z			; UI::CWindow::SetColor
PUBLIC	?IsWindow@CWindow@UI@@UAEHXZ			; UI::CWindow::IsWindow
PUBLIC	?Type@CGridSlotWindow@UI@@SAKXZ			; UI::CGridSlotWindow::Type
PUBLIC	??0CGridSlotWindow@UI@@QAE@PAU_object@@@Z	; UI::CGridSlotWindow::CGridSlotWindow
PUBLIC	??1CGridSlotWindow@UI@@UAE@XZ			; UI::CGridSlotWindow::~CGridSlotWindow
PUBLIC	?Destroy@CGridSlotWindow@UI@@QAEXXZ		; UI::CGridSlotWindow::Destroy
PUBLIC	?ArrangeGridSlot@CGridSlotWindow@UI@@QAEXKKKHHHH@Z ; UI::CGridSlotWindow::ArrangeGridSlot
PUBLIC	?__Initialize@CGridSlotWindow@UI@@IAEXXZ	; UI::CGridSlotWindow::__Initialize
PUBLIC	?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z ; UI::CGridSlotWindow::GetPickedSlotPointer
PUBLIC	?GetPickedSlotList@CGridSlotWindow@UI@@IAEHHHPAV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z ; UI::CGridSlotWindow::GetPickedSlotList
PUBLIC	?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z ; UI::CGridSlotWindow::GetGridSlotPointer
PUBLIC	?GetPickedGridSlotPosition@CGridSlotWindow@UI@@IAEHHHPAH0@Z ; UI::CGridSlotWindow::GetPickedGridSlotPosition
PUBLIC	?CheckMoving@CGridSlotWindow@UI@@IAEHKKABV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z ; UI::CGridSlotWindow::CheckMoving
PUBLIC	?OnIsType@CGridSlotWindow@UI@@MAEHK@Z		; UI::CGridSlotWindow::OnIsType
PUBLIC	?OnRefreshSlot@CGridSlotWindow@UI@@MAEXXZ	; UI::CGridSlotWindow::OnRefreshSlot
PUBLIC	?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ	; UI::CGridSlotWindow::OnRenderPickingSlot
PUBLIC	?deallocate@?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@QAEXQAPAUSSlot@CSlotWindow@UI@@I@Z ; std::allocator<UI::CSlotWindow::SSlot *>::deallocate
PUBLIC	?clear@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear
PUBLIC	?_Destroy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXPAPAUSSlot@CSlotWindow@UI@@0@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@ABEII@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXQAPAUSSlot@CSlotWindow@UI@@II@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@CAXXZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Xlength
PUBLIC	?_Getal@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@2@XZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Getal
PUBLIC	??_GCGridSlotWindow@UI@@UAEPAXI@Z		; UI::CGridSlotWindow::`scalar deleting destructor'
PUBLIC	??0?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >
PUBLIC	??1?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::~list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >
PUBLIC	?begin@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::begin
PUBLIC	?clear@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear
PUBLIC	?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Alloc_sentinel_and_proxy
PUBLIC	??$find@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@@Z ; std::find<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot *> > >,UI::CSlotWindow::SSlot *>
PUBLIC	??D?$reverse_iterator@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@std@@@std@@QBEAAUSSlot@CSlotWindow@UI@@XZ ; std::reverse_iterator<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot> > > >::operator*
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
PUBLIC	??$_Emplace@ABQAUSSlot@CSlotWindow@UI@@@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@1@QAU21@ABQAUSSlot@CSlotWindow@UI@@@Z ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Emplace<UI::CSlotWindow::SSlot * const &>
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Destroy_range<std::allocator<UI::CSlotWindow::SSlot *> >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_Transfer_before
PUBLIC	??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > ><UI::CSlotWindow::SSlot * const &>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * const &>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@IAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<UI::CSlotWindow::SSlot *> >
PUBLIC	??$_Find_unchecked1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@U?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot *> > >,UI::CSlotWindow::SSlot *>
PUBLIC	??$_Zero_range@PAPAUSSlot@CSlotWindow@UI@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0@Z ; std::_Zero_range<UI::CSlotWindow::SSlot * *>
PUBLIC	??$_Uninitialized_move@PAPAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0PAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Uninitialized_move<UI::CSlotWindow::SSlot * *,std::allocator<UI::CSlotWindow::SSlot *> >
PUBLIC	??$_Copy_memmove@PAPAUSSlot@CSlotWindow@UI@@PAPAU123@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@00@Z ; std::_Copy_memmove<UI::CSlotWindow::SSlot * *,UI::CSlotWindow::SSlot * *>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CGridSlotWindow@UI@@6B@			; UI::CGridSlotWindow::`vftable'
PUBLIC	??_C@_0BA@BFEGLPNH@CGridSlotWindow@		; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_R1A@?0A@EA@CWindow@UI@@8			; UI::CWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCWindow@UI@@@8				; UI::CWindow `RTTI Type Descriptor'
PUBLIC	??_R3CWindow@UI@@8				; UI::CWindow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWindow@UI@@8				; UI::CWindow::`RTTI Base Class Array'
PUBLIC	??_R4CGridSlotWindow@UI@@6B@			; UI::CGridSlotWindow::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCGridSlotWindow@UI@@@8			; UI::CGridSlotWindow `RTTI Type Descriptor'
PUBLIC	??_R3CGridSlotWindow@UI@@8			; UI::CGridSlotWindow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CGridSlotWindow@UI@@8			; UI::CGridSlotWindow::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CGridSlotWindow@UI@@8		; UI::CGridSlotWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CSlotWindow@UI@@8			; UI::CSlotWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCSlotWindow@UI@@@8			; UI::CSlotWindow `RTTI Type Descriptor'
PUBLIC	??_R3CSlotWindow@UI@@8				; UI::CSlotWindow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSlotWindow@UI@@8				; UI::CSlotWindow::`RTTI Base Class Array'
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?GetCRC32@@YAKPBDI@Z:PROC			; GetCRC32
EXTRN	?RenderBar2d@CScreen@@QAEXMMMMM@Z:PROC		; CScreen::RenderBar2d
EXTRN	?SetDiffuseColor@CScreen@@QAEXMMMM@Z:PROC	; CScreen::SetDiffuseColor
EXTRN	?IsAttaching@CWindowManager@UI@@QAEHXZ:PROC	; UI::CWindowManager::IsAttaching
EXTRN	?GetAttachingIndex@CWindowManager@UI@@QAEKXZ:PROC ; UI::CWindowManager::GetAttachingIndex
EXTRN	?GetAttachingSlotNumber@CWindowManager@UI@@QAEKXZ:PROC ; UI::CWindowManager::GetAttachingSlotNumber
EXTRN	?GetAttachingIconSize@CWindowManager@UI@@QAEXPAE0@Z:PROC ; UI::CWindowManager::GetAttachingIconSize
EXTRN	?SetSize@CWindow@UI@@QAEXJJ@Z:PROC		; UI::CWindow::SetSize
EXTRN	?GetMouseLocalPosition@CWindow@UI@@QAEXAAJ0@Z:PROC ; UI::CWindow::GetMouseLocalPosition
EXTRN	?OnSetFocus@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnSetFocus
EXTRN	?OnKillFocus@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnKillFocus
EXTRN	?OnMouseDrag@CWindow@UI@@UAEXJJ@Z:PROC		; UI::CWindow::OnMouseDrag
EXTRN	?OnMouseOverIn@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnMouseOverIn
EXTRN	?OnDrop@CWindow@UI@@UAEXXZ:PROC			; UI::CWindow::OnDrop
EXTRN	?OnTop@CWindow@UI@@UAEXXZ:PROC			; UI::CWindow::OnTop
EXTRN	?OnIMEUpdate@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnIMEUpdate
EXTRN	?OnMoveWindow@CWindow@UI@@UAEXJJ@Z:PROC		; UI::CWindow::OnMoveWindow
EXTRN	?OnIMETabEvent@CWindow@UI@@UAEHXZ:PROC		; UI::CWindow::OnIMETabEvent
EXTRN	?OnIMEReturnEvent@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnIMEReturnEvent
EXTRN	?OnIMEKeyDownEvent@CWindow@UI@@UAEHH@Z:PROC	; UI::CWindow::OnIMEKeyDownEvent
EXTRN	?OnIMEChangeCodePage@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnIMEChangeCodePage
EXTRN	?OnIMEOpenCandidateListEvent@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnIMEOpenCandidateListEvent
EXTRN	?OnIMECloseCandidateListEvent@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnIMECloseCandidateListEvent
EXTRN	?OnIMEOpenReadingWndEvent@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnIMEOpenReadingWndEvent
EXTRN	?OnIMECloseReadingWndEvent@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnIMECloseReadingWndEvent
EXTRN	?OnMouseRightButtonUp@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnMouseRightButtonUp
EXTRN	?OnMouseRightButtonDoubleClick@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnMouseRightButtonDoubleClick
EXTRN	?OnMouseMiddleButtonDown@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnMouseMiddleButtonDown
EXTRN	?OnMouseMiddleButtonUp@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnMouseMiddleButtonUp
EXTRN	?OnKeyDown@CWindow@UI@@UAEHH@Z:PROC		; UI::CWindow::OnKeyDown
EXTRN	?OnKeyUp@CWindow@UI@@UAEHH@Z:PROC		; UI::CWindow::OnKeyUp
EXTRN	?OnPressEscapeKey@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnPressEscapeKey
EXTRN	?OnPressExitKey@CWindow@UI@@UAEHXZ:PROC		; UI::CWindow::OnPressExitKey
EXTRN	??0CSlotWindow@UI@@QAE@PAU_object@@@Z:PROC	; UI::CSlotWindow::CSlotWindow
EXTRN	??1CSlotWindow@UI@@UAE@XZ:PROC			; UI::CSlotWindow::~CSlotWindow
EXTRN	?Destroy@CSlotWindow@UI@@QAEXXZ:PROC		; UI::CSlotWindow::Destroy
EXTRN	?AppendSlot@CSlotWindow@UI@@QAEXKHHHH@Z:PROC	; UI::CSlotWindow::AppendSlot
EXTRN	?OnUpdate@CSlotWindow@UI@@MAEXXZ:PROC		; UI::CSlotWindow::OnUpdate
EXTRN	?OnRender@CSlotWindow@UI@@MAEXXZ:PROC		; UI::CSlotWindow::OnRender
EXTRN	?OnMouseLeftButtonDown@CSlotWindow@UI@@MAEHXZ:PROC ; UI::CSlotWindow::OnMouseLeftButtonDown
EXTRN	?OnMouseLeftButtonUp@CSlotWindow@UI@@MAEHXZ:PROC ; UI::CSlotWindow::OnMouseLeftButtonUp
EXTRN	?OnMouseRightButtonDown@CSlotWindow@UI@@MAEHXZ:PROC ; UI::CSlotWindow::OnMouseRightButtonDown
EXTRN	?OnMouseLeftButtonDoubleClick@CSlotWindow@UI@@MAEHXZ:PROC ; UI::CSlotWindow::OnMouseLeftButtonDoubleClick
EXTRN	?OnMouseOverOut@CSlotWindow@UI@@MAEXXZ:PROC	; UI::CSlotWindow::OnMouseOverOut
EXTRN	?OnMouseOver@CSlotWindow@UI@@MAEXXZ:PROC	; UI::CSlotWindow::OnMouseOver
EXTRN	?OnRenderSelectedSlot@CSlotWindow@UI@@MAEXXZ:PROC ; UI::CSlotWindow::OnRenderSelectedSlot
EXTRN	?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z:PROC ; UI::CSlotWindow::GetSlotPointer
EXTRN	?GetPickedSlotPointer@CSlotWindow@UI@@MAEHPAPAUSSlot@12@@Z:PROC ; UI::CSlotWindow::GetPickedSlotPointer
EXTRN	?OnIsType@CSlotWindow@UI@@MAEHK@Z:PROC		; UI::CSlotWindow::OnIsType
EXTRN	??_ECGridSlotWindow@UI@@UAEPAXI@Z:PROC		; UI::CGridSlotWindow::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A DD 01H DUP (?) ; CSingleton<CPythonGraphic>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A DD 01H DUP (?) ; CSingleton<UI::CWindowManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_Type@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA
_BSS	SEGMENT
?s_Type@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA DD 01H DUP (?) ; `UI::CGridSlotWindow::Type'::`2'::s_Type
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA DD 01H DUP (?) ; `UI::CGridSlotWindow::Type'::`2'::$TSS0
_BSS	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT ??_R2CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R2CSlotWindow@UI@@8 DD FLAT:??_R1A@?0A@EA@CSlotWindow@UI@@8 ; UI::CSlotWindow::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R3CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R3CSlotWindow@UI@@8 DD 00H				; UI::CSlotWindow::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSlotWindow@UI@@@8
data$rs	SEGMENT
??_R0?AVCSlotWindow@UI@@@8 DD FLAT:??_7type_info@@6B@	; UI::CSlotWindow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSlotWindow@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSlotWindow@UI@@8 DD FLAT:??_R0?AVCSlotWindow@UI@@@8 ; UI::CSlotWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CGridSlotWindow@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CGridSlotWindow@UI@@8 DD FLAT:??_R0?AVCGridSlotWindow@UI@@@8 ; UI::CGridSlotWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CGridSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R2CGridSlotWindow@UI@@8
rdata$r	SEGMENT
??_R2CGridSlotWindow@UI@@8 DD FLAT:??_R1A@?0A@EA@CGridSlotWindow@UI@@8 ; UI::CGridSlotWindow::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CSlotWindow@UI@@8
	DD	FLAT:??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R3CGridSlotWindow@UI@@8
rdata$r	SEGMENT
??_R3CGridSlotWindow@UI@@8 DD 00H			; UI::CGridSlotWindow::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CGridSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCGridSlotWindow@UI@@@8
data$rs	SEGMENT
??_R0?AVCGridSlotWindow@UI@@@8 DD FLAT:??_7type_info@@6B@ ; UI::CGridSlotWindow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCGridSlotWindow@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CGridSlotWindow@UI@@6B@
rdata$r	SEGMENT
??_R4CGridSlotWindow@UI@@6B@ DD 00H			; UI::CGridSlotWindow::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCGridSlotWindow@UI@@@8
	DD	FLAT:??_R3CGridSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R2CWindow@UI@@8
rdata$r	SEGMENT
??_R2CWindow@UI@@8 DD FLAT:??_R1A@?0A@EA@CWindow@UI@@8	; UI::CWindow::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CWindow@UI@@8
rdata$r	SEGMENT
??_R3CWindow@UI@@8 DD 00H				; UI::CWindow::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWindow@UI@@@8
data$rs	SEGMENT
??_R0?AVCWindow@UI@@@8 DD FLAT:??_7type_info@@6B@	; UI::CWindow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWindow@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWindow@UI@@8 DD FLAT:??_R0?AVCWindow@UI@@@8 ; UI::CWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BFEGLPNH@CGridSlotWindow@
CONST	SEGMENT
??_C@_0BA@BFEGLPNH@CGridSlotWindow@ DB 'CGridSlotWindow', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7CGridSlotWindow@UI@@6B@
CONST	SEGMENT
??_7CGridSlotWindow@UI@@6B@ DD FLAT:??_R4CGridSlotWindow@UI@@6B@ ; UI::CGridSlotWindow::`vftable'
	DD	FLAT:??_ECGridSlotWindow@UI@@UAEPAXI@Z
	DD	FLAT:?OnRender@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnUpdate@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnChangePosition@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnSetFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnKillFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseDrag@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnMouseOverIn@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseOverOut@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnMouseOver@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnDrop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnTop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnIMEUpdate@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMoveWindow@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnIMETabEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEReturnEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEKeyDownEvent@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnIMEChangeCodePage@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonDown@CSlotWindow@UI@@MAEHXZ
	DD	FLAT:?OnMouseLeftButtonUp@CSlotWindow@UI@@MAEHXZ
	DD	FLAT:?OnMouseLeftButtonDoubleClick@CSlotWindow@UI@@MAEHXZ
	DD	FLAT:?OnMouseRightButtonDown@CSlotWindow@UI@@MAEHXZ
	DD	FLAT:?OnMouseRightButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonDoubleClick@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonDown@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnKeyDown@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnKeyUp@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnPressEscapeKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnPressExitKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?SetColor@CWindow@UI@@UAEXK@Z
	DD	FLAT:?OnIsType@CGridSlotWindow@UI@@MAEHK@Z
	DD	FLAT:?IsWindow@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnRenderSelectedSlot@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z
	DD	FLAT:?OnRefreshSlot@CGridSlotWindow@UI@@MAEXXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z$0
__ehfuncinfo$??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ$0
__ehfuncinfo$?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z$0
__ehfuncinfo$?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Type@CGridSlotWindow@UI@@SAKXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Type@CGridSlotWindow@UI@@SAKXZ$0
__ehfuncinfo$?Type@CGridSlotWindow@UI@@SAKXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Type@CGridSlotWindow@UI@@SAKXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUSSlot@CSlotWindow@UI@@PAPAU123@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUSSlot@CSlotWindow@UI@@PAPAU123@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@00@Z PROC ; std::_Copy_memmove<UI::CSlotWindow::SSlot * *,UI::CSlotWindow::SSlot * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAUSSlot@CSlotWindow@UI@@PAPAU123@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@00@Z ENDP ; std::_Copy_memmove<UI::CSlotWindow::SSlot * *,UI::CSlotWindow::SSlot * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0PAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0PAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z PROC ; std::_Uninitialized_move<UI::CSlotWindow::SSlot * *,std::allocator<UI::CSlotWindow::SSlot *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAUSSlot@CSlotWindow@UI@@PAPAU123@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@00@Z ; std::_Copy_memmove<UI::CSlotWindow::SSlot * *,UI::CSlotWindow::SSlot * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0PAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ENDP ; std::_Uninitialized_move<UI::CSlotWindow::SSlot * *,std::allocator<UI::CSlotWindow::SSlot *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PAPAUSSlot@CSlotWindow@UI@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAUSSlot@CSlotWindow@UI@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0@Z PROC ; std::_Zero_range<UI::CSlotWindow::SSlot * *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00014	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1856 :     return _Last;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1857 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$_Zero_range@PAPAUSSlot@CSlotWindow@UI@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0@Z ENDP ; std::_Zero_range<UI::CSlotWindow::SSlot * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Find_unchecked1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv92 = -12						; size = 4
tv129 = -8						; size = 4
$T3 = -2						; size = 1
$T4 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Find_unchecked1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot *> > >,UI::CSlotWindow::SSlot *>, COMDAT

; 5437 : _NODISCARD constexpr _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 5439 :     for (; _First != _Last; ++_First) {

  00006	eb 08		 jmp	 SHORT $LN4@Find_unche
$LN2@Find_unche:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 52   :         _Ptr = _Ptr->_Next;

  00008	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Find_unche:

; 74   :         return _Ptr == _Right._Ptr;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00013	3b 45 10	 cmp	 eax, DWORD PTR __Last$[ebp]
  00016	75 09		 jne	 SHORT $LN20@Find_unche
  00018	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv129[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN21@Find_unche
$LN20@Find_unche:
  00021	83 65 f8 00	 and	 DWORD PTR tv129[ebp], 0
$LN21@Find_unche:
  00025	8a 45 f8	 mov	 al, BYTE PTR tv129[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T4[ebp], al

; 78   :         return !(*this == _Right);

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T4[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	75 09		 jne	 SHORT $LN15@Find_unche
  00033	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv92[ebp], 1
  0003a	eb 04		 jmp	 SHORT $LN16@Find_unche
$LN15@Find_unche:
  0003c	83 65 f4 00	 and	 DWORD PTR tv92[ebp], 0
$LN16@Find_unche:
  00040	8a 45 f4	 mov	 al, BYTE PTR tv92[ebp]
  00043	88 45 fe	 mov	 BYTE PTR $T3[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5439 :     for (; _First != _Last; ++_First) {

  00046	0f b6 45 fe	 movzx	 eax, BYTE PTR $T3[ebp]
  0004a	85 c0		 test	 eax, eax
  0004c	74 1f		 je	 SHORT $LN3@Find_unche
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 44   :         return _Ptr->_Myval;

  0004e	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  00051	83 c0 08	 add	 eax, 8
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 100  :         return const_cast<reference>(_Mybase::operator*());

  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5440 :         if (*_First == _Val) {

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 4d 14	 mov	 ecx, DWORD PTR __Val$[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	3b 01		 cmp	 eax, DWORD PTR [ecx]
  00067	75 02		 jne	 SHORT $LN5@Find_unche

; 5441 :             break;

  00069	eb 02		 jmp	 SHORT $LN3@Find_unche
$LN5@Find_unche:

; 5442 :         }
; 5443 :     }

  0006b	eb 9b		 jmp	 SHORT $LN2@Find_unche
$LN3@Find_unche:

; 5444 : 
; 5445 :     return _First;

  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00073	89 08		 mov	 DWORD PTR [eax], ecx
  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5446 : }

  00078	c9		 leave
  00079	c3		 ret	 0
??$_Find_unchecked1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot *> > >,UI::CSlotWindow::SSlot *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@IAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z
_TEXT	SEGMENT
__PFirst$1 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@IAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<UI::CSlotWindow::SSlot *> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR __PFirst$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR __PFirst$1[ebp]
  00010	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00013	50		 push	 eax
  00014	ff 75 fc	 push	 DWORD PTR __PFirst$1[ebp]
  00017	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAUSSlot@CSlotWindow@UI@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0@Z ; std::_Zero_range<UI::CSlotWindow::SSlot * *>
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx

; 1868 :         return _First + _Count;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00024	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1871 :         for (; 0 < _Count; --_Count) {
; 1872 :             _Backout._Emplace_back();
; 1873 :         }
; 1874 : 
; 1875 :         return _Backout._Release();
; 1876 :     }
; 1877 : }

  00027	c9		 leave
  00028	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@IAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<UI::CSlotWindow::SSlot *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Max_possible$2 = -148					; size = 4
$T3 = -144						; size = 4
$T4 = -140						; size = 4
__First$ = -136						; size = 4
__Last$ = -132						; size = 4
$T5 = -128						; size = 4
$T6 = -124						; size = 4
tv244 = -120						; size = 4
$T7 = -116						; size = 4
$T8 = -112						; size = 4
$T9 = -108						; size = 4
$T10 = -104						; size = 4
$T11 = -100						; size = 4
$T12 = -96						; size = 4
$T13 = -92						; size = 4
$T14 = -88						; size = 4
$T15 = -84						; size = 4
__Appended_last$ = -80					; size = 4
__Myfirst$ = -76					; size = 4
__Mylast$ = -72						; size = 4
__Oldsize$ = -68					; size = 4
__My_data$ = -64					; size = 4
tv147 = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
__Appended_first$ = -48					; size = 4
___formal$ = -44					; size = 1
___formal$ = -40					; size = 1
__Overflow_is_possible$18 = -33				; size = 1
__Newvec$ = -32						; size = 4
__Newcapacity$ = -28					; size = 4
$T19 = -21						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00035	89 45 ac	 mov	 DWORD PTR $T15[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00038	8b 45 ac	 mov	 eax, DWORD PTR $T15[ebp]
  0003b	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00041	c7 45 cc ff ff
	ff 3f		 mov	 DWORD PTR $T17[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00048	c7 45 a8 ff ff
	ff 7f		 mov	 DWORD PTR $T14[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0004f	8b 45 a8	 mov	 eax, DWORD PTR $T14[ebp]
  00052	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00055	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  00058	3b 45 c8	 cmp	 eax, DWORD PTR $T16[ebp]
  0005b	73 08		 jae	 SHORT $LN26@Resize_rea
  0005d	8d 45 cc	 lea	 eax, DWORD PTR $T17[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
  00063	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  00065	8d 45 c8	 lea	 eax, DWORD PTR $T16[ebp]
  00068	89 45 c4	 mov	 DWORD PTR tv147[ebp], eax
$LN27@Resize_rea:
  0006b	8b 45 c4	 mov	 eax, DWORD PTR tv147[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T13[ebp], eax
  00071	8b 45 a4	 mov	 eax, DWORD PTR $T13[ebp]
  00074	89 45 a0	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00077	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	89 45 9c	 mov	 DWORD PTR $T11[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  0007f	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00082	3b 45 9c	 cmp	 eax, DWORD PTR $T11[ebp]
  00085	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00087	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@CAXXZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  0008c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008f	89 45 c0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  00092	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	89 45 b4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00098	8b 45 c0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009b	83 c0 04	 add	 eax, 4
  0009e	89 45 b8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  000a1	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a4	8b 4d b4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	2b 01		 sub	 eax, DWORD PTR [ecx]
  000ab	c1 f8 02	 sar	 eax, 2
  000ae	89 45 bc	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000b1	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@ABEII@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Calculate_growth
  000bc	89 45 e4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000bf	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000c2	89 45 98	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000c5	8b 45 98	 mov	 eax, DWORD PTR $T10[ebp]
  000c8	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000ce	c6 45 df 01	 mov	 BYTE PTR __Overflow_is_possible$18[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000d2	c7 85 6c ff ff
	ff ff ff ff 3f	 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000dc	81 7d e4 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000e3	76 05		 jbe	 SHORT $LN65@Resize_rea

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000e5	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN65@Resize_rea:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000ea	8b 45 e4	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000ed	c1 e0 02	 shl	 eax, 2
  000f0	89 45 94	 mov	 DWORD PTR $T9[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000f3	ff 75 94	 push	 DWORD PTR $T9[ebp]
  000f6	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000fb	59		 pop	 ecx
  000fc	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000ff	8b 45 bc	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  00102	8b 4d e0	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00105	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00108	89 45 d0	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  0010b	8b 45 d0	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  0010e	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  00111	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00115	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00118	8a 00		 mov	 al, BYTE PTR [eax]
  0011a	88 45 d8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0011d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00120	89 45 90	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00123	8b 45 90	 mov	 eax, DWORD PTR $T8[ebp]
  00126	89 45 8c	 mov	 DWORD PTR $T7[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00129	ff 75 8c	 push	 DWORD PTR $T7[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  0012c	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0012f	2b 45 bc	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00132	50		 push	 eax
  00133	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00136	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@IAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<UI::CSlotWindow::SSlot *> >
  0013b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013e	89 45 88	 mov	 DWORD PTR tv244[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00141	8b 45 88	 mov	 eax, DWORD PTR tv244[ebp]
  00144	89 45 b0	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00147	8b 45 b8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0014a	8b 00		 mov	 eax, DWORD PTR [eax]
  0014c	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Last$[ebp], eax
  00152	8b 45 b4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00155	8b 00		 mov	 eax, DWORD PTR [eax]
  00157	89 85 78 ff ff
	ff		 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0015d	33 c0		 xor	 eax, eax
  0015f	88 45 eb	 mov	 BYTE PTR $T19[ebp], al
  00162	8a 45 eb	 mov	 al, BYTE PTR $T19[ebp]
  00165	88 45 d4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00168	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0016b	89 45 84	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0016e	8b 45 84	 mov	 eax, DWORD PTR $T6[ebp]
  00171	89 45 80	 mov	 DWORD PTR $T5[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00174	ff 75 80	 push	 DWORD PTR $T5[ebp]
  00177	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  0017a	ff b5 7c ff ff
	ff		 push	 DWORD PTR __Last$[ebp]
  00180	ff b5 78 ff ff
	ff		 push	 DWORD PTR __First$[ebp]
  00186	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@QAPAU123@0PAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Uninitialized_move<UI::CSlotWindow::SSlot * *,std::allocator<UI::CSlotWindow::SSlot *> >
  0018b	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0018e	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  00190	ff 75 b0	 push	 DWORD PTR __Appended_last$[ebp]
  00193	ff 75 d0	 push	 DWORD PTR __Appended_first$[ebp]
  00196	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00199	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXPAPAUSSlot@CSlotWindow@UI@@0@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  0019e	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001a1	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001a4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001a7	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@2@XZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Getal
  001ac	8b c8		 mov	 ecx, eax
  001ae	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@QAEXQAPAUSSlot@CSlotWindow@UI@@I@Z ; std::allocator<UI::CSlotWindow::SSlot *>::deallocate

; 1204 :         _RERAISE;

  001b3	6a 00		 push	 0
  001b5	6a 00		 push	 0
  001b7	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  001bc	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  001c1	c3		 ret	 0
$LN5@Resize_rea:
  001c2	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  001c6	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  001c8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001cc	ff 75 e4	 push	 DWORD PTR __Newcapacity$[ebp]
  001cf	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  001d2	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  001d5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  001d8	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXQAPAUSSlot@CSlotWindow@UI@@II@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Change_array
$LN68@Resize_rea:

; 1208 :     }

  001dd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001e0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001e7	59		 pop	 ecx
  001e8	5f		 pop	 edi
  001e9	5e		 pop	 esi
  001ea	5b		 pop	 ebx
  001eb	c9		 leave
  001ec	c2 08 00	 ret	 8
  001ef	cc		 int	 3
  001f0	cc		 int	 3
  001f1	cc		 int	 3
  001f2	cc		 int	 3
  001f3	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > ><UI::CSlotWindow::SSlot * const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00046	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	83 c0 08	 add	 eax, 8
  00052	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  00058	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00063	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00066	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00069	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006c	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0006f	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00072	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00075	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	c9		 leave
  0008c	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > ><UI::CSlotWindow::SSlot * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 12		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 0c	 imul	 eax, eax, 12
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 0c	 imul	 eax, eax, 12
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z PROC ; std::_Destroy_range<std::allocator<UI::CSlotWindow::SSlot *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<UI::CSlotWindow::SSlot *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 0c	 imul	 eax, eax, 12
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	c1 f8 02	 sar	 eax, 2
  0002b	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00031	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00034	73 3d		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00036	8b 45 ec	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0003e	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00041	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  00044	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00047	8b 00		 mov	 eax, DWORD PTR [eax]
  00049	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0004c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0004f	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00052	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  00055	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00058	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  0005b	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  0005e	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  00061	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Destroy_range<std::allocator<UI::CSlotWindow::SSlot *> >
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  00069	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006c	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  00071	eb 67		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  00073	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00076	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00079	76 5f		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  0007b	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007e	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00081	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00084	2b 01		 sub	 eax, DWORD PTR [ecx]
  00086	c1 f8 02	 sar	 eax, 2
  00089	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  0008c	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0008f	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00092	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  00094	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  00097	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  000a2	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  000a4	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000ac	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000af	8a 00		 mov	 al, BYTE PTR [eax]
  000b1	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000b4	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b7	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000ba	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000bd	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c0	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000c3	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000c6	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c9	50		 push	 eax
  000ca	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000cd	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAPAPAUSSlot@CSlotWindow@UI@@PAPAU123@IAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<UI::CSlotWindow::SSlot *> >
  000d2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000d5	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000d8	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000da	c9		 leave
  000db	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABQAUSSlot@CSlotWindow@UI@@@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@1@QAU21@ABQAUSSlot@CSlotWindow@UI@@@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABQAUSSlot@CSlotWindow@UI@@@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@1@QAU21@ABQAUSSlot@CSlotWindow@UI@@@Z PROC ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Emplace<UI::CSlotWindow::SSlot * const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 55 55
	55 15		 mov	 DWORD PTR $T12[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABQAUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@ABQAUSSlot@CSlotWindow@UI@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > ><UI::CSlotWindow::SSlot * const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABQAUSSlot@CSlotWindow@UI@@@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@1@QAU21@ABQAUSSlot@CSlotWindow@UI@@@Z ENDP ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Emplace<UI::CSlotWindow::SSlot * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??D?$reverse_iterator@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@std@@@std@@QBEAAUSSlot@CSlotWindow@UI@@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
__New_ptr$4 = -12					; size = 4
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
??D?$reverse_iterator@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@std@@@std@@QBEAAUSSlot@CSlotWindow@UI@@XZ PROC ; std::reverse_iterator<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot> > > >::operator*, COMDAT
; _this$ = ecx

; 1930 :     _NODISCARD _CONSTEXPR17 reference operator*() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1931 :         _BidIt _Tmp = current;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 fc	 mov	 DWORD PTR __Tmp$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 177  :         const auto _New_ptr = this->_Ptr->_Prev;

  00011	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f4	 mov	 DWORD PTR __New_ptr$4[ebp], eax

; 178  : #if _ITERATOR_DEBUG_LEVEL == 2
; 179  :         const auto _Mycont = static_cast<const _Mylist*>(this->_Getcont());
; 180  :         _STL_ASSERT(_Mycont, "cannot decrement value-initialized list iterator");
; 181  :         _STL_VERIFY(_New_ptr != _Mycont->_Myhead, "cannot decrement begin list iterator");
; 182  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 183  : 
; 184  :         this->_Ptr = _New_ptr;

  0001a	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$4[ebp]
  0001d	89 45 fc	 mov	 DWORD PTR __Tmp$[ebp], eax

; 259  :         return *this;

  00020	8d 45 fc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax

; 152  :         return this->_Ptr->_Myval;

  00026	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	83 c0 08	 add	 eax, 8
  0002e	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00031	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00034	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1932 :         return *--_Tmp;

  00037	8b 45 e8	 mov	 eax, DWORD PTR $T1[ebp]

; 1933 :     }

  0003a	c9		 leave
  0003b	c3		 ret	 0
??D?$reverse_iterator@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@std@@@std@@QBEAAUSSlot@CSlotWindow@UI@@XZ ENDP ; std::reverse_iterator<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$find@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
__First$ = -28						; size = 4
__Last$ = -24						; size = 4
$T5 = -20						; size = 1
$T6 = -16						; size = 4
$T7 = -12						; size = 4
___param0$8 = -8					; size = 4
___param0$9 = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Val$ = 20						; size = 4
??$find@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@@Z PROC ; std::find<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot *> > >,UI::CSlotWindow::SSlot *>, COMDAT

; 5478 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1079 :         return nullptr;

  00006	83 65 d8 00	 and	 DWORD PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 271  :         return _List_unchecked_iterator<_Mylist>(this->_Ptr, static_cast<const _Mylist*>(this->_Getcont()));

  0000a	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0000d	89 45 fc	 mov	 DWORD PTR ___param0$9[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00010	8b 45 fc	 mov	 eax, DWORD PTR ___param0$9[ebp]
  00013	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1079 :         return nullptr;

  00016	83 65 d4 00	 and	 DWORD PTR $T1[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 271  :         return _List_unchecked_iterator<_Mylist>(this->_Ptr, static_cast<const _Mylist*>(this->_Getcont()));

  0001a	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0001d	89 45 f8	 mov	 DWORD PTR ___param0$8[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00020	8b 45 f8	 mov	 eax, DWORD PTR ___param0$8[ebp]
  00023	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5480 :     _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

  00026	8b 45 f4	 mov	 eax, DWORD PTR $T7[ebp]
  00029	89 45 e8	 mov	 DWORD PTR __Last$[ebp], eax
  0002c	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  0002f	89 45 e4	 mov	 DWORD PTR __First$[ebp], eax

; 5474 :     return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});

  00032	33 c0		 xor	 eax, eax
  00034	88 45 ec	 mov	 BYTE PTR $T5[ebp], al
  00037	ff 75 ec	 push	 DWORD PTR $T5[ebp]
  0003a	ff 75 14	 push	 DWORD PTR __Val$[ebp]
  0003d	ff 75 e8	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e4	 push	 DWORD PTR __First$[ebp]
  00043	8d 45 e0	 lea	 eax, DWORD PTR $T4[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Find_unchecked1@V?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_unchecked_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@U?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<std::_List_unchecked_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot *> > >,UI::CSlotWindow::SSlot *>
  0004c	83 c4 14	 add	 esp, 20			; 00000014H

; 1490 :         _It._Seek_to(static_cast<_UIter&&>(_UIt));

  0004f	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00052	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 219  :         this->_Ptr = _It._Ptr;

  00055	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00058	89 45 0c	 mov	 DWORD PTR __First$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 5481 :     return _First;

  0005b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR __First$[ebp]
  00061	89 08		 mov	 DWORD PTR [eax], ecx
  00063	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 5482 : }

  00066	c9		 leave
  00067	c3		 ret	 0
??$find@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@@Z ENDP ; std::find<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot *> > >,UI::CSlotWindow::SSlot *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S12$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ PROC ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S12$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 0c	 imul	 eax, eax, 12
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot *,void *> *,std::_List_node<UI::CSlotWindow::SSlot *,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ENDP ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ PROC ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ENDP ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ PROC ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot *,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot *,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ENDP ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?begin@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
___param0$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ PROC ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::begin, COMDAT
; _this$ = ecx

; 1095 :     _NODISCARD const_iterator begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1096 :         return const_iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1096 :         return const_iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 1096 :         return const_iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1097 :     }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?begin@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ENDP ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ PROC ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::~list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ENDP ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::~list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ PROC ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ENDP ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCGridSlotWindow@UI@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCGridSlotWindow@UI@@UAEPAXI@Z PROC			; UI::CGridSlotWindow::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CGridSlotWindow@UI@@UAE@XZ ; UI::CGridSlotWindow::~CGridSlotWindow
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 d0 00 00 00	 push	 208			; 000000d0H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCGridSlotWindow@UI@@UAEPAXI@Z ENDP			; UI::CGridSlotWindow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@2@XZ PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEAAV?$allocator@PAUSSlot@CSlotWindow@UI@@@2@XZ ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@CAXXZ PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@CAXXZ ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Destroy_range<std::allocator<UI::CSlotWindow::SSlot *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXQAPAUSSlot@CSlotWindow@UI@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXQAPAUSSlot@CSlotWindow@UI@@II@Z PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Destroy_range<std::allocator<UI::CSlotWindow::SSlot *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXQAPAUSSlot@CSlotWindow@UI@@II@Z ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@ABEII@Z PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@ABEII@Z ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXPAPAUSSlot@CSlotWindow@UI@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXPAPAUSSlot@CSlotWindow@UI@@0@Z PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Destroy_range<std::allocator<UI::CSlotWindow::SSlot *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXPAPAUSSlot@CSlotWindow@UI@@0@Z ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ PROC ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@YAXPAPAUSSlot@CSlotWindow@UI@@QAPAU123@AAV?$allocator@PAUSSlot@CSlotWindow@UI@@@0@@Z ; std::_Destroy_range<std::allocator<UI::CSlotWindow::SSlot *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ENDP ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@QAEXQAPAUSSlot@CSlotWindow@UI@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@QAEXQAPAUSSlot@CSlotWindow@UI@@I@Z PROC ; std::allocator<UI::CSlotWindow::SSlot *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@QAEXQAPAUSSlot@CSlotWindow@UI@@I@Z ENDP ; std::allocator<UI::CSlotWindow::SSlot *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
$T7 = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
___param0$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___param0$ = 0						; size = 4
_dwSlotNumber$10 = 4					; size = 4
_dwItemIndex$11 = 8					; size = 4
_pSlot$12 = 12						; size = 4
$T13 = 16						; size = 4
$T14 = 20						; size = 4
$T15 = 24						; size = 4
___param0$ = 28						; size = 4
$T16 = 32						; size = 4
$T17 = 36						; size = 4
$T18 = 40						; size = 4
tv371 = 44						; size = 4
tv345 = 48						; size = 4
tv319 = 52						; size = 4
tv301 = 56						; size = 4
tv522 = 60						; size = 4
tv546 = 64						; size = 4
_itor$19 = 68						; size = 4
_SlotList$ = 72						; size = 8
_byHeight$ = 83						; size = 1
_pCenterSlot$20 = 84					; size = 4
$T21 = 89						; size = 1
$T22 = 90						; size = 1
_byWidth$ = 91						; size = 1
_pSlot$23 = 92						; size = 4
_this$ = 96						; size = 4
_Rect$24 = 100						; size = 16
__$ArrayPad$ = 116					; size = 4
?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ PROC	; UI::CGridSlotWindow::OnRenderPickingSlot, COMDAT
; _this$ = ecx

; 8    : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	83 ec 78	 sub	 esp, 120		; 00000078H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	83 ec 24	 sub	 esp, 36			; 00000024H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 74	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 4d 60	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00030	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00035	89 45 28	 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 9    : 	if (!UI::CWindowManager::Instance().IsAttaching())

  00038	8b 4d 28	 mov	 ecx, DWORD PTR $T18[ebp]
  0003b	e8 00 00 00 00	 call	 ?IsAttaching@CWindowManager@UI@@QAEHXZ ; UI::CWindowManager::IsAttaching
  00040	85 c0		 test	 eax, eax
  00042	75 05		 jne	 SHORT $LN5@OnRenderPi

; 10   : 		return;

  00044	e9 5f 04 00 00	 jmp	 $LN1@OnRenderPi
$LN5@OnRenderPi:

; 11   : 
; 12   : 	BYTE byWidth, byHeight;
; 13   : 	UI::CWindowManager::Instance().GetAttachingIconSize(&byWidth, &byHeight);

  00049	8d 45 53	 lea	 eax, DWORD PTR _byHeight$[ebp]
  0004c	50		 push	 eax
  0004d	8d 45 5b	 lea	 eax, DWORD PTR _byWidth$[ebp]
  00050	50		 push	 eax
  00051	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00057	e8 00 00 00 00	 call	 ?GetAttachingIconSize@CWindowManager@UI@@QAEXPAE0@Z ; UI::CWindowManager::GetAttachingIconSize

; 14   : 
; 15   : 	std::list<TSlot*> SlotList;

  0005c	8d 4d 48	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  0005f	e8 00 00 00 00	 call	 ??0?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >
  00064	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 16   : 	if (GetPickedSlotList(byWidth, byHeight, &SlotList))

  00068	8d 45 48	 lea	 eax, DWORD PTR _SlotList$[ebp]
  0006b	50		 push	 eax
  0006c	0f b6 45 53	 movzx	 eax, BYTE PTR _byHeight$[ebp]
  00070	50		 push	 eax
  00071	0f b6 45 5b	 movzx	 eax, BYTE PTR _byWidth$[ebp]
  00075	50		 push	 eax
  00076	8b 4d 60	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ?GetPickedSlotList@CGridSlotWindow@UI@@IAEHHHPAV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z ; UI::CGridSlotWindow::GetPickedSlotList
  0007e	85 c0		 test	 eax, eax
  00080	0f 84 16 04 00
	00		 je	 $LN6@OnRenderPi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00086	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0008b	89 45 24	 mov	 DWORD PTR $T17[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 18   : 		DWORD dwSlotNumber = UI::CWindowManager::Instance().GetAttachingSlotNumber();

  0008e	8b 4d 24	 mov	 ecx, DWORD PTR $T17[ebp]
  00091	e8 00 00 00 00	 call	 ?GetAttachingSlotNumber@CWindowManager@UI@@QAEKXZ ; UI::CWindowManager::GetAttachingSlotNumber
  00096	89 45 04	 mov	 DWORD PTR _dwSlotNumber$10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0009e	89 45 20	 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 19   : 		DWORD dwItemIndex = UI::CWindowManager::Instance().GetAttachingIndex();

  000a1	8b 4d 20	 mov	 ecx, DWORD PTR $T16[ebp]
  000a4	e8 00 00 00 00	 call	 ?GetAttachingIndex@CWindowManager@UI@@QAEKXZ ; UI::CWindowManager::GetAttachingIndex
  000a9	89 45 08	 mov	 DWORD PTR _dwItemIndex$11[ebp], eax

; 20   : 
; 21   : 		// UseMode ..
; 22   : 		if (m_isUseMode)

  000ac	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  000af	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [eax+148], 0
  000b6	0f 84 74 01 00
	00		 je	 $LN9@OnRenderPi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000bc	8d 45 48	 lea	 eax, DWORD PTR _SlotList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000bf	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000c2	8b 45 48	 mov	 eax, DWORD PTR _SlotList$[ebp]
  000c5	8b 00		 mov	 eax, DWORD PTR [eax]
  000c7	89 45 1c	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000ca	8b 45 1c	 mov	 eax, DWORD PTR ___param0$[ebp]
  000cd	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000d0	8d 45 dc	 lea	 eax, DWORD PTR $T5[ebp]
  000d3	89 45 18	 mov	 DWORD PTR $T15[ebp], eax

; 152  :         return this->_Ptr->_Myval;

  000d6	8b 45 18	 mov	 eax, DWORD PTR $T15[ebp]
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]
  000db	83 c0 08	 add	 eax, 8
  000de	89 45 14	 mov	 DWORD PTR $T14[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000e1	8b 45 14	 mov	 eax, DWORD PTR $T14[ebp]
  000e4	89 45 10	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 25   : 			TSlot * pSlot = *SlotList.begin();

  000e7	8b 45 10	 mov	 eax, DWORD PTR $T13[ebp]
  000ea	8b 00		 mov	 eax, DWORD PTR [eax]
  000ec	89 45 0c	 mov	 DWORD PTR _pSlot$12[ebp], eax

; 26   : 			TSlot * pCenterSlot;
; 27   : 			if (GetSlotPointer(pSlot->dwCenterSlotNumber, &pCenterSlot))

  000ef	8d 45 54	 lea	 eax, DWORD PTR _pCenterSlot$20[ebp]
  000f2	50		 push	 eax
  000f3	8b 45 0c	 mov	 eax, DWORD PTR _pSlot$12[ebp]
  000f6	ff 70 08	 push	 DWORD PTR [eax+8]
  000f9	8b 4d 60	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00101	85 c0		 test	 eax, eax
  00103	0f 84 27 01 00
	00		 je	 $LN9@OnRenderPi

; 28   : 			if (pCenterSlot->isItem)

  00109	8b 45 54	 mov	 eax, DWORD PTR _pCenterSlot$20[ebp]
  0010c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00110	0f 84 1a 01 00
	00		 je	 $LN9@OnRenderPi

; 29   : 			{
; 30   : 				if (m_isUsableItem)

  00116	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00119	83 b8 98 00 00
	00 00		 cmp	 DWORD PTR [eax+152], 0
  00120	74 40		 je	 SHORT $LN10@OnRenderPi

; 31   : 					CPythonGraphic::Instance().SetDiffuseColor(1.0f, 1.0f, 0.0f, 0.5f);

  00122	51		 push	 ecx
  00123	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0012b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00130	51		 push	 ecx
  00131	0f 57 c0	 xorps	 xmm0, xmm0
  00134	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00139	51		 push	 ecx
  0013a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00142	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00147	51		 push	 ecx
  00148	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00150	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  0015b	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor
  00160	eb 39		 jmp	 SHORT $LN11@OnRenderPi
$LN10@OnRenderPi:

; 32   : 				else
; 33   : 					CPythonGraphic::Instance().SetDiffuseColor(1.0f, 0.0f, 0.0f, 0.5f);

  00162	51		 push	 ecx
  00163	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0016b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00170	51		 push	 ecx
  00171	0f 57 c0	 xorps	 xmm0, xmm0
  00174	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00179	51		 push	 ecx
  0017a	0f 57 c0	 xorps	 xmm0, xmm0
  0017d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00182	51		 push	 ecx
  00183	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0018b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  00196	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor
$LN11@OnRenderPi:

; 34   : 
; 35   : 				CPythonGraphic::Instance().RenderBar2d(	m_rect.left + pCenterSlot->ixPosition,

  0019b	51		 push	 ecx
  0019c	0f 57 c0	 xorps	 xmm0, xmm0
  0019f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001a4	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  001a7	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  001aa	8b 4d 54	 mov	 ecx, DWORD PTR _pCenterSlot$20[ebp]
  001ad	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  001b0	8b 4d 54	 mov	 ecx, DWORD PTR _pCenterSlot$20[ebp]
  001b3	0f b6 49 31	 movzx	 ecx, BYTE PTR [ecx+49]
  001b7	c1 e1 05	 shl	 ecx, 5
  001ba	03 c1		 add	 eax, ecx
  001bc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001c0	51		 push	 ecx
  001c1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001c6	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  001c9	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  001cc	8b 4d 54	 mov	 ecx, DWORD PTR _pCenterSlot$20[ebp]
  001cf	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  001d2	8b 4d 54	 mov	 ecx, DWORD PTR _pCenterSlot$20[ebp]
  001d5	0f b6 49 30	 movzx	 ecx, BYTE PTR [ecx+48]
  001d9	c1 e1 05	 shl	 ecx, 5
  001dc	03 c1		 add	 eax, ecx
  001de	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001e2	51		 push	 ecx
  001e3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001e8	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  001eb	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  001ee	8b 4d 54	 mov	 ecx, DWORD PTR _pCenterSlot$20[ebp]
  001f1	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  001f4	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001f8	51		 push	 ecx
  001f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001fe	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00201	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00204	8b 4d 54	 mov	 ecx, DWORD PTR _pCenterSlot$20[ebp]
  00207	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  0020a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0020e	51		 push	 ecx
  0020f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00214	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  0021a	e8 00 00 00 00	 call	 ?RenderBar2d@CScreen@@QAEXMMMMM@Z ; CScreen::RenderBar2d

; 39   : 				return;

  0021f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  00223	8d 4d 48	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  00226	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 39   : 				return;

  0022b	e9 78 02 00 00	 jmp	 $LN1@OnRenderPi
$LN9@OnRenderPi:

; 40   : 			}
; 41   : 		}
; 42   : 
; 43   : 		//   
; 44   : 		if (CheckMoving(dwSlotNumber, dwItemIndex, SlotList))

  00230	8d 45 48	 lea	 eax, DWORD PTR _SlotList$[ebp]
  00233	50		 push	 eax
  00234	ff 75 08	 push	 DWORD PTR _dwItemIndex$11[ebp]
  00237	ff 75 04	 push	 DWORD PTR _dwSlotNumber$10[ebp]
  0023a	8b 4d 60	 mov	 ecx, DWORD PTR _this$[ebp]
  0023d	e8 00 00 00 00	 call	 ?CheckMoving@CGridSlotWindow@UI@@IAEHKKABV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z ; UI::CGridSlotWindow::CheckMoving
  00242	85 c0		 test	 eax, eax
  00244	74 45		 je	 SHORT $LN12@OnRenderPi

; 45   : 			CPythonGraphic::Instance().SetDiffuseColor(1.0f, 1.0f, 1.0f, 0.5f);

  00246	51		 push	 ecx
  00247	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  0024f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00254	51		 push	 ecx
  00255	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0025d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00262	51		 push	 ecx
  00263	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0026b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00270	51		 push	 ecx
  00271	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00279	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0027e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  00284	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor
  00289	eb 39		 jmp	 SHORT $LN13@OnRenderPi
$LN12@OnRenderPi:

; 46   : 		else
; 47   : 			CPythonGraphic::Instance().SetDiffuseColor(1.0f, 0.0f, 0.0f, 0.5f);

  0028b	51		 push	 ecx
  0028c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00294	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00299	51		 push	 ecx
  0029a	0f 57 c0	 xorps	 xmm0, xmm0
  0029d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a2	51		 push	 ecx
  002a3	0f 57 c0	 xorps	 xmm0, xmm0
  002a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ab	51		 push	 ecx
  002ac	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  002b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  002bf	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor
$LN13@OnRenderPi:

; 48   : 
; 49   : 		RECT Rect;
; 50   : 		Rect.left = m_rect.right;

  002c4	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  002c7	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]
  002ca	89 45 64	 mov	 DWORD PTR _Rect$24[ebp], eax

; 51   : 		Rect.top = m_rect.bottom;

  002cd	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  002d0	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  002d3	89 45 68	 mov	 DWORD PTR _Rect$24[ebp+4], eax

; 52   : 		Rect.right = 0;

  002d6	83 65 6c 00	 and	 DWORD PTR _Rect$24[ebp+8], 0

; 53   : 		Rect.bottom = 0;

  002da	83 65 70 00	 and	 DWORD PTR _Rect$24[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  002de	8d 45 48	 lea	 eax, DWORD PTR _SlotList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  002e1	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  002e4	8b 45 48	 mov	 eax, DWORD PTR _SlotList$[ebp]
  002e7	8b 00		 mov	 eax, DWORD PTR [eax]
  002e9	89 45 00	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  002ec	8b 45 00	 mov	 eax, DWORD PTR ___param0$[ebp]
  002ef	89 45 44	 mov	 DWORD PTR _itor$19[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 55   : 		for (std::list<TSlot*>::iterator itor = SlotList.begin(); itor != SlotList.end(); ++itor)

  002f2	eb 08		 jmp	 SHORT $LN134@OnRenderPi
$LN2@OnRenderPi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  002f4	8b 45 44	 mov	 eax, DWORD PTR _itor$19[ebp]
  002f7	8b 00		 mov	 eax, DWORD PTR [eax]
  002f9	89 45 44	 mov	 DWORD PTR _itor$19[ebp], eax
$LN134@OnRenderPi:

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  002fc	8d 45 48	 lea	 eax, DWORD PTR _SlotList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  002ff	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00302	8b 45 48	 mov	 eax, DWORD PTR _SlotList$[ebp]
  00305	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00308	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0030b	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0030e	8d 45 ec	 lea	 eax, DWORD PTR $T9[ebp]
  00311	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00314	8b 45 e8	 mov	 eax, DWORD PTR $T8[ebp]
  00317	8b 4d 44	 mov	 ecx, DWORD PTR _itor$19[ebp]
  0031a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0031c	75 09		 jne	 SHORT $LN165@OnRenderPi
  0031e	c7 45 40 01 00
	00 00		 mov	 DWORD PTR tv546[ebp], 1
  00325	eb 04		 jmp	 SHORT $LN166@OnRenderPi
$LN165@OnRenderPi:
  00327	83 65 40 00	 and	 DWORD PTR tv546[ebp], 0
$LN166@OnRenderPi:
  0032b	8a 45 40	 mov	 al, BYTE PTR tv546[ebp]
  0032e	88 45 5a	 mov	 BYTE PTR $T22[ebp], al

; 203  :         return !(*this == _Right);

  00331	0f b6 45 5a	 movzx	 eax, BYTE PTR $T22[ebp]
  00335	85 c0		 test	 eax, eax
  00337	75 09		 jne	 SHORT $LN160@OnRenderPi
  00339	c7 45 3c 01 00
	00 00		 mov	 DWORD PTR tv522[ebp], 1
  00340	eb 04		 jmp	 SHORT $LN161@OnRenderPi
$LN160@OnRenderPi:
  00342	83 65 3c 00	 and	 DWORD PTR tv522[ebp], 0
$LN161@OnRenderPi:
  00346	8a 45 3c	 mov	 al, BYTE PTR tv522[ebp]
  00349	88 45 59	 mov	 BYTE PTR $T21[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 55   : 		for (std::list<TSlot*>::iterator itor = SlotList.begin(); itor != SlotList.end(); ++itor)

  0034c	0f b6 45 59	 movzx	 eax, BYTE PTR $T21[ebp]
  00350	85 c0		 test	 eax, eax
  00352	0f 84 04 01 00
	00		 je	 $LN3@OnRenderPi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00358	8b 45 44	 mov	 eax, DWORD PTR _itor$19[ebp]
  0035b	83 c0 08	 add	 eax, 8
  0035e	89 45 e4	 mov	 DWORD PTR $T7[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00361	8b 45 e4	 mov	 eax, DWORD PTR $T7[ebp]
  00364	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 57   : 			TSlot * pSlot = *itor;

  00367	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  0036a	8b 00		 mov	 eax, DWORD PTR [eax]
  0036c	89 45 5c	 mov	 DWORD PTR _pSlot$23[ebp], eax

; 58   : 			Rect.left = min(Rect.left, m_rect.left + pSlot->ixPosition);

  0036f	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00372	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00375	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  00378	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  0037b	39 45 64	 cmp	 DWORD PTR _Rect$24[ebp], eax
  0037e	7d 08		 jge	 SHORT $LN15@OnRenderPi
  00380	8b 45 64	 mov	 eax, DWORD PTR _Rect$24[ebp]
  00383	89 45 38	 mov	 DWORD PTR tv301[ebp], eax
  00386	eb 0f		 jmp	 SHORT $LN16@OnRenderPi
$LN15@OnRenderPi:
  00388	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  0038b	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0038e	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  00391	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  00394	89 45 38	 mov	 DWORD PTR tv301[ebp], eax
$LN16@OnRenderPi:
  00397	8b 45 38	 mov	 eax, DWORD PTR tv301[ebp]
  0039a	89 45 64	 mov	 DWORD PTR _Rect$24[ebp], eax

; 59   : 			Rect.top = min(Rect.top, m_rect.top + pSlot->iyPosition);

  0039d	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  003a0	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  003a3	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  003a6	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  003a9	39 45 68	 cmp	 DWORD PTR _Rect$24[ebp+4], eax
  003ac	7d 08		 jge	 SHORT $LN17@OnRenderPi
  003ae	8b 45 68	 mov	 eax, DWORD PTR _Rect$24[ebp+4]
  003b1	89 45 34	 mov	 DWORD PTR tv319[ebp], eax
  003b4	eb 0f		 jmp	 SHORT $LN18@OnRenderPi
$LN17@OnRenderPi:
  003b6	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  003b9	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  003bc	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  003bf	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  003c2	89 45 34	 mov	 DWORD PTR tv319[ebp], eax
$LN18@OnRenderPi:
  003c5	8b 45 34	 mov	 eax, DWORD PTR tv319[ebp]
  003c8	89 45 68	 mov	 DWORD PTR _Rect$24[ebp+4], eax

; 60   : 			Rect.right = max(Rect.right, m_rect.left + pSlot->ixPosition + pSlot->byxPlacedItemSize*ITEM_WIDTH);

  003cb	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  003ce	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  003d1	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  003d4	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  003d7	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  003da	0f b6 49 30	 movzx	 ecx, BYTE PTR [ecx+48]
  003de	c1 e1 05	 shl	 ecx, 5
  003e1	03 c1		 add	 eax, ecx
  003e3	39 45 6c	 cmp	 DWORD PTR _Rect$24[ebp+8], eax
  003e6	7e 08		 jle	 SHORT $LN19@OnRenderPi
  003e8	8b 45 6c	 mov	 eax, DWORD PTR _Rect$24[ebp+8]
  003eb	89 45 30	 mov	 DWORD PTR tv345[ebp], eax
  003ee	eb 1b		 jmp	 SHORT $LN20@OnRenderPi
$LN19@OnRenderPi:
  003f0	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  003f3	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  003f6	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  003f9	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  003fc	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  003ff	0f b6 49 30	 movzx	 ecx, BYTE PTR [ecx+48]
  00403	c1 e1 05	 shl	 ecx, 5
  00406	03 c1		 add	 eax, ecx
  00408	89 45 30	 mov	 DWORD PTR tv345[ebp], eax
$LN20@OnRenderPi:
  0040b	8b 45 30	 mov	 eax, DWORD PTR tv345[ebp]
  0040e	89 45 6c	 mov	 DWORD PTR _Rect$24[ebp+8], eax

; 61   : 			Rect.bottom = max(Rect.bottom, m_rect.top + pSlot->iyPosition + pSlot->byxPlacedItemSize*ITEM_HEIGHT);

  00411	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00414	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00417	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  0041a	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  0041d	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  00420	0f b6 49 30	 movzx	 ecx, BYTE PTR [ecx+48]
  00424	c1 e1 05	 shl	 ecx, 5
  00427	03 c1		 add	 eax, ecx
  00429	39 45 70	 cmp	 DWORD PTR _Rect$24[ebp+12], eax
  0042c	7e 08		 jle	 SHORT $LN21@OnRenderPi
  0042e	8b 45 70	 mov	 eax, DWORD PTR _Rect$24[ebp+12]
  00431	89 45 2c	 mov	 DWORD PTR tv371[ebp], eax
  00434	eb 1b		 jmp	 SHORT $LN22@OnRenderPi
$LN21@OnRenderPi:
  00436	8b 45 60	 mov	 eax, DWORD PTR _this$[ebp]
  00439	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  0043c	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  0043f	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  00442	8b 4d 5c	 mov	 ecx, DWORD PTR _pSlot$23[ebp]
  00445	0f b6 49 30	 movzx	 ecx, BYTE PTR [ecx+48]
  00449	c1 e1 05	 shl	 ecx, 5
  0044c	03 c1		 add	 eax, ecx
  0044e	89 45 2c	 mov	 DWORD PTR tv371[ebp], eax
$LN22@OnRenderPi:
  00451	8b 45 2c	 mov	 eax, DWORD PTR tv371[ebp]
  00454	89 45 70	 mov	 DWORD PTR _Rect$24[ebp+12], eax

; 62   : 		}

  00457	e9 98 fe ff ff	 jmp	 $LN2@OnRenderPi
$LN3@OnRenderPi:

; 63   : 
; 64   : 		CPythonGraphic::Instance().RenderBar2d(Rect.left, Rect.top, Rect.right, Rect.bottom);

  0045c	51		 push	 ecx
  0045d	0f 57 c0	 xorps	 xmm0, xmm0
  00460	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00465	f3 0f 2a 45 70	 cvtsi2ss xmm0, DWORD PTR _Rect$24[ebp+12]
  0046a	51		 push	 ecx
  0046b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00470	f3 0f 2a 45 6c	 cvtsi2ss xmm0, DWORD PTR _Rect$24[ebp+8]
  00475	51		 push	 ecx
  00476	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0047b	f3 0f 2a 45 68	 cvtsi2ss xmm0, DWORD PTR _Rect$24[ebp+4]
  00480	51		 push	 ecx
  00481	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00486	f3 0f 2a 45 64	 cvtsi2ss xmm0, DWORD PTR _Rect$24[ebp]
  0048b	51		 push	 ecx
  0048c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00491	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  00497	e8 00 00 00 00	 call	 ?RenderBar2d@CScreen@@QAEXMMMMM@Z ; CScreen::RenderBar2d
$LN6@OnRenderPi:

; 66   : }

  0049c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  004a0	8d 4d 48	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  004a3	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
$LN1@OnRenderPi:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 66   : }

  004a8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004ab	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004b2	59		 pop	 ecx
  004b3	8b 4d 74	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004b6	33 cd		 xor	 ecx, ebp
  004b8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004bd	83 c5 78	 add	 ebp, 120		; 00000078H
  004c0	c9		 leave
  004c1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ$0:
  00000	8d 4d 48	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::~list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 80 00 00
	00		 mov	 ecx, DWORD PTR [edx+128]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnRenderPickingSlot@CGridSlotWindow@UI@@MAEXXZ ENDP	; UI::CGridSlotWindow::OnRenderPickingSlot
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?OnRefreshSlot@CGridSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
_pSubSlot$1 = -32					; size = 4
_pSlot$2 = -28						; size = 4
_xSub$3 = -24						; size = 4
_ySub$4 = -20						; size = 4
_pSlot$5 = -16						; size = 4
_this$ = -12						; size = 4
_x$ = -8						; size = 4
_y$ = -4						; size = 4
?OnRefreshSlot@CGridSlotWindow@UI@@MAEXXZ PROC		; UI::CGridSlotWindow::OnRefreshSlot, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 304  : 	DWORD x, y;
; 305  : 
; 306  : 	for (x = 0; x < m_dwxCount; ++x)

  00009	83 65 f8 00	 and	 DWORD PTR _x$[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@OnRefreshS
$LN2@OnRefreshS:
  0000f	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00012	40		 inc	 eax
  00013	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
$LN4@OnRefreshS:
  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0001c	3b 88 bc 00 00
	00		 cmp	 ecx, DWORD PTR [eax+188]
  00022	73 43		 jae	 SHORT $LN3@OnRefreshS

; 307  : 	for (y = 0; y < m_dwyCount; ++y)

  00024	83 65 fc 00	 and	 DWORD PTR _y$[ebp], 0
  00028	eb 07		 jmp	 SHORT $LN7@OnRefreshS
$LN5@OnRefreshS:
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  0002d	40		 inc	 eax
  0002e	89 45 fc	 mov	 DWORD PTR _y$[ebp], eax
$LN7@OnRefreshS:
  00031	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _y$[ebp]
  00037	3b 88 c0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+192]
  0003d	73 26		 jae	 SHORT $LN6@OnRefreshS

; 308  : 	{
; 309  : 		TSlot * pSlot;
; 310  : 		if (!GetGridSlotPointer(x, y, &pSlot))

  0003f	8d 45 e4	 lea	 eax, DWORD PTR _pSlot$2[ebp]
  00042	50		 push	 eax
  00043	ff 75 fc	 push	 DWORD PTR _y$[ebp]
  00046	ff 75 f8	 push	 DWORD PTR _x$[ebp]
  00049	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z ; UI::CGridSlotWindow::GetGridSlotPointer
  00051	85 c0		 test	 eax, eax
  00053	75 02		 jne	 SHORT $LN20@OnRefreshS

; 311  : 			continue;

  00055	eb d3		 jmp	 SHORT $LN5@OnRefreshS
$LN20@OnRefreshS:

; 312  : 
; 313  : 		pSlot->dwCenterSlotNumber = pSlot->dwSlotNumber;

  00057	8b 45 e4	 mov	 eax, DWORD PTR _pSlot$2[ebp]
  0005a	8b 4d e4	 mov	 ecx, DWORD PTR _pSlot$2[ebp]
  0005d	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00060	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 314  : 	}

  00063	eb c5		 jmp	 SHORT $LN5@OnRefreshS
$LN6@OnRefreshS:
  00065	eb a8		 jmp	 SHORT $LN2@OnRefreshS
$LN3@OnRefreshS:

; 315  : 
; 316  : 	for (x = 0; x < m_dwxCount; ++x)

  00067	83 65 f8 00	 and	 DWORD PTR _x$[ebp], 0
  0006b	eb 07		 jmp	 SHORT $LN10@OnRefreshS
$LN8@OnRefreshS:
  0006d	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00070	40		 inc	 eax
  00071	89 45 f8	 mov	 DWORD PTR _x$[ebp], eax
$LN10@OnRefreshS:
  00074	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _x$[ebp]
  0007a	3b 88 bc 00 00
	00		 cmp	 ecx, DWORD PTR [eax+188]
  00080	0f 83 c1 00 00
	00		 jae	 $LN1@OnRefreshS

; 317  : 	for (y = 0; y < m_dwyCount; ++y)

  00086	83 65 fc 00	 and	 DWORD PTR _y$[ebp], 0
  0008a	eb 07		 jmp	 SHORT $LN13@OnRefreshS
$LN11@OnRefreshS:
  0008c	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  0008f	40		 inc	 eax
  00090	89 45 fc	 mov	 DWORD PTR _y$[ebp], eax
$LN13@OnRefreshS:
  00093	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00096	8b 4d fc	 mov	 ecx, DWORD PTR _y$[ebp]
  00099	3b 88 c0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+192]
  0009f	0f 83 9d 00 00
	00		 jae	 $LN12@OnRefreshS

; 318  : 	{
; 319  : 		TSlot * pSlot;
; 320  : 		if (!GetGridSlotPointer(x, y, &pSlot))

  000a5	8d 45 f0	 lea	 eax, DWORD PTR _pSlot$5[ebp]
  000a8	50		 push	 eax
  000a9	ff 75 fc	 push	 DWORD PTR _y$[ebp]
  000ac	ff 75 f8	 push	 DWORD PTR _x$[ebp]
  000af	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z ; UI::CGridSlotWindow::GetGridSlotPointer
  000b7	85 c0		 test	 eax, eax
  000b9	75 02		 jne	 SHORT $LN21@OnRefreshS

; 321  : 			continue;

  000bb	eb cf		 jmp	 SHORT $LN11@OnRefreshS
$LN21@OnRefreshS:

; 322  : 
; 323  : 		if (pSlot->isItem)

  000bd	8b 45 f0	 mov	 eax, DWORD PTR _pSlot$5[ebp]
  000c0	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000c4	74 70		 je	 SHORT $LN22@OnRefreshS

; 324  : 		{
; 325  : 			for (DWORD xSub = 0; xSub < pSlot->byxPlacedItemSize; ++xSub)

  000c6	83 65 e8 00	 and	 DWORD PTR _xSub$3[ebp], 0
  000ca	eb 07		 jmp	 SHORT $LN16@OnRefreshS
$LN14@OnRefreshS:
  000cc	8b 45 e8	 mov	 eax, DWORD PTR _xSub$3[ebp]
  000cf	40		 inc	 eax
  000d0	89 45 e8	 mov	 DWORD PTR _xSub$3[ebp], eax
$LN16@OnRefreshS:
  000d3	8b 45 f0	 mov	 eax, DWORD PTR _pSlot$5[ebp]
  000d6	0f b6 40 30	 movzx	 eax, BYTE PTR [eax+48]
  000da	39 45 e8	 cmp	 DWORD PTR _xSub$3[ebp], eax
  000dd	73 55		 jae	 SHORT $LN15@OnRefreshS

; 326  : 			for (DWORD ySub = 0; ySub < pSlot->byyPlacedItemSize; ++ySub)

  000df	83 65 ec 00	 and	 DWORD PTR _ySub$4[ebp], 0
  000e3	eb 07		 jmp	 SHORT $LN19@OnRefreshS
$LN17@OnRefreshS:
  000e5	8b 45 ec	 mov	 eax, DWORD PTR _ySub$4[ebp]
  000e8	40		 inc	 eax
  000e9	89 45 ec	 mov	 DWORD PTR _ySub$4[ebp], eax
$LN19@OnRefreshS:
  000ec	8b 45 f0	 mov	 eax, DWORD PTR _pSlot$5[ebp]
  000ef	0f b6 40 31	 movzx	 eax, BYTE PTR [eax+49]
  000f3	39 45 ec	 cmp	 DWORD PTR _ySub$4[ebp], eax
  000f6	73 3a		 jae	 SHORT $LN18@OnRefreshS

; 327  : 			{
; 328  : 				TSlot * pSubSlot;
; 329  : 				if (!GetGridSlotPointer(x+xSub, y+ySub, &pSubSlot))

  000f8	8d 45 e0	 lea	 eax, DWORD PTR _pSubSlot$1[ebp]
  000fb	50		 push	 eax
  000fc	8b 45 fc	 mov	 eax, DWORD PTR _y$[ebp]
  000ff	03 45 ec	 add	 eax, DWORD PTR _ySub$4[ebp]
  00102	50		 push	 eax
  00103	8b 45 f8	 mov	 eax, DWORD PTR _x$[ebp]
  00106	03 45 e8	 add	 eax, DWORD PTR _xSub$3[ebp]
  00109	50		 push	 eax
  0010a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	e8 00 00 00 00	 call	 ?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z ; UI::CGridSlotWindow::GetGridSlotPointer
  00112	85 c0		 test	 eax, eax
  00114	75 02		 jne	 SHORT $LN24@OnRefreshS

; 330  : 					continue;

  00116	eb cd		 jmp	 SHORT $LN17@OnRefreshS
$LN24@OnRefreshS:

; 331  : 
; 332  : 				pSubSlot->dwCenterSlotNumber = pSlot->dwSlotNumber;

  00118	8b 45 e0	 mov	 eax, DWORD PTR _pSubSlot$1[ebp]
  0011b	8b 4d f0	 mov	 ecx, DWORD PTR _pSlot$5[ebp]
  0011e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00121	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 333  : 				pSubSlot->dwItemIndex = pSlot->dwItemIndex;

  00124	8b 45 e0	 mov	 eax, DWORD PTR _pSubSlot$1[ebp]
  00127	8b 4d f0	 mov	 ecx, DWORD PTR _pSlot$5[ebp]
  0012a	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0012d	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 334  : 			}

  00130	eb b3		 jmp	 SHORT $LN17@OnRefreshS
$LN18@OnRefreshS:
  00132	eb 98		 jmp	 SHORT $LN14@OnRefreshS
$LN15@OnRefreshS:

; 335  : 		}

  00134	eb 07		 jmp	 SHORT $LN23@OnRefreshS
$LN22@OnRefreshS:

; 336  : 		else
; 337  : 		{
; 338  : 			pSlot->dwItemIndex = 0;

  00136	8b 45 f0	 mov	 eax, DWORD PTR _pSlot$5[ebp]
  00139	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
$LN23@OnRefreshS:

; 339  : 		}
; 340  : 	}

  0013d	e9 4a ff ff ff	 jmp	 $LN11@OnRefreshS
$LN12@OnRefreshS:
  00142	e9 26 ff ff ff	 jmp	 $LN8@OnRefreshS
$LN1@OnRefreshS:

; 341  : }

  00147	c9		 leave
  00148	c3		 ret	 0
?OnRefreshSlot@CGridSlotWindow@UI@@MAEXXZ ENDP		; UI::CGridSlotWindow::OnRefreshSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?OnIsType@CGridSlotWindow@UI@@MAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwType$ = 8						; size = 4
?OnIsType@CGridSlotWindow@UI@@MAEHK@Z PROC		; UI::CGridSlotWindow::OnIsType, COMDAT
; _this$ = ecx

; 387  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 388  : 	if (CGridSlotWindow::Type() == dwType)

  00007	e8 00 00 00 00	 call	 ?Type@CGridSlotWindow@UI@@SAKXZ ; UI::CGridSlotWindow::Type
  0000c	3b 45 08	 cmp	 eax, DWORD PTR _dwType$[ebp]
  0000f	75 05		 jne	 SHORT $LN2@OnIsType

; 389  : 		return TRUE;

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	eb 0b		 jmp	 SHORT $LN1@OnIsType
$LN2@OnIsType:

; 390  : 
; 391  : 	return CSlotWindow::OnIsType(dwType);

  00016	ff 75 08	 push	 DWORD PTR _dwType$[ebp]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?OnIsType@CSlotWindow@UI@@MAEHK@Z ; UI::CSlotWindow::OnIsType
$LN1@OnIsType:

; 392  : }

  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?OnIsType@CGridSlotWindow@UI@@MAEHK@Z ENDP		; UI::CGridSlotWindow::OnIsType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?CheckMoving@CGridSlotWindow@UI@@IAEHKKABV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
___param0$ = -28					; size = 4
_this$ = -24						; size = 4
tv162 = -20						; size = 4
tv182 = -16						; size = 4
_itor$5 = -12						; size = 4
_pSlot$6 = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
_dwSlotNumber$ = 8					; size = 4
_dwItemIndex$ = 12					; size = 4
_c_rSlotList$ = 16					; size = 4
?CheckMoving@CGridSlotWindow@UI@@IAEHKKABV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z PROC ; UI::CGridSlotWindow::CheckMoving, COMDAT
; _this$ = ecx

; 344  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 345  : 	if (m_dwSlotStyle != SLOT_STYLE_PICK_UP)

  00009	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 7c 01	 cmp	 DWORD PTR [eax+124], 1
  00010	74 08		 je	 SHORT $LN5@CheckMovin

; 346  : 		return TRUE;

  00012	33 c0		 xor	 eax, eax
  00014	40		 inc	 eax
  00015	e9 ba 00 00 00	 jmp	 $LN1@CheckMovin
$LN5@CheckMovin:

; 348  : 	for (std::list<TSlot*>::const_iterator itor = c_rSlotList.begin(); itor != c_rSlotList.end(); ++itor)

  0001a	8d 45 f4	 lea	 eax, DWORD PTR _itor$5[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 10	 mov	 ecx, DWORD PTR _c_rSlotList$[ebp]
  00021	e8 00 00 00 00	 call	 ?begin@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QBE?AV?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::begin
  00026	eb 08		 jmp	 SHORT $LN4@CheckMovin
$LN2@CheckMovin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  00028	8b 45 f4	 mov	 eax, DWORD PTR _itor$5[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 f4	 mov	 DWORD PTR _itor$5[ebp], eax
$LN4@CheckMovin:

; 1104 :         return const_iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00030	8b 45 10	 mov	 eax, DWORD PTR _c_rSlotList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1104 :         return const_iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00036	8b 45 10	 mov	 eax, DWORD PTR _c_rSlotList$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0003e	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00041	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1104 :         return const_iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00044	8d 45 e0	 lea	 eax, DWORD PTR $T4[ebp]
  00047	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0004a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _itor$5[ebp]
  00050	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00052	75 09		 jne	 SHORT $LN51@CheckMovin
  00054	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv182[ebp], 1
  0005b	eb 04		 jmp	 SHORT $LN52@CheckMovin
$LN51@CheckMovin:
  0005d	83 65 f0 00	 and	 DWORD PTR tv182[ebp], 0
$LN52@CheckMovin:
  00061	8a 45 f0	 mov	 al, BYTE PTR tv182[ebp]
  00064	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 203  :         return !(*this == _Right);

  00067	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN46@CheckMovin
  0006f	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv162[ebp], 1
  00076	eb 04		 jmp	 SHORT $LN47@CheckMovin
$LN46@CheckMovin:
  00078	83 65 ec 00	 and	 DWORD PTR tv162[ebp], 0
$LN47@CheckMovin:
  0007c	8a 45 ec	 mov	 al, BYTE PTR tv162[ebp]
  0007f	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 348  : 	for (std::list<TSlot*>::const_iterator itor = c_rSlotList.begin(); itor != c_rSlotList.end(); ++itor)

  00082	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00086	85 c0		 test	 eax, eax
  00088	74 47		 je	 SHORT $LN3@CheckMovin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0008a	8b 45 f4	 mov	 eax, DWORD PTR _itor$5[ebp]
  0008d	83 c0 08	 add	 eax, 8
  00090	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 350  : 		TSlot * pSlot = *itor;

  00093	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00096	8b 00		 mov	 eax, DWORD PTR [eax]
  00098	89 45 f8	 mov	 DWORD PTR _pSlot$6[ebp], eax

; 351  : 
; 352  : 		if (dwSlotNumber != pSlot->dwCenterSlotNumber) //    

  0009b	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$6[ebp]
  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _dwSlotNumber$[ebp]
  000a1	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  000a4	74 26		 je	 SHORT $LN6@CheckMovin

; 353  : 		{
; 354  : 			if (0 != pSlot->dwItemIndex || pSlot->dwCenterSlotNumber != pSlot->dwSlotNumber) //  

  000a6	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$6[ebp]
  000a9	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  000ad	75 0e		 jne	 SHORT $LN8@CheckMovin
  000af	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$6[ebp]
  000b2	8b 4d f8	 mov	 ecx, DWORD PTR _pSlot$6[ebp]
  000b5	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  000b8	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  000bb	74 0f		 je	 SHORT $LN6@CheckMovin
$LN8@CheckMovin:

; 355  : 			{
; 356  : 				if (dwItemIndex != pSlot->dwItemIndex) //    

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$6[ebp]
  000c0	8b 4d 0c	 mov	 ecx, DWORD PTR _dwItemIndex$[ebp]
  000c3	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  000c6	74 04		 je	 SHORT $LN6@CheckMovin

; 357  : 					return false;

  000c8	33 c0		 xor	 eax, eax
  000ca	eb 08		 jmp	 SHORT $LN1@CheckMovin
$LN6@CheckMovin:

; 358  : 			}
; 359  : 		}
; 360  : 	}

  000cc	e9 57 ff ff ff	 jmp	 $LN2@CheckMovin
$LN3@CheckMovin:

; 361  : 
; 362  : 	return true;

  000d1	33 c0		 xor	 eax, eax
  000d3	40		 inc	 eax
$LN1@CheckMovin:

; 363  : }

  000d4	c9		 leave
  000d5	c2 0c 00	 ret	 12			; 0000000cH
?CheckMoving@CGridSlotWindow@UI@@IAEHKKABV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z ENDP ; UI::CGridSlotWindow::CheckMoving
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?GetPickedGridSlotPosition@CGridSlotWindow@UI@@IAEHHHPAH0@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_y$1 = -12						; size = 4
_x$2 = -8						; size = 4
_pSlot$3 = -4						; size = 4
_ixLocal$ = 8						; size = 4
_iyLocal$ = 12						; size = 4
_pix$ = 16						; size = 4
_piy$ = 20						; size = 4
?GetPickedGridSlotPosition@CGridSlotWindow@UI@@IAEHHHPAH0@Z PROC ; UI::CGridSlotWindow::GetPickedGridSlotPosition, COMDAT
; _this$ = ecx

; 253  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 254  : 	for (DWORD x = 0; x < m_dwxCount; ++x)

  00009	83 65 f8 00	 and	 DWORD PTR _x$2[ebp], 0
  0000d	eb 07		 jmp	 SHORT $LN4@GetPickedG
$LN2@GetPickedG:
  0000f	8b 45 f8	 mov	 eax, DWORD PTR _x$2[ebp]
  00012	40		 inc	 eax
  00013	89 45 f8	 mov	 DWORD PTR _x$2[ebp], eax
$LN4@GetPickedG:
  00016	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _x$2[ebp]
  0001c	3b 88 bc 00 00
	00		 cmp	 ecx, DWORD PTR [eax+188]
  00022	0f 83 87 00 00
	00		 jae	 $LN3@GetPickedG

; 255  : 	for (DWORD y = 0; y < m_dwyCount; ++y)

  00028	83 65 f4 00	 and	 DWORD PTR _y$1[ebp], 0
  0002c	eb 07		 jmp	 SHORT $LN7@GetPickedG
$LN5@GetPickedG:
  0002e	8b 45 f4	 mov	 eax, DWORD PTR _y$1[ebp]
  00031	40		 inc	 eax
  00032	89 45 f4	 mov	 DWORD PTR _y$1[ebp], eax
$LN7@GetPickedG:
  00035	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d f4	 mov	 ecx, DWORD PTR _y$1[ebp]
  0003b	3b 88 c0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+192]
  00041	73 67		 jae	 SHORT $LN6@GetPickedG

; 256  : 	{
; 257  : 		TSlot * pSlot;
; 258  : 		if (!GetGridSlotPointer(x, y, &pSlot))

  00043	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$3[ebp]
  00046	50		 push	 eax
  00047	ff 75 f4	 push	 DWORD PTR _y$1[ebp]
  0004a	ff 75 f8	 push	 DWORD PTR _x$2[ebp]
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z ; UI::CGridSlotWindow::GetGridSlotPointer
  00055	85 c0		 test	 eax, eax
  00057	75 02		 jne	 SHORT $LN8@GetPickedG

; 259  : 			continue;

  00059	eb d3		 jmp	 SHORT $LN5@GetPickedG
$LN8@GetPickedG:

; 260  : 
; 261  : 		if (ixLocal >= pSlot->ixPosition)

  0005b	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$3[ebp]
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR _ixLocal$[ebp]
  00061	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  00064	7c 42		 jl	 SHORT $LN9@GetPickedG

; 262  : 		if (iyLocal >= pSlot->iyPosition)

  00066	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$3[ebp]
  00069	8b 4d 0c	 mov	 ecx, DWORD PTR _iyLocal$[ebp]
  0006c	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  0006f	7c 37		 jl	 SHORT $LN9@GetPickedG

; 263  : 		if (ixLocal <= pSlot->ixPosition + pSlot->ixCellSize)

  00071	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$3[ebp]
  00074	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$3[ebp]
  0007a	03 41 28	 add	 eax, DWORD PTR [ecx+40]
  0007d	39 45 08	 cmp	 DWORD PTR _ixLocal$[ebp], eax
  00080	7f 26		 jg	 SHORT $LN9@GetPickedG

; 264  : 		if (iyLocal <= pSlot->iyPosition + pSlot->iyCellSize)

  00082	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$3[ebp]
  00085	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$3[ebp]
  0008b	03 41 2c	 add	 eax, DWORD PTR [ecx+44]
  0008e	39 45 0c	 cmp	 DWORD PTR _iyLocal$[ebp], eax
  00091	7f 15		 jg	 SHORT $LN9@GetPickedG

; 265  : 		{
; 266  : 			*pix = x;

  00093	8b 45 10	 mov	 eax, DWORD PTR _pix$[ebp]
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _x$2[ebp]
  00099	89 08		 mov	 DWORD PTR [eax], ecx

; 267  : 			*piy = y;

  0009b	8b 45 14	 mov	 eax, DWORD PTR _piy$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR _y$1[ebp]
  000a1	89 08		 mov	 DWORD PTR [eax], ecx

; 268  : 			return TRUE;

  000a3	33 c0		 xor	 eax, eax
  000a5	40		 inc	 eax
  000a6	eb 09		 jmp	 SHORT $LN1@GetPickedG
$LN9@GetPickedG:

; 269  : 		}
; 270  : 	}

  000a8	eb 84		 jmp	 SHORT $LN5@GetPickedG
$LN6@GetPickedG:
  000aa	e9 60 ff ff ff	 jmp	 $LN2@GetPickedG
$LN3@GetPickedG:

; 271  : 
; 272  : 	return FALSE;

  000af	33 c0		 xor	 eax, eax
$LN1@GetPickedG:

; 273  : }

  000b1	c9		 leave
  000b2	c2 10 00	 ret	 16			; 00000010H
?GetPickedGridSlotPosition@CGridSlotWindow@UI@@IAEHHHPAH0@Z ENDP ; UI::CGridSlotWindow::GetPickedGridSlotPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z
_TEXT	SEGMENT
$T1 = -24						; size = 4
__My_data$2 = -20					; size = 4
$T3 = -16						; size = 4
_dwSlotIndex$ = -12					; size = 4
__My_data$4 = -8					; size = 4
_this$ = -4						; size = 4
_ix$ = 8						; size = 4
_iy$ = 12						; size = 4
_ppSlot$ = 16						; size = 4
?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z PROC ; UI::CGridSlotWindow::GetGridSlotPointer, COMDAT
; _this$ = ecx

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 243  : 	DWORD dwSlotIndex = ix + iy*m_dwxCount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _iy$[ebp]
  0000f	0f af 88 bc 00
	00 00		 imul	 ecx, DWORD PTR [eax+188]
  00016	03 4d 08	 add	 ecx, DWORD PTR _ix$[ebp]
  00019	89 4d f4	 mov	 DWORD PTR _dwSlotIndex$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  00024	89 45 f8	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00027	8b 45 f8	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  0002d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00030	2b 01		 sub	 eax, DWORD PTR [ecx]
  00032	c1 f8 02	 sar	 eax, 2
  00035	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 244  : 	if (dwSlotIndex >= m_SlotVector.size())

  00038	8b 45 f4	 mov	 eax, DWORD PTR _dwSlotIndex$[ebp]
  0003b	3b 45 f0	 cmp	 eax, DWORD PTR $T3[ebp]
  0003e	72 04		 jb	 SHORT $LN2@GetGridSlo

; 245  : 		return FALSE;

  00040	33 c0		 xor	 eax, eax
  00042	eb 26		 jmp	 SHORT $LN1@GetGridSlo
$LN2@GetGridSlo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  0004c	89 45 ec	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0004f	8b 45 ec	 mov	 eax, DWORD PTR __My_data$2[ebp]
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	8b 4d f4	 mov	 ecx, DWORD PTR _dwSlotIndex$[ebp]
  00057	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0005a	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 247  : 	*ppSlot = m_SlotVector[dwSlotIndex];

  0005d	8b 45 10	 mov	 eax, DWORD PTR _ppSlot$[ebp]
  00060	8b 4d e8	 mov	 ecx, DWORD PTR $T1[ebp]
  00063	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00065	89 08		 mov	 DWORD PTR [eax], ecx

; 248  : 
; 249  : 	return TRUE;

  00067	33 c0		 xor	 eax, eax
  00069	40		 inc	 eax
$LN1@GetGridSlo:

; 250  : }

  0006a	c9		 leave
  0006b	c2 0c 00	 ret	 12			; 0000000cH
?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z ENDP ; UI::CGridSlotWindow::GetGridSlotPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?GetPickedSlotList@CGridSlotWindow@UI@@IAEHHHPAV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z
_TEXT	SEGMENT
$T1 = -116						; size = 4
$T2 = -112						; size = 4
$T3 = -108						; size = 4
$T4 = -104						; size = 4
$T5 = -100						; size = 4
$T6 = -96						; size = 4
$T7 = -92						; size = 4
__Right$ = -88						; size = 4
$T8 = -84						; size = 4
$T9 = -80						; size = 4
$T10 = -76						; size = 4
$T11 = -72						; size = 4
___param0$ = -68					; size = 4
$T12 = -64						; size = 4
___param0$ = -60					; size = 4
$T13 = -56						; size = 4
___param0$ = -52					; size = 4
_pMainSlot$14 = -48					; size = 4
$T15 = -44						; size = 4
$T16 = -40						; size = 4
$T17 = -36						; size = 4
$T18 = -32						; size = 4
___param0$ = -28					; size = 4
___param0$ = -24					; size = 4
$T19 = -20						; size = 4
$T20 = -16						; size = 4
$T21 = -12						; size = 4
$T22 = -8						; size = 4
___param0$ = -4						; size = 4
$T23 = 0						; size = 4
_pSlot$24 = 4						; size = 4
$T25 = 8						; size = 4
$T26 = 12						; size = 4
tv527 = 16						; size = 4
tv501 = 20						; size = 4
tv362 = 24						; size = 4
tv376 = 28						; size = 4
__My_data$27 = 32					; size = 4
__My_data$28 = 36					; size = 4
_iyTemporary$29 = 40					; size = 4
_ixTemporary$30 = 44					; size = 4
_ix$ = 48						; size = 4
_pSlot$31 = 52						; size = 4
_ixHalfStep$32 = 56					; size = 4
_lx$ = 60						; size = 4
_ly$ = 64						; size = 4
_itor$33 = 68						; size = 4
_i$34 = 72						; size = 4
_j$35 = 76						; size = 4
_ixStart$36 = 80					; size = 4
_iy$ = 84						; size = 4
_ixEnd$37 = 88						; size = 4
$T38 = 92						; size = 1
$T39 = 93						; size = 1
$T40 = 94						; size = 1
$T41 = 95						; size = 1
_iyStart$42 = 96					; size = 4
_iyEnd$43 = 100						; size = 4
_this$ = 104						; size = 4
_iWidth$ = 116						; size = 4
_iHeight$ = 120						; size = 4
_pSlotPointerList$ = 124				; size = 4
?GetPickedSlotList@CGridSlotWindow@UI@@IAEHHHPAV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z PROC ; UI::CGridSlotWindow::GetPickedSlotList, COMDAT
; _this$ = ecx

; 138  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 94	 lea	 ebp, DWORD PTR [esp-108]
  00005	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  0000b	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 139  : 	long lx, ly;
; 140  : 	GetMouseLocalPosition(lx, ly);

  0000e	8d 45 40	 lea	 eax, DWORD PTR _ly$[ebp]
  00011	50		 push	 eax
  00012	8d 45 3c	 lea	 eax, DWORD PTR _lx$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetMouseLocalPosition@CWindow@UI@@QAEXAAJ0@Z ; UI::CWindow::GetMouseLocalPosition

; 141  : 
; 142  : 	if (lx < 0)

  0001e	83 7d 3c 00	 cmp	 DWORD PTR _lx$[ebp], 0
  00022	7d 07		 jge	 SHORT $LN11@GetPickedS

; 143  : 		return FALSE;

  00024	33 c0		 xor	 eax, eax
  00026	e9 a2 03 00 00	 jmp	 $LN1@GetPickedS
$LN11@GetPickedS:

; 144  : 	if (ly < 0)

  0002b	83 7d 40 00	 cmp	 DWORD PTR _ly$[ebp], 0
  0002f	7d 07		 jge	 SHORT $LN12@GetPickedS

; 145  : 		return FALSE;

  00031	33 c0		 xor	 eax, eax
  00033	e9 95 03 00 00	 jmp	 $LN1@GetPickedS
$LN12@GetPickedS:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h

; 59   : 			long			GetWidth()		{ return m_lWidth; }

  00038	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0003e	89 45 0c	 mov	 DWORD PTR $T26[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 146  : 	if (lx >= GetWidth())

  00041	8b 45 3c	 mov	 eax, DWORD PTR _lx$[ebp]
  00044	3b 45 0c	 cmp	 eax, DWORD PTR $T26[ebp]
  00047	7c 07		 jl	 SHORT $LN13@GetPickedS

; 147  : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 7d 03 00 00	 jmp	 $LN1@GetPickedS
$LN13@GetPickedS:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h

; 60   : 			long			GetHeight()		{ return m_lHeight; }

  00050	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00056	89 45 08	 mov	 DWORD PTR $T25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 148  : 	if (ly >= GetHeight())

  00059	8b 45 40	 mov	 eax, DWORD PTR _ly$[ebp]
  0005c	3b 45 08	 cmp	 eax, DWORD PTR $T25[ebp]
  0005f	7c 07		 jl	 SHORT $LN14@GetPickedS

; 149  : 		return FALSE;

  00061	33 c0		 xor	 eax, eax
  00063	e9 65 03 00 00	 jmp	 $LN1@GetPickedS
$LN14@GetPickedS:

; 150  : 
; 151  : 	pSlotPointerList->clear();

  00068	8b 4d 7c	 mov	 ecx, DWORD PTR _pSlotPointerList$[ebp]
  0006b	e8 00 00 00 00	 call	 ?clear@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear

; 152  : 
; 153  : 	int ix, iy;
; 154  : 	if (GetPickedGridSlotPosition(lx, ly, &ix, &iy))

  00070	8d 45 54	 lea	 eax, DWORD PTR _iy$[ebp]
  00073	50		 push	 eax
  00074	8d 45 30	 lea	 eax, DWORD PTR _ix$[ebp]
  00077	50		 push	 eax
  00078	ff 75 40	 push	 DWORD PTR _ly$[ebp]
  0007b	ff 75 3c	 push	 DWORD PTR _lx$[ebp]
  0007e	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	e8 00 00 00 00	 call	 ?GetPickedGridSlotPosition@CGridSlotWindow@UI@@IAEHHHPAH0@Z ; UI::CGridSlotWindow::GetPickedGridSlotPosition
  00086	85 c0		 test	 eax, eax
  00088	0f 84 3d 03 00
	00		 je	 $LN15@GetPickedS

; 155  : 	{
; 156  : 		int ixHalfStep = (iWidth / 2);

  0008e	8b 45 74	 mov	 eax, DWORD PTR _iWidth$[ebp]
  00091	99		 cdq
  00092	2b c2		 sub	 eax, edx
  00094	d1 f8		 sar	 eax, 1
  00096	89 45 38	 mov	 DWORD PTR _ixHalfStep$32[ebp], eax

; 157  : 		//int iyHalfStep = (iHeight / 2);
; 158  : 
; 159  : 		int ixStart = int(ix) - int(ixHalfStep - (ixHalfStep % 2));

  00099	8b 45 38	 mov	 eax, DWORD PTR _ixHalfStep$32[ebp]
  0009c	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  000a1	79 05		 jns	 SHORT $LN264@GetPickedS
  000a3	48		 dec	 eax
  000a4	83 c8 fe	 or	 eax, -2			; fffffffeH
  000a7	40		 inc	 eax
$LN264@GetPickedS:
  000a8	8b 4d 38	 mov	 ecx, DWORD PTR _ixHalfStep$32[ebp]
  000ab	2b c8		 sub	 ecx, eax
  000ad	8b 45 30	 mov	 eax, DWORD PTR _ix$[ebp]
  000b0	2b c1		 sub	 eax, ecx
  000b2	89 45 50	 mov	 DWORD PTR _ixStart$36[ebp], eax

; 160  : 		int ixEnd = int(ix) + int(ixHalfStep);

  000b5	8b 45 30	 mov	 eax, DWORD PTR _ix$[ebp]
  000b8	03 45 38	 add	 eax, DWORD PTR _ixHalfStep$32[ebp]
  000bb	89 45 58	 mov	 DWORD PTR _ixEnd$37[ebp], eax

; 161  : 
; 162  : 		// FIXME :      - [levites]
; 163  : 		int iyStart = 0, iyEnd = 0;

  000be	83 65 60 00	 and	 DWORD PTR _iyStart$42[ebp], 0
  000c2	83 65 64 00	 and	 DWORD PTR _iyEnd$43[ebp], 0

; 164  : 
; 165  : 		if (1 == iHeight)

  000c6	83 7d 78 01	 cmp	 DWORD PTR _iHeight$[ebp], 1
  000ca	75 0e		 jne	 SHORT $LN16@GetPickedS

; 166  : 		{
; 167  : 			iyStart = iy;

  000cc	8b 45 54	 mov	 eax, DWORD PTR _iy$[ebp]
  000cf	89 45 60	 mov	 DWORD PTR _iyStart$42[ebp], eax

; 168  : 			iyEnd = iy;

  000d2	8b 45 54	 mov	 eax, DWORD PTR _iy$[ebp]
  000d5	89 45 64	 mov	 DWORD PTR _iyEnd$43[ebp], eax

; 169  : 		}

  000d8	eb 29		 jmp	 SHORT $LN17@GetPickedS
$LN16@GetPickedS:

; 170  : 		else if (2 == iHeight)

  000da	83 7d 78 02	 cmp	 DWORD PTR _iHeight$[ebp], 2
  000de	75 0f		 jne	 SHORT $LN18@GetPickedS

; 171  : 		{
; 172  : 			iyStart = iy;

  000e0	8b 45 54	 mov	 eax, DWORD PTR _iy$[ebp]
  000e3	89 45 60	 mov	 DWORD PTR _iyStart$42[ebp], eax

; 173  : 			iyEnd = iy + 1;

  000e6	8b 45 54	 mov	 eax, DWORD PTR _iy$[ebp]
  000e9	40		 inc	 eax
  000ea	89 45 64	 mov	 DWORD PTR _iyEnd$43[ebp], eax

; 174  : 		}

  000ed	eb 14		 jmp	 SHORT $LN17@GetPickedS
$LN18@GetPickedS:

; 175  : 		else if (3 == iHeight)

  000ef	83 7d 78 03	 cmp	 DWORD PTR _iHeight$[ebp], 3
  000f3	75 0e		 jne	 SHORT $LN17@GetPickedS

; 176  : 		{
; 177  : 			iyStart = iy - 1;

  000f5	8b 45 54	 mov	 eax, DWORD PTR _iy$[ebp]
  000f8	48		 dec	 eax
  000f9	89 45 60	 mov	 DWORD PTR _iyStart$42[ebp], eax

; 178  : 			iyEnd = iy + 1;

  000fc	8b 45 54	 mov	 eax, DWORD PTR _iy$[ebp]
  000ff	40		 inc	 eax
  00100	89 45 64	 mov	 DWORD PTR _iyEnd$43[ebp], eax
$LN17@GetPickedS:

; 179  : 		}
; 180  : 
; 181  : 		if (ixStart < 0)

  00103	83 7d 50 00	 cmp	 DWORD PTR _ixStart$36[ebp], 0
  00107	7d 0f		 jge	 SHORT $LN21@GetPickedS

; 182  : 		{
; 183  : 			ixEnd += -ixStart;

  00109	8b 45 50	 mov	 eax, DWORD PTR _ixStart$36[ebp]
  0010c	f7 d8		 neg	 eax
  0010e	03 45 58	 add	 eax, DWORD PTR _ixEnd$37[ebp]
  00111	89 45 58	 mov	 DWORD PTR _ixEnd$37[ebp], eax

; 184  : 			ixStart = 0;

  00114	83 65 50 00	 and	 DWORD PTR _ixStart$36[ebp], 0
$LN21@GetPickedS:

; 185  : 		}
; 186  : 
; 187  : 		if (iyStart < 0)

  00118	83 7d 60 00	 cmp	 DWORD PTR _iyStart$42[ebp], 0
  0011c	7d 0f		 jge	 SHORT $LN22@GetPickedS

; 188  : 		{
; 189  : 			iyEnd += -iyStart;

  0011e	8b 45 60	 mov	 eax, DWORD PTR _iyStart$42[ebp]
  00121	f7 d8		 neg	 eax
  00123	03 45 64	 add	 eax, DWORD PTR _iyEnd$43[ebp]
  00126	89 45 64	 mov	 DWORD PTR _iyEnd$43[ebp], eax

; 190  : 			iyStart = 0;

  00129	83 65 60 00	 and	 DWORD PTR _iyStart$42[ebp], 0
$LN22@GetPickedS:

; 191  : 		}
; 192  : 
; 193  : 		if (DWORD(ixEnd) >= m_dwxCount)

  0012d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 4d 58	 mov	 ecx, DWORD PTR _ixEnd$37[ebp]
  00133	3b 88 bc 00 00
	00		 cmp	 ecx, DWORD PTR [eax+188]
  00139	72 22		 jb	 SHORT $LN23@GetPickedS

; 194  : 		{
; 195  : 			int ixTemporary = DWORD(ixEnd) - m_dwxCount + 1;

  0013b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0013e	8b 4d 58	 mov	 ecx, DWORD PTR _ixEnd$37[ebp]
  00141	2b 88 bc 00 00
	00		 sub	 ecx, DWORD PTR [eax+188]
  00147	41		 inc	 ecx
  00148	89 4d 2c	 mov	 DWORD PTR _ixTemporary$30[ebp], ecx

; 196  : 			ixStart -= ixTemporary;

  0014b	8b 45 50	 mov	 eax, DWORD PTR _ixStart$36[ebp]
  0014e	2b 45 2c	 sub	 eax, DWORD PTR _ixTemporary$30[ebp]
  00151	89 45 50	 mov	 DWORD PTR _ixStart$36[ebp], eax

; 197  : 			ixEnd -= ixTemporary;

  00154	8b 45 58	 mov	 eax, DWORD PTR _ixEnd$37[ebp]
  00157	2b 45 2c	 sub	 eax, DWORD PTR _ixTemporary$30[ebp]
  0015a	89 45 58	 mov	 DWORD PTR _ixEnd$37[ebp], eax
$LN23@GetPickedS:

; 198  : 		}
; 199  : 
; 200  : 		if (DWORD(iyEnd) >= m_dwyCount)

  0015d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00160	8b 4d 64	 mov	 ecx, DWORD PTR _iyEnd$43[ebp]
  00163	3b 88 c0 00 00
	00		 cmp	 ecx, DWORD PTR [eax+192]
  00169	72 22		 jb	 SHORT $LN24@GetPickedS

; 201  : 		{
; 202  : 			int iyTemporary = DWORD(iyEnd) - m_dwyCount + 1;

  0016b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0016e	8b 4d 64	 mov	 ecx, DWORD PTR _iyEnd$43[ebp]
  00171	2b 88 c0 00 00
	00		 sub	 ecx, DWORD PTR [eax+192]
  00177	41		 inc	 ecx
  00178	89 4d 28	 mov	 DWORD PTR _iyTemporary$29[ebp], ecx

; 203  : 			iyStart -= iyTemporary;

  0017b	8b 45 60	 mov	 eax, DWORD PTR _iyStart$42[ebp]
  0017e	2b 45 28	 sub	 eax, DWORD PTR _iyTemporary$29[ebp]
  00181	89 45 60	 mov	 DWORD PTR _iyStart$42[ebp], eax

; 204  : 			iyEnd -= iyTemporary;

  00184	8b 45 64	 mov	 eax, DWORD PTR _iyEnd$43[ebp]
  00187	2b 45 28	 sub	 eax, DWORD PTR _iyTemporary$29[ebp]
  0018a	89 45 64	 mov	 DWORD PTR _iyEnd$43[ebp], eax
$LN24@GetPickedS:

; 205  : 		}
; 206  : 
; 207  : 		for (int i = ixStart; i <= ixEnd; ++i)

  0018d	8b 45 50	 mov	 eax, DWORD PTR _ixStart$36[ebp]
  00190	89 45 48	 mov	 DWORD PTR _i$34[ebp], eax
  00193	eb 07		 jmp	 SHORT $LN4@GetPickedS
$LN2@GetPickedS:
  00195	8b 45 48	 mov	 eax, DWORD PTR _i$34[ebp]
  00198	40		 inc	 eax
  00199	89 45 48	 mov	 DWORD PTR _i$34[ebp], eax
$LN4@GetPickedS:
  0019c	8b 45 48	 mov	 eax, DWORD PTR _i$34[ebp]
  0019f	3b 45 58	 cmp	 eax, DWORD PTR _ixEnd$37[ebp]
  001a2	7f 42		 jg	 SHORT $LN3@GetPickedS

; 208  : 		for (int j = iyStart; j <= iyEnd; ++j)

  001a4	8b 45 60	 mov	 eax, DWORD PTR _iyStart$42[ebp]
  001a7	89 45 4c	 mov	 DWORD PTR _j$35[ebp], eax
  001aa	eb 07		 jmp	 SHORT $LN7@GetPickedS
$LN5@GetPickedS:
  001ac	8b 45 4c	 mov	 eax, DWORD PTR _j$35[ebp]
  001af	40		 inc	 eax
  001b0	89 45 4c	 mov	 DWORD PTR _j$35[ebp], eax
$LN7@GetPickedS:
  001b3	8b 45 4c	 mov	 eax, DWORD PTR _j$35[ebp]
  001b6	3b 45 64	 cmp	 eax, DWORD PTR _iyEnd$43[ebp]
  001b9	7f 29		 jg	 SHORT $LN6@GetPickedS

; 209  : 		{
; 210  : 			TSlot * pSlot;
; 211  : 			if (GetGridSlotPointer(DWORD(i), DWORD(j), &pSlot))

  001bb	8d 45 04	 lea	 eax, DWORD PTR _pSlot$24[ebp]
  001be	50		 push	 eax
  001bf	ff 75 4c	 push	 DWORD PTR _j$35[ebp]
  001c2	ff 75 48	 push	 DWORD PTR _i$34[ebp]
  001c5	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	e8 00 00 00 00	 call	 ?GetGridSlotPointer@CGridSlotWindow@UI@@IAEHHHPAPAUSSlot@CSlotWindow@2@@Z ; UI::CGridSlotWindow::GetGridSlotPointer
  001cd	85 c0		 test	 eax, eax
  001cf	74 11		 je	 SHORT $LN25@GetPickedS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  001d1	8d 45 04	 lea	 eax, DWORD PTR _pSlot$24[ebp]
  001d4	50		 push	 eax
  001d5	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
  001d8	ff 30		 push	 DWORD PTR [eax]
  001da	8b 4d 7c	 mov	 ecx, DWORD PTR _pSlotPointerList$[ebp]
  001dd	e8 00 00 00 00	 call	 ??$_Emplace@ABQAUSSlot@CSlotWindow@UI@@@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@1@QAU21@ABQAUSSlot@CSlotWindow@UI@@@Z ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Emplace<UI::CSlotWindow::SSlot * const &>
$LN25@GetPickedS:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 215  : 		}

  001e2	eb c8		 jmp	 SHORT $LN5@GetPickedS
$LN6@GetPickedS:
  001e4	eb af		 jmp	 SHORT $LN2@GetPickedS
$LN3@GetPickedS:

; 218  : 		if (m_isUseMode && 1 == pSlotPointerList->size())

  001e6	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  001e9	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [eax+148], 0
  001f0	0f 84 ac 01 00
	00		 je	 $LN26@GetPickedS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1191 :         return _Mypair._Myval2._Mysize;

  001f6	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
  001f9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  001fc	89 45 00	 mov	 DWORD PTR $T23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 218  : 		if (m_isUseMode && 1 == pSlotPointerList->size())

  001ff	83 7d 00 01	 cmp	 DWORD PTR $T23[ebp], 1
  00203	0f 85 99 01 00
	00		 jne	 $LN26@GetPickedS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00209	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0020c	89 45 a4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0020f	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
  00212	8b 00		 mov	 eax, DWORD PTR [eax]
  00214	8b 00		 mov	 eax, DWORD PTR [eax]
  00216	89 45 fc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00219	8b 45 fc	 mov	 eax, DWORD PTR ___param0$[ebp]
  0021c	89 45 f8	 mov	 DWORD PTR $T22[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0021f	8d 45 f8	 lea	 eax, DWORD PTR $T22[ebp]
  00222	89 45 f4	 mov	 DWORD PTR $T21[ebp], eax

; 152  :         return this->_Ptr->_Myval;

  00225	8b 45 f4	 mov	 eax, DWORD PTR $T21[ebp]
  00228	8b 00		 mov	 eax, DWORD PTR [eax]
  0022a	83 c0 08	 add	 eax, 8
  0022d	89 45 f0	 mov	 DWORD PTR $T20[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00230	8b 45 f0	 mov	 eax, DWORD PTR $T20[ebp]
  00233	89 45 ec	 mov	 DWORD PTR $T19[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 220  : 			TSlot * pMainSlot = *pSlotPointerList->begin();

  00236	8b 45 ec	 mov	 eax, DWORD PTR $T19[ebp]
  00239	8b 00		 mov	 eax, DWORD PTR [eax]
  0023b	89 45 d0	 mov	 DWORD PTR _pMainSlot$14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0023e	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00241	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  00246	89 45 24	 mov	 DWORD PTR __My_data$28[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00249	8b 45 24	 mov	 eax, DWORD PTR __My_data$28[ebp]
  0024c	89 45 a0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0024f	8b 45 24	 mov	 eax, DWORD PTR __My_data$28[ebp]
  00252	8b 00		 mov	 eax, DWORD PTR [eax]
  00254	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00257	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  0025a	89 45 44	 mov	 DWORD PTR _itor$33[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 223  : 			for (; itor != m_SlotVector.end(); ++itor)

  0025d	eb 09		 jmp	 SHORT $LN10@GetPickedS
$LN8@GetPickedS:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 75   :         ++_Ptr;

  0025f	8b 45 44	 mov	 eax, DWORD PTR _itor$33[ebp]
  00262	83 c0 04	 add	 eax, 4
  00265	89 45 44	 mov	 DWORD PTR _itor$33[ebp], eax
$LN10@GetPickedS:

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00268	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  0026b	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  00270	89 45 20	 mov	 DWORD PTR __My_data$27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00273	8b 45 20	 mov	 eax, DWORD PTR __My_data$27[ebp]
  00276	89 45 9c	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00279	8b 45 20	 mov	 eax, DWORD PTR __My_data$27[ebp]
  0027c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0027f	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00282	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00285	89 45 e0	 mov	 DWORD PTR $T18[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00288	8d 45 e0	 lea	 eax, DWORD PTR $T18[ebp]
  0028b	89 45 dc	 mov	 DWORD PTR $T17[ebp], eax

; 149  :         return _Ptr == _Right._Ptr;

  0028e	8b 45 dc	 mov	 eax, DWORD PTR $T17[ebp]
  00291	8b 4d 44	 mov	 ecx, DWORD PTR _itor$33[ebp]
  00294	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00296	75 09		 jne	 SHORT $LN138@GetPickedS
  00298	c7 45 1c 01 00
	00 00		 mov	 DWORD PTR tv376[ebp], 1
  0029f	eb 04		 jmp	 SHORT $LN139@GetPickedS
$LN138@GetPickedS:
  002a1	83 65 1c 00	 and	 DWORD PTR tv376[ebp], 0
$LN139@GetPickedS:
  002a5	8a 45 1c	 mov	 al, BYTE PTR tv376[ebp]
  002a8	88 45 5f	 mov	 BYTE PTR $T41[ebp], al

; 153  :         return !(*this == _Right);

  002ab	0f b6 45 5f	 movzx	 eax, BYTE PTR $T41[ebp]
  002af	85 c0		 test	 eax, eax
  002b1	75 09		 jne	 SHORT $LN133@GetPickedS
  002b3	c7 45 18 01 00
	00 00		 mov	 DWORD PTR tv362[ebp], 1
  002ba	eb 04		 jmp	 SHORT $LN134@GetPickedS
$LN133@GetPickedS:
  002bc	83 65 18 00	 and	 DWORD PTR tv362[ebp], 0
$LN134@GetPickedS:
  002c0	8a 45 18	 mov	 al, BYTE PTR tv362[ebp]
  002c3	88 45 5e	 mov	 BYTE PTR $T40[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 223  : 			for (; itor != m_SlotVector.end(); ++itor)

  002c6	0f b6 45 5e	 movzx	 eax, BYTE PTR $T40[ebp]
  002ca	85 c0		 test	 eax, eax
  002cc	0f 84 d0 00 00
	00		 je	 $LN26@GetPickedS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 54   :         return *_Ptr;

  002d2	8b 45 44	 mov	 eax, DWORD PTR _itor$33[ebp]
  002d5	89 45 d8	 mov	 DWORD PTR $T16[ebp], eax

; 252  :         return const_cast<reference>(_Mybase::operator*());

  002d8	8b 45 d8	 mov	 eax, DWORD PTR $T16[ebp]
  002db	89 45 d4	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 225  : 				TSlot * pSlot = *itor;

  002de	8b 45 d4	 mov	 eax, DWORD PTR $T15[ebp]
  002e1	8b 00		 mov	 eax, DWORD PTR [eax]
  002e3	89 45 34	 mov	 DWORD PTR _pSlot$31[ebp], eax

; 226  : 				if (pSlot->dwCenterSlotNumber == pMainSlot->dwCenterSlotNumber)

  002e6	8b 45 34	 mov	 eax, DWORD PTR _pSlot$31[ebp]
  002e9	8b 4d d0	 mov	 ecx, DWORD PTR _pMainSlot$14[ebp]
  002ec	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002ef	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  002f2	0f 85 a5 00 00
	00		 jne	 $LN27@GetPickedS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  002f8	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  002fb	89 45 98	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  002fe	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
  00301	8b 00		 mov	 eax, DWORD PTR [eax]
  00303	89 45 cc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00306	8b 45 cc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00309	89 45 c8	 mov	 DWORD PTR $T13[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0030c	8d 45 c8	 lea	 eax, DWORD PTR $T13[ebp]
  0030f	89 45 b4	 mov	 DWORD PTR $T10[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00312	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00315	89 45 94	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00318	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
  0031b	8b 00		 mov	 eax, DWORD PTR [eax]
  0031d	8b 00		 mov	 eax, DWORD PTR [eax]
  0031f	89 45 c4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00322	8b 45 c4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00325	89 45 c0	 mov	 DWORD PTR $T12[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00328	8d 45 c0	 lea	 eax, DWORD PTR $T12[ebp]
  0032b	89 45 b0	 mov	 DWORD PTR $T9[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0032e	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00331	89 45 90	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00334	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
  00337	8b 00		 mov	 eax, DWORD PTR [eax]
  00339	89 45 bc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0033c	8b 45 bc	 mov	 eax, DWORD PTR ___param0$[ebp]
  0033f	89 45 b8	 mov	 DWORD PTR $T11[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00342	8d 45 b8	 lea	 eax, DWORD PTR $T11[ebp]
  00345	89 45 ac	 mov	 DWORD PTR $T8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 227  : 				if (pSlotPointerList->end() == std::find(pSlotPointerList->begin(), pSlotPointerList->end(), pSlot))

  00348	8d 45 34	 lea	 eax, DWORD PTR _pSlot$31[ebp]
  0034b	50		 push	 eax
  0034c	8b 45 b4	 mov	 eax, DWORD PTR $T10[ebp]
  0034f	ff 30		 push	 DWORD PTR [eax]
  00351	8b 45 b0	 mov	 eax, DWORD PTR $T9[ebp]
  00354	ff 30		 push	 DWORD PTR [eax]
  00356	8d 45 8c	 lea	 eax, DWORD PTR $T1[ebp]
  00359	50		 push	 eax
  0035a	e8 00 00 00 00	 call	 ??$find@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@std@@PAUSSlot@CSlotWindow@UI@@@std@@YA?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@0@V10@V10@ABQAUSSlot@CSlotWindow@UI@@@Z ; std::find<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot *> > >,UI::CSlotWindow::SSlot *>
  0035f	83 c4 10	 add	 esp, 16			; 00000010H
  00362	89 45 a8	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 199  :         return this->_Ptr == _Right._Ptr;

  00365	8b 45 ac	 mov	 eax, DWORD PTR $T8[ebp]
  00368	8b 4d a8	 mov	 ecx, DWORD PTR __Right$[ebp]
  0036b	8b 00		 mov	 eax, DWORD PTR [eax]
  0036d	3b 01		 cmp	 eax, DWORD PTR [ecx]
  0036f	75 09		 jne	 SHORT $LN221@GetPickedS
  00371	c7 45 14 01 00
	00 00		 mov	 DWORD PTR tv501[ebp], 1
  00378	eb 04		 jmp	 SHORT $LN222@GetPickedS
$LN221@GetPickedS:
  0037a	83 65 14 00	 and	 DWORD PTR tv501[ebp], 0
$LN222@GetPickedS:
  0037e	8a 45 14	 mov	 al, BYTE PTR tv501[ebp]
  00381	88 45 5d	 mov	 BYTE PTR $T39[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 227  : 				if (pSlotPointerList->end() == std::find(pSlotPointerList->begin(), pSlotPointerList->end(), pSlot))

  00384	0f b6 45 5d	 movzx	 eax, BYTE PTR $T39[ebp]
  00388	85 c0		 test	 eax, eax
  0038a	74 11		 je	 SHORT $LN27@GetPickedS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  0038c	8d 45 34	 lea	 eax, DWORD PTR _pSlot$31[ebp]
  0038f	50		 push	 eax
  00390	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
  00393	ff 30		 push	 DWORD PTR [eax]
  00395	8b 4d 7c	 mov	 ecx, DWORD PTR _pSlotPointerList$[ebp]
  00398	e8 00 00 00 00	 call	 ??$_Emplace@ABQAUSSlot@CSlotWindow@UI@@@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@PAUSSlot@CSlotWindow@UI@@PAX@1@QAU21@ABQAUSSlot@CSlotWindow@UI@@@Z ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Emplace<UI::CSlotWindow::SSlot * const &>
$LN27@GetPickedS:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 231  : 			}

  0039d	e9 bd fe ff ff	 jmp	 $LN8@GetPickedS
$LN26@GetPickedS:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1200 :         return _Mypair._Myval2._Mysize == 0;

  003a2	8b 45 7c	 mov	 eax, DWORD PTR _pSlotPointerList$[ebp]
  003a5	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  003a9	75 09		 jne	 SHORT $LN261@GetPickedS
  003ab	c7 45 10 01 00
	00 00		 mov	 DWORD PTR tv527[ebp], 1
  003b2	eb 04		 jmp	 SHORT $LN262@GetPickedS
$LN261@GetPickedS:
  003b4	83 65 10 00	 and	 DWORD PTR tv527[ebp], 0
$LN262@GetPickedS:
  003b8	8a 45 10	 mov	 al, BYTE PTR tv527[ebp]
  003bb	88 45 5c	 mov	 BYTE PTR $T38[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 234  : 		if (!pSlotPointerList->empty())

  003be	0f b6 45 5c	 movzx	 eax, BYTE PTR $T38[ebp]
  003c2	85 c0		 test	 eax, eax
  003c4	75 05		 jne	 SHORT $LN15@GetPickedS

; 235  : 			return TRUE;

  003c6	33 c0		 xor	 eax, eax
  003c8	40		 inc	 eax
  003c9	eb 02		 jmp	 SHORT $LN1@GetPickedS
$LN15@GetPickedS:

; 236  : 	}
; 237  : 
; 238  : 	return FALSE;

  003cb	33 c0		 xor	 eax, eax
$LN1@GetPickedS:

; 239  : }

  003cd	83 c5 6c	 add	 ebp, 108		; 0000006cH
  003d0	c9		 leave
  003d1	c2 0c 00	 ret	 12			; 0000000cH
?GetPickedSlotList@CGridSlotWindow@UI@@IAEHHHPAV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z ENDP ; UI::CGridSlotWindow::GetPickedSlotList
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z
_TEXT	SEGMENT
_SlotList$ = -116					; size = 8
$T2 = -108						; size = 4
$T3 = -104						; size = 4
$T4 = -100						; size = 4
_dwSlotNumber$5 = -96					; size = 4
$T6 = -92						; size = 4
$T7 = -88						; size = 4
$T8 = -84						; size = 4
$T9 = -80						; size = 4
$T10 = -76						; size = 4
$T11 = -72						; size = 4
$T12 = -68						; size = 4
$T13 = -64						; size = 4
___param0$ = -60					; size = 4
___param0$ = -56					; size = 4
$T14 = -52						; size = 4
$T15 = -48						; size = 4
_pCenterSlot$16 = -44					; size = 4
tv276 = -40						; size = 4
tv300 = -36						; size = 4
_this$ = -32						; size = 4
_itor$17 = -28						; size = 4
_pSlot$18 = -24						; size = 4
_pMinSlot$ = -20					; size = 4
$T19 = -16						; size = 1
$T20 = -15						; size = 1
_byWidth$ = -14						; size = 1
_byHeight$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_ppSlot$ = 8						; size = 4
?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z PROC ; UI::CGridSlotWindow::GetPickedSlotPointer, COMDAT
; _this$ = ecx

; 69   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 68	 sub	 esp, 104		; 00000068H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0002d	89 45 d0	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 70   : 	if (!UI::CWindowManager::Instance().IsAttaching())

  00030	8b 4d d0	 mov	 ecx, DWORD PTR $T15[ebp]
  00033	e8 00 00 00 00	 call	 ?IsAttaching@CWindowManager@UI@@QAEHXZ ; UI::CWindowManager::IsAttaching
  00038	85 c0		 test	 eax, eax
  0003a	75 10		 jne	 SHORT $LN21@GetPickedS

; 71   : 		return CSlotWindow::GetPickedSlotPointer(ppSlot);

  0003c	ff 75 08	 push	 DWORD PTR _ppSlot$[ebp]
  0003f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?GetPickedSlotPointer@CSlotWindow@UI@@MAEHPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetPickedSlotPointer
  00047	e9 c6 01 00 00	 jmp	 $LN1@GetPickedS
$LN21@GetPickedS:

; 72   : 
; 73   : 	BYTE byWidth, byHeight;
; 74   : 	UI::CWindowManager::Instance().GetAttachingIconSize(&byWidth, &byHeight);

  0004c	8d 45 f3	 lea	 eax, DWORD PTR _byHeight$[ebp]
  0004f	50		 push	 eax
  00050	8d 45 f2	 lea	 eax, DWORD PTR _byWidth$[ebp]
  00053	50		 push	 eax
  00054	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0005a	e8 00 00 00 00	 call	 ?GetAttachingIconSize@CWindowManager@UI@@QAEXPAE0@Z ; UI::CWindowManager::GetAttachingIconSize

; 75   : 
; 76   : 	std::list<TSlot*> SlotList;

  0005f	8d 4d 8c	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >
  00067	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 77   : 	if (!GetPickedSlotList(byWidth, byHeight, &SlotList))

  0006b	8d 45 8c	 lea	 eax, DWORD PTR _SlotList$[ebp]
  0006e	50		 push	 eax
  0006f	0f b6 45 f3	 movzx	 eax, BYTE PTR _byHeight$[ebp]
  00073	50		 push	 eax
  00074	0f b6 45 f2	 movzx	 eax, BYTE PTR _byWidth$[ebp]
  00078	50		 push	 eax
  00079	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	e8 00 00 00 00	 call	 ?GetPickedSlotList@CGridSlotWindow@UI@@IAEHHHPAV?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@@Z ; UI::CGridSlotWindow::GetPickedSlotList
  00081	85 c0		 test	 eax, eax
  00083	75 18		 jne	 SHORT $LN6@GetPickedS

; 78   : 		return FALSE;

  00085	83 65 cc 00	 and	 DWORD PTR $T14[ebp], 0
  00089	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0008d	8d 4d 8c	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 78   : 		return FALSE;

  00095	8b 45 cc	 mov	 eax, DWORD PTR $T14[ebp]
  00098	e9 75 01 00 00	 jmp	 $LN1@GetPickedS
$LN6@GetPickedS:

; 79   : 
; 80   : 	TSlot * pMinSlot = NULL;

  0009d	83 65 ec 00	 and	 DWORD PTR _pMinSlot$[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000a1	8d 45 8c	 lea	 eax, DWORD PTR _SlotList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000a4	89 45 98	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000a7	8b 45 8c	 mov	 eax, DWORD PTR _SlotList$[ebp]
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	89 45 c8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000af	8b 45 c8	 mov	 eax, DWORD PTR ___param0$[ebp]
  000b2	89 45 e4	 mov	 DWORD PTR _itor$17[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 84   : 	for (std::list<TSlot*>::iterator itor = SlotList.begin(); itor != SlotList.end(); ++itor)

  000b5	eb 08		 jmp	 SHORT $LN4@GetPickedS
$LN2@GetPickedS:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  000b7	8b 45 e4	 mov	 eax, DWORD PTR _itor$17[ebp]
  000ba	8b 00		 mov	 eax, DWORD PTR [eax]
  000bc	89 45 e4	 mov	 DWORD PTR _itor$17[ebp], eax
$LN4@GetPickedS:

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000bf	8d 45 8c	 lea	 eax, DWORD PTR _SlotList$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000c2	89 45 94	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000c5	8b 45 8c	 mov	 eax, DWORD PTR _SlotList$[ebp]
  000c8	89 45 c4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000cb	8b 45 c4	 mov	 eax, DWORD PTR ___param0$[ebp]
  000ce	89 45 c0	 mov	 DWORD PTR $T13[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000d1	8d 45 c0	 lea	 eax, DWORD PTR $T13[ebp]
  000d4	89 45 bc	 mov	 DWORD PTR $T12[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  000d7	8b 45 bc	 mov	 eax, DWORD PTR $T12[ebp]
  000da	8b 4d e4	 mov	 ecx, DWORD PTR _itor$17[ebp]
  000dd	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000df	75 09		 jne	 SHORT $LN103@GetPickedS
  000e1	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv300[ebp], 1
  000e8	eb 04		 jmp	 SHORT $LN104@GetPickedS
$LN103@GetPickedS:
  000ea	83 65 dc 00	 and	 DWORD PTR tv300[ebp], 0
$LN104@GetPickedS:
  000ee	8a 45 dc	 mov	 al, BYTE PTR tv300[ebp]
  000f1	88 45 f1	 mov	 BYTE PTR $T20[ebp], al

; 203  :         return !(*this == _Right);

  000f4	0f b6 45 f1	 movzx	 eax, BYTE PTR $T20[ebp]
  000f8	85 c0		 test	 eax, eax
  000fa	75 09		 jne	 SHORT $LN98@GetPickedS
  000fc	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv276[ebp], 1
  00103	eb 04		 jmp	 SHORT $LN99@GetPickedS
$LN98@GetPickedS:
  00105	83 65 d8 00	 and	 DWORD PTR tv276[ebp], 0
$LN99@GetPickedS:
  00109	8a 45 d8	 mov	 al, BYTE PTR tv276[ebp]
  0010c	88 45 f0	 mov	 BYTE PTR $T19[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 84   : 	for (std::list<TSlot*>::iterator itor = SlotList.begin(); itor != SlotList.end(); ++itor)

  0010f	0f b6 45 f0	 movzx	 eax, BYTE PTR $T19[ebp]
  00113	85 c0		 test	 eax, eax
  00115	74 58		 je	 SHORT $LN3@GetPickedS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00117	8b 45 e4	 mov	 eax, DWORD PTR _itor$17[ebp]
  0011a	83 c0 08	 add	 eax, 8
  0011d	89 45 b8	 mov	 DWORD PTR $T11[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00120	8b 45 b8	 mov	 eax, DWORD PTR $T11[ebp]
  00123	89 45 b4	 mov	 DWORD PTR $T10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 86   : 		TSlot * pSlot = *itor;

  00126	8b 45 b4	 mov	 eax, DWORD PTR $T10[ebp]
  00129	8b 00		 mov	 eax, DWORD PTR [eax]
  0012b	89 45 e8	 mov	 DWORD PTR _pSlot$18[ebp], eax

; 87   : 
; 88   : 		// NOTE :            .
; 89   : 		//          ..    ? - [levites]
; 90   : 		if (!pMinSlot)

  0012e	83 7d ec 00	 cmp	 DWORD PTR _pMinSlot$[ebp], 0
  00132	75 08		 jne	 SHORT $LN7@GetPickedS

; 91   : 		{
; 92   : 			pMinSlot = pSlot;

  00134	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$18[ebp]
  00137	89 45 ec	 mov	 DWORD PTR _pMinSlot$[ebp], eax

; 93   : 		}

  0013a	eb 2e		 jmp	 SHORT $LN8@GetPickedS
$LN7@GetPickedS:

; 94   : 		else
; 95   : 		{
; 96   : 			if (pSlot->dwSlotNumber < pMinSlot->dwSlotNumber)

  0013c	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$18[ebp]
  0013f	8b 4d ec	 mov	 ecx, DWORD PTR _pMinSlot$[ebp]
  00142	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00145	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  00148	73 08		 jae	 SHORT $LN9@GetPickedS

; 97   : 			{
; 98   : 				pMinSlot = pSlot;

  0014a	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$18[ebp]
  0014d	89 45 ec	 mov	 DWORD PTR _pMinSlot$[ebp], eax

; 99   : 			}

  00150	eb 18		 jmp	 SHORT $LN8@GetPickedS
$LN9@GetPickedS:

; 100  : 			else
; 101  : 			{
; 102  : 				if (!pMinSlot->isItem && pSlot->isItem)

  00152	8b 45 ec	 mov	 eax, DWORD PTR _pMinSlot$[ebp]
  00155	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00159	75 0f		 jne	 SHORT $LN8@GetPickedS
  0015b	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$18[ebp]
  0015e	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00162	74 06		 je	 SHORT $LN8@GetPickedS

; 103  : 				{
; 104  : 					pMinSlot = pSlot;

  00164	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$18[ebp]
  00167	89 45 ec	 mov	 DWORD PTR _pMinSlot$[ebp], eax
$LN8@GetPickedS:

; 105  : 				}
; 106  : 			}
; 107  : 		}
; 108  : 	}

  0016a	e9 48 ff ff ff	 jmp	 $LN2@GetPickedS
$LN3@GetPickedS:

; 109  : 
; 110  : 	if (!pMinSlot)

  0016f	83 7d ec 00	 cmp	 DWORD PTR _pMinSlot$[ebp], 0
  00173	75 1a		 jne	 SHORT $LN12@GetPickedS

; 112  : 		return FALSE;

  00175	83 65 b0 00	 and	 DWORD PTR $T9[ebp], 0
  00179	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0017d	8d 4d 8c	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  00180	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 112  : 		return FALSE;

  00185	8b 45 b0	 mov	 eax, DWORD PTR $T9[ebp]
  00188	e9 85 00 00 00	 jmp	 $LN1@GetPickedS

; 113  : 	}

  0018d	eb 6d		 jmp	 SHORT $LN13@GetPickedS
$LN12@GetPickedS:

; 114  : 	else
; 115  : 	{
; 116  : 		TSlot * pCenterSlot;
; 117  : 		if (!GetSlotPointer(pMinSlot->dwCenterSlotNumber, &pCenterSlot))

  0018f	8d 45 d4	 lea	 eax, DWORD PTR _pCenterSlot$16[ebp]
  00192	50		 push	 eax
  00193	8b 45 ec	 mov	 eax, DWORD PTR _pMinSlot$[ebp]
  00196	ff 70 08	 push	 DWORD PTR [eax+8]
  00199	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0019c	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  001a1	85 c0		 test	 eax, eax
  001a3	75 15		 jne	 SHORT $LN14@GetPickedS

; 118  : 			return FALSE;

  001a5	83 65 ac 00	 and	 DWORD PTR $T8[ebp], 0
  001a9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  001ad	8d 4d 8c	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  001b0	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 118  : 			return FALSE;

  001b5	8b 45 ac	 mov	 eax, DWORD PTR $T8[ebp]
  001b8	eb 58		 jmp	 SHORT $LN1@GetPickedS
$LN14@GetPickedS:

; 119  : 
; 120  : 		*ppSlot = pCenterSlot;

  001ba	8b 45 08	 mov	 eax, DWORD PTR _ppSlot$[ebp]
  001bd	8b 4d d4	 mov	 ecx, DWORD PTR _pCenterSlot$16[ebp]
  001c0	89 08		 mov	 DWORD PTR [eax], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  001c2	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  001c7	89 45 a8	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 123  : 		if (UI::CWindowManager::Instance().IsAttaching())

  001ca	8b 4d a8	 mov	 ecx, DWORD PTR $T7[ebp]
  001cd	e8 00 00 00 00	 call	 ?IsAttaching@CWindowManager@UI@@QAEHXZ ; UI::CWindowManager::IsAttaching
  001d2	85 c0		 test	 eax, eax
  001d4	74 26		 je	 SHORT $LN13@GetPickedS
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  001d6	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  001db	89 45 a4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 125  : 			DWORD dwSlotNumber = UI::CWindowManager::Instance().GetAttachingSlotNumber();

  001de	8b 4d a4	 mov	 ecx, DWORD PTR $T6[ebp]
  001e1	e8 00 00 00 00	 call	 ?GetAttachingSlotNumber@CWindowManager@UI@@QAEKXZ ; UI::CWindowManager::GetAttachingSlotNumber
  001e6	89 45 a0	 mov	 DWORD PTR _dwSlotNumber$5[ebp], eax

; 126  : 
; 127  : 			if (dwSlotNumber == pCenterSlot->dwSlotNumber)

  001e9	8b 45 d4	 mov	 eax, DWORD PTR _pCenterSlot$16[ebp]
  001ec	8b 4d a0	 mov	 ecx, DWORD PTR _dwSlotNumber$5[ebp]
  001ef	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  001f2	75 08		 jne	 SHORT $LN13@GetPickedS

; 128  : 			{
; 129  : 				*ppSlot = pMinSlot;

  001f4	8b 45 08	 mov	 eax, DWORD PTR _ppSlot$[ebp]
  001f7	8b 4d ec	 mov	 ecx, DWORD PTR _pMinSlot$[ebp]
  001fa	89 08		 mov	 DWORD PTR [eax], ecx
$LN13@GetPickedS:

; 134  : 	return TRUE;

  001fc	c7 45 9c 01 00
	00 00		 mov	 DWORD PTR $T4[ebp], 1
  00203	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  00207	8d 4d 8c	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  0020a	e8 00 00 00 00	 call	 ?_Tidy@?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 134  : 	return TRUE;

  0020f	8b 45 9c	 mov	 eax, DWORD PTR $T4[ebp]
$LN1@GetPickedS:

; 135  : }

  00212	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00215	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0021c	59		 pop	 ecx
  0021d	c9		 leave
  0021e	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z$0:
  00000	8d 4d 8c	 lea	 ecx, DWORD PTR _SlotList$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$list@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::~list<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 94	 mov	 ecx, DWORD PTR [edx-108]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?GetPickedSlotPointer@CGridSlotWindow@UI@@MAEHPAPAUSSlot@CSlotWindow@2@@Z ENDP ; UI::CGridSlotWindow::GetPickedSlotPointer
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?__Initialize@CGridSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__Initialize@CGridSlotWindow@UI@@IAEXXZ PROC		; UI::CGridSlotWindow::__Initialize, COMDAT
; _this$ = ecx

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 376  : 	m_dwxCount = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 a0 bc 00 00
	00 00		 and	 DWORD PTR [eax+188], 0

; 377  : 	m_dwyCount = 0;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 a0 c0 00 00
	00 00		 and	 DWORD PTR [eax+192], 0

; 378  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?__Initialize@CGridSlotWindow@UI@@IAEXXZ ENDP		; UI::CGridSlotWindow::__Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?ArrangeGridSlot@CGridSlotWindow@UI@@QAEXKKKHHHH@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
_iWidth$ = -76						; size = 4
_iHeight$ = -72						; size = 4
$T2 = -68						; size = 4
$T3 = -64						; size = 4
__My_data$4 = -60					; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
__Right$ = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
___param0$9 = -36					; size = 4
_dwIndex$10 = -32					; size = 4
_ixPosition$11 = -28					; size = 4
_iyPosition$12 = -24					; size = 4
_this$ = -20						; size = 4
_x$13 = -16						; size = 4
_y$14 = -12						; size = 4
_this$ = -8						; size = 4
$T15 = -1						; size = 1
_dwStartIndex$ = 8					; size = 4
_dwxCount$ = 12						; size = 4
_dwyCount$ = 16						; size = 4
_ixSlotSize$ = 20					; size = 4
_iySlotSize$ = 24					; size = 4
_ixTemporarySize$ = 28					; size = 4
_iyTemporarySize$ = 32					; size = 4
?ArrangeGridSlot@CGridSlotWindow@UI@@QAEXKKKHHHH@Z PROC	; UI::CGridSlotWindow::ArrangeGridSlot, COMDAT
; _this$ = ecx

; 276  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 277  : 	Destroy();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?Destroy@CGridSlotWindow@UI@@QAEXXZ ; UI::CGridSlotWindow::Destroy

; 278  : 
; 279  : 	m_dwxCount = dwxCount;

  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _dwxCount$[ebp]
  00017	89 88 bc 00 00
	00		 mov	 DWORD PTR [eax+188], ecx

; 280  : 	m_dwyCount = dwyCount;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 4d 10	 mov	 ecx, DWORD PTR _dwyCount$[ebp]
  00023	89 88 c0 00 00
	00		 mov	 DWORD PTR [eax+192], ecx

; 281  : 
; 282  : 	m_SlotVector.clear();

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  00032	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00037	8d 45 ff	 lea	 eax, DWORD PTR $T15[ebp]
  0003a	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 283  : 	m_SlotVector.resize(dwxCount*dwyCount);

  0003b	8b 45 0c	 mov	 eax, DWORD PTR _dwxCount$[ebp]
  0003e	0f af 45 10	 imul	 eax, DWORD PTR _dwyCount$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00042	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 283  : 	m_SlotVector.resize(dwxCount*dwyCount);

  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  0004c	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 285  : 	for (DWORD x = 0; x < dwxCount; ++x)

  00051	83 65 f0 00	 and	 DWORD PTR _x$13[ebp], 0
  00055	eb 07		 jmp	 SHORT $LN4@ArrangeGri
$LN2@ArrangeGri:
  00057	8b 45 f0	 mov	 eax, DWORD PTR _x$13[ebp]
  0005a	40		 inc	 eax
  0005b	89 45 f0	 mov	 DWORD PTR _x$13[ebp], eax
$LN4@ArrangeGri:
  0005e	8b 45 f0	 mov	 eax, DWORD PTR _x$13[ebp]
  00061	3b 45 0c	 cmp	 eax, DWORD PTR _dwxCount$[ebp]
  00064	0f 83 d4 00 00
	00		 jae	 $LN3@ArrangeGri

; 286  : 	for (DWORD y = 0; y < dwyCount; ++y)

  0006a	83 65 f4 00	 and	 DWORD PTR _y$14[ebp], 0
  0006e	eb 07		 jmp	 SHORT $LN7@ArrangeGri
$LN5@ArrangeGri:
  00070	8b 45 f4	 mov	 eax, DWORD PTR _y$14[ebp]
  00073	40		 inc	 eax
  00074	89 45 f4	 mov	 DWORD PTR _y$14[ebp], eax
$LN7@ArrangeGri:
  00077	8b 45 f4	 mov	 eax, DWORD PTR _y$14[ebp]
  0007a	3b 45 10	 cmp	 eax, DWORD PTR _dwyCount$[ebp]
  0007d	0f 83 b6 00 00
	00		 jae	 $LN6@ArrangeGri

; 287  : 	{
; 288  : 		DWORD dwIndex = dwStartIndex + x + y * dwxCount;

  00083	8b 45 08	 mov	 eax, DWORD PTR _dwStartIndex$[ebp]
  00086	03 45 f0	 add	 eax, DWORD PTR _x$13[ebp]
  00089	8b 4d f4	 mov	 ecx, DWORD PTR _y$14[ebp]
  0008c	0f af 4d 0c	 imul	 ecx, DWORD PTR _dwxCount$[ebp]
  00090	03 c1		 add	 eax, ecx
  00092	89 45 e0	 mov	 DWORD PTR _dwIndex$10[ebp], eax

; 289  : 		int ixPosition = x * (ixSlotSize + ixTemporarySize);

  00095	8b 45 14	 mov	 eax, DWORD PTR _ixSlotSize$[ebp]
  00098	03 45 1c	 add	 eax, DWORD PTR _ixTemporarySize$[ebp]
  0009b	0f af 45 f0	 imul	 eax, DWORD PTR _x$13[ebp]
  0009f	89 45 e4	 mov	 DWORD PTR _ixPosition$11[ebp], eax

; 290  : 		int iyPosition = y * (iySlotSize + iyTemporarySize);

  000a2	8b 45 18	 mov	 eax, DWORD PTR _iySlotSize$[ebp]
  000a5	03 45 20	 add	 eax, DWORD PTR _iyTemporarySize$[ebp]
  000a8	0f af 45 f4	 imul	 eax, DWORD PTR _y$14[ebp]
  000ac	89 45 e8	 mov	 DWORD PTR _iyPosition$12[ebp], eax

; 291  : 
; 292  : 		AppendSlot(dwIndex, ixPosition, iyPosition, ixSlotSize, iySlotSize);

  000af	ff 75 18	 push	 DWORD PTR _iySlotSize$[ebp]
  000b2	ff 75 14	 push	 DWORD PTR _ixSlotSize$[ebp]
  000b5	ff 75 e8	 push	 DWORD PTR _iyPosition$12[ebp]
  000b8	ff 75 e4	 push	 DWORD PTR _ixPosition$11[ebp]
  000bb	ff 75 e0	 push	 DWORD PTR _dwIndex$10[ebp]
  000be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c1	e8 00 00 00 00	 call	 ?AppendSlot@CSlotWindow@UI@@QAEXKHHHH@Z ; UI::CSlotWindow::AppendSlot

; 294  : 		m_SlotVector[x+y*dwxCount] = &(*m_SlotList.rbegin());

  000c6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c9	05 88 00 00 00	 add	 eax, 136		; 00000088H
  000ce	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000d1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000d4	89 45 b0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000d7	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000da	8b 00		 mov	 eax, DWORD PTR [eax]
  000dc	89 45 dc	 mov	 DWORD PTR ___param0$9[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000df	8b 45 dc	 mov	 eax, DWORD PTR ___param0$9[ebp]
  000e2	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000e5	8d 45 d8	 lea	 eax, DWORD PTR $T8[ebp]
  000e8	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax

; 1132 :         return reverse_iterator(end());

  000eb	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	89 45 d0	 mov	 DWORD PTR __Right$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  000f3	8d 45 d0	 lea	 eax, DWORD PTR __Right$[ebp]
  000f6	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1902 :         : current(_STD move(_Right)) {}

  000f9	8b 45 cc	 mov	 eax, DWORD PTR $T6[ebp]
  000fc	8b 00		 mov	 eax, DWORD PTR [eax]
  000fe	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1132 :         return reverse_iterator(end());

  00101	8d 45 c8	 lea	 eax, DWORD PTR $T5[ebp]
  00104	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00107	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  0010f	89 45 c4	 mov	 DWORD PTR __My_data$4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 294  : 		m_SlotVector[x+y*dwxCount] = &(*m_SlotList.rbegin());

  00112	8b 45 f4	 mov	 eax, DWORD PTR _y$14[ebp]
  00115	0f af 45 0c	 imul	 eax, DWORD PTR _dwxCount$[ebp]
  00119	03 45 f0	 add	 eax, DWORD PTR _x$13[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1504 :         return _My_data._Myfirst[_Pos];

  0011c	8b 4d c4	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  0011f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00121	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00124	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 294  : 		m_SlotVector[x+y*dwxCount] = &(*m_SlotList.rbegin());

  00127	8b 4d c0	 mov	 ecx, DWORD PTR $T3[ebp]
  0012a	e8 00 00 00 00	 call	 ??D?$reverse_iterator@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@std@@@std@@QBEAAUSSlot@CSlotWindow@UI@@XZ ; std::reverse_iterator<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CSlotWindow::SSlot> > > >::operator*
  0012f	8b 4d bc	 mov	 ecx, DWORD PTR $T2[ebp]
  00132	89 01		 mov	 DWORD PTR [ecx], eax

; 295  : 	}

  00134	e9 37 ff ff ff	 jmp	 $LN5@ArrangeGri
$LN6@ArrangeGri:
  00139	e9 19 ff ff ff	 jmp	 $LN2@ArrangeGri
$LN3@ArrangeGri:

; 296  : 
; 297  : 	int iWidth = dwxCount * (ixSlotSize + ixTemporarySize);

  0013e	8b 45 14	 mov	 eax, DWORD PTR _ixSlotSize$[ebp]
  00141	03 45 1c	 add	 eax, DWORD PTR _ixTemporarySize$[ebp]
  00144	0f af 45 0c	 imul	 eax, DWORD PTR _dwxCount$[ebp]
  00148	89 45 b4	 mov	 DWORD PTR _iWidth$[ebp], eax

; 298  : 	int iHeight = dwyCount * (iySlotSize + iyTemporarySize);

  0014b	8b 45 18	 mov	 eax, DWORD PTR _iySlotSize$[ebp]
  0014e	03 45 20	 add	 eax, DWORD PTR _iyTemporarySize$[ebp]
  00151	0f af 45 10	 imul	 eax, DWORD PTR _dwyCount$[ebp]
  00155	89 45 b8	 mov	 DWORD PTR _iHeight$[ebp], eax

; 299  : 	SetSize(iWidth, iHeight);

  00158	ff 75 b8	 push	 DWORD PTR _iHeight$[ebp]
  0015b	ff 75 b4	 push	 DWORD PTR _iWidth$[ebp]
  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	e8 00 00 00 00	 call	 ?SetSize@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetSize

; 300  : }

  00166	c9		 leave
  00167	c2 1c 00	 ret	 28			; 0000001cH
?ArrangeGridSlot@CGridSlotWindow@UI@@QAEXKKKHHHH@Z ENDP	; UI::CGridSlotWindow::ArrangeGridSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?Destroy@CGridSlotWindow@UI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Destroy@CGridSlotWindow@UI@@QAEXXZ PROC		; UI::CGridSlotWindow::Destroy, COMDAT
; _this$ = ecx

; 366  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 367  : 	CSlotWindow::Destroy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Destroy@CSlotWindow@UI@@QAEXXZ ; UI::CSlotWindow::Destroy

; 368  : 
; 369  : 	m_SlotVector.clear();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  00018	e8 00 00 00 00	 call	 ?clear@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::clear

; 370  : 
; 371  : 	__Initialize();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?__Initialize@CGridSlotWindow@UI@@IAEXXZ ; UI::CGridSlotWindow::__Initialize

; 372  : }

  00025	c9		 leave
  00026	c3		 ret	 0
?Destroy@CGridSlotWindow@UI@@QAEXXZ ENDP		; UI::CGridSlotWindow::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ??1CGridSlotWindow@UI@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CGridSlotWindow@UI@@UAE@XZ PROC			; UI::CGridSlotWindow::~CGridSlotWindow, COMDAT
; _this$ = ecx

; 399  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGridSlotWindow@UI@@6B@

; 400  : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00019	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAUSSlot@CSlotWindow@UI@@V?$allocator@PAUSSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::vector<UI::CSlotWindow::SSlot *,std::allocator<UI::CSlotWindow::SSlot *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 400  : }

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??1CSlotWindow@UI@@UAE@XZ ; UI::CSlotWindow::~CSlotWindow
  00026	c9		 leave
  00027	c3		 ret	 0
??1CGridSlotWindow@UI@@UAE@XZ ENDP			; UI::CGridSlotWindow::~CGridSlotWindow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ??0CGridSlotWindow@UI@@QAE@PAU_object@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_this$1 = -8						; size = 4
_this$ = -4						; size = 4
_ppyObject$ = 8						; size = 4
??0CGridSlotWindow@UI@@QAE@PAU_object@@@Z PROC		; UI::CGridSlotWindow::CGridSlotWindow, COMDAT
; _this$ = ecx

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 394  : CGridSlotWindow::CGridSlotWindow(PyObject * ppyObject) : CSlotWindow(ppyObject)

  00009	ff 75 08	 push	 DWORD PTR _ppyObject$[ebp]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0CSlotWindow@UI@@QAE@PAU_object@@@Z ; UI::CSlotWindow::CSlotWindow

; 395  : {

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CGridSlotWindow@UI@@6B@
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	05 c4 00 00 00	 add	 eax, 196		; 000000c4H
  00025	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00028	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  00037	83 20 00	 and	 DWORD PTR [eax], 0
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  0003d	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$1[ebp]
  00044	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp

; 396  : }

  00048	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	c9		 leave
  0004c	c2 04 00	 ret	 4
??0CGridSlotWindow@UI@@QAE@PAU_object@@@Z ENDP		; UI::CGridSlotWindow::CGridSlotWindow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonGridSlotWindow.cpp
;	COMDAT ?Type@CGridSlotWindow@UI@@SAKXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Type@CGridSlotWindow@UI@@SAKXZ PROC			; UI::CGridSlotWindow::Type, COMDAT

; 381  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Type@CGridSlotWindow@UI@@SAKXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 382  : 	static int s_Type = GetCRC32("CGridSlotWindow", strlen("CGridSlotWindow"));

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00027	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0002e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA
  00037	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  0003d	7e 44		 jle	 SHORT $LN2@Type
  0003f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA
  00044	e8 00 00 00 00	 call	 __Init_thread_header
  00049	59		 pop	 ecx
  0004a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA, -1
  00051	75 30		 jne	 SHORT $LN2@Type
  00053	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BFEGLPNH@CGridSlotWindow@
  0005c	e8 00 00 00 00	 call	 _strlen
  00061	59		 pop	 ecx
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@BFEGLPNH@CGridSlotWindow@
  00068	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  0006d	59		 pop	 ecx
  0006e	59		 pop	 ecx
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?s_Type@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA, eax
  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA
  0007d	e8 00 00 00 00	 call	 __Init_thread_footer
  00082	59		 pop	 ecx
$LN2@Type:

; 383  : 	return s_Type;

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_Type@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA

; 384  : }

  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	c9		 leave
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Type@CGridSlotWindow@UI@@SAKXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CGridSlotWindow@UI@@SAKXZ@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Type@CGridSlotWindow@UI@@SAKXZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Type@CGridSlotWindow@UI@@SAKXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Type@CGridSlotWindow@UI@@SAKXZ ENDP			; UI::CGridSlotWindow::Type
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
;	COMDAT ?IsWindow@CWindow@UI@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWindow@CWindow@UI@@UAEHXZ PROC			; UI::CWindow::IsWindow, COMDAT
; _this$ = ecx

; 161  : 			virtual BOOL	IsWindow() { return TRUE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?IsWindow@CWindow@UI@@UAEHXZ ENDP			; UI::CWindow::IsWindow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
;	COMDAT ?SetColor@CWindow@UI@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwColor$ = 8						; size = 4
?SetColor@CWindow@UI@@UAEXK@Z PROC			; UI::CWindow::SetColor, COMDAT
; _this$ = ecx

; 157  : 			virtual void	SetColor(DWORD dwColor){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 04 00	 ret	 4
?SetColor@CWindow@UI@@UAEXK@Z ENDP			; UI::CWindow::SetColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
;	COMDAT ?OnChangePosition@CWindow@UI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnChangePosition@CWindow@UI@@UAEXXZ PROC		; UI::CWindow::OnChangePosition, COMDAT
; _this$ = ecx

; 106  : 			virtual void	OnChangePosition(){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnChangePosition@CWindow@UI@@UAEXXZ ENDP		; UI::CWindow::OnChangePosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
