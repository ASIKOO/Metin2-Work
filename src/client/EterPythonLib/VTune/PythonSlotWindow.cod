; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?OnChangePosition@CWindow@UI@@UAEXXZ		; UI::CWindow::OnChangePosition
PUBLIC	?SetColor@CWindow@UI@@UAEXK@Z			; UI::CWindow::SetColor
PUBLIC	?IsWindow@CWindow@UI@@UAEHXZ			; UI::CWindow::IsWindow
PUBLIC	?Type@CSlotWindow@UI@@SAKXZ			; UI::CSlotWindow::Type
PUBLIC	??0?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >
PUBLIC	??1?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::~list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >
PUBLIC	?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
PUBLIC	?clear@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::clear
PUBLIC	?_Tidy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Alloc_sentinel_and_proxy
PUBLIC	??0CSlotWindow@UI@@QAE@PAU_object@@@Z		; UI::CSlotWindow::CSlotWindow
PUBLIC	??1CSlotWindow@UI@@UAE@XZ			; UI::CSlotWindow::~CSlotWindow
PUBLIC	?Destroy@CSlotWindow@UI@@QAEXXZ			; UI::CSlotWindow::Destroy
PUBLIC	?SetSlotType@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::SetSlotType
PUBLIC	?SetSlotStyle@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::SetSlotStyle
PUBLIC	?AppendSlot@CSlotWindow@UI@@QAEXKHHHH@Z		; UI::CSlotWindow::AppendSlot
PUBLIC	?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z	; UI::CSlotWindow::SetCoverButton
PUBLIC	?SetSlotBaseImage@CSlotWindow@UI@@QAEXPBDMMMM@Z	; UI::CSlotWindow::SetSlotBaseImage
PUBLIC	?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z	; UI::CSlotWindow::AppendSlotButton
PUBLIC	?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z ; UI::CSlotWindow::AppendRequirementSignImage
PUBLIC	?EnableCoverButton@CSlotWindow@UI@@QAEXK@Z	; UI::CSlotWindow::EnableCoverButton
PUBLIC	?DisableCoverButton@CSlotWindow@UI@@QAEXK@Z	; UI::CSlotWindow::DisableCoverButton
PUBLIC	?SetAlwaysRenderCoverButton@CSlotWindow@UI@@QAEXK_N@Z ; UI::CSlotWindow::SetAlwaysRenderCoverButton
PUBLIC	?ShowSlotBaseImage@CSlotWindow@UI@@QAEXK@Z	; UI::CSlotWindow::ShowSlotBaseImage
PUBLIC	?HideSlotBaseImage@CSlotWindow@UI@@QAEXK@Z	; UI::CSlotWindow::HideSlotBaseImage
PUBLIC	?IsDisableCoverButton@CSlotWindow@UI@@QAEHK@Z	; UI::CSlotWindow::IsDisableCoverButton
PUBLIC	?HasSlot@CSlotWindow@UI@@QAEHK@Z		; UI::CSlotWindow::HasSlot
PUBLIC	?ClearAllSlot@CSlotWindow@UI@@QAEXXZ		; UI::CSlotWindow::ClearAllSlot
PUBLIC	?ClearSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::ClearSlot
PUBLIC	?SetSlot@CSlotWindow@UI@@QAEXKKEEPAVCGraphicImage@@AAUD3DXCOLOR@@@Z ; UI::CSlotWindow::SetSlot
PUBLIC	?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z		; UI::CSlotWindow::SetSlotCount
PUBLIC	?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z	; UI::CSlotWindow::SetSlotCountNew
PUBLIC	?SetSlotCoolTime@CSlotWindow@UI@@QAEXKMM@Z	; UI::CSlotWindow::SetSlotCoolTime
PUBLIC	?ActivateSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::ActivateSlot
PUBLIC	?DeactivateSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::DeactivateSlot
PUBLIC	?RefreshSlot@CSlotWindow@UI@@QAEXXZ		; UI::CSlotWindow::RefreshSlot
PUBLIC	?GetSlotCount@CSlotWindow@UI@@QAEKXZ		; UI::CSlotWindow::GetSlotCount
PUBLIC	?LockSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::LockSlot
PUBLIC	?UnlockSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::UnlockSlot
PUBLIC	?SetCantUseSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::SetCantUseSlot
PUBLIC	?SetUseSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::SetUseSlot
PUBLIC	?EnableSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::EnableSlot
PUBLIC	?DisableSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::DisableSlot
PUBLIC	?ClearSelected@CSlotWindow@UI@@QAEXXZ		; UI::CSlotWindow::ClearSelected
PUBLIC	?SelectSlot@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::SelectSlot
PUBLIC	?isSelectedSlot@CSlotWindow@UI@@QAEHK@Z		; UI::CSlotWindow::isSelectedSlot
PUBLIC	?GetSelectedSlotCount@CSlotWindow@UI@@QAEKXZ	; UI::CSlotWindow::GetSelectedSlotCount
PUBLIC	?GetSelectedSlotNumber@CSlotWindow@UI@@QAEKK@Z	; UI::CSlotWindow::GetSelectedSlotNumber
PUBLIC	?ShowSlotButton@CSlotWindow@UI@@QAEXK@Z		; UI::CSlotWindow::ShowSlotButton
PUBLIC	?HideAllSlotButton@CSlotWindow@UI@@QAEXXZ	; UI::CSlotWindow::HideAllSlotButton
PUBLIC	?OnPressedSlotButton@CSlotWindow@UI@@QAEXKKH@Z	; UI::CSlotWindow::OnPressedSlotButton
PUBLIC	?ShowRequirementSign@CSlotWindow@UI@@QAEXK@Z	; UI::CSlotWindow::ShowRequirementSign
PUBLIC	?HideRequirementSign@CSlotWindow@UI@@QAEXK@Z	; UI::CSlotWindow::HideRequirementSign
PUBLIC	?OnOverInItem@CSlotWindow@UI@@QAEHK@Z		; UI::CSlotWindow::OnOverInItem
PUBLIC	?OnOverOutItem@CSlotWindow@UI@@QAEXXZ		; UI::CSlotWindow::OnOverOutItem
PUBLIC	?SetUseMode@CSlotWindow@UI@@QAEXH@Z		; UI::CSlotWindow::SetUseMode
PUBLIC	?SetUsableItem@CSlotWindow@UI@@QAEXH@Z		; UI::CSlotWindow::SetUsableItem
PUBLIC	?ReserveDestroyCoolTimeFinishEffect@CSlotWindow@UI@@QAEXK@Z ; UI::CSlotWindow::ReserveDestroyCoolTimeFinishEffect
PUBLIC	?__Initialize@CSlotWindow@UI@@IAEXXZ		; UI::CSlotWindow::__Initialize
PUBLIC	?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ	; UI::CSlotWindow::__CreateToggleSlotImage
PUBLIC	?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__CreateSlotEnableEffect
PUBLIC	?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::__CreateFinishCoolTimeEffect
PUBLIC	?__CreateBaseImage@CSlotWindow@UI@@IAEXPBDMMMM@Z ; UI::CSlotWindow::__CreateBaseImage
PUBLIC	?__DestroyToggleSlotImage@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__DestroyToggleSlotImage
PUBLIC	?__DestroySlotEnableEffect@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__DestroySlotEnableEffect
PUBLIC	?__DestroyFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::__DestroyFinishCoolTimeEffect
PUBLIC	?__DestroyBaseImage@CSlotWindow@UI@@IAEXXZ	; UI::CSlotWindow::__DestroyBaseImage
PUBLIC	?OnUpdate@CSlotWindow@UI@@MAEXXZ		; UI::CSlotWindow::OnUpdate
PUBLIC	?OnRender@CSlotWindow@UI@@MAEXXZ		; UI::CSlotWindow::OnRender
PUBLIC	?OnMouseLeftButtonDown@CSlotWindow@UI@@MAEHXZ	; UI::CSlotWindow::OnMouseLeftButtonDown
PUBLIC	?OnMouseLeftButtonUp@CSlotWindow@UI@@MAEHXZ	; UI::CSlotWindow::OnMouseLeftButtonUp
PUBLIC	?OnMouseRightButtonDown@CSlotWindow@UI@@MAEHXZ	; UI::CSlotWindow::OnMouseRightButtonDown
PUBLIC	?OnMouseLeftButtonDoubleClick@CSlotWindow@UI@@MAEHXZ ; UI::CSlotWindow::OnMouseLeftButtonDoubleClick
PUBLIC	?OnMouseOverOut@CSlotWindow@UI@@MAEXXZ		; UI::CSlotWindow::OnMouseOverOut
PUBLIC	?OnMouseOver@CSlotWindow@UI@@MAEXXZ		; UI::CSlotWindow::OnMouseOver
PUBLIC	?RenderSlotBaseImage@CSlotWindow@UI@@IAEXXZ	; UI::CSlotWindow::RenderSlotBaseImage
PUBLIC	?RenderLockedSlot@CSlotWindow@UI@@IAEXXZ	; UI::CSlotWindow::RenderLockedSlot
PUBLIC	?OnRenderPickingSlot@CSlotWindow@UI@@MAEXXZ	; UI::CSlotWindow::OnRenderPickingSlot
PUBLIC	?OnRenderSelectedSlot@CSlotWindow@UI@@MAEXXZ	; UI::CSlotWindow::OnRenderSelectedSlot
PUBLIC	?OnSelectEmptySlot@CSlotWindow@UI@@IAEXH@Z	; UI::CSlotWindow::OnSelectEmptySlot
PUBLIC	?OnSelectItemSlot@CSlotWindow@UI@@IAEXH@Z	; UI::CSlotWindow::OnSelectItemSlot
PUBLIC	?OnUnselectEmptySlot@CSlotWindow@UI@@IAEXH@Z	; UI::CSlotWindow::OnUnselectEmptySlot
PUBLIC	?OnUnselectItemSlot@CSlotWindow@UI@@IAEXH@Z	; UI::CSlotWindow::OnUnselectItemSlot
PUBLIC	?OnUseSlot@CSlotWindow@UI@@IAEXXZ		; UI::CSlotWindow::OnUseSlot
PUBLIC	?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
PUBLIC	?GetSelectedSlotPointer@CSlotWindow@UI@@IAEHPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSelectedSlotPointer
PUBLIC	?GetPickedSlotPointer@CSlotWindow@UI@@MAEHPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetPickedSlotPointer
PUBLIC	?ClearSlot@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z	; UI::CSlotWindow::ClearSlot
PUBLIC	?OnRefreshSlot@CSlotWindow@UI@@MAEXXZ		; UI::CSlotWindow::OnRefreshSlot
PUBLIC	?OnIsType@CSlotWindow@UI@@MAEHK@Z		; UI::CSlotWindow::OnIsType
PUBLIC	??0?$list@KV?$allocator@K@std@@@std@@QAE@XZ	; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ	; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >
PUBLIC	?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::begin
PUBLIC	?erase@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::erase
PUBLIC	?clear@?$list@KV?$allocator@K@std@@@std@@QAEXXZ	; std::list<unsigned long,std::allocator<unsigned long> >::clear
PUBLIC	?_Tidy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ	; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ ; std::list<unsigned long,std::allocator<unsigned long> >::_Alloc_sentinel_and_proxy
PUBLIC	??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ	; std::deque<unsigned long,std::allocator<unsigned long> >::deque<unsigned long,std::allocator<unsigned long> >
PUBLIC	??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ	; std::deque<unsigned long,std::allocator<unsigned long> >::~deque<unsigned long,std::allocator<unsigned long> >
PUBLIC	?begin@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ ; std::deque<unsigned long,std::allocator<unsigned long> >::begin
PUBLIC	?end@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ ; std::deque<unsigned long,std::allocator<unsigned long> >::end
PUBLIC	?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::pop_back
PUBLIC	?_Xlen@?$deque@KV?$allocator@K@std@@@std@@ABEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Xlen
PUBLIC	?_Growmap@?$deque@KV?$allocator@K@std@@@std@@AAEXI@Z ; std::deque<unsigned long,std::allocator<unsigned long> >::_Growmap
PUBLIC	?_Tidy@?$deque@KV?$allocator@K@std@@@std@@AAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Deque_val<std::_Deque_simple_types<unsigned long> >
PUBLIC	??_GCSlotWindow@UI@@UAEPAXI@Z			; UI::CSlotWindow::`scalar deleting destructor'
PUBLIC	?OnMouseLeftButtonDown@CSlotButton@CSlotWindow@UI@@UAEHXZ ; UI::CSlotWindow::CSlotButton::OnMouseLeftButtonDown
PUBLIC	?OnMouseLeftButtonUp@CSlotButton@CSlotWindow@UI@@UAEHXZ ; UI::CSlotWindow::CSlotButton::OnMouseLeftButtonUp
PUBLIC	?OnMouseOverIn@CSlotButton@CSlotWindow@UI@@UAEXXZ ; UI::CSlotWindow::CSlotButton::OnMouseOverIn
PUBLIC	?OnMouseOverOut@CSlotButton@CSlotWindow@UI@@UAEXXZ ; UI::CSlotWindow::CSlotButton::OnMouseOverOut
PUBLIC	??_GCSlotButton@CSlotWindow@UI@@UAEPAXI@Z	; UI::CSlotWindow::CSlotButton::`scalar deleting destructor'
PUBLIC	?OnRender@CCoverButton@CSlotWindow@UI@@UAEXXZ	; UI::CSlotWindow::CCoverButton::OnRender
PUBLIC	?OnMouseLeftButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ ; UI::CSlotWindow::CCoverButton::OnMouseLeftButtonDown
PUBLIC	?OnMouseLeftButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ ; UI::CSlotWindow::CCoverButton::OnMouseLeftButtonUp
PUBLIC	?OnMouseRightButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ ; UI::CSlotWindow::CCoverButton::OnMouseRightButtonDown
PUBLIC	?OnMouseRightButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ ; UI::CSlotWindow::CCoverButton::OnMouseRightButtonUp
PUBLIC	??_GCCoverButton@CSlotWindow@UI@@UAEPAXI@Z	; UI::CSlotWindow::CCoverButton::`scalar deleting destructor'
PUBLIC	?OnEndFrame@CCoolTimeFinishEffect@CSlotWindow@UI@@UAEXXZ ; UI::CSlotWindow::CCoolTimeFinishEffect::OnEndFrame
PUBLIC	??_GCCoolTimeFinishEffect@CSlotWindow@UI@@UAEPAXI@Z ; UI::CSlotWindow::CCoolTimeFinishEffect::`scalar deleting destructor'
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QBEABKXZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >::operator*
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >
PUBLIC	??_9CWindow@UI@@$B3AE				; UI::CWindow::`vcall'{4}'
PUBLIC	??$for_each@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@std@@V?$void_mem_fun_t@VCWindow@UI@@@2@@std@@YA?AV?$void_mem_fun_t@VCWindow@UI@@@0@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@0@0V10@@Z ; std::for_each<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CWindow *> > >,std::void_mem_fun_t<UI::CWindow> >
PUBLIC	??$_Emplace_back_internal@ABK@?$deque@KV?$allocator@K@std@@@std@@AAEXABK@Z ; std::deque<unsigned long,std::allocator<unsigned long> >::_Emplace_back_internal<unsigned long const &>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ; std::_List_node<unsigned long,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned long,void *> > >
PUBLIC	??$_Emplace@ABK@?$list@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@QAU21@ABK@Z ; std::list<unsigned long,std::allocator<unsigned long> >::_Emplace<unsigned long const &>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
PUBLIC	??$_Emplace@ABUSSlot@CSlotWindow@UI@@@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@1@QAU21@ABUSSlot@CSlotWindow@UI@@@Z ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Emplace<UI::CSlotWindow::SSlot const &>
PUBLIC	??$_Destroy_in_place@PAK@std@@YAXAAPAK@Z	; std::_Destroy_in_place<unsigned long *>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@KPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ; std::_List_node<unsigned long,void *>::_Freenode0<std::allocator<std::_List_node<unsigned long,void *> > >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::_Transfer_before
PUBLIC	??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > ><unsigned long const &>
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_Transfer_before
PUBLIC	??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > ><UI::CSlotWindow::SSlot const &>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<unsigned long,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * const &>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@KPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * const &>
PUBLIC	??$uninitialized_copy@PAPAKPAPAK@std@@YAPAPAKQAPAK0PAPAK@Z ; std::uninitialized_copy<unsigned long * *,unsigned long * *>
PUBLIC	??$_Uninitialized_value_construct_n_unchecked1@PAPAKI@std@@YAPAPAKPAPAKI@Z ; std::_Uninitialized_value_construct_n_unchecked1<unsigned long * *,unsigned int>
PUBLIC	??$_Destroy_range@PAPAKPAPAK@std@@YAXPAPAKQAPAK@Z ; std::_Destroy_range<unsigned long * *,unsigned long * *>
PUBLIC	??$_Copy_memmove@PAPAKPAPAK@std@@YAPAPAKPAPAK00@Z ; std::_Copy_memmove<unsigned long * *,unsigned long * *>
PUBLIC	??$_Zero_range@PAPAK@std@@YAPAPAKQAPAK0@Z	; std::_Zero_range<unsigned long * *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7CSlotWindow@UI@@6B@				; UI::CSlotWindow::`vftable'
PUBLIC	??_7CSlotButton@CSlotWindow@UI@@6B@		; UI::CSlotWindow::CSlotButton::`vftable'
PUBLIC	??_7CCoverButton@CSlotWindow@UI@@6B@		; UI::CSlotWindow::CCoverButton::`vftable'
PUBLIC	??_7CCoolTimeFinishEffect@CSlotWindow@UI@@6B@	; UI::CSlotWindow::CCoolTimeFinishEffect::`vftable'
PUBLIC	??_C@_02DPKJAMEF@?$CFd@				; `string'
PUBLIC	??_C@_03CIOACFJF@m?$CFd@			; `string'
PUBLIC	??_C@_03EHFNMFPB@g?$CFd@			; `string'
PUBLIC	??_C@_01JBBJJEPG@p@				; `string'
PUBLIC	??_C@_03LIHNMIHG@?$CIi?$CJ@			; `string'
PUBLIC	??_C@_0BC@JJECHKOF@OnSelectEmptySlot@		; `string'
PUBLIC	??_C@_0BB@PFHJJJ@OnSelectItemSlot@		; `string'
PUBLIC	??_C@_0BE@GMADJAFC@OnUnselectEmptySlot@		; `string'
PUBLIC	??_C@_0BD@EONLJJMO@OnUnselectItemSlot@		; `string'
PUBLIC	??_C@_09HJIBPFCA@OnUseSlot@			; `string'
PUBLIC	??_C@_0N@CBOPEHFH@OnOverInItem@			; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ@			; `string'
PUBLIC	??_C@_0O@IBCIPGEP@OnOverOutItem@		; `string'
PUBLIC	??_C@_0BE@MBGDMPNF@OnPressedSlotButton@		; `string'
PUBLIC	??_C@_0M@DKKKJBKL@CSlotWindow@			; `string'
PUBLIC	??_C@_0CH@JJGPDFBJ@d?3?1ymir?5work?1ui?1public?1slot_tog@ ; `string'
PUBLIC	??_C@_0CP@LLEDDNBJ@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@HABPOOLM@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@PGILJMBC@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@DNNHEPLH@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@CANCHPAP@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@OLIOKMKK@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@GNBKNOAE@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@KGEGANKB@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@FHBALPHE@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@JMEMGMNB@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@BNDEDGKN@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@NGGIOFAI@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0CP@FAPMJHKG@d?3?1ymir?5work?1ui?1public?1slotacti@ ; `string'
PUBLIC	??_C@_0DH@EECLJILE@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@IPHHELBB@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@JODDJLP@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@MCLPOKBK@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@NPLKNKKC@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@BEOGAJAH@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@JCHCHLKJ@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@FJCOKIAM@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@KIHIBKNJ@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@GDCEMJHM@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0DH@OCFMJDAA@d?3?1ymir?5work?1ui?1public?1slotfini@ ; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@	; `string'
PUBLIC	??_R1A@?0A@EA@CWindow@UI@@8			; UI::CWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCWindow@UI@@@8				; UI::CWindow `RTTI Type Descriptor'
PUBLIC	??_R3CWindow@UI@@8				; UI::CWindow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CWindow@UI@@8				; UI::CWindow::`RTTI Base Class Array'
PUBLIC	??_R4CSlotWindow@UI@@6B@			; UI::CSlotWindow::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSlotWindow@UI@@@8			; UI::CSlotWindow `RTTI Type Descriptor'
PUBLIC	??_R3CSlotWindow@UI@@8				; UI::CSlotWindow::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSlotWindow@UI@@8				; UI::CSlotWindow::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSlotWindow@UI@@8			; UI::CSlotWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CSlotButton@CSlotWindow@UI@@6B@		; UI::CSlotWindow::CSlotButton::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCSlotButton@CSlotWindow@UI@@@8		; UI::CSlotWindow::CSlotButton `RTTI Type Descriptor'
PUBLIC	??_R3CSlotButton@CSlotWindow@UI@@8		; UI::CSlotWindow::CSlotButton::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CSlotButton@CSlotWindow@UI@@8		; UI::CSlotWindow::CSlotButton::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CSlotButton@CSlotWindow@UI@@8	; UI::CSlotWindow::CSlotButton::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CButton@UI@@8			; UI::CButton::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCButton@UI@@@8				; UI::CButton `RTTI Type Descriptor'
PUBLIC	??_R3CButton@UI@@8				; UI::CButton::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CButton@UI@@8				; UI::CButton::`RTTI Base Class Array'
PUBLIC	??_R4CCoverButton@CSlotWindow@UI@@6B@		; UI::CSlotWindow::CCoverButton::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCoverButton@CSlotWindow@UI@@@8		; UI::CSlotWindow::CCoverButton `RTTI Type Descriptor'
PUBLIC	??_R3CCoverButton@CSlotWindow@UI@@8		; UI::CSlotWindow::CCoverButton::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCoverButton@CSlotWindow@UI@@8		; UI::CSlotWindow::CCoverButton::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCoverButton@CSlotWindow@UI@@8	; UI::CSlotWindow::CCoverButton::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CCoolTimeFinishEffect@CSlotWindow@UI@@6B@	; UI::CSlotWindow::CCoolTimeFinishEffect::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCCoolTimeFinishEffect@CSlotWindow@UI@@@8 ; UI::CSlotWindow::CCoolTimeFinishEffect `RTTI Type Descriptor'
PUBLIC	??_R3CCoolTimeFinishEffect@CSlotWindow@UI@@8	; UI::CSlotWindow::CCoolTimeFinishEffect::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CCoolTimeFinishEffect@CSlotWindow@UI@@8	; UI::CSlotWindow::CCoolTimeFinishEffect::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CCoolTimeFinishEffect@CSlotWindow@UI@@8 ; UI::CSlotWindow::CCoolTimeFinishEffect::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CAniImageBox@UI@@8		; UI::CAniImageBox::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCAniImageBox@UI@@@8			; UI::CAniImageBox `RTTI Type Descriptor'
PUBLIC	??_R3CAniImageBox@UI@@8				; UI::CAniImageBox::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAniImageBox@UI@@8				; UI::CAniImageBox::`RTTI Base Class Array'
PUBLIC	__real@00000000
PUBLIC	__real@3e99999a
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@41800000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp__Py_BuildValue:PROC
EXTRN	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z:PROC ; PyCallClassMemberFunc
EXTRN	?GetCurrentSecond@CTimer@@QAEMXZ:PROC		; CTimer::GetCurrentSecond
EXTRN	?GetCRC32@@YAKPBDI@Z:PROC			; GetCRC32
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	?Render@CGraphicImageInstance@@QAEXXZ:PROC	; CGraphicImageInstance::Render
EXTRN	?SetDiffuseColor@CGraphicImageInstance@@QAEXMMMM@Z:PROC ; CGraphicImageInstance::SetDiffuseColor
EXTRN	?SetPosition@CGraphicImageInstance@@QAEXMM@Z:PROC ; CGraphicImageInstance::SetPosition
EXTRN	?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z:PROC ; CGraphicImageInstance::SetImagePointer
EXTRN	?New@CGraphicImageInstance@@SAPAV1@XZ:PROC	; CGraphicImageInstance::New
EXTRN	?Delete@CGraphicImageInstance@@SAXPAV1@@Z:PROC	; CGraphicImageInstance::Delete
EXTRN	?RenderBar2d@CScreen@@QAEXMMMMM@Z:PROC		; CScreen::RenderBar2d
EXTRN	?SetDiffuseColor@CScreen@@QAEXMMMM@Z:PROC	; CScreen::SetDiffuseColor
EXTRN	?RenderCoolTimeBox@CPythonGraphic@@QAEXMMMM@Z:PROC ; CPythonGraphic::RenderCoolTimeBox
EXTRN	?GetMousePosition@CWindowManager@UI@@QAEXAAJ0@Z:PROC ; UI::CWindowManager::GetMousePosition
EXTRN	?IsDragging@CWindowManager@UI@@QAEHXZ:PROC	; UI::CWindowManager::IsDragging
EXTRN	?SetParent@CWindowManager@UI@@QAEXPAVCWindow@2@0@Z:PROC ; UI::CWindowManager::SetParent
EXTRN	?DestroyWindow@CWindowManager@UI@@QAEXPAVCWindow@2@@Z:PROC ; UI::CWindowManager::DestroyWindow
EXTRN	?IsAttaching@CWindowManager@UI@@QAEHXZ:PROC	; UI::CWindowManager::IsAttaching
EXTRN	?DeattachIcon@CWindowManager@UI@@QAEXXZ:PROC	; UI::CWindowManager::DeattachIcon
EXTRN	?IsType@CWindow@UI@@QAEHK@Z:PROC		; UI::CWindow::IsType
EXTRN	??0CWindow@UI@@QAE@PAU_object@@@Z:PROC		; UI::CWindow::CWindow
EXTRN	??1CWindow@UI@@UAE@XZ:PROC			; UI::CWindow::~CWindow
EXTRN	?Update@CWindow@UI@@QAEXXZ:PROC			; UI::CWindow::Update
EXTRN	?Render@CWindow@UI@@QAEXXZ:PROC			; UI::CWindow::Render
EXTRN	?SetPosition@CWindow@UI@@QAEXJJ@Z:PROC		; UI::CWindow::SetPosition
EXTRN	?GetMouseLocalPosition@CWindow@UI@@QAEXAAJ0@Z:PROC ; UI::CWindow::GetMouseLocalPosition
EXTRN	?Show@CWindow@UI@@QAEXXZ:PROC			; UI::CWindow::Show
EXTRN	?Hide@CWindow@UI@@QAEXXZ:PROC			; UI::CWindow::Hide
EXTRN	?IsRendering@CWindow@UI@@QAE_NXZ:PROC		; UI::CWindow::IsRendering
EXTRN	?SetTop@CWindow@UI@@QAEXPAV12@@Z:PROC		; UI::CWindow::SetTop
EXTRN	?IsIn@CWindow@UI@@QAE_NXZ:PROC			; UI::CWindow::IsIn
EXTRN	?OnSetFocus@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnSetFocus
EXTRN	?OnKillFocus@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnKillFocus
EXTRN	?OnMouseDrag@CWindow@UI@@UAEXJJ@Z:PROC		; UI::CWindow::OnMouseDrag
EXTRN	?OnMouseOverIn@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnMouseOverIn
EXTRN	?OnMouseOverOut@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnMouseOverOut
EXTRN	?OnMouseOver@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnMouseOver
EXTRN	?OnDrop@CWindow@UI@@UAEXXZ:PROC			; UI::CWindow::OnDrop
EXTRN	?OnTop@CWindow@UI@@UAEXXZ:PROC			; UI::CWindow::OnTop
EXTRN	?OnIMEUpdate@CWindow@UI@@UAEXXZ:PROC		; UI::CWindow::OnIMEUpdate
EXTRN	?OnMoveWindow@CWindow@UI@@UAEXJJ@Z:PROC		; UI::CWindow::OnMoveWindow
EXTRN	?OnIMETabEvent@CWindow@UI@@UAEHXZ:PROC		; UI::CWindow::OnIMETabEvent
EXTRN	?OnIMEReturnEvent@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnIMEReturnEvent
EXTRN	?OnIMEKeyDownEvent@CWindow@UI@@UAEHH@Z:PROC	; UI::CWindow::OnIMEKeyDownEvent
EXTRN	?OnIMEChangeCodePage@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnIMEChangeCodePage
EXTRN	?OnIMEOpenCandidateListEvent@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnIMEOpenCandidateListEvent
EXTRN	?OnIMECloseCandidateListEvent@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnIMECloseCandidateListEvent
EXTRN	?OnIMEOpenReadingWndEvent@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnIMEOpenReadingWndEvent
EXTRN	?OnIMECloseReadingWndEvent@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnIMECloseReadingWndEvent
EXTRN	?OnMouseLeftButtonDown@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnMouseLeftButtonDown
EXTRN	?OnMouseLeftButtonUp@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnMouseLeftButtonUp
EXTRN	?OnMouseLeftButtonDoubleClick@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnMouseLeftButtonDoubleClick
EXTRN	?OnMouseRightButtonDown@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnMouseRightButtonDown
EXTRN	?OnMouseRightButtonUp@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnMouseRightButtonUp
EXTRN	?OnMouseRightButtonDoubleClick@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnMouseRightButtonDoubleClick
EXTRN	?OnMouseMiddleButtonDown@CWindow@UI@@UAEHXZ:PROC ; UI::CWindow::OnMouseMiddleButtonDown
EXTRN	?OnMouseMiddleButtonUp@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnMouseMiddleButtonUp
EXTRN	?OnKeyDown@CWindow@UI@@UAEHH@Z:PROC		; UI::CWindow::OnKeyDown
EXTRN	?OnKeyUp@CWindow@UI@@UAEHH@Z:PROC		; UI::CWindow::OnKeyUp
EXTRN	?OnPressEscapeKey@CWindow@UI@@UAEHXZ:PROC	; UI::CWindow::OnPressEscapeKey
EXTRN	?OnPressExitKey@CWindow@UI@@UAEHXZ:PROC		; UI::CWindow::OnPressExitKey
EXTRN	?OnIsType@CWindow@UI@@UAEHK@Z:PROC		; UI::CWindow::OnIsType
EXTRN	??0CNumberLine@UI@@QAE@PAVCWindow@1@@Z:PROC	; UI::CNumberLine::CNumberLine
EXTRN	?SetHorizontalAlign@CNumberLine@UI@@QAEXH@Z:PROC ; UI::CNumberLine::SetHorizontalAlign
EXTRN	?SetNumber@CNumberLine@UI@@QAEXPBD@Z:PROC	; UI::CNumberLine::SetNumber
EXTRN	??0CImageBox@UI@@QAE@PAU_object@@@Z:PROC	; UI::CImageBox::CImageBox
EXTRN	?LoadImageA@CImageBox@UI@@QAEHPBD@Z:PROC	; UI::CImageBox::LoadImageA
EXTRN	??0CAniImageBox@UI@@QAE@PAU_object@@@Z:PROC	; UI::CAniImageBox::CAniImageBox
EXTRN	??1CAniImageBox@UI@@UAE@XZ:PROC			; UI::CAniImageBox::~CAniImageBox
EXTRN	?SetDelay@CAniImageBox@UI@@QAEXH@Z:PROC		; UI::CAniImageBox::SetDelay
EXTRN	?AppendImage@CAniImageBox@UI@@QAEXPBD@Z:PROC	; UI::CAniImageBox::AppendImage
EXTRN	?SetRenderingMode@CAniImageBox@UI@@QAEXH@Z:PROC	; UI::CAniImageBox::SetRenderingMode
EXTRN	?ResetFrame@CAniImageBox@UI@@QAEXXZ:PROC	; UI::CAniImageBox::ResetFrame
EXTRN	?OnUpdate@CAniImageBox@UI@@MAEXXZ:PROC		; UI::CAniImageBox::OnUpdate
EXTRN	?OnRender@CAniImageBox@UI@@MAEXXZ:PROC		; UI::CAniImageBox::OnRender
EXTRN	?OnChangePosition@CAniImageBox@UI@@MAEXXZ:PROC	; UI::CAniImageBox::OnChangePosition
EXTRN	?OnIsType@CAniImageBox@UI@@MAEHK@Z:PROC		; UI::CAniImageBox::OnIsType
EXTRN	??0CButton@UI@@QAE@PAU_object@@@Z:PROC		; UI::CButton::CButton
EXTRN	??1CButton@UI@@UAE@XZ:PROC			; UI::CButton::~CButton
EXTRN	?SetUpVisual@CButton@UI@@QAEHPBD@Z:PROC		; UI::CButton::SetUpVisual
EXTRN	?SetOverVisual@CButton@UI@@QAEHPBD@Z:PROC	; UI::CButton::SetOverVisual
EXTRN	?SetDownVisual@CButton@UI@@QAEHPBD@Z:PROC	; UI::CButton::SetDownVisual
EXTRN	?SetDisableVisual@CButton@UI@@QAEHPBD@Z:PROC	; UI::CButton::SetDisableVisual
EXTRN	?Enable@CButton@UI@@QAEXXZ:PROC			; UI::CButton::Enable
EXTRN	?Disable@CButton@UI@@QAEXXZ:PROC		; UI::CButton::Disable
EXTRN	?SetUp@CButton@UI@@QAEXXZ:PROC			; UI::CButton::SetUp
EXTRN	?Down@CButton@UI@@QAEXXZ:PROC			; UI::CButton::Down
EXTRN	?IsDisable@CButton@UI@@QAEHXZ:PROC		; UI::CButton::IsDisable
EXTRN	?IsPressed@CButton@UI@@QAEHXZ:PROC		; UI::CButton::IsPressed
EXTRN	?OnUpdate@CButton@UI@@MAEXXZ:PROC		; UI::CButton::OnUpdate
EXTRN	?OnRender@CButton@UI@@MAEXXZ:PROC		; UI::CButton::OnRender
EXTRN	?OnChangePosition@CButton@UI@@MAEXXZ:PROC	; UI::CButton::OnChangePosition
EXTRN	?OnMouseLeftButtonDown@CButton@UI@@MAEHXZ:PROC	; UI::CButton::OnMouseLeftButtonDown
EXTRN	?OnMouseLeftButtonDoubleClick@CButton@UI@@MAEHXZ:PROC ; UI::CButton::OnMouseLeftButtonDoubleClick
EXTRN	?OnMouseLeftButtonUp@CButton@UI@@MAEHXZ:PROC	; UI::CButton::OnMouseLeftButtonUp
EXTRN	?IsEnable@CButton@UI@@IAEHXZ:PROC		; UI::CButton::IsEnable
EXTRN	?SetCurrentVisual@CButton@UI@@IAEXPAVCGraphicImageInstance@@@Z:PROC ; UI::CButton::SetCurrentVisual
EXTRN	??_ECSlotWindow@UI@@UAEPAXI@Z:PROC		; UI::CSlotWindow::`vector deleting destructor'
EXTRN	??_ECSlotButton@CSlotWindow@UI@@UAEPAXI@Z:PROC	; UI::CSlotWindow::CSlotButton::`vector deleting destructor'
EXTRN	??_ECCoverButton@CSlotWindow@UI@@UAEPAXI@Z:PROC	; UI::CSlotWindow::CCoverButton::`vector deleting destructor'
EXTRN	??_ECCoolTimeFinishEffect@CSlotWindow@UI@@UAEPAXI@Z:PROC ; UI::CSlotWindow::CCoolTimeFinishEffect::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A DD 01H DUP (?) ; CSingleton<CTimer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A DD 01H DUP (?) ; CSingleton<CPythonGraphic>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A DD 01H DUP (?) ; CSingleton<UI::CWindowManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?s_Type@?1??Type@CSlotWindow@UI@@SAKXZ@4HA
_BSS	SEGMENT
?s_Type@?1??Type@CSlotWindow@UI@@SAKXZ@4HA DD 01H DUP (?) ; `UI::CSlotWindow::Type'::`2'::s_Type
_BSS	ENDS
;	COMDAT ?$TSS0@?1??Type@CSlotWindow@UI@@SAKXZ@4HA
_BSS	SEGMENT
?$TSS0@?1??Type@CSlotWindow@UI@@SAKXZ@4HA DD 01H DUP (?) ; `UI::CSlotWindow::Type'::`2'::$TSS0
_BSS	ENDS
;	COMDAT __real@41800000
CONST	SEGMENT
__real@41800000 DD 041800000r			; 16
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e99999a
CONST	SEGMENT
__real@3e99999a DD 03e99999ar			; 0.3
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R2CAniImageBox@UI@@8
rdata$r	SEGMENT
??_R2CAniImageBox@UI@@8 DD FLAT:??_R1A@?0A@EA@CAniImageBox@UI@@8 ; UI::CAniImageBox::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R3CAniImageBox@UI@@8
rdata$r	SEGMENT
??_R3CAniImageBox@UI@@8 DD 00H				; UI::CAniImageBox::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CAniImageBox@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAniImageBox@UI@@@8
data$rs	SEGMENT
??_R0?AVCAniImageBox@UI@@@8 DD FLAT:??_7type_info@@6B@	; UI::CAniImageBox `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAniImageBox@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CAniImageBox@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAniImageBox@UI@@8 DD FLAT:??_R0?AVCAniImageBox@UI@@@8 ; UI::CAniImageBox::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAniImageBox@UI@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CCoolTimeFinishEffect@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCoolTimeFinishEffect@CSlotWindow@UI@@8 DD FLAT:??_R0?AVCCoolTimeFinishEffect@CSlotWindow@UI@@@8 ; UI::CSlotWindow::CCoolTimeFinishEffect::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCoolTimeFinishEffect@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R2CCoolTimeFinishEffect@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R2CCoolTimeFinishEffect@CSlotWindow@UI@@8 DD FLAT:??_R1A@?0A@EA@CCoolTimeFinishEffect@CSlotWindow@UI@@8 ; UI::CSlotWindow::CCoolTimeFinishEffect::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CAniImageBox@UI@@8
	DD	FLAT:??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R3CCoolTimeFinishEffect@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R3CCoolTimeFinishEffect@CSlotWindow@UI@@8 DD 00H	; UI::CSlotWindow::CCoolTimeFinishEffect::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CCoolTimeFinishEffect@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCoolTimeFinishEffect@CSlotWindow@UI@@@8
data$rs	SEGMENT
??_R0?AVCCoolTimeFinishEffect@CSlotWindow@UI@@@8 DD FLAT:??_7type_info@@6B@ ; UI::CSlotWindow::CCoolTimeFinishEffect `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCoolTimeFinishEffect@CSlotWindow@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CCoolTimeFinishEffect@CSlotWindow@UI@@6B@
rdata$r	SEGMENT
??_R4CCoolTimeFinishEffect@CSlotWindow@UI@@6B@ DD 00H	; UI::CSlotWindow::CCoolTimeFinishEffect::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCoolTimeFinishEffect@CSlotWindow@UI@@@8
	DD	FLAT:??_R3CCoolTimeFinishEffect@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CCoverButton@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CCoverButton@CSlotWindow@UI@@8 DD FLAT:??_R0?AVCCoverButton@CSlotWindow@UI@@@8 ; UI::CSlotWindow::CCoverButton::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CCoverButton@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R2CCoverButton@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R2CCoverButton@CSlotWindow@UI@@8 DD FLAT:??_R1A@?0A@EA@CCoverButton@CSlotWindow@UI@@8 ; UI::CSlotWindow::CCoverButton::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CSlotButton@CSlotWindow@UI@@8
	DD	FLAT:??_R1A@?0A@EA@CButton@UI@@8
	DD	FLAT:??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R3CCoverButton@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R3CCoverButton@CSlotWindow@UI@@8 DD 00H		; UI::CSlotWindow::CCoverButton::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2CCoverButton@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCCoverButton@CSlotWindow@UI@@@8
data$rs	SEGMENT
??_R0?AVCCoverButton@CSlotWindow@UI@@@8 DD FLAT:??_7type_info@@6B@ ; UI::CSlotWindow::CCoverButton `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCCoverButton@CSlotWindow@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CCoverButton@CSlotWindow@UI@@6B@
rdata$r	SEGMENT
??_R4CCoverButton@CSlotWindow@UI@@6B@ DD 00H		; UI::CSlotWindow::CCoverButton::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCCoverButton@CSlotWindow@UI@@@8
	DD	FLAT:??_R3CCoverButton@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R2CButton@UI@@8
rdata$r	SEGMENT
??_R2CButton@UI@@8 DD FLAT:??_R1A@?0A@EA@CButton@UI@@8	; UI::CButton::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R3CButton@UI@@8
rdata$r	SEGMENT
??_R3CButton@UI@@8 DD 00H				; UI::CButton::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CButton@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCButton@UI@@@8
data$rs	SEGMENT
??_R0?AVCButton@UI@@@8 DD FLAT:??_7type_info@@6B@	; UI::CButton `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCButton@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CButton@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CButton@UI@@8 DD FLAT:??_R0?AVCButton@UI@@@8 ; UI::CButton::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CButton@UI@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CSlotButton@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSlotButton@CSlotWindow@UI@@8 DD FLAT:??_R0?AVCSlotButton@CSlotWindow@UI@@@8 ; UI::CSlotWindow::CSlotButton::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSlotButton@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R2CSlotButton@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R2CSlotButton@CSlotWindow@UI@@8 DD FLAT:??_R1A@?0A@EA@CSlotButton@CSlotWindow@UI@@8 ; UI::CSlotWindow::CSlotButton::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CButton@UI@@8
	DD	FLAT:??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R3CSlotButton@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R3CSlotButton@CSlotWindow@UI@@8 DD 00H		; UI::CSlotWindow::CSlotButton::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CSlotButton@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSlotButton@CSlotWindow@UI@@@8
data$rs	SEGMENT
??_R0?AVCSlotButton@CSlotWindow@UI@@@8 DD FLAT:??_7type_info@@6B@ ; UI::CSlotWindow::CSlotButton `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSlotButton@CSlotWindow@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CSlotButton@CSlotWindow@UI@@6B@
rdata$r	SEGMENT
??_R4CSlotButton@CSlotWindow@UI@@6B@ DD 00H		; UI::CSlotWindow::CSlotButton::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSlotButton@CSlotWindow@UI@@@8
	DD	FLAT:??_R3CSlotButton@CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CSlotWindow@UI@@8 DD FLAT:??_R0?AVCSlotWindow@UI@@@8 ; UI::CSlotWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R2CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R2CSlotWindow@UI@@8 DD FLAT:??_R1A@?0A@EA@CSlotWindow@UI@@8 ; UI::CSlotWindow::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R3CSlotWindow@UI@@8
rdata$r	SEGMENT
??_R3CSlotWindow@UI@@8 DD 00H				; UI::CSlotWindow::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCSlotWindow@UI@@@8
data$rs	SEGMENT
??_R0?AVCSlotWindow@UI@@@8 DD FLAT:??_7type_info@@6B@	; UI::CSlotWindow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCSlotWindow@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CSlotWindow@UI@@6B@
rdata$r	SEGMENT
??_R4CSlotWindow@UI@@6B@ DD 00H				; UI::CSlotWindow::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCSlotWindow@UI@@@8
	DD	FLAT:??_R3CSlotWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R2CWindow@UI@@8
rdata$r	SEGMENT
??_R2CWindow@UI@@8 DD FLAT:??_R1A@?0A@EA@CWindow@UI@@8	; UI::CWindow::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CWindow@UI@@8
rdata$r	SEGMENT
??_R3CWindow@UI@@8 DD 00H				; UI::CWindow::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCWindow@UI@@@8
data$rs	SEGMENT
??_R0?AVCWindow@UI@@@8 DD FLAT:??_7type_info@@6B@	; UI::CWindow `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCWindow@UI@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CWindow@UI@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CWindow@UI@@8 DD FLAT:??_R0?AVCWindow@UI@@@8 ; UI::CWindow::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CWindow@UI@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@OCFMJDAA@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@OCFMJDAA@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/10.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@GDCEMJHM@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@GDCEMJHM@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/09.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@KIHIBKNJ@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@KIHIBKNJ@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/08.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FJCOKIAM@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@FJCOKIAM@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/07.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JCHCHLKJ@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@JCHCHLKJ@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/06.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BEOGAJAH@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@BEOGAJAH@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/05.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@NPLKNKKC@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@NPLKNKKC@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/04.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@MCLPOKBK@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@MCLPOKBK@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/03.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@JODDJLP@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@JODDJLP@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir work'
	DB	'/ui/public/slotfinishcooltimeeffect/02.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@IPHHELBB@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@IPHHELBB@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/01.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EECLJILE@d?3?1ymir?5work?1ui?1public?1slotfini@
CONST	SEGMENT
??_C@_0DH@EECLJILE@d?3?1ymir?5work?1ui?1public?1slotfini@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotfinishcooltimeeffect/00.sub', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FAPMJHKG@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@FAPMJHKG@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/12.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@NGGIOFAI@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@NGGIOFAI@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/11.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@BNDEDGKN@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@BNDEDGKN@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/10.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@JMEMGMNB@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@JMEMGMNB@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/09.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FHBALPHE@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@FHBALPHE@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/08.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@KGEGANKB@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@KGEGANKB@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/07.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GNBKNOAE@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@GNBKNOAE@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/06.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@OLIOKMKK@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@OLIOKMKK@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/05.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@CANCHPAP@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@CANCHPAP@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/04.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@DNNHEPLH@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@DNNHEPLH@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/03.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@PGILJMBC@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@PGILJMBC@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/02.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HABPOOLM@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@HABPOOLM@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/01.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LLEDDNBJ@d?3?1ymir?5work?1ui?1public?1slotacti@
CONST	SEGMENT
??_C@_0CP@LLEDDNBJ@d?3?1ymir?5work?1ui?1public?1slotacti@ DB 'd:/ymir wor'
	DB	'k/ui/public/slotactiveeffect/00.sub', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JJGPDFBJ@d?3?1ymir?5work?1ui?1public?1slot_tog@
CONST	SEGMENT
??_C@_0CH@JJGPDFBJ@d?3?1ymir?5work?1ui?1public?1slot_tog@ DB 'd:/ymir wor'
	DB	'k/ui/public/slot_toggle.sub', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DKKKJBKL@CSlotWindow@
CONST	SEGMENT
??_C@_0M@DKKKJBKL@CSlotWindow@ DB 'CSlotWindow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MBGDMPNF@OnPressedSlotButton@
CONST	SEGMENT
??_C@_0BE@MBGDMPNF@OnPressedSlotButton@ DB 'OnPressedSlotButton', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IBCIPGEP@OnOverOutItem@
CONST	SEGMENT
??_C@_0O@IBCIPGEP@OnOverOutItem@ DB 'OnOverOutItem', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ@ DB '()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CBOPEHFH@OnOverInItem@
CONST	SEGMENT
??_C@_0N@CBOPEHFH@OnOverInItem@ DB 'OnOverInItem', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09HJIBPFCA@OnUseSlot@
CONST	SEGMENT
??_C@_09HJIBPFCA@OnUseSlot@ DB 'OnUseSlot', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EONLJJMO@OnUnselectItemSlot@
CONST	SEGMENT
??_C@_0BD@EONLJJMO@OnUnselectItemSlot@ DB 'OnUnselectItemSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GMADJAFC@OnUnselectEmptySlot@
CONST	SEGMENT
??_C@_0BE@GMADJAFC@OnUnselectEmptySlot@ DB 'OnUnselectEmptySlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@PFHJJJ@OnSelectItemSlot@
CONST	SEGMENT
??_C@_0BB@PFHJJJ@OnSelectItemSlot@ DB 'OnSelectItemSlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JJECHKOF@OnSelectEmptySlot@
CONST	SEGMENT
??_C@_0BC@JJECHKOF@OnSelectEmptySlot@ DB 'OnSelectEmptySlot', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LIHNMIHG@?$CIi?$CJ@
CONST	SEGMENT
??_C@_03LIHNMIHG@?$CIi?$CJ@ DB '(i)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p@
CONST	SEGMENT
??_C@_01JBBJJEPG@p@ DB 'p', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03EHFNMFPB@g?$CFd@
CONST	SEGMENT
??_C@_03EHFNMFPB@g?$CFd@ DB 'g%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CIOACFJF@m?$CFd@
CONST	SEGMENT
??_C@_03CIOACFJF@m?$CFd@ DB 'm%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd@ DB '%d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CCoolTimeFinishEffect@CSlotWindow@UI@@6B@
CONST	SEGMENT
??_7CCoolTimeFinishEffect@CSlotWindow@UI@@6B@ DD FLAT:??_R4CCoolTimeFinishEffect@CSlotWindow@UI@@6B@ ; UI::CSlotWindow::CCoolTimeFinishEffect::`vftable'
	DD	FLAT:??_ECCoolTimeFinishEffect@CSlotWindow@UI@@UAEPAXI@Z
	DD	FLAT:?OnRender@CAniImageBox@UI@@MAEXXZ
	DD	FLAT:?OnUpdate@CAniImageBox@UI@@MAEXXZ
	DD	FLAT:?OnChangePosition@CAniImageBox@UI@@MAEXXZ
	DD	FLAT:?OnSetFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnKillFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseDrag@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnMouseOverIn@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseOverOut@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseOver@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnDrop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnTop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnIMEUpdate@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMoveWindow@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnIMETabEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEReturnEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEKeyDownEvent@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnIMEChangeCodePage@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonDown@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonDoubleClick@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonDown@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonDoubleClick@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonDown@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnKeyDown@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnKeyUp@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnPressEscapeKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnPressExitKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?SetColor@CWindow@UI@@UAEXK@Z
	DD	FLAT:?OnIsType@CAniImageBox@UI@@MAEHK@Z
	DD	FLAT:?IsWindow@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnEndFrame@CCoolTimeFinishEffect@CSlotWindow@UI@@UAEXXZ
CONST	ENDS
;	COMDAT ??_7CCoverButton@CSlotWindow@UI@@6B@
CONST	SEGMENT
??_7CCoverButton@CSlotWindow@UI@@6B@ DD FLAT:??_R4CCoverButton@CSlotWindow@UI@@6B@ ; UI::CSlotWindow::CCoverButton::`vftable'
	DD	FLAT:??_ECCoverButton@CSlotWindow@UI@@UAEPAXI@Z
	DD	FLAT:?OnRender@CCoverButton@CSlotWindow@UI@@UAEXXZ
	DD	FLAT:?OnUpdate@CButton@UI@@MAEXXZ
	DD	FLAT:?OnChangePosition@CButton@UI@@MAEXXZ
	DD	FLAT:?OnSetFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnKillFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseDrag@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnMouseOverIn@CSlotButton@CSlotWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseOverOut@CSlotButton@CSlotWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseOver@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnDrop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnTop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnIMEUpdate@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMoveWindow@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnIMETabEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEReturnEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEKeyDownEvent@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnIMEChangeCodePage@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonDoubleClick@CButton@UI@@MAEHXZ
	DD	FLAT:?OnMouseRightButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonDoubleClick@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonDown@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnKeyDown@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnKeyUp@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnPressEscapeKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnPressExitKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?SetColor@CWindow@UI@@UAEXK@Z
	DD	FLAT:?OnIsType@CWindow@UI@@UAEHK@Z
	DD	FLAT:?IsWindow@CWindow@UI@@UAEHXZ
CONST	ENDS
;	COMDAT ??_7CSlotButton@CSlotWindow@UI@@6B@
CONST	SEGMENT
??_7CSlotButton@CSlotWindow@UI@@6B@ DD FLAT:??_R4CSlotButton@CSlotWindow@UI@@6B@ ; UI::CSlotWindow::CSlotButton::`vftable'
	DD	FLAT:??_ECSlotButton@CSlotWindow@UI@@UAEPAXI@Z
	DD	FLAT:?OnRender@CButton@UI@@MAEXXZ
	DD	FLAT:?OnUpdate@CButton@UI@@MAEXXZ
	DD	FLAT:?OnChangePosition@CButton@UI@@MAEXXZ
	DD	FLAT:?OnSetFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnKillFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseDrag@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnMouseOverIn@CSlotButton@CSlotWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseOverOut@CSlotButton@CSlotWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseOver@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnDrop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnTop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnIMEUpdate@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMoveWindow@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnIMETabEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEReturnEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEKeyDownEvent@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnIMEChangeCodePage@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonDown@CSlotButton@CSlotWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonUp@CSlotButton@CSlotWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonDoubleClick@CButton@UI@@MAEHXZ
	DD	FLAT:?OnMouseRightButtonDown@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonDoubleClick@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonDown@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnKeyDown@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnKeyUp@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnPressEscapeKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnPressExitKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?SetColor@CWindow@UI@@UAEXK@Z
	DD	FLAT:?OnIsType@CWindow@UI@@UAEHK@Z
	DD	FLAT:?IsWindow@CWindow@UI@@UAEHXZ
CONST	ENDS
;	COMDAT ??_7CSlotWindow@UI@@6B@
CONST	SEGMENT
??_7CSlotWindow@UI@@6B@ DD FLAT:??_R4CSlotWindow@UI@@6B@ ; UI::CSlotWindow::`vftable'
	DD	FLAT:??_ECSlotWindow@UI@@UAEPAXI@Z
	DD	FLAT:?OnRender@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnUpdate@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnChangePosition@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnSetFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnKillFocus@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseDrag@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnMouseOverIn@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMouseOverOut@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnMouseOver@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnDrop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnTop@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnIMEUpdate@CWindow@UI@@UAEXXZ
	DD	FLAT:?OnMoveWindow@CWindow@UI@@UAEXJJ@Z
	DD	FLAT:?OnIMETabEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEReturnEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEKeyDownEvent@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnIMEChangeCodePage@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseCandidateListEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMEOpenReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnIMECloseReadingWndEvent@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseLeftButtonDown@CSlotWindow@UI@@MAEHXZ
	DD	FLAT:?OnMouseLeftButtonUp@CSlotWindow@UI@@MAEHXZ
	DD	FLAT:?OnMouseLeftButtonDoubleClick@CSlotWindow@UI@@MAEHXZ
	DD	FLAT:?OnMouseRightButtonDown@CSlotWindow@UI@@MAEHXZ
	DD	FLAT:?OnMouseRightButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseRightButtonDoubleClick@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonDown@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnMouseMiddleButtonUp@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnKeyDown@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnKeyUp@CWindow@UI@@UAEHH@Z
	DD	FLAT:?OnPressEscapeKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnPressExitKey@CWindow@UI@@UAEHXZ
	DD	FLAT:?SetColor@CWindow@UI@@UAEXK@Z
	DD	FLAT:?OnIsType@CSlotWindow@UI@@MAEHK@Z
	DD	FLAT:?IsWindow@CWindow@UI@@UAEHXZ
	DD	FLAT:?OnRenderPickingSlot@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?OnRenderSelectedSlot@CSlotWindow@UI@@MAEXXZ
	DD	FLAT:?GetPickedSlotPointer@CSlotWindow@UI@@MAEHPAPAUSSlot@12@@Z
	DD	FLAT:?OnRefreshSlot@CSlotWindow@UI@@MAEXXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z$0
__ehfuncinfo$??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z$0
__ehfuncinfo$??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?OnUpdate@CSlotWindow@UI@@MAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?OnUpdate@CSlotWindow@UI@@MAEXXZ$0
__ehfuncinfo$?OnUpdate@CSlotWindow@UI@@MAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?OnUpdate@CSlotWindow@UI@@MAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z$0
__ehfuncinfo$?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ$0
__ehfuncinfo$?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ$0
__ehfuncinfo$?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z$0
__ehfuncinfo$?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z$0
__ehfuncinfo$?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z$0
__ehfuncinfo$?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z$0
__ehfuncinfo$?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z$0
__ehfuncinfo$?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CSlotWindow@UI@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CSlotWindow@UI@@QAE@PAU_object@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CSlotWindow@UI@@QAE@PAU_object@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CSlotWindow@UI@@QAE@PAU_object@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CSlotWindow@UI@@QAE@PAU_object@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CSlotWindow@UI@@QAE@PAU_object@@@Z$3
__ehfuncinfo$??0CSlotWindow@UI@@QAE@PAU_object@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0CSlotWindow@UI@@QAE@PAU_object@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Type@CSlotWindow@UI@@SAKXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Type@CSlotWindow@UI@@SAKXZ$0
__ehfuncinfo$?Type@CSlotWindow@UI@@SAKXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Type@CSlotWindow@UI@@SAKXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PAPAK@std@@YAPAPAKQAPAK0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAK@std@@YAPAPAKQAPAK0@Z PROC		; std::_Zero_range<unsigned long * *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00014	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1856 :     return _Last;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1857 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$_Zero_range@PAPAK@std@@YAPAPAKQAPAK0@Z ENDP		; std::_Zero_range<unsigned long * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAKPAPAK@std@@YAPAPAKPAPAK00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAKPAPAK@std@@YAPAPAKPAPAK00@Z PROC	; std::_Copy_memmove<unsigned long * *,unsigned long * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAKPAPAK@std@@YAPAPAKPAPAK00@Z ENDP	; std::_Copy_memmove<unsigned long * *,unsigned long * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@PAPAKPAPAK@std@@YAXPAPAKQAPAK@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Destroy_range@PAPAKPAPAK@std@@YAXPAPAKQAPAK@Z PROC	; std::_Destroy_range<unsigned long * *,unsigned long * *>, COMDAT

; 974  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 975  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 976  :     if _CONSTEXPR_IF (!is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>) {
; 977  :         for (; _First != _Last; ++_First) {
; 978  :             _Destroy_in_place(*_First);
; 979  :         }
; 980  :     }
; 981  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@PAPAKPAPAK@std@@YAXPAPAKQAPAK@Z ENDP	; std::_Destroy_range<unsigned long * *,unsigned long * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n_unchecked1@PAPAKI@std@@YAPAPAKPAPAKI@Z
_TEXT	SEGMENT
__UFirst$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Uninitialized_value_construct_n_unchecked1@PAPAKI@std@@YAPAPAKPAPAKI@Z PROC ; std::_Uninitialized_value_construct_n_unchecked1<unsigned long * *,unsigned int>, COMDAT

; 1912 : _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1913 :     // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
; 1914 :     _STL_INTERNAL_CHECK(_Count >= 0);
; 1915 :     if constexpr (_Use_memset_value_construct_v<_NoThrowFwdIt>) {
; 1916 :         return _Zero_range(_UFirst, _UFirst + _Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 4d 08	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00009	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR __UFirst$[ebp]
  00010	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAK@std@@YAPAPAKQAPAK0@Z ; std::_Zero_range<unsigned long * *>
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx

; 1917 :     } else {
; 1918 :         _Uninitialized_backout<_NoThrowFwdIt> _Backout{_UFirst};
; 1919 :         for (; 0 < _Count; --_Count) {
; 1920 :             _Backout._Emplace_back();
; 1921 :         }
; 1922 : 
; 1923 :         return _Backout._Release();
; 1924 :     }
; 1925 : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Uninitialized_value_construct_n_unchecked1@PAPAKI@std@@YAPAPAKPAPAKI@Z ENDP ; std::_Uninitialized_value_construct_n_unchecked1<unsigned long * *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$uninitialized_copy@PAPAKPAPAK@std@@YAPAPAKQAPAK0PAPAK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
__UFirst$ = -12						; size = 4
__ULast$ = -8						; size = 4
__UDest$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$uninitialized_copy@PAPAKPAPAK@std@@YAPAPAKQAPAK0PAPAK@Z PROC ; std::uninitialized_copy<unsigned long * *,unsigned long * *>, COMDAT

; 1629 : _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1630 :     // copy [_First, _Last) to raw [_Dest, ...)
; 1631 :     _Adl_verify_range(_First, _Last);
; 1632 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1633 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1557 :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __ULast$[ebp]
  00015	2b 45 f4	 sub	 eax, DWORD PTR __UFirst$[ebp]
  00018	c1 f8 02	 sar	 eax, 2
  0001b	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1634 :     auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));

  0001e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00021	89 45 fc	 mov	 DWORD PTR __UDest$[ebp], eax

; 1635 :     if constexpr (_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial) {
; 1636 :         _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);

  00024	ff 75 fc	 push	 DWORD PTR __UDest$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __ULast$[ebp]
  0002a	ff 75 f4	 push	 DWORD PTR __UFirst$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAKPAPAK@std@@YAPAPAKPAPAK00@Z ; std::_Copy_memmove<unsigned long * *,unsigned long * *>
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	89 45 fc	 mov	 DWORD PTR __UDest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 1492 :         _It = static_cast<_UIter&&>(_UIt);

  00038	8b 45 fc	 mov	 eax, DWORD PTR __UDest$[ebp]
  0003b	89 45 10	 mov	 DWORD PTR __Dest$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1647 :     return _Dest;

  0003e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]

; 1648 : }

  00041	c9		 leave
  00042	c3		 ret	 0
??$uninitialized_copy@PAPAKPAPAK@std@@YAPAPAKQAPAK0PAPAK@Z ENDP ; std::uninitialized_copy<unsigned long * *,unsigned long * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@KPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@KPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@KPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<unsigned long,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<unsigned long,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > ><UI::CSlotWindow::SSlot const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00039	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00051	83 c0 08	 add	 eax, 8
  00054	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00057	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005a	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00065	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00068	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00071	6a 14		 push	 20			; 00000014H
  00073	59		 pop	 ecx
  00074	8b 75 e0	 mov	 esi, DWORD PTR $T3[ebp]
  00077	8b 7d dc	 mov	 edi, DWORD PTR $T2[ebp]
  0007a	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  0007c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	c9		 leave
  00091	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > ><UI::CSlotWindow::SSlot const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 12		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 58	 imul	 eax, eax, 88
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 2e ba
	e8 02		 mov	 DWORD PTR __Max_possible$1[ebp], 48806446 ; 02e8ba2eH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 2e ba e8 02	 cmp	 eax, 48806446		; 02e8ba2eH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 58	 imul	 eax, eax, 88
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > ><unsigned long const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00028	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002e	89 08		 mov	 DWORD PTR [eax], ecx
  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00037	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00046	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0004f	83 c0 08	 add	 eax, 8
  00052	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  00058	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 00		 mov	 eax, DWORD PTR [eax]
  00060	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00063	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00066	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00069	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006c	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0006f	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00072	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00075	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00077	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  00079	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00083	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008a	59		 pop	 ecx
  0008b	c9		 leave
  0008c	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > ><unsigned long const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@KPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@KPAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 12		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 0c	 imul	 eax, eax, 12
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 0c	 imul	 eax, eax, 12
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<unsigned long,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
__Mycont_$ = -16					; size = 4
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f4	 mov	 eax, DWORD PTR $T1[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 45 f0	 mov	 DWORD PTR __Mycont_$[ebp], eax

; 1089 :     _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr) {}

  00020	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00023	8b 4d f0	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00026	89 08		 mov	 DWORD PTR [eax], ecx
  00028	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0002b	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0002f	c9		 leave
  00030	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 1003 : void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00003	33 c0		 xor	 eax, eax
  00005	40		 inc	 eax
  00006	c1 e0 03	 shl	 eax, 3
  00009	50		 push	 eax
  0000a	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00012	59		 pop	 ecx
  00013	59		 pop	 ecx

; 1004 :     // deallocate a plain pointer using an allocator
; 1005 :     using _Alloc_traits = allocator_traits<_Alloc>;
; 1006 :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 1007 :         _Alloc_traits::deallocate(_Al, _Ptr, 1);
; 1008 :     } else {
; 1009 :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 1010 :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 1011 :     }
; 1012 : }

  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 58	 imul	 eax, eax, 88
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<unsigned long,void *>::_Freenode0<std::allocator<std::_List_node<unsigned long,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<unsigned long,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@KPAX@std@@@std@@YAXAAPAU?$_List_node@KPAX@0@@Z ; std::_Destroy_in_place<std::_List_node<unsigned long,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 0c	 imul	 eax, eax, 12
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<unsigned long,void *>::_Freenode0<std::allocator<std::_List_node<unsigned long,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@KPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@KPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@KPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAK@std@@YAXAAPAK@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAK@std@@YAXAAPAK@Z PROC		; std::_Destroy_in_place<unsigned long *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAK@std@@YAXAAPAK@Z ENDP		; std::_Destroy_in_place<unsigned long *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABUSSlot@CSlotWindow@UI@@@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@1@QAU21@ABUSSlot@CSlotWindow@UI@@@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABUSSlot@CSlotWindow@UI@@@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@1@QAU21@ABUSSlot@CSlotWindow@UI@@@Z PROC ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Emplace<UI::CSlotWindow::SSlot const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 2e ba
	e8 02		 mov	 DWORD PTR $T12[ebp], 48806446 ; 02e8ba2eH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABUSSlot@CSlotWindow@UI@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@ABUSSlot@CSlotWindow@UI@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > ><UI::CSlotWindow::SSlot const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABUSSlot@CSlotWindow@UI@@@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@1@QAU21@ABUSSlot@CSlotWindow@UI@@@Z ENDP ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Emplace<UI::CSlotWindow::SSlot const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABK@?$list@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@QAU21@ABK@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABK@?$list@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@QAU21@ABK@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Emplace<unsigned long const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 55 55
	55 15		 mov	 DWORD PTR $T12[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABK@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@KPAX@std@@@1@ABK@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > ><unsigned long const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAEPAU?$_List_node@KPAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@KPAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<unsigned long,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABK@?$list@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@QAU21@ABK@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Emplace<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z PROC ; std::_List_node<unsigned long,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned long,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ; std::_List_node<unsigned long,void *>::_Freenode0<std::allocator<std::_List_node<unsigned long,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<unsigned long,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned long,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__New_proxy$ = -8					; size = 4
__Overflow_is_possible$5 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1106 :     void _Alloc_proxy(_Alloc&& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00009	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000d	c7 45 e4 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 60   :         if (_Count > _Max_possible) {

  00014	33 c0		 xor	 eax, eax
  00016	40		 inc	 eax
  00017	3d ff ff ff 1f	 cmp	 eax, 536870911		; 1fffffffH
  0001c	76 05		 jbe	 SHORT $LN6@Alloc_prox

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001e	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Alloc_prox:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	c1 e0 03	 shl	 eax, 3
  00029	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0002c	ff 75 f0	 push	 DWORD PTR $T4[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00034	59		 pop	 ecx
  00035	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00038	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0003b	89 45 f8	 mov	 DWORD PTR __New_proxy$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1108 :         _Construct_in_place(*_New_proxy, this);

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  00044	8d 45 e8	 lea	 eax, DWORD PTR $T2[ebp]
  00047	50		 push	 eax
  00048	ff 75 f8	 push	 DWORD PTR __New_proxy$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00050	59		 pop	 ecx
  00051	59		 pop	 ecx

; 1109 :         _Myproxy            = _New_proxy;

  00052	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00055	8b 4d f8	 mov	 ecx, DWORD PTR __New_proxy$[ebp]
  00058	89 08		 mov	 DWORD PTR [eax], ecx

; 1110 :         _New_proxy->_Mycont = this;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR __New_proxy$[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	89 08		 mov	 DWORD PTR [eax], ecx
$LN9@Alloc_prox:

; 1111 :     }

  00062	c9		 leave
  00063	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 1031 : void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1032 :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1033 :     using _Ty = typename _Alloc::value_type;
; 1034 :     _Ptr->~_Ty();
; 1035 :     _Deallocate_plain(_Al, _Ptr);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  00009	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0000e	59		 pop	 ecx
  0000f	59		 pop	 ecx

; 1036 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??$_Emplace_back_internal@ABK@?$deque@KV?$allocator@K@std@@@std@@AAEXABK@Z
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
__Max_possible$3 = -52					; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
$T9 = -28						; size = 4
$T10 = -24						; size = 4
$T11 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T12 = -12						; size = 4
$T13 = -8						; size = 4
$T14 = -4						; size = 4
$T15 = 0						; size = 4
$T16 = 4						; size = 4
$T17 = 8						; size = 4
$T18 = 12						; size = 4
$T19 = 16						; size = 4
$T20 = 20						; size = 4
$T21 = 24						; size = 4
$T22 = 28						; size = 4
$T23 = 32						; size = 4
$T24 = 36						; size = 4
$T25 = 40						; size = 4
$T26 = 44						; size = 4
$T27 = 48						; size = 4
$T28 = 52						; size = 4
$T29 = 56						; size = 4
$T30 = 60						; size = 4
$T31 = 64						; size = 4
$T32 = 68						; size = 4
$T33 = 72						; size = 4
$T34 = 76						; size = 4
$T35 = 80						; size = 4
$T36 = 84						; size = 4
$T37 = 88						; size = 4
__Newoff$ = 92						; size = 4
tv163 = 96						; size = 4
__Block$ = 100						; size = 4
tv86 = 104						; size = 4
__Overflow_is_possible$38 = 111				; size = 1
_this$ = 112						; size = 4
_<_Vals_0>$ = 124					; size = 4
??$_Emplace_back_internal@ABK@?$deque@KV?$allocator@K@std@@@std@@AAEXABK@Z PROC ; std::deque<unsigned long,std::allocator<unsigned long> >::_Emplace_back_internal<unsigned long const &>, COMDAT
; _this$ = ecx

; 1114 :     void _Emplace_back_internal(_Tys&&... _Vals) {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec b0 00 00
	00		 sub	 esp, 176		; 000000b0H
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  0000e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00011	89 45 58	 mov	 DWORD PTR $T37[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  00014	8b 45 58	 mov	 eax, DWORD PTR $T37[ebp]
  00017	83 c0 0c	 add	 eax, 12			; 0000000cH
  0001a	89 45 50	 mov	 DWORD PTR $T35[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0001d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 54	 mov	 DWORD PTR $T36[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  00023	8b 45 54	 mov	 eax, DWORD PTR $T36[ebp]
  00026	83 c0 10	 add	 eax, 16			; 00000010H
  00029	89 45 4c	 mov	 DWORD PTR $T34[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  0002c	8b 45 50	 mov	 eax, DWORD PTR $T35[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	8b 4d 4c	 mov	 ecx, DWORD PTR $T34[ebp]
  00034	03 01		 add	 eax, DWORD PTR [ecx]
  00036	33 d2		 xor	 edx, edx
  00038	6a 04		 push	 4
  0003a	59		 pop	 ecx
  0003b	f7 f1		 div	 ecx
  0003d	85 d2		 test	 edx, edx
  0003f	75 3a		 jne	 SHORT $LN2@Emplace_ba

; 1530 :         return _Mypair._Myval2;

  00041	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00044	89 45 48	 mov	 DWORD PTR $T33[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00047	8b 45 48	 mov	 eax, DWORD PTR $T33[ebp]
  0004a	83 c0 08	 add	 eax, 8
  0004d	89 45 3c	 mov	 DWORD PTR $T30[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00050	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00053	89 45 44	 mov	 DWORD PTR $T32[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  00056	8b 45 44	 mov	 eax, DWORD PTR $T32[ebp]
  00059	83 c0 10	 add	 eax, 16			; 00000010H
  0005c	89 45 40	 mov	 DWORD PTR $T31[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  0005f	8b 45 40	 mov	 eax, DWORD PTR $T31[ebp]
  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	83 c0 04	 add	 eax, 4
  00067	c1 e8 02	 shr	 eax, 2
  0006a	8b 4d 3c	 mov	 ecx, DWORD PTR $T30[ebp]
  0006d	39 01		 cmp	 DWORD PTR [ecx], eax
  0006f	77 0a		 ja	 SHORT $LN2@Emplace_ba
  00071	6a 01		 push	 1
  00073	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Growmap@?$deque@KV?$allocator@K@std@@@std@@AAEXI@Z ; std::deque<unsigned long,std::allocator<unsigned long> >::_Growmap
$LN2@Emplace_ba:
  0007b	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  0007e	89 45 68	 mov	 DWORD PTR tv86[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00081	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00084	89 45 38	 mov	 DWORD PTR $T29[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  00087	8b 45 38	 mov	 eax, DWORD PTR $T29[ebp]
  0008a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0008d	89 45 68	 mov	 DWORD PTR tv86[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00090	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00093	89 45 34	 mov	 DWORD PTR $T28[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00096	8b 45 34	 mov	 eax, DWORD PTR $T28[ebp]
  00099	83 c0 08	 add	 eax, 8
  0009c	89 45 30	 mov	 DWORD PTR $T27[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  0009f	8b 45 30	 mov	 eax, DWORD PTR $T27[ebp]
  000a2	8b 00		 mov	 eax, DWORD PTR [eax]
  000a4	8d 04 85 ff ff
	ff ff		 lea	 eax, DWORD PTR [eax*4-1]
  000ab	8b 4d 68	 mov	 ecx, DWORD PTR tv86[ebp]
  000ae	23 01		 and	 eax, DWORD PTR [ecx]
  000b0	8b 4d 68	 mov	 ecx, DWORD PTR tv86[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1530 :         return _Mypair._Myval2;

  000b5	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	89 45 2c	 mov	 DWORD PTR $T26[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000bb	8b 45 2c	 mov	 eax, DWORD PTR $T26[ebp]
  000be	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c1	89 45 24	 mov	 DWORD PTR $T24[ebp], eax

; 1530 :         return _Mypair._Myval2;

  000c4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000c7	89 45 28	 mov	 DWORD PTR $T25[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  000ca	8b 45 28	 mov	 eax, DWORD PTR $T25[ebp]
  000cd	83 c0 10	 add	 eax, 16			; 00000010H
  000d0	89 45 20	 mov	 DWORD PTR $T23[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  000d3	8b 45 24	 mov	 eax, DWORD PTR $T24[ebp]
  000d6	8b 00		 mov	 eax, DWORD PTR [eax]
  000d8	8b 4d 20	 mov	 ecx, DWORD PTR $T23[ebp]
  000db	03 01		 add	 eax, DWORD PTR [ecx]
  000dd	89 45 5c	 mov	 DWORD PTR __Newoff$[ebp], eax

; 1534 :         return _Mypair._Myval2;

  000e0	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	89 45 1c	 mov	 DWORD PTR $T22[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  000e6	8b 45 5c	 mov	 eax, DWORD PTR __Newoff$[ebp]
  000e9	c1 e8 02	 shr	 eax, 2
  000ec	8b 4d 1c	 mov	 ecx, DWORD PTR $T22[ebp]
  000ef	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000f2	49		 dec	 ecx
  000f3	23 c1		 and	 eax, ecx
  000f5	89 45 18	 mov	 DWORD PTR $T21[ebp], eax

; 1514 :         return _Get_data()._Getblock(_Off);

  000f8	8b 45 18	 mov	 eax, DWORD PTR $T21[ebp]
  000fb	89 45 64	 mov	 DWORD PTR __Block$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  000fe	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00101	89 45 14	 mov	 DWORD PTR $T20[ebp], eax

; 1538 :         return _Get_data()._Map;

  00104	8b 45 14	 mov	 eax, DWORD PTR $T20[ebp]
  00107	83 c0 04	 add	 eax, 4
  0010a	89 45 10	 mov	 DWORD PTR $T19[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  0010d	8b 45 10	 mov	 eax, DWORD PTR $T19[ebp]
  00110	8b 00		 mov	 eax, DWORD PTR [eax]
  00112	8b 4d 64	 mov	 ecx, DWORD PTR __Block$[ebp]
  00115	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00119	75 58		 jne	 SHORT $LN3@Emplace_ba

; 1522 :         return _Mypair._Get_first();

  0011b	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0011e	89 45 0c	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00121	8b 45 0c	 mov	 eax, DWORD PTR $T18[ebp]
  00124	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00127	c6 45 6f 01	 mov	 BYTE PTR __Overflow_is_possible$38[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0012b	c7 45 cc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$3[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00132	6a 04		 push	 4
  00134	58		 pop	 eax
  00135	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0013a	76 05		 jbe	 SHORT $LN77@Emplace_ba

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0013c	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN77@Emplace_ba:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00141	6a 04		 push	 4
  00143	58		 pop	 eax
  00144	c1 e0 02	 shl	 eax, 2
  00147	89 45 08	 mov	 DWORD PTR $T17[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0014a	ff 75 08	 push	 DWORD PTR $T17[ebp]
  0014d	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00152	59		 pop	 ecx
  00153	89 45 fc	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00156	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00159	89 45 04	 mov	 DWORD PTR $T16[ebp], eax

; 1538 :         return _Get_data()._Map;

  0015c	8b 45 04	 mov	 eax, DWORD PTR $T16[ebp]
  0015f	83 c0 04	 add	 eax, 4
  00162	89 45 00	 mov	 DWORD PTR $T15[ebp], eax

; 1115 :         _PUSH_BACK_BEGIN;

  00165	8b 45 00	 mov	 eax, DWORD PTR $T15[ebp]
  00168	8b 00		 mov	 eax, DWORD PTR [eax]
  0016a	8b 4d 64	 mov	 ecx, DWORD PTR __Block$[ebp]
  0016d	8b 55 fc	 mov	 edx, DWORD PTR $T14[ebp]
  00170	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN3@Emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00173	8b 45 7c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00176	89 45 e4	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00179	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0017c	89 45 f8	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  0017f	8b 45 f8	 mov	 eax, DWORD PTR $T13[ebp]
  00182	83 c0 04	 add	 eax, 4
  00185	89 45 f4	 mov	 DWORD PTR $T12[ebp], eax

; 1116 :         _Alty_traits::construct(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ), _STD forward<_Tys>(_Vals)...);

  00188	8b 45 5c	 mov	 eax, DWORD PTR __Newoff$[ebp]
  0018b	33 d2		 xor	 edx, edx
  0018d	6a 04		 push	 4
  0018f	59		 pop	 ecx
  00190	f7 f1		 div	 ecx
  00192	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00195	8b 00		 mov	 eax, DWORD PTR [eax]
  00197	8b 4d 64	 mov	 ecx, DWORD PTR __Block$[ebp]
  0019a	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0019d	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  001a0	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  001a3	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  001a6	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  001a9	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ac	89 45 ec	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  001af	8b 45 ec	 mov	 eax, DWORD PTR $T11[ebp]
  001b2	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  001b5	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  001b8	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  001bb	8b 45 e4	 mov	 eax, DWORD PTR $T9[ebp]
  001be	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  001c1	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  001c4	8b 4d dc	 mov	 ecx, DWORD PTR $T7[ebp]
  001c7	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001c9	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1117 :         _PUSH_BACK_END;

  001cb	8b 45 c4	 mov	 eax, DWORD PTR $T1[ebp]
  001ce	89 45 60	 mov	 DWORD PTR tv163[ebp], eax

; 1530 :         return _Mypair._Myval2;

  001d1	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001d4	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  001d7	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  001da	83 c0 10	 add	 eax, 16			; 00000010H
  001dd	89 45 60	 mov	 DWORD PTR tv163[ebp], eax

; 1117 :         _PUSH_BACK_END;

  001e0	8b 45 60	 mov	 eax, DWORD PTR tv163[ebp]
  001e3	8b 00		 mov	 eax, DWORD PTR [eax]
  001e5	40		 inc	 eax
  001e6	8b 4d 60	 mov	 ecx, DWORD PTR tv163[ebp]
  001e9	89 01		 mov	 DWORD PTR [ecx], eax
$LN80@Emplace_ba:

; 1118 :     }

  001eb	83 c5 74	 add	 ebp, 116		; 00000074H
  001ee	c9		 leave
  001ef	c2 04 00	 ret	 4
??$_Emplace_back_internal@ABK@?$deque@KV?$allocator@K@std@@@std@@AAEXABK@Z ENDP ; std::deque<unsigned long,std::allocator<unsigned long> >::_Emplace_back_internal<unsigned long const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@std@@V?$void_mem_fun_t@VCWindow@UI@@@2@@std@@YA?AV?$void_mem_fun_t@VCWindow@UI@@@0@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
__P$ = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
__ULast$ = -28						; size = 4
___param0$5 = -24					; size = 4
___param0$6 = -20					; size = 4
tv178 = -16						; size = 4
tv184 = -12						; size = 4
__UFirst$ = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Func$ = 20						; size = 4
??$for_each@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@std@@V?$void_mem_fun_t@VCWindow@UI@@@2@@std@@YA?AV?$void_mem_fun_t@VCWindow@UI@@@0@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@0@0V10@@Z PROC ; std::for_each<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CWindow *> > >,std::void_mem_fun_t<UI::CWindow> >, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1079 :         return nullptr;

  00006	83 65 d4 00	 and	 DWORD PTR $T2[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 271  :         return _List_unchecked_iterator<_Mylist>(this->_Ptr, static_cast<const _Mylist*>(this->_Getcont()));

  0000a	8b 45 0c	 mov	 eax, DWORD PTR __First$[ebp]
  0000d	89 45 ec	 mov	 DWORD PTR ___param0$6[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00010	8b 45 ec	 mov	 eax, DWORD PTR ___param0$6[ebp]
  00013	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1079 :         return nullptr;

  00016	83 65 d0 00	 and	 DWORD PTR $T1[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 271  :         return _List_unchecked_iterator<_Mylist>(this->_Ptr, static_cast<const _Mylist*>(this->_Getcont()));

  0001a	8b 45 10	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	89 45 e8	 mov	 DWORD PTR ___param0$5[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00020	8b 45 e8	 mov	 eax, DWORD PTR ___param0$5[ebp]
  00023	89 45 e4	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00026	eb 08		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 52   :         _Ptr = _Ptr->_Next;

  00028	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0002b	8b 00		 mov	 eax, DWORD PTR [eax]
  0002d	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:

; 74   :         return _Ptr == _Right._Ptr;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00033	3b 45 e4	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00036	75 09		 jne	 SHORT $LN55@for_each
  00038	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv184[ebp], 1
  0003f	eb 04		 jmp	 SHORT $LN56@for_each
$LN55@for_each:
  00041	83 65 f4 00	 and	 DWORD PTR tv184[ebp], 0
$LN56@for_each:
  00045	8a 45 f4	 mov	 al, BYTE PTR tv184[ebp]
  00048	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 78   :         return !(*this == _Right);

  0004b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0004f	85 c0		 test	 eax, eax
  00051	75 09		 jne	 SHORT $LN50@for_each
  00053	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv178[ebp], 1
  0005a	eb 04		 jmp	 SHORT $LN51@for_each
$LN50@for_each:
  0005c	83 65 f0 00	 and	 DWORD PTR tv178[ebp], 0
$LN51@for_each:
  00060	8a 45 f0	 mov	 al, BYTE PTR tv178[ebp]
  00063	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00066	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  0006a	85 c0		 test	 eax, eax
  0006c	74 1f		 je	 SHORT $LN3@for_each
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 44   :         return _Ptr->_Myval;

  0006e	8b 45 f8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00071	83 c0 08	 add	 eax, 8
  00074	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 100  :         return const_cast<reference>(_Mybase::operator*());

  00077	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  0007a	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 308  :         _Func(*_UFirst);

  0007d	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  00080	8b 00		 mov	 eax, DWORD PTR [eax]
  00082	89 45 d8	 mov	 DWORD PTR __P$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 41   : 		{((_P->*_Ptr)()); }

  00085	8b 4d d8	 mov	 ecx, DWORD PTR __P$[ebp]
  00088	ff 55 14	 call	 DWORD PTR __Func$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 309  :     }

  0008b	eb 9b		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  0008d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00090	8b 4d 14	 mov	 ecx, DWORD PTR __Func$[ebp]
  00093	89 08		 mov	 DWORD PTR [eax], ecx
  00095	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 312  : }

  00098	c9		 leave
  00099	c3		 ret	 0
??$for_each@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@std@@V?$void_mem_fun_t@VCWindow@UI@@@2@@std@@YA?AV?$void_mem_fun_t@VCWindow@UI@@@0@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@0@0V10@@Z ENDP ; std::for_each<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CWindow *> > >,std::void_mem_fun_t<UI::CWindow> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_9CWindow@UI@@$B3AE
_TEXT	SEGMENT
??_9CWindow@UI@@$B3AE PROC				; UI::CWindow::`vcall'{4}', COMDAT
  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 60 04	 jmp	 DWORD PTR [eax+4]
??_9CWindow@UI@@$B3AE ENDP				; UI::CWindow::`vcall'{4}'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QBEABKXZ
_TEXT	SEGMENT
__Off$ = -24						; size = 4
__Block$ = -20						; size = 4
__Off$ = -16						; size = 4
__Mycont$ = -12						; size = 4
tv89 = -8						; size = 4
_this$ = -4						; size = 4
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QBEABKXZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >::operator*, COMDAT
; _this$ = ecx

; 260  :     _NODISCARD reference operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1185 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 0c		 je	 SHORT $LN5@operator
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f8	 mov	 DWORD PTR tv89[ebp], eax
  0001b	eb 04		 jmp	 SHORT $LN6@operator
$LN5@operator:
  0001d	83 65 f8 00	 and	 DWORD PTR tv89[ebp], 0
$LN6@operator:
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv89[ebp]
  00024	89 45 f4	 mov	 DWORD PTR __Mycont$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 268  :         _Size_type _Block = _Mycont->_Getblock(_Myoff);

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002d	89 45 f0	 mov	 DWORD PTR __Off$[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  00030	8b 45 f0	 mov	 eax, DWORD PTR __Off$[ebp]
  00033	c1 e8 02	 shr	 eax, 2
  00036	8b 4d f4	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  00039	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0003c	49		 dec	 ecx
  0003d	23 c1		 and	 eax, ecx
  0003f	89 45 ec	 mov	 DWORD PTR __Block$[ebp], eax

; 269  :         _Size_type _Off   = _Myoff % _DEQUESIZ;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00048	33 d2		 xor	 edx, edx
  0004a	6a 04		 push	 4
  0004c	59		 pop	 ecx
  0004d	f7 f1		 div	 ecx
  0004f	89 55 e8	 mov	 DWORD PTR __Off$[ebp], edx

; 270  :         return _Mycont->_Map[_Block][_Off];

  00052	8b 45 f4	 mov	 eax, DWORD PTR __Mycont$[ebp]
  00055	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00058	8b 4d ec	 mov	 ecx, DWORD PTR __Block$[ebp]
  0005b	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0005e	8b 4d e8	 mov	 ecx, DWORD PTR __Off$[ebp]
  00061	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 271  :     }

  00064	c9		 leave
  00065	c3		 ret	 0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QBEABKXZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ??_GCCoolTimeFinishEffect@CSlotWindow@UI@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCCoolTimeFinishEffect@CSlotWindow@UI@@UAEPAXI@Z PROC ; UI::CSlotWindow::CCoolTimeFinishEffect::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 		{

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCoolTimeFinishEffect@CSlotWindow@UI@@6B@

; 185  : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CAniImageBox@UI@@UAE@XZ ; UI::CAniImageBox::~CAniImageBox
  00018	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	74 0f		 je	 SHORT $LN2@scalar
  00020	68 8c 00 00 00	 push	 140			; 0000008cH
  00025	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	59		 pop	 ecx
$LN2@scalar:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c9		 leave
  00033	c2 04 00	 ret	 4
??_GCCoolTimeFinishEffect@CSlotWindow@UI@@UAEPAXI@Z ENDP ; UI::CSlotWindow::CCoolTimeFinishEffect::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnEndFrame@CCoolTimeFinishEffect@CSlotWindow@UI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnEndFrame@CCoolTimeFinishEffect@CSlotWindow@UI@@UAEXXZ PROC ; UI::CSlotWindow::CCoolTimeFinishEffect::OnEndFrame, COMDAT
; _this$ = ecx

; 188  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  : 			((CSlotWindow *)m_pParent)->ReserveDestroyCoolTimeFinishEffect(m_dwSlotIndex);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff b0 88 00 00
	00		 push	 DWORD PTR [eax+136]
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00016	e8 00 00 00 00	 call	 ?ReserveDestroyCoolTimeFinishEffect@CSlotWindow@UI@@QAEXK@Z ; UI::CSlotWindow::ReserveDestroyCoolTimeFinishEffect

; 190  : 		}

  0001b	c9		 leave
  0001c	c3		 ret	 0
?OnEndFrame@CCoolTimeFinishEffect@CSlotWindow@UI@@UAEXXZ ENDP ; UI::CSlotWindow::CCoolTimeFinishEffect::OnEndFrame
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ??_GCCoverButton@CSlotWindow@UI@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCCoverButton@CSlotWindow@UI@@UAEPAXI@Z PROC		; UI::CSlotWindow::CCoverButton::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 97   : 		{

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCoverButton@CSlotWindow@UI@@6B@

; 28   : 		{

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSlotButton@CSlotWindow@UI@@6B@

; 29   : 		}

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??1CButton@UI@@UAE@XZ	; UI::CButton::~CButton
  00021	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00024	83 e0 01	 and	 eax, 1
  00027	74 0f		 je	 SHORT $LN2@scalar
  00029	68 1c 01 00 00	 push	 284			; 0000011cH
  0002e	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx
$LN2@scalar:
  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	c9		 leave
  0003c	c2 04 00	 ret	 4
??_GCCoverButton@CSlotWindow@UI@@UAEPAXI@Z ENDP		; UI::CSlotWindow::CCoverButton::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseRightButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseRightButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ PROC ; UI::CSlotWindow::CCoverButton::OnMouseRightButtonUp, COMDAT
; _this$ = ecx

; 157  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 158  : 			if (!IsEnable())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsEnable@CButton@UI@@IAEHXZ ; UI::CButton::IsEnable
  0000f	85 c0		 test	 eax, eax
  00011	75 05		 jne	 SHORT $LN2@OnMouseRig

; 159  : 				return TRUE;

  00013	33 c0		 xor	 eax, eax
  00015	40		 inc	 eax
  00016	eb 2e		 jmp	 SHORT $LN1@OnMouseRig
$LN2@OnMouseRig:

; 160  : 			m_pParent->OnMouseRightButtonDown();

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 80 10 01 00
	00		 mov	 eax, DWORD PTR [eax+272]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	8b 89 10 01 00
	00		 mov	 ecx, DWORD PTR [ecx+272]
  0002c	ff 50 64	 call	 DWORD PTR [eax+100]

; 161  : 			if (m_bRightButtonEnable)

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 b8 18 01 00
	00 00		 cmp	 DWORD PTR [eax+280], 0
  00039	74 08		 je	 SHORT $LN3@OnMouseRig

; 162  : 				CButton::OnMouseLeftButtonUp();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?OnMouseLeftButtonUp@CButton@UI@@MAEHXZ ; UI::CButton::OnMouseLeftButtonUp
$LN3@OnMouseRig:

; 163  : 			return TRUE;

  00043	33 c0		 xor	 eax, eax
  00045	40		 inc	 eax
$LN1@OnMouseRig:

; 164  : 		}

  00046	c9		 leave
  00047	c3		 ret	 0
?OnMouseRightButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ ENDP ; UI::CSlotWindow::CCoverButton::OnMouseRightButtonUp
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseRightButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseRightButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ PROC ; UI::CSlotWindow::CCoverButton::OnMouseRightButtonDown, COMDAT
; _this$ = ecx

; 149  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 150  : 			if (!IsEnable())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsEnable@CButton@UI@@IAEHXZ ; UI::CButton::IsEnable
  0000f	85 c0		 test	 eax, eax
  00011	75 05		 jne	 SHORT $LN2@OnMouseRig

; 151  : 				return TRUE;

  00013	33 c0		 xor	 eax, eax
  00015	40		 inc	 eax
  00016	eb 17		 jmp	 SHORT $LN1@OnMouseRig
$LN2@OnMouseRig:

; 152  : 			if (m_bRightButtonEnable)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 b8 18 01 00
	00 00		 cmp	 DWORD PTR [eax+280], 0
  00022	74 08		 je	 SHORT $LN3@OnMouseRig

; 153  : 				CButton::OnMouseLeftButtonDown();

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?OnMouseLeftButtonDown@CButton@UI@@MAEHXZ ; UI::CButton::OnMouseLeftButtonDown
$LN3@OnMouseRig:

; 154  : 			return TRUE;

  0002c	33 c0		 xor	 eax, eax
  0002e	40		 inc	 eax
$LN1@OnMouseRig:

; 155  : 		}

  0002f	c9		 leave
  00030	c3		 ret	 0
?OnMouseRightButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ ENDP ; UI::CSlotWindow::CCoverButton::OnMouseRightButtonDown
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseLeftButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseLeftButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ PROC ; UI::CSlotWindow::CCoverButton::OnMouseLeftButtonUp, COMDAT
; _this$ = ecx

; 133  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 134  : 			if (!IsEnable())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsEnable@CButton@UI@@IAEHXZ ; UI::CButton::IsEnable
  0000f	85 c0		 test	 eax, eax
  00011	75 05		 jne	 SHORT $LN2@OnMouseLef

; 135  : 				return TRUE;

  00013	33 c0		 xor	 eax, eax
  00015	40		 inc	 eax
  00016	eb 47		 jmp	 SHORT $LN1@OnMouseLef
$LN2@OnMouseLef:

; 136  : 			if (m_bLeftButtonEnable)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 b8 14 01 00
	00 00		 cmp	 DWORD PTR [eax+276], 0
  00022	74 21		 je	 SHORT $LN3@OnMouseLef

; 137  : 			{
; 138  : 				CButton::OnMouseLeftButtonUp();

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?OnMouseLeftButtonUp@CButton@UI@@MAEHXZ ; UI::CButton::OnMouseLeftButtonUp

; 139  : 				m_pParent->OnMouseLeftButtonDown();

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 80 10 01 00
	00		 mov	 eax, DWORD PTR [eax+272]
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	8b 00		 mov	 eax, DWORD PTR [eax]
  0003a	8b 89 10 01 00
	00		 mov	 ecx, DWORD PTR [ecx+272]
  00040	ff 50 58	 call	 DWORD PTR [eax+88]

; 140  : 			}

  00043	eb 17		 jmp	 SHORT $LN4@OnMouseLef
$LN3@OnMouseLef:

; 141  : 			else
; 142  : 			{
; 143  : 				m_pParent->OnMouseLeftButtonUp();

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 80 10 01 00
	00		 mov	 eax, DWORD PTR [eax+272]
  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b 89 10 01 00
	00		 mov	 ecx, DWORD PTR [ecx+272]
  00059	ff 50 5c	 call	 DWORD PTR [eax+92]
$LN4@OnMouseLef:

; 144  : 			}
; 145  : 			return TRUE;

  0005c	33 c0		 xor	 eax, eax
  0005e	40		 inc	 eax
$LN1@OnMouseLef:

; 146  : 		}

  0005f	c9		 leave
  00060	c3		 ret	 0
?OnMouseLeftButtonUp@CCoverButton@CSlotWindow@UI@@UAEHXZ ENDP ; UI::CSlotWindow::CCoverButton::OnMouseLeftButtonUp
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseLeftButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseLeftButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ PROC ; UI::CSlotWindow::CCoverButton::OnMouseLeftButtonDown, COMDAT
; _this$ = ecx

; 119  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 120  : 			if (!IsEnable())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsEnable@CButton@UI@@IAEHXZ ; UI::CButton::IsEnable
  0000f	85 c0		 test	 eax, eax
  00011	75 05		 jne	 SHORT $LN2@OnMouseLef

; 121  : 				return TRUE;

  00013	33 c0		 xor	 eax, eax
  00015	40		 inc	 eax
  00016	eb 30		 jmp	 SHORT $LN1@OnMouseLef
$LN2@OnMouseLef:

; 122  : 			if (m_bLeftButtonEnable)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 b8 14 01 00
	00 00		 cmp	 DWORD PTR [eax+276], 0
  00022	74 0a		 je	 SHORT $LN3@OnMouseLef

; 123  : 			{
; 124  : 				CButton::OnMouseLeftButtonDown();

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?OnMouseLeftButtonDown@CButton@UI@@MAEHXZ ; UI::CButton::OnMouseLeftButtonDown

; 125  : 			}

  0002c	eb 17		 jmp	 SHORT $LN4@OnMouseLef
$LN3@OnMouseLef:

; 126  : 			else
; 127  : 			{
; 128  : 				m_pParent->OnMouseLeftButtonDown();

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 80 10 01 00
	00		 mov	 eax, DWORD PTR [eax+272]
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	8b 89 10 01 00
	00		 mov	 ecx, DWORD PTR [ecx+272]
  00042	ff 50 58	 call	 DWORD PTR [eax+88]
$LN4@OnMouseLef:

; 129  : 			}
; 130  : 			return TRUE;

  00045	33 c0		 xor	 eax, eax
  00047	40		 inc	 eax
$LN1@OnMouseLef:

; 131  : 		}

  00048	c9		 leave
  00049	c3		 ret	 0
?OnMouseLeftButtonDown@CCoverButton@CSlotWindow@UI@@UAEHXZ ENDP ; UI::CSlotWindow::CCoverButton::OnMouseLeftButtonDown
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnRender@CCoverButton@CSlotWindow@UI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnRender@CCoverButton@CSlotWindow@UI@@UAEXXZ PROC	; UI::CSlotWindow::CCoverButton::OnRender, COMDAT
; _this$ = ecx

; 110  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : 		}

  00007	c9		 leave
  00008	c3		 ret	 0
?OnRender@CCoverButton@CSlotWindow@UI@@UAEXXZ ENDP	; UI::CSlotWindow::CCoverButton::OnRender
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ??_GCSlotButton@CSlotWindow@UI@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCSlotButton@CSlotWindow@UI@@UAEPAXI@Z PROC		; UI::CSlotWindow::CSlotButton::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : 		{

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSlotButton@CSlotWindow@UI@@6B@

; 29   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CButton@UI@@UAE@XZ	; UI::CButton::~CButton
  00018	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001b	83 e0 01	 and	 eax, 1
  0001e	74 0f		 je	 SHORT $LN2@scalar
  00020	68 14 01 00 00	 push	 276			; 00000114H
  00025	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002d	59		 pop	 ecx
  0002e	59		 pop	 ecx
$LN2@scalar:
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c9		 leave
  00033	c2 04 00	 ret	 4
??_GCSlotButton@CSlotWindow@UI@@UAEPAXI@Z ENDP		; UI::CSlotWindow::CSlotButton::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseOverOut@CSlotButton@CSlotWindow@UI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseOverOut@CSlotButton@CSlotWindow@UI@@UAEXXZ PROC	; UI::CSlotWindow::CSlotButton::OnMouseOverOut, COMDAT
; _this$ = ecx

; 69   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 70   : 			if (IsEnable())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsEnable@CButton@UI@@IAEHXZ ; UI::CButton::IsEnable
  0000f	85 c0		 test	 eax, eax
  00011	74 19		 je	 SHORT $LN2@OnMouseOve

; 71   : 			{
; 72   : 				SetUp();

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?SetUp@CButton@UI@@QAEXXZ ; UI::CButton::SetUp

; 73   : 				SetCurrentVisual(&m_upVisual);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00023	50		 push	 eax
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?SetCurrentVisual@CButton@UI@@IAEXPAVCGraphicImageInstance@@@Z ; UI::CButton::SetCurrentVisual
$LN2@OnMouseOve:

; 74   : 			}
; 75   : 			m_pParent->OnOverOutItem();

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 88 10 01 00
	00		 mov	 ecx, DWORD PTR [eax+272]
  00035	e8 00 00 00 00	 call	 ?OnOverOutItem@CSlotWindow@UI@@QAEXXZ ; UI::CSlotWindow::OnOverOutItem

; 76   : 		}

  0003a	c9		 leave
  0003b	c3		 ret	 0
?OnMouseOverOut@CSlotButton@CSlotWindow@UI@@UAEXXZ ENDP	; UI::CSlotWindow::CSlotButton::OnMouseOverOut
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseOverIn@CSlotButton@CSlotWindow@UI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseOverIn@CSlotButton@CSlotWindow@UI@@UAEXXZ PROC	; UI::CSlotWindow::CSlotButton::OnMouseOverIn, COMDAT
; _this$ = ecx

; 61   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 62   : 			if (IsEnable())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsEnable@CButton@UI@@IAEHXZ ; UI::CButton::IsEnable
  0000f	85 c0		 test	 eax, eax
  00011	74 11		 je	 SHORT $LN2@OnMouseOve

; 63   : 			{
; 64   : 				SetCurrentVisual(&m_overVisual);

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?SetCurrentVisual@CButton@UI@@IAEXPAVCGraphicImageInstance@@@Z ; UI::CButton::SetCurrentVisual
$LN2@OnMouseOve:

; 65   : 			}
; 66   : 			m_pParent->OnOverInItem(m_dwSlotNumber);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	ff b0 0c 01 00
	00		 push	 DWORD PTR [eax+268]
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 88 10 01 00
	00		 mov	 ecx, DWORD PTR [eax+272]
  00036	e8 00 00 00 00	 call	 ?OnOverInItem@CSlotWindow@UI@@QAEHK@Z ; UI::CSlotWindow::OnOverInItem

; 67   : 		}

  0003b	c9		 leave
  0003c	c3		 ret	 0
?OnMouseOverIn@CSlotButton@CSlotWindow@UI@@UAEXXZ ENDP	; UI::CSlotWindow::CSlotButton::OnMouseOverIn
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseLeftButtonUp@CSlotButton@CSlotWindow@UI@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseLeftButtonUp@CSlotButton@CSlotWindow@UI@@UAEHXZ PROC ; UI::CSlotWindow::CSlotButton::OnMouseLeftButtonUp, COMDAT
; _this$ = ecx

; 44   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 			if (!IsEnable())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsEnable@CButton@UI@@IAEHXZ ; UI::CButton::IsEnable
  0000f	85 c0		 test	 eax, eax
  00011	75 05		 jne	 SHORT $LN2@OnMouseLef

; 46   : 				return TRUE;

  00013	33 c0		 xor	 eax, eax
  00015	40		 inc	 eax
  00016	eb 69		 jmp	 SHORT $LN1@OnMouseLef
$LN2@OnMouseLef:

; 47   : 			if (!IsPressed())

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?IsPressed@CButton@UI@@QAEHXZ ; UI::CButton::IsPressed
  00020	85 c0		 test	 eax, eax
  00022	75 05		 jne	 SHORT $LN3@OnMouseLef

; 48   : 				return TRUE;

  00024	33 c0		 xor	 eax, eax
  00026	40		 inc	 eax
  00027	eb 58		 jmp	 SHORT $LN1@OnMouseLef
$LN3@OnMouseLef:

; 49   : 
; 50   : 			if (IsIn())

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?IsIn@CWindow@UI@@QAE_NXZ ; UI::CWindow::IsIn
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	74 13		 je	 SHORT $LN4@OnMouseLef

; 51   : 				SetCurrentVisual(&m_overVisual);

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  00040	50		 push	 eax
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?SetCurrentVisual@CButton@UI@@IAEXPAVCGraphicImageInstance@@@Z ; UI::CButton::SetCurrentVisual
  00049	eb 11		 jmp	 SHORT $LN5@OnMouseLef
$LN4@OnMouseLef:

; 52   : 			else
; 53   : 				SetCurrentVisual(&m_upVisual);

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00053	50		 push	 eax
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?SetCurrentVisual@CButton@UI@@IAEXPAVCGraphicImageInstance@@@Z ; UI::CButton::SetCurrentVisual
$LN5@OnMouseLef:

; 54   : 
; 55   : 			m_pParent->OnPressedSlotButton(m_dwSlotButtonType, m_dwSlotNumber);

  0005c	6a 01		 push	 1
  0005e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00061	ff b0 0c 01 00
	00		 push	 DWORD PTR [eax+268]
  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006a	ff b0 08 01 00
	00		 push	 DWORD PTR [eax+264]
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 88 10 01 00
	00		 mov	 ecx, DWORD PTR [eax+272]
  00079	e8 00 00 00 00	 call	 ?OnPressedSlotButton@CSlotWindow@UI@@QAEXKKH@Z ; UI::CSlotWindow::OnPressedSlotButton

; 56   : 
; 57   : 			return TRUE;

  0007e	33 c0		 xor	 eax, eax
  00080	40		 inc	 eax
$LN1@OnMouseLef:

; 58   : 		}

  00081	c9		 leave
  00082	c3		 ret	 0
?OnMouseLeftButtonUp@CSlotButton@CSlotWindow@UI@@UAEHXZ ENDP ; UI::CSlotWindow::CSlotButton::OnMouseLeftButtonUp
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseLeftButtonDown@CSlotButton@CSlotWindow@UI@@UAEHXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?OnMouseLeftButtonDown@CSlotButton@CSlotWindow@UI@@UAEHXZ PROC ; UI::CSlotWindow::CSlotButton::OnMouseLeftButtonDown, COMDAT
; _this$ = ecx

; 32   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 33   : 			if (!IsEnable())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?IsEnable@CButton@UI@@IAEHXZ ; UI::CButton::IsEnable
  00010	85 c0		 test	 eax, eax
  00012	75 05		 jne	 SHORT $LN2@OnMouseLef

; 34   : 				return TRUE;

  00014	33 c0		 xor	 eax, eax
  00016	40		 inc	 eax
  00017	eb 2e		 jmp	 SHORT $LN1@OnMouseLef
$LN2@OnMouseLef:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0001e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 35   : 			if (UI::CWindowManager::Instance().IsAttaching())

  00021	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00024	e8 00 00 00 00	 call	 ?IsAttaching@CWindowManager@UI@@QAEHXZ ; UI::CWindowManager::IsAttaching
  00029	85 c0		 test	 eax, eax
  0002b	74 05		 je	 SHORT $LN3@OnMouseLef

; 36   : 				return TRUE;

  0002d	33 c0		 xor	 eax, eax
  0002f	40		 inc	 eax
  00030	eb 15		 jmp	 SHORT $LN1@OnMouseLef
$LN3@OnMouseLef:

; 37   : 
; 38   : 			m_isPressed = TRUE;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c7 40 7c 01 00
	00 00		 mov	 DWORD PTR [eax+124], 1

; 39   : 			Down();

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?Down@CButton@UI@@QAEXXZ ; UI::CButton::Down

; 40   : 
; 41   : 			return TRUE;

  00044	33 c0		 xor	 eax, eax
  00046	40		 inc	 eax
$LN1@OnMouseLef:

; 42   : 		}

  00047	c9		 leave
  00048	c3		 ret	 0
?OnMouseLeftButtonDown@CSlotButton@CSlotWindow@UI@@UAEHXZ ENDP ; UI::CSlotWindow::CSlotButton::OnMouseLeftButtonDown
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCSlotWindow@UI@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCSlotWindow@UI@@UAEPAXI@Z PROC			; UI::CSlotWindow::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CSlotWindow@UI@@UAE@XZ ; UI::CSlotWindow::~CSlotWindow
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 bc 00 00 00	 push	 188			; 000000bcH
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCSlotWindow@UI@@UAEPAXI@Z ENDP			; UI::CSlotWindow::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Deque_val<std::_Deque_simple_types<unsigned long> >, COMDAT
; _this$ = ecx

; 544  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1097 :     _Container_base12() noexcept : _Myproxy(nullptr) {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 544  :     _Deque_val() noexcept : _Map(), _Mapsize(0), _Myoff(0), _Mysize(0) {}

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c9		 leave
  0002d	c3		 ret	 0
??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Deque_val<std::_Deque_simple_types<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Tidy@?$deque@KV?$allocator@K@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
$T3 = -120						; size = 4
$T4 = -116						; size = 4
$T5 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
__Ptr$ = -100						; size = 4
__Count$ = -96						; size = 4
$T8 = -92						; size = 4
$T9 = -88						; size = 4
$T10 = -84						; size = 4
$T11 = -80						; size = 4
$T12 = -76						; size = 4
$T13 = -72						; size = 4
$T14 = -68						; size = 4
$T15 = -64						; size = 4
__Ptr$ = -60						; size = 4
$T16 = -56						; size = 4
$T17 = -52						; size = 4
$T18 = -48						; size = 4
$T19 = -44						; size = 4
$T20 = -40						; size = 4
$T21 = -36						; size = 4
$T22 = -32						; size = 4
$T23 = -28						; size = 4
$T24 = -24						; size = 4
$T25 = -20						; size = 4
tv149 = -16						; size = 4
__Block$26 = -12					; size = 4
_this$ = -8						; size = 4
$T27 = -1						; size = 1
?_Tidy@?$deque@KV?$allocator@K@std@@@std@@AAEXXZ PROC	; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1469 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00009	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	89 45 88	 mov	 DWORD PTR $T3[ebp], eax

; 1522 :         return _Mypair._Get_first();

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00015	89 45 ec	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00018	8b 45 ec	 mov	 eax, DWORD PTR $T25[ebp]
  0001b	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
$LN2@Tidy:

; 1534 :         return _Mypair._Myval2;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	89 45 e8	 mov	 DWORD PTR $T24[ebp], eax

; 1566 :         return _Get_data()._Mysize;

  00024	8b 45 e8	 mov	 eax, DWORD PTR $T24[ebp]
  00027	83 c0 10	 add	 eax, 16			; 00000010H
  0002a	89 45 e4	 mov	 DWORD PTR $T23[ebp], eax

; 1010 :         return _Mysize() == 0;

  0002d	8b 45 e4	 mov	 eax, DWORD PTR $T23[ebp]
  00030	83 38 00	 cmp	 DWORD PTR [eax], 0
  00033	75 09		 jne	 SHORT $LN30@Tidy
  00035	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv149[ebp], 1
  0003c	eb 04		 jmp	 SHORT $LN31@Tidy
$LN30@Tidy:
  0003e	83 65 f0 00	 and	 DWORD PTR tv149[ebp], 0
$LN31@Tidy:
  00042	8a 45 f0	 mov	 al, BYTE PTR tv149[ebp]
  00045	88 45 ff	 mov	 BYTE PTR $T27[ebp], al

; 1470 :         _Orphan_all();
; 1471 : 
; 1472 :         _Alpty _Almap(_Getal());
; 1473 :         while (!empty()) {

  00048	0f b6 45 ff	 movzx	 eax, BYTE PTR $T27[ebp]
  0004c	85 c0		 test	 eax, eax
  0004e	75 0a		 jne	 SHORT $LN3@Tidy

; 1474 :             pop_back();

  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::pop_back

; 1475 :         }

  00058	eb c4		 jmp	 SHORT $LN2@Tidy
$LN3@Tidy:

; 1530 :         return _Mypair._Myval2;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	89 45 e0	 mov	 DWORD PTR $T22[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T22[ebp]
  00063	83 c0 08	 add	 eax, 8
  00066	89 45 dc	 mov	 DWORD PTR $T21[ebp], eax

; 1476 : 
; 1477 :         for (size_type _Block = _Mapsize(); 0 < _Block;) { // free storage for a block and destroy pointer

  00069	8b 45 dc	 mov	 eax, DWORD PTR $T21[ebp]
  0006c	8b 00		 mov	 eax, DWORD PTR [eax]
  0006e	89 45 f4	 mov	 DWORD PTR __Block$26[ebp], eax
$LN6@Tidy:
  00071	83 7d f4 00	 cmp	 DWORD PTR __Block$26[ebp], 0
  00075	0f 86 84 00 00
	00		 jbe	 $LN5@Tidy

; 1478 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  0007b	8b 45 f4	 mov	 eax, DWORD PTR __Block$26[ebp]
  0007e	48		 dec	 eax
  0007f	89 45 f4	 mov	 DWORD PTR __Block$26[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00085	89 45 d8	 mov	 DWORD PTR $T20[ebp], eax

; 1538 :         return _Get_data()._Map;

  00088	8b 45 d8	 mov	 eax, DWORD PTR $T20[ebp]
  0008b	83 c0 04	 add	 eax, 4
  0008e	89 45 d4	 mov	 DWORD PTR $T19[ebp], eax

; 1478 :             if (_Map()[--_Block]) { // free block and destroy its pointer

  00091	8b 45 d4	 mov	 eax, DWORD PTR $T19[ebp]
  00094	8b 00		 mov	 eax, DWORD PTR [eax]
  00096	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  00099	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  0009d	74 5b		 je	 SHORT $LN7@Tidy

; 1530 :         return _Mypair._Myval2;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	89 45 d0	 mov	 DWORD PTR $T18[ebp], eax

; 1538 :         return _Get_data()._Map;

  000a5	8b 45 d0	 mov	 eax, DWORD PTR $T18[ebp]
  000a8	83 c0 04	 add	 eax, 4
  000ab	89 45 c8	 mov	 DWORD PTR $T16[ebp], eax

; 1522 :         return _Mypair._Get_first();

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b1	89 45 cc	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  000b4	8b 45 cc	 mov	 eax, DWORD PTR $T17[ebp]
  000b7	89 45 80	 mov	 DWORD PTR $T1[ebp], eax

; 1479 :                 _Getal().deallocate(_Map()[_Block], _DEQUESIZ);

  000ba	8b 45 c8	 mov	 eax, DWORD PTR $T16[ebp]
  000bd	8b 00		 mov	 eax, DWORD PTR [eax]
  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  000c2	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  000c5	89 45 c4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000c8	6a 04		 push	 4
  000ca	58		 pop	 eax
  000cb	c1 e0 02	 shl	 eax, 2
  000ce	50		 push	 eax
  000cf	ff 75 c4	 push	 DWORD PTR __Ptr$[ebp]
  000d2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000d7	59		 pop	 ecx
  000d8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  000d9	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	89 45 c0	 mov	 DWORD PTR $T15[ebp], eax

; 1538 :         return _Get_data()._Map;

  000df	8b 45 c0	 mov	 eax, DWORD PTR $T15[ebp]
  000e2	83 c0 04	 add	 eax, 4
  000e5	89 45 bc	 mov	 DWORD PTR $T14[ebp], eax

; 1480 :                 _Destroy_in_place(_Map()[_Block]);

  000e8	8b 45 bc	 mov	 eax, DWORD PTR $T14[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR __Block$26[ebp]
  000f0	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAK@std@@YAXAAPAK@Z ; std::_Destroy_in_place<unsigned long *>
  000f9	59		 pop	 ecx
$LN7@Tidy:

; 1481 :             }
; 1482 :         }

  000fa	e9 72 ff ff ff	 jmp	 $LN6@Tidy
$LN5@Tidy:

; 1530 :         return _Mypair._Myval2;

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00102	89 45 b8	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  00105	8b 45 b8	 mov	 eax, DWORD PTR $T13[ebp]
  00108	83 c0 04	 add	 eax, 4
  0010b	89 45 b4	 mov	 DWORD PTR $T12[ebp], eax

; 1483 : 
; 1484 :         if (_Map() != _Mapptr()) {

  0010e	8b 45 b4	 mov	 eax, DWORD PTR $T12[ebp]
  00111	83 38 00	 cmp	 DWORD PTR [eax], 0
  00114	74 3f		 je	 SHORT $LN8@Tidy

; 1530 :         return _Mypair._Myval2;

  00116	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00119	89 45 b0	 mov	 DWORD PTR $T11[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0011c	8b 45 b0	 mov	 eax, DWORD PTR $T11[ebp]
  0011f	83 c0 08	 add	 eax, 8
  00122	89 45 a8	 mov	 DWORD PTR $T9[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00128	89 45 ac	 mov	 DWORD PTR $T10[ebp], eax

; 1538 :         return _Get_data()._Map;

  0012b	8b 45 ac	 mov	 eax, DWORD PTR $T10[ebp]
  0012e	83 c0 04	 add	 eax, 4
  00131	89 45 a4	 mov	 DWORD PTR $T8[ebp], eax

; 1485 :             _Almap.deallocate(_Map(), _Mapsize()); // free storage for map

  00134	8b 45 a8	 mov	 eax, DWORD PTR $T9[ebp]
  00137	8b 00		 mov	 eax, DWORD PTR [eax]
  00139	89 45 a0	 mov	 DWORD PTR __Count$[ebp], eax
  0013c	8b 45 a4	 mov	 eax, DWORD PTR $T8[ebp]
  0013f	8b 00		 mov	 eax, DWORD PTR [eax]
  00141	89 45 9c	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00144	8b 45 a0	 mov	 eax, DWORD PTR __Count$[ebp]
  00147	c1 e0 02	 shl	 eax, 2
  0014a	50		 push	 eax
  0014b	ff 75 9c	 push	 DWORD PTR __Ptr$[ebp]
  0014e	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00153	59		 pop	 ecx
  00154	59		 pop	 ecx
$LN8@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00155	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00158	89 45 98	 mov	 DWORD PTR $T7[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0015b	8b 45 98	 mov	 eax, DWORD PTR $T7[ebp]
  0015e	83 c0 08	 add	 eax, 8
  00161	89 45 94	 mov	 DWORD PTR $T6[ebp], eax

; 1486 :         }
; 1487 : 
; 1488 :         _Mapsize() = 0;

  00164	8b 45 94	 mov	 eax, DWORD PTR $T6[ebp]
  00167	83 20 00	 and	 DWORD PTR [eax], 0

; 1530 :         return _Mypair._Myval2;

  0016a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	89 45 90	 mov	 DWORD PTR $T5[ebp], eax

; 1538 :         return _Get_data()._Map;

  00170	8b 45 90	 mov	 eax, DWORD PTR $T5[ebp]
  00173	83 c0 04	 add	 eax, 4
  00176	89 45 8c	 mov	 DWORD PTR $T4[ebp], eax

; 1489 :         _Map()     = _Mapptr();

  00179	8b 45 8c	 mov	 eax, DWORD PTR $T4[ebp]
  0017c	83 20 00	 and	 DWORD PTR [eax], 0

; 1490 :     }

  0017f	c9		 leave
  00180	c3		 ret	 0
?_Tidy@?$deque@KV?$allocator@K@std@@@std@@AAEXXZ ENDP	; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Growmap@?$deque@KV?$allocator@K@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
$T1 = -164						; size = 4
__Max_possible$2 = -160					; size = 4
$T3 = -156						; size = 4
$T4 = -152						; size = 4
$T5 = -148						; size = 4
$T6 = -144						; size = 4
$T7 = -140						; size = 4
__Ptr$ = -136						; size = 4
__Count$ = -132						; size = 4
$T8 = -128						; size = 4
$T9 = -124						; size = 4
$T10 = -120						; size = 4
$T11 = -116						; size = 4
$T12 = -112						; size = 4
$T13 = -108						; size = 4
$T14 = -104						; size = 4
$T15 = -100						; size = 4
$T16 = -96						; size = 4
$T17 = -92						; size = 4
$T18 = -88						; size = 4
$T19 = -84						; size = 4
$T20 = -80						; size = 4
$T21 = -76						; size = 4
$T22 = -72						; size = 4
$T23 = -68						; size = 4
$T24 = -64						; size = 4
$T25 = -60						; size = 4
$T26 = -56						; size = 4
$T27 = -52						; size = 4
$T28 = -48						; size = 4
$T29 = -44						; size = 4
$T30 = -40						; size = 4
$T31 = -36						; size = 4
$T32 = -32						; size = 4
$T33 = -28						; size = 4
$T34 = -24						; size = 4
$T35 = -20						; size = 4
$T36 = -16						; size = 4
$T37 = -12						; size = 4
$T38 = -8						; size = 4
$T39 = -4						; size = 4
$T40 = 0						; size = 4
$T41 = 4						; size = 4
$T42 = 8						; size = 4
$T43 = 12						; size = 4
$T44 = 16						; size = 4
$T45 = 20						; size = 4
$T46 = 24						; size = 4
$T47 = 28						; size = 4
$T48 = 32						; size = 4
$T49 = 36						; size = 4
$T50 = 40						; size = 4
$T51 = 44						; size = 4
$T52 = 48						; size = 4
$T53 = 52						; size = 4
$T54 = 56						; size = 4
$T55 = 60						; size = 4
$T56 = 64						; size = 4
__Count$ = 68						; size = 4
tv232 = 72						; size = 4
$T57 = 76						; size = 4
$T58 = 80						; size = 4
tv73 = 84						; size = 4
tv214 = 88						; size = 4
__Overflow_is_possible$59 = 95				; size = 1
__Newmap$ = 96						; size = 4
__Newsize$ = 100					; size = 4
__Myboff$ = 104						; size = 4
__Myptr$ = 108						; size = 4
_this$ = 112						; size = 4
__Count$ = 124						; size = 4
?_Growmap@?$deque@KV?$allocator@K@std@@@std@@AAEXI@Z PROC ; std::deque<unsigned long,std::allocator<unsigned long> >::_Growmap, COMDAT
; _this$ = ecx

; 1430 :     void _Growmap(size_type _Count) { // grow map by at least _Count pointers, _Mapsize() a power of 2

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 1522 :         return _Mypair._Get_first();

  0000e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00011	89 45 40	 mov	 DWORD PTR $T56[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00014	8b 45 40	 mov	 eax, DWORD PTR $T56[ebp]
  00017	89 85 68 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0001d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 3c	 mov	 DWORD PTR $T55[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00023	8b 45 3c	 mov	 eax, DWORD PTR $T55[ebp]
  00026	83 c0 08	 add	 eax, 8
  00029	89 45 38	 mov	 DWORD PTR $T54[ebp], eax

; 1431 :         static_assert(1 < _DEQUEMAPSIZ, "The _Xlen() test should always be performed.");
; 1432 : 
; 1433 :         _Alpty _Almap(_Getal());
; 1434 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  0002c	8b 45 38	 mov	 eax, DWORD PTR $T54[ebp]
  0002f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00032	76 19		 jbe	 SHORT $LN10@Growmap

; 1530 :         return _Mypair._Myval2;

  00034	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00037	89 45 34	 mov	 DWORD PTR $T53[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0003a	8b 45 34	 mov	 eax, DWORD PTR $T53[ebp]
  0003d	83 c0 08	 add	 eax, 8
  00040	89 45 30	 mov	 DWORD PTR $T52[ebp], eax

; 1431 :         static_assert(1 < _DEQUEMAPSIZ, "The _Xlen() test should always be performed.");
; 1432 : 
; 1433 :         _Alpty _Almap(_Getal());
; 1434 :         size_type _Newsize = 0 < _Mapsize() ? _Mapsize() : 1;

  00043	8b 45 30	 mov	 eax, DWORD PTR $T52[ebp]
  00046	8b 00		 mov	 eax, DWORD PTR [eax]
  00048	89 45 54	 mov	 DWORD PTR tv73[ebp], eax
  0004b	eb 07		 jmp	 SHORT $LN11@Growmap
$LN10@Growmap:
  0004d	c7 45 54 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
$LN11@Growmap:
  00054	8b 45 54	 mov	 eax, DWORD PTR tv73[ebp]
  00057	89 45 64	 mov	 DWORD PTR __Newsize$[ebp], eax
$LN2@Growmap:

; 1530 :         return _Mypair._Myval2;

  0005a	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	89 45 2c	 mov	 DWORD PTR $T51[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00060	8b 45 2c	 mov	 eax, DWORD PTR $T51[ebp]
  00063	83 c0 08	 add	 eax, 8
  00066	89 45 28	 mov	 DWORD PTR $T50[ebp], eax

; 1435 :         while (_Newsize - _Mapsize() < _Count || _Newsize < _DEQUEMAPSIZ) {

  00069	8b 45 28	 mov	 eax, DWORD PTR $T50[ebp]
  0006c	8b 4d 64	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  0006f	2b 08		 sub	 ecx, DWORD PTR [eax]
  00071	3b 4d 7c	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00074	72 06		 jb	 SHORT $LN4@Growmap
  00076	83 7d 64 08	 cmp	 DWORD PTR __Newsize$[ebp], 8
  0007a	73 70		 jae	 SHORT $LN3@Growmap
$LN4@Growmap:

; 1526 :         return _Mypair._Get_first();

  0007c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007f	89 45 24	 mov	 DWORD PTR $T49[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1526 :         return _Mypair._Get_first();

  00082	8b 45 24	 mov	 eax, DWORD PTR $T49[ebp]
  00085	89 85 64 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0008b	c7 45 50 ff ff
	ff 3f		 mov	 DWORD PTR $T58[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00092	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T48[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1005 :         return (_STD min)(

  00099	8b 45 20	 mov	 eax, DWORD PTR $T48[ebp]
  0009c	89 45 4c	 mov	 DWORD PTR $T57[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009f	8b 45 50	 mov	 eax, DWORD PTR $T58[ebp]
  000a2	3b 45 4c	 cmp	 eax, DWORD PTR $T57[ebp]
  000a5	73 08		 jae	 SHORT $LN56@Growmap
  000a7	8d 45 50	 lea	 eax, DWORD PTR $T58[ebp]
  000aa	89 45 48	 mov	 DWORD PTR tv232[ebp], eax
  000ad	eb 06		 jmp	 SHORT $LN57@Growmap
$LN56@Growmap:
  000af	8d 45 4c	 lea	 eax, DWORD PTR $T57[ebp]
  000b2	89 45 48	 mov	 DWORD PTR tv232[ebp], eax
$LN57@Growmap:
  000b5	8b 45 48	 mov	 eax, DWORD PTR tv232[ebp]
  000b8	89 45 1c	 mov	 DWORD PTR $T47[ebp], eax
  000bb	8b 45 1c	 mov	 eax, DWORD PTR $T47[ebp]
  000be	89 45 18	 mov	 DWORD PTR $T46[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1005 :         return (_STD min)(

  000c1	8b 45 18	 mov	 eax, DWORD PTR $T46[ebp]
  000c4	8b 00		 mov	 eax, DWORD PTR [eax]
  000c6	89 45 14	 mov	 DWORD PTR $T45[ebp], eax

; 1436 :             // scale _Newsize to 2^N >= _Mapsize() + _Count
; 1437 :             if (max_size() / _DEQUESIZ - _Newsize < _Newsize) {

  000c9	8b 45 14	 mov	 eax, DWORD PTR $T45[ebp]
  000cc	c1 e8 02	 shr	 eax, 2
  000cf	2b 45 64	 sub	 eax, DWORD PTR __Newsize$[ebp]
  000d2	3b 45 64	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  000d5	73 08		 jae	 SHORT $LN5@Growmap

; 1438 :                 _Xlen(); // result too long

  000d7	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  000da	e8 00 00 00 00	 call	 ?_Xlen@?$deque@KV?$allocator@K@std@@@std@@ABEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Xlen
$LN5@Growmap:

; 1439 :             }
; 1440 : 
; 1441 :             _Newsize *= 2;

  000df	8b 45 64	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000e2	d1 e0		 shl	 eax, 1
  000e4	89 45 64	 mov	 DWORD PTR __Newsize$[ebp], eax

; 1442 :         }

  000e7	e9 6e ff ff ff	 jmp	 $LN2@Growmap
$LN3@Growmap:

; 1530 :         return _Mypair._Myval2;

  000ec	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	89 45 10	 mov	 DWORD PTR $T44[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  000f2	8b 45 10	 mov	 eax, DWORD PTR $T44[ebp]
  000f5	83 c0 08	 add	 eax, 8
  000f8	89 45 0c	 mov	 DWORD PTR $T43[ebp], eax

; 1443 :         _Count = _Newsize - _Mapsize();

  000fb	8b 45 0c	 mov	 eax, DWORD PTR $T43[ebp]
  000fe	8b 4d 64	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00101	2b 08		 sub	 ecx, DWORD PTR [eax]
  00103	89 4d 7c	 mov	 DWORD PTR __Count$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00106	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00109	89 45 08	 mov	 DWORD PTR $T42[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0010c	8b 45 08	 mov	 eax, DWORD PTR $T42[ebp]
  0010f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00112	89 45 04	 mov	 DWORD PTR $T41[ebp], eax

; 1444 : 
; 1445 :         size_type _Myboff = _Myoff() / _DEQUESIZ;

  00115	8b 45 04	 mov	 eax, DWORD PTR $T41[ebp]
  00118	8b 00		 mov	 eax, DWORD PTR [eax]
  0011a	c1 e8 02	 shr	 eax, 2
  0011d	89 45 68	 mov	 DWORD PTR __Myboff$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00120	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00123	89 45 00	 mov	 DWORD PTR $T40[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  00126	8b 45 00	 mov	 eax, DWORD PTR $T40[ebp]
  00129	83 c0 08	 add	 eax, 8
  0012c	89 45 fc	 mov	 DWORD PTR $T39[ebp], eax

; 1446 :         _Mapptr _Newmap   = _Almap.allocate(_Mapsize() + _Count);

  0012f	8b 45 fc	 mov	 eax, DWORD PTR $T39[ebp]
  00132	8b 00		 mov	 eax, DWORD PTR [eax]
  00134	03 45 7c	 add	 eax, DWORD PTR __Count$[ebp]
  00137	89 45 44	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0013a	c6 45 5f 01	 mov	 BYTE PTR __Overflow_is_possible$59[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0013e	c7 85 60 ff ff
	ff ff ff ff 3f	 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  00148	81 7d 44 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  0014f	76 05		 jbe	 SHORT $LN80@Growmap

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00151	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN80@Growmap:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00156	8b 45 44	 mov	 eax, DWORD PTR __Count$[ebp]
  00159	c1 e0 02	 shl	 eax, 2
  0015c	89 45 f8	 mov	 DWORD PTR $T38[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0015f	ff 75 f8	 push	 DWORD PTR $T38[ebp]
  00162	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00167	59		 pop	 ecx
  00168	89 45 60	 mov	 DWORD PTR __Newmap$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1447 :         _Mapptr _Myptr    = _Newmap + _Myboff;

  0016b	8b 45 68	 mov	 eax, DWORD PTR __Myboff$[ebp]
  0016e	8b 4d 60	 mov	 ecx, DWORD PTR __Newmap$[ebp]
  00171	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00174	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00177	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	89 45 f4	 mov	 DWORD PTR $T37[ebp], eax

; 1538 :         return _Get_data()._Map;

  0017d	8b 45 f4	 mov	 eax, DWORD PTR $T37[ebp]
  00180	83 c0 04	 add	 eax, 4
  00183	89 45 e4	 mov	 DWORD PTR $T33[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00186	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00189	89 45 f0	 mov	 DWORD PTR $T36[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0018c	8b 45 f0	 mov	 eax, DWORD PTR $T36[ebp]
  0018f	83 c0 08	 add	 eax, 8
  00192	89 45 e8	 mov	 DWORD PTR $T34[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00195	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00198	89 45 ec	 mov	 DWORD PTR $T35[ebp], eax

; 1538 :         return _Get_data()._Map;

  0019b	8b 45 ec	 mov	 eax, DWORD PTR $T35[ebp]
  0019e	83 c0 04	 add	 eax, 4
  001a1	89 45 e0	 mov	 DWORD PTR $T32[ebp], eax

; 1448 : 
; 1449 :         _Myptr = _STD uninitialized_copy(_Map() + _Myboff, _Map() + _Mapsize(), _Myptr); // copy initial to end

  001a4	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  001a7	8b 45 e8	 mov	 eax, DWORD PTR $T34[ebp]
  001aa	8b 00		 mov	 eax, DWORD PTR [eax]
  001ac	8b 4d e4	 mov	 ecx, DWORD PTR $T33[ebp]
  001af	8b 09		 mov	 ecx, DWORD PTR [ecx]
  001b1	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001b4	50		 push	 eax
  001b5	8b 45 e0	 mov	 eax, DWORD PTR $T32[ebp]
  001b8	8b 00		 mov	 eax, DWORD PTR [eax]
  001ba	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  001bd	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  001c0	50		 push	 eax
  001c1	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAKPAPAK@std@@YAPAPAKQAPAK0PAPAK@Z ; std::uninitialized_copy<unsigned long * *,unsigned long * *>
  001c6	83 c4 0c	 add	 esp, 12			; 0000000cH
  001c9	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1450 :         if (_Myboff <= _Count) { // increment greater than offset of initial block

  001cc	8b 45 68	 mov	 eax, DWORD PTR __Myboff$[ebp]
  001cf	3b 45 7c	 cmp	 eax, DWORD PTR __Count$[ebp]
  001d2	77 60		 ja	 SHORT $LN6@Growmap

; 1530 :         return _Mypair._Myval2;

  001d4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001d7	89 45 dc	 mov	 DWORD PTR $T31[ebp], eax

; 1538 :         return _Get_data()._Map;

  001da	8b 45 dc	 mov	 eax, DWORD PTR $T31[ebp]
  001dd	83 c0 04	 add	 eax, 4
  001e0	89 45 d4	 mov	 DWORD PTR $T29[ebp], eax

; 1530 :         return _Mypair._Myval2;

  001e3	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	89 45 d8	 mov	 DWORD PTR $T30[ebp], eax

; 1538 :         return _Get_data()._Map;

  001e9	8b 45 d8	 mov	 eax, DWORD PTR $T30[ebp]
  001ec	83 c0 04	 add	 eax, 4
  001ef	89 45 d0	 mov	 DWORD PTR $T28[ebp], eax

; 1451 :             _Myptr = _STD uninitialized_copy(_Map(), _Map() + _Myboff, _Myptr); // copy rest of old

  001f2	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  001f5	8b 45 d4	 mov	 eax, DWORD PTR $T29[ebp]
  001f8	8b 00		 mov	 eax, DWORD PTR [eax]
  001fa	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  001fd	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00200	50		 push	 eax
  00201	8b 45 d0	 mov	 eax, DWORD PTR $T28[ebp]
  00204	ff 30		 push	 DWORD PTR [eax]
  00206	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAKPAPAK@std@@YAPAPAKQAPAK0PAPAK@Z ; std::uninitialized_copy<unsigned long * *,unsigned long * *>
  0020b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0020e	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1452 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count - _Myboff); // clear suffix of new

  00211	8b 45 7c	 mov	 eax, DWORD PTR __Count$[ebp]
  00214	2b 45 68	 sub	 eax, DWORD PTR __Myboff$[ebp]
  00217	50		 push	 eax
  00218	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  0021b	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAKI@std@@YAPAPAKPAPAKI@Z ; std::_Uninitialized_value_construct_n_unchecked1<unsigned long * *,unsigned int>
  00220	59		 pop	 ecx
  00221	59		 pop	 ecx

; 1453 :             _Uninitialized_value_construct_n_unchecked1(_Newmap, _Myboff); // clear prefix of new

  00222	ff 75 68	 push	 DWORD PTR __Myboff$[ebp]
  00225	ff 75 60	 push	 DWORD PTR __Newmap$[ebp]
  00228	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAKI@std@@YAPAPAKPAPAKI@Z ; std::_Uninitialized_value_construct_n_unchecked1<unsigned long * *,unsigned int>
  0022d	59		 pop	 ecx
  0022e	59		 pop	 ecx

; 1454 :         } else { // increment not greater than offset of initial block

  0022f	e9 8b 00 00 00	 jmp	 $LN7@Growmap
$LN6@Growmap:

; 1530 :         return _Mypair._Myval2;

  00234	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00237	89 45 cc	 mov	 DWORD PTR $T27[ebp], eax

; 1538 :         return _Get_data()._Map;

  0023a	8b 45 cc	 mov	 eax, DWORD PTR $T27[ebp]
  0023d	83 c0 04	 add	 eax, 4
  00240	89 45 c4	 mov	 DWORD PTR $T25[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00243	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00246	89 45 c8	 mov	 DWORD PTR $T26[ebp], eax

; 1538 :         return _Get_data()._Map;

  00249	8b 45 c8	 mov	 eax, DWORD PTR $T26[ebp]
  0024c	83 c0 04	 add	 eax, 4
  0024f	89 45 c0	 mov	 DWORD PTR $T24[ebp], eax

; 1455 :             _STD uninitialized_copy(_Map(), _Map() + _Count, _Myptr); // copy more old

  00252	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  00255	8b 45 c4	 mov	 eax, DWORD PTR $T25[ebp]
  00258	8b 00		 mov	 eax, DWORD PTR [eax]
  0025a	8b 4d 7c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0025d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00260	50		 push	 eax
  00261	8b 45 c0	 mov	 eax, DWORD PTR $T24[ebp]
  00264	ff 30		 push	 DWORD PTR [eax]
  00266	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAKPAPAK@std@@YAPAPAKQAPAK0PAPAK@Z ; std::uninitialized_copy<unsigned long * *,unsigned long * *>
  0026b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1530 :         return _Mypair._Myval2;

  0026e	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00271	89 45 bc	 mov	 DWORD PTR $T23[ebp], eax

; 1538 :         return _Get_data()._Map;

  00274	8b 45 bc	 mov	 eax, DWORD PTR $T23[ebp]
  00277	83 c0 04	 add	 eax, 4
  0027a	89 45 b4	 mov	 DWORD PTR $T21[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0027d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00280	89 45 b8	 mov	 DWORD PTR $T22[ebp], eax

; 1538 :         return _Get_data()._Map;

  00283	8b 45 b8	 mov	 eax, DWORD PTR $T22[ebp]
  00286	83 c0 04	 add	 eax, 4
  00289	89 45 b0	 mov	 DWORD PTR $T20[ebp], eax

; 1456 :             _Myptr = _STD uninitialized_copy(_Map() + _Count, _Map() + _Myboff, _Newmap); // copy rest of old

  0028c	ff 75 60	 push	 DWORD PTR __Newmap$[ebp]
  0028f	8b 45 b4	 mov	 eax, DWORD PTR $T21[ebp]
  00292	8b 00		 mov	 eax, DWORD PTR [eax]
  00294	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  00297	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  0029a	50		 push	 eax
  0029b	8b 45 b0	 mov	 eax, DWORD PTR $T20[ebp]
  0029e	8b 00		 mov	 eax, DWORD PTR [eax]
  002a0	8b 4d 7c	 mov	 ecx, DWORD PTR __Count$[ebp]
  002a3	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  002a6	50		 push	 eax
  002a7	e8 00 00 00 00	 call	 ??$uninitialized_copy@PAPAKPAPAK@std@@YAPAPAKQAPAK0PAPAK@Z ; std::uninitialized_copy<unsigned long * *,unsigned long * *>
  002ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  002af	89 45 6c	 mov	 DWORD PTR __Myptr$[ebp], eax

; 1457 :             _Uninitialized_value_construct_n_unchecked1(_Myptr, _Count); // clear rest to initial block

  002b2	ff 75 7c	 push	 DWORD PTR __Count$[ebp]
  002b5	ff 75 6c	 push	 DWORD PTR __Myptr$[ebp]
  002b8	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n_unchecked1@PAPAKI@std@@YAPAPAKPAPAKI@Z ; std::_Uninitialized_value_construct_n_unchecked1<unsigned long * *,unsigned int>
  002bd	59		 pop	 ecx
  002be	59		 pop	 ecx
$LN7@Growmap:

; 1530 :         return _Mypair._Myval2;

  002bf	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002c2	89 45 ac	 mov	 DWORD PTR $T19[ebp], eax

; 1538 :         return _Get_data()._Map;

  002c5	8b 45 ac	 mov	 eax, DWORD PTR $T19[ebp]
  002c8	83 c0 04	 add	 eax, 4
  002cb	89 45 9c	 mov	 DWORD PTR $T15[ebp], eax

; 1530 :         return _Mypair._Myval2;

  002ce	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002d1	89 45 a8	 mov	 DWORD PTR $T18[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  002d4	8b 45 a8	 mov	 eax, DWORD PTR $T18[ebp]
  002d7	83 c0 08	 add	 eax, 8
  002da	89 45 a0	 mov	 DWORD PTR $T16[ebp], eax

; 1530 :         return _Mypair._Myval2;

  002dd	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002e0	89 45 a4	 mov	 DWORD PTR $T17[ebp], eax

; 1538 :         return _Get_data()._Map;

  002e3	8b 45 a4	 mov	 eax, DWORD PTR $T17[ebp]
  002e6	83 c0 04	 add	 eax, 4
  002e9	89 45 98	 mov	 DWORD PTR $T14[ebp], eax

; 1458 :         }
; 1459 : 
; 1460 :         _Destroy_range(_Map() + _Myboff, _Map() + _Mapsize());

  002ec	8b 45 a0	 mov	 eax, DWORD PTR $T16[ebp]
  002ef	8b 00		 mov	 eax, DWORD PTR [eax]
  002f1	8b 4d 9c	 mov	 ecx, DWORD PTR $T15[ebp]
  002f4	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002f6	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  002f9	50		 push	 eax
  002fa	8b 45 98	 mov	 eax, DWORD PTR $T14[ebp]
  002fd	8b 00		 mov	 eax, DWORD PTR [eax]
  002ff	8b 4d 68	 mov	 ecx, DWORD PTR __Myboff$[ebp]
  00302	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00305	50		 push	 eax
  00306	e8 00 00 00 00	 call	 ??$_Destroy_range@PAPAKPAPAK@std@@YAXPAPAKQAPAK@Z ; std::_Destroy_range<unsigned long * *,unsigned long * *>
  0030b	59		 pop	 ecx
  0030c	59		 pop	 ecx

; 1530 :         return _Mypair._Myval2;

  0030d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00310	89 45 94	 mov	 DWORD PTR $T13[ebp], eax

; 1538 :         return _Get_data()._Map;

  00313	8b 45 94	 mov	 eax, DWORD PTR $T13[ebp]
  00316	83 c0 04	 add	 eax, 4
  00319	89 45 90	 mov	 DWORD PTR $T12[ebp], eax

; 1461 :         if (_Map() != _Mapptr()) {

  0031c	8b 45 90	 mov	 eax, DWORD PTR $T12[ebp]
  0031f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00322	74 4b		 je	 SHORT $LN8@Growmap

; 1530 :         return _Mypair._Myval2;

  00324	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00327	89 45 8c	 mov	 DWORD PTR $T11[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  0032a	8b 45 8c	 mov	 eax, DWORD PTR $T11[ebp]
  0032d	83 c0 08	 add	 eax, 8
  00330	89 45 84	 mov	 DWORD PTR $T9[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00333	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00336	89 45 88	 mov	 DWORD PTR $T10[ebp], eax

; 1538 :         return _Get_data()._Map;

  00339	8b 45 88	 mov	 eax, DWORD PTR $T10[ebp]
  0033c	83 c0 04	 add	 eax, 4
  0033f	89 45 80	 mov	 DWORD PTR $T8[ebp], eax

; 1462 :             _Almap.deallocate(_Map(), _Mapsize()); // free storage for old

  00342	8b 45 84	 mov	 eax, DWORD PTR $T9[ebp]
  00345	8b 00		 mov	 eax, DWORD PTR [eax]
  00347	89 85 7c ff ff
	ff		 mov	 DWORD PTR __Count$[ebp], eax
  0034d	8b 45 80	 mov	 eax, DWORD PTR $T8[ebp]
  00350	8b 00		 mov	 eax, DWORD PTR [eax]
  00352	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00358	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR __Count$[ebp]
  0035e	c1 e0 02	 shl	 eax, 2
  00361	50		 push	 eax
  00362	ff b5 78 ff ff
	ff		 push	 DWORD PTR __Ptr$[ebp]
  00368	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0036d	59		 pop	 ecx
  0036e	59		 pop	 ecx
$LN8@Growmap:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  0036f	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00372	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax

; 1538 :         return _Get_data()._Map;

  00378	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  0037e	83 c0 04	 add	 eax, 4
  00381	89 85 70 ff ff
	ff		 mov	 DWORD PTR $T6[ebp], eax

; 1463 :         }
; 1464 : 
; 1465 :         _Map() = _Newmap; // point at new

  00387	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  0038d	8b 4d 60	 mov	 ecx, DWORD PTR __Newmap$[ebp]
  00390	89 08		 mov	 DWORD PTR [eax], ecx

; 1466 :         _Mapsize() += _Count;

  00392	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR $T1[ebp]
  00398	89 45 58	 mov	 DWORD PTR tv214[ebp], eax

; 1530 :         return _Mypair._Myval2;

  0039b	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0039e	89 85 6c ff ff
	ff		 mov	 DWORD PTR $T5[ebp], eax

; 1546 :         return _Get_data()._Mapsize;

  003a4	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T5[ebp]
  003aa	83 c0 08	 add	 eax, 8
  003ad	89 45 58	 mov	 DWORD PTR tv214[ebp], eax

; 1466 :         _Mapsize() += _Count;

  003b0	8b 45 58	 mov	 eax, DWORD PTR tv214[ebp]
  003b3	8b 00		 mov	 eax, DWORD PTR [eax]
  003b5	03 45 7c	 add	 eax, DWORD PTR __Count$[ebp]
  003b8	8b 4d 58	 mov	 ecx, DWORD PTR tv214[ebp]
  003bb	89 01		 mov	 DWORD PTR [ecx], eax
$LN83@Growmap:

; 1467 :     }

  003bd	83 c5 74	 add	 ebp, 116		; 00000074H
  003c0	c9		 leave
  003c1	c2 04 00	 ret	 4
?_Growmap@?$deque@KV?$allocator@K@std@@@std@@AAEXI@Z ENDP ; std::deque<unsigned long,std::allocator<unsigned long> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?_Xlen@?$deque@KV?$allocator@K@std@@@std@@ABEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$deque@KV?$allocator@K@std@@@std@@ABEXXZ PROC	; std::deque<unsigned long,std::allocator<unsigned long> >::_Xlen, COMDAT
; _this$ = ecx

; 1422 :     [[noreturn]] void _Xlen() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1423 :         _Xlength_error("deque<T> too long");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long@
  0000c	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 1424 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Xlen@?$deque@KV?$allocator@K@std@@@std@@ABEXXZ ENDP	; std::deque<unsigned long,std::allocator<unsigned long> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
$T7 = -56						; size = 4
__Ptr$ = -52						; size = 4
__Block$ = -48						; size = 4
$T8 = -44						; size = 4
$T9 = -40						; size = 4
$T10 = -36						; size = 4
$T11 = -32						; size = 4
$T12 = -28						; size = 4
$T13 = -24						; size = 4
$T14 = -20						; size = 4
$T15 = -16						; size = 4
__Newoff$ = -12						; size = 4
tv88 = -8						; size = 4
_this$ = -4						; size = 4
?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ PROC ; std::deque<unsigned long,std::allocator<unsigned long> >::pop_back, COMDAT
; _this$ = ecx

; 1126 :     void pop_back() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR $T15[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T15[ebp]
  00012	83 c0 0c	 add	 eax, 12			; 0000000cH
  00015	89 45 e8	 mov	 DWORD PTR $T13[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	89 45 ec	 mov	 DWORD PTR $T14[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0001e	8b 45 ec	 mov	 eax, DWORD PTR $T14[ebp]
  00021	83 c0 10	 add	 eax, 16			; 00000010H
  00024	89 45 e4	 mov	 DWORD PTR $T12[ebp], eax

; 1127 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1128 :         if (empty()) {
; 1129 :             _STL_REPORT_ERROR("deque empty before pop");
; 1130 :         } else { // something to erase, do it
; 1131 :             size_type _Newoff = _Myoff() + _Mysize() - 1;
; 1132 :             _Orphan_off(_Newoff);
; 1133 :             size_type _Block = _Getblock(_Newoff);
; 1134 :             _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1135 :             if (--_Mysize() == 0) {
; 1136 :                 _Myoff() = 0;
; 1137 :             }
; 1138 :         }
; 1139 : 
; 1140 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1141 :         size_type _Newoff = _Myoff() + _Mysize() - 1;

  00027	8b 45 e8	 mov	 eax, DWORD PTR $T13[ebp]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	8b 4d e4	 mov	 ecx, DWORD PTR $T12[ebp]
  0002f	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00031	8d 44 08 ff	 lea	 eax, DWORD PTR [eax+ecx-1]
  00035	89 45 f4	 mov	 DWORD PTR __Newoff$[ebp], eax

; 1534 :         return _Mypair._Myval2;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T11[ebp], eax

; 548  :         return (_Off / _DEQUESIZ) & (_Mapsize - 1);

  0003e	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$[ebp]
  00041	c1 e8 02	 shr	 eax, 2
  00044	8b 4d e0	 mov	 ecx, DWORD PTR $T11[ebp]
  00047	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0004a	49		 dec	 ecx
  0004b	23 c1		 and	 eax, ecx
  0004d	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax

; 1514 :         return _Get_data()._Getblock(_Off);

  00050	8b 45 dc	 mov	 eax, DWORD PTR $T10[ebp]
  00053	89 45 d0	 mov	 DWORD PTR __Block$[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	89 45 d8	 mov	 DWORD PTR $T9[ebp], eax

; 1538 :         return _Get_data()._Map;

  0005c	8b 45 d8	 mov	 eax, DWORD PTR $T9[ebp]
  0005f	83 c0 04	 add	 eax, 4
  00062	89 45 d4	 mov	 DWORD PTR $T8[ebp], eax

; 1142 :         size_type _Block  = _Getblock(_Newoff);
; 1143 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Map()[_Block] + _Newoff % _DEQUESIZ));

  00065	8b 45 f4	 mov	 eax, DWORD PTR __Newoff$[ebp]
  00068	33 d2		 xor	 edx, edx
  0006a	6a 04		 push	 4
  0006c	59		 pop	 ecx
  0006d	f7 f1		 div	 ecx
  0006f	8b 45 d4	 mov	 eax, DWORD PTR $T8[ebp]
  00072	8b 00		 mov	 eax, DWORD PTR [eax]
  00074	8b 4d d0	 mov	 ecx, DWORD PTR __Block$[ebp]
  00077	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  0007a	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  0007d	89 45 cc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00080	8b 45 cc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00083	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00086	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00089	89 45 c8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  0008c	8b 45 c8	 mov	 eax, DWORD PTR $T7[ebp]
  0008f	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 1144 :         if (--_Mysize() == 0) {

  00092	8b 45 b0	 mov	 eax, DWORD PTR $T1[ebp]
  00095	89 45 f8	 mov	 DWORD PTR tv88[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00098	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0009b	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0009e	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000a1	83 c0 10	 add	 eax, 16			; 00000010H
  000a4	89 45 f8	 mov	 DWORD PTR tv88[ebp], eax

; 1144 :         if (--_Mysize() == 0) {

  000a7	8b 45 f8	 mov	 eax, DWORD PTR tv88[ebp]
  000aa	8b 00		 mov	 eax, DWORD PTR [eax]
  000ac	48		 dec	 eax
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR tv88[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax
  000b2	8b 45 f8	 mov	 eax, DWORD PTR tv88[ebp]
  000b5	83 38 00	 cmp	 DWORD PTR [eax], 0
  000b8	75 15		 jne	 SHORT $LN3@pop_back

; 1530 :         return _Mypair._Myval2;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  000c0	8b 45 c0	 mov	 eax, DWORD PTR $T5[ebp]
  000c3	83 c0 0c	 add	 eax, 12			; 0000000cH
  000c6	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 1145 :             _Myoff() = 0;

  000c9	8b 45 bc	 mov	 eax, DWORD PTR $T4[ebp]
  000cc	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@pop_back:

; 1146 :         }
; 1147 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1148 :     }

  000cf	c9		 leave
  000d0	c3		 ret	 0
?pop_back@?$deque@KV?$allocator@K@std@@@std@@QAEXXZ ENDP ; std::deque<unsigned long,std::allocator<unsigned long> >::pop_back
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?end@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Parent_proxy$1 = -36					; size = 4
___param0$ = -32					; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
$T7 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ PROC ; std::deque<unsigned long,std::allocator<unsigned long> >::end, COMDAT
; _this$ = ecx

; 905  :     _NODISCARD iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00012	89 45 f8	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax

; 1562 :         return _Get_data()._Mysize;

  0002a	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  0002d	83 c0 10	 add	 eax, 16			; 00000010H
  00030	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax

; 906  :         return iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00033	8b 45 e8	 mov	 eax, DWORD PTR $T3[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  0003b	03 01		 add	 eax, DWORD PTR [ecx]
  0003d	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1126 :     _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {} // construct orphaned iterator

  00040	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00043	83 20 00	 and	 DWORD PTR [eax], 0
  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00049	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 256  :     _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {

  0004d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00050	8b 4d e0	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00053	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1157 :         if (_Parent) {

  00056	83 7d f8 00	 cmp	 DWORD PTR $T7[ebp], 0
  0005a	74 12		 je	 SHORT $LN34@end

; 1158 :             // have a parent, do adoption
; 1159 :             _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  0005c	8b 45 f8	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	89 45 dc	 mov	 DWORD PTR __Parent_proxy$1[ebp], eax

; 1160 : 
; 1161 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1162 :             if (_Myproxy != _Parent_proxy) { // change parentage
; 1163 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1164 :                 _Orphan_me();
; 1165 :                 _Mynextiter                 = _Parent_proxy->_Myfirstiter;
; 1166 :                 _Parent_proxy->_Myfirstiter = this;
; 1167 :                 _Myproxy                    = _Parent_proxy;
; 1168 :             }
; 1169 : 
; 1170 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1171 :             _Myproxy = _Parent_proxy;

  00064	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00067	8b 4d dc	 mov	 ecx, DWORD PTR __Parent_proxy$1[ebp]
  0006a	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1173 :         } else {

  0006c	eb 06		 jmp	 SHORT $LN22@end
$LN34@end:

; 1174 :             // no future parent, just disown current parent
; 1175 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1176 :             _Lockit _Lock(_LOCK_DEBUG);
; 1177 :             _Orphan_me();
; 1178 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1179 :             _Myproxy = nullptr;

  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00071	83 20 00	 and	 DWORD PTR [eax], 0
$LN22@end:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 906  :         return iterator(_Myoff() + _Mysize(), _STD addressof(_Get_data()));

  00074	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 907  :     }

  00077	c9		 leave
  00078	c2 04 00	 ret	 4
?end@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ ENDP ; std::deque<unsigned long,std::allocator<unsigned long> >::end
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ?begin@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
__Parent_proxy$1 = -28					; size = 4
___param0$ = -24					; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
$T4 = -12						; size = 4
$T5 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ PROC ; std::deque<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 897  :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1530 :         return _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T4[ebp]
  00012	89 45 f8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax

; 1554 :         return _Get_data()._Myoff;

  0001b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0001e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00021	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 898  :         return iterator(_Myoff(), _STD addressof(_Get_data()));

  00024	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1126 :     _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr) {} // construct orphaned iterator

  0002c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	83 20 00	 and	 DWORD PTR [eax], 0
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00035	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 256  :     _Deque_const_iterator(_Size_type _Off, const _Container_base12* _Pdeque) noexcept : _Myoff(_Off) {

  00039	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	8b 4d e8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0003f	89 48 08	 mov	 DWORD PTR [eax+8], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1157 :         if (_Parent) {

  00042	83 7d f8 00	 cmp	 DWORD PTR $T5[ebp], 0
  00046	74 12		 je	 SHORT $LN28@begin

; 1158 :             // have a parent, do adoption
; 1159 :             _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00048	8b 45 f8	 mov	 eax, DWORD PTR $T5[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	89 45 e4	 mov	 DWORD PTR __Parent_proxy$1[ebp], eax

; 1160 : 
; 1161 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1162 :             if (_Myproxy != _Parent_proxy) { // change parentage
; 1163 :                 _Lockit _Lock(_LOCK_DEBUG);
; 1164 :                 _Orphan_me();
; 1165 :                 _Mynextiter                 = _Parent_proxy->_Myfirstiter;
; 1166 :                 _Parent_proxy->_Myfirstiter = this;
; 1167 :                 _Myproxy                    = _Parent_proxy;
; 1168 :             }
; 1169 : 
; 1170 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1171 :             _Myproxy = _Parent_proxy;

  00050	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00053	8b 4d e4	 mov	 ecx, DWORD PTR __Parent_proxy$1[ebp]
  00056	89 08		 mov	 DWORD PTR [eax], ecx

; 1172 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1173 :         } else {

  00058	eb 06		 jmp	 SHORT $LN16@begin
$LN28@begin:

; 1174 :             // no future parent, just disown current parent
; 1175 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1176 :             _Lockit _Lock(_LOCK_DEBUG);
; 1177 :             _Orphan_me();
; 1178 : #else // _ITERATOR_DEBUG_LEVEL == 2
; 1179 :             _Myproxy = nullptr;

  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	83 20 00	 and	 DWORD PTR [eax], 0
$LN16@begin:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 898  :         return iterator(_Myoff(), _STD addressof(_Get_data()));

  00060	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 899  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
?begin@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ ENDP ; std::deque<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Old_val$3 = -24					; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
__Proxy_allocator$ = -1					; size = 1
??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::deque<unsigned long,std::allocator<unsigned long> >::~deque<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 869  :     ~deque() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 870  :         _Tidy();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Tidy@?$deque@KV?$allocator@K@std@@@std@@AAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy

; 1522 :         return _Mypair._Get_first();

  00011	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00014	89 45 f0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00017	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  0001a	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax

; 872  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

  0001d	83 65 ec 00	 and	 DWORD PTR $T4[ebp], 0

; 1530 :         return _Mypair._Myval2;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00027	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  0002a	8b 00		 mov	 eax, DWORD PTR [eax]
  0002c	89 45 e8	 mov	 DWORD PTR __Old_val$3[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  0002f	8b 45 f4	 mov	 eax, DWORD PTR $T6[ebp]
  00032	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  00035	89 08		 mov	 DWORD PTR [eax], ecx

; 600  :     return _Old_val;

  00037	8b 45 e8	 mov	 eax, DWORD PTR __Old_val$3[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 872  :         _Delete_plain_internal(_Proxy_allocator, _STD exchange(_Get_data()._Myproxy, nullptr));

  0003d	ff 75 e4	 push	 DWORD PTR $T2[ebp]
  00040	8d 45 ff	 lea	 eax, DWORD PTR __Proxy_allocator$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00049	59		 pop	 ecx
  0004a	59		 pop	 ecx

; 873  :     }

  0004b	c9		 leave
  0004c	c3		 ret	 0
??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::deque<unsigned long,std::allocator<unsigned long> >::~deque<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
;	COMDAT ??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -1						; size = 1
??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::deque<unsigned long,std::allocator<unsigned long> >::deque<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 596  :     deque() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<unsigned long> >::_Deque_val<std::_Deque_simple_types<unsigned long> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  00017	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001a	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1522 :         return _Mypair._Get_first();

  0001d	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  00020	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1530 :         return _Mypair._Myval2;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax

; 597  :         _Get_data()._Alloc_proxy(static_cast<_Alproxy_ty>(_Getal()));

  00029	8d 45 ff	 lea	 eax, DWORD PTR $T4[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 598  :     }

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c9		 leave
  00039	c3		 ret	 0
??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::deque<unsigned long,std::allocator<unsigned long> >::deque<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S12$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ PROC ; std::list<unsigned long,std::allocator<unsigned long> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S12$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc 55 55
	55 15		 mov	 DWORD PTR __Max_possible$1[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d 55 55 55 15	 cmp	 eax, 357913941		; 15555555H
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 0c	 imul	 eax, eax, 12
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@KPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@KPAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@KPAX@0@0@Z ; std::_Construct_in_place<std::_List_node<unsigned long,void *> *,std::_List_node<unsigned long,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ; std::_List_node<unsigned long,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned long,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ; std::_List_node<unsigned long,void *>::_Freenode0<std::allocator<std::_List_node<unsigned long,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@KV?$allocator@K@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@KV?$allocator@K@std@@@std@@QAEXXZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ; std::_List_node<unsigned long,void *>::_Free_non_head<std::allocator<std::_List_node<unsigned long,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@KV?$allocator@K@std@@@std@@QAEXXZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?erase@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
__Result$ = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@@Z PROC ; std::list<unsigned long,std::allocator<unsigned long> >::erase, COMDAT
; _this$ = ecx

; 1349 :     iterator erase(const const_iterator _Where) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1350 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1351 :         _STL_VERIFY(_Where._Getcont() == _STD addressof(_Mypair._Myval2), "list erase iterator outside range");
; 1352 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1353 :         const auto _Result = _Where._Ptr->_Next;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax

; 1354 :         _Node::_Freenode(_Getal(), _Mypair._Myval2._Unlinknode(_Where._Ptr));

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 396  :         _Pnode->_Prev->_Next = _Pnode->_Next;

  00017	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0001a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00020	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00022	89 08		 mov	 DWORD PTR [eax], ecx

; 397  :         _Pnode->_Next->_Prev = _Pnode->_Prev;

  00024	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00027	8b 00		 mov	 eax, DWORD PTR [eax]
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  0002c	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0002f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 398  :         --_Mysize;

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00038	48		 dec	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 399  :         return _Pnode;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  00042	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0004b	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00051	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00054	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00057	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  0005a	ff 75 f4	 push	 DWORD PTR $T5[ebp]
  0005d	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00060	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@KPAX@std@@@std@@@?$_List_node@KPAX@std@@SAXAAV?$allocator@U?$_List_node@KPAX@std@@@1@PAU01@@Z ; std::_List_node<unsigned long,void *>::_Freenode0<std::allocator<std::_List_node<unsigned long,void *> > >
  00065	59		 pop	 ecx
  00066	59		 pop	 ecx

; 1124 :         return iterator(_Where, _STD addressof(_Mypair._Myval2));

  00067	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0006a	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00070	8b 4d e8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00073	89 08		 mov	 DWORD PTR [eax], ecx

; 1355 :         return _Make_iter(_Result);

  00075	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1356 :     }

  00078	c9		 leave
  00079	c2 08 00	 ret	 8
?erase@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@@Z ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
___param0$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ PROC ; std::list<unsigned long,std::allocator<unsigned long> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ENDP ; std::list<unsigned long,std::allocator<unsigned long> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ ; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@KV?$allocator@K@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@KV?$allocator@K@std@@@std@@QAE@XZ PROC	; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ ; std::list<unsigned long,std::allocator<unsigned long> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@KV?$allocator@K@std@@@std@@QAE@XZ ENDP	; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnIsType@CSlotWindow@UI@@MAEHK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwType$ = 8						; size = 4
?OnIsType@CSlotWindow@UI@@MAEHK@Z PROC			; UI::CSlotWindow::OnIsType, COMDAT
; _this$ = ecx

; 1272 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1273 : 	if (CSlotWindow::Type() == dwType)

  00007	e8 00 00 00 00	 call	 ?Type@CSlotWindow@UI@@SAKXZ ; UI::CSlotWindow::Type
  0000c	3b 45 08	 cmp	 eax, DWORD PTR _dwType$[ebp]
  0000f	75 05		 jne	 SHORT $LN2@OnIsType

; 1274 : 		return TRUE;

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	eb 0b		 jmp	 SHORT $LN1@OnIsType
$LN2@OnIsType:

; 1275 : 
; 1276 : 	return CWindow::OnIsType(dwType);

  00016	ff 75 08	 push	 DWORD PTR _dwType$[ebp]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?OnIsType@CWindow@UI@@UAEHK@Z ; UI::CWindow::OnIsType
$LN1@OnIsType:

; 1277 : }

  00021	c9		 leave
  00022	c2 04 00	 ret	 4
?OnIsType@CSlotWindow@UI@@MAEHK@Z ENDP			; UI::CSlotWindow::OnIsType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnRefreshSlot@CSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnRefreshSlot@CSlotWindow@UI@@MAEXXZ PROC		; UI::CSlotWindow::OnRefreshSlot, COMDAT
; _this$ = ecx

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 602  : }

  00007	c9		 leave
  00008	c3		 ret	 0
?OnRefreshSlot@CSlotWindow@UI@@MAEXXZ ENDP		; UI::CSlotWindow::OnRefreshSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ClearSlot@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_pSlot$ = 8						; size = 4
?ClearSlot@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z PROC	; UI::CSlotWindow::ClearSlot, COMDAT
; _this$ = ecx

; 542  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 543  : 	pSlot->bActive = FALSE;

  00007	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0000a	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 544  : 	pSlot->byxPlacedItemSize = 1;

  0000e	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00011	c6 40 30 01	 mov	 BYTE PTR [eax+48], 1

; 545  : 	pSlot->byyPlacedItemSize = 1;

  00015	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00018	c6 40 31 01	 mov	 BYTE PTR [eax+49], 1

; 546  : 
; 547  : 	pSlot->isItem = FALSE;

  0001c	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0001f	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 548  : 	pSlot->dwState = 0;

  00023	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00026	83 20 00	 and	 DWORD PTR [eax], 0

; 549  : 	pSlot->fCoolTime = 0.0f;

  00029	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002c	0f 57 c0	 xorps	 xmm0, xmm0
  0002f	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 550  : 	pSlot->fStartCoolTime = 0.0f;

  00034	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00037	0f 57 c0	 xorps	 xmm0, xmm0
  0003a	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0

; 551  : 	pSlot->dwCenterSlotNumber = 0xffffffff;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00042	83 48 08 ff	 or	 DWORD PTR [eax+8], -1

; 552  : 
; 553  : 	pSlot->dwItemIndex = 0;

  00046	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00049	83 60 0c 00	 and	 DWORD PTR [eax+12], 0

; 554  : 	pSlot->bRenderBaseSlotImage = true;

  0004d	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00050	c6 40 3c 01	 mov	 BYTE PTR [eax+60], 1

; 555  : 
; 556  : 	if (pSlot->pInstance)

  00054	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00057	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0005b	74 13		 je	 SHORT $LN2@ClearSlot

; 557  : 	{
; 558  : 		CGraphicImageInstance::Delete(pSlot->pInstance);

  0005d	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00060	ff 70 34	 push	 DWORD PTR [eax+52]
  00063	e8 00 00 00 00	 call	 ?Delete@CGraphicImageInstance@@SAXPAV1@@Z ; CGraphicImageInstance::Delete
  00068	59		 pop	 ecx

; 559  : 		pSlot->pInstance = NULL;

  00069	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0006c	83 60 34 00	 and	 DWORD PTR [eax+52], 0
$LN2@ClearSlot:

; 560  : 	}
; 561  : 	if (pSlot->pCoverButton)

  00070	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00073	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00077	74 0b		 je	 SHORT $LN3@ClearSlot

; 562  : 	{
; 563  : 		pSlot->pCoverButton->Hide();

  00079	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0007c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0007f	e8 00 00 00 00	 call	 ?Hide@CWindow@UI@@QAEXXZ ; UI::CWindow::Hide
$LN3@ClearSlot:

; 564  : 	}
; 565  : 	if (pSlot->pSlotButton)

  00084	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00087	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0008b	74 0b		 je	 SHORT $LN4@ClearSlot

; 566  : 	{
; 567  : 		pSlot->pSlotButton->Hide();

  0008d	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00090	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00093	e8 00 00 00 00	 call	 ?Hide@CWindow@UI@@QAEXXZ ; UI::CWindow::Hide
$LN4@ClearSlot:

; 568  : 	}
; 569  : 	if (pSlot->pSignImage)

  00098	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0009b	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  0009f	74 0b		 je	 SHORT $LN5@ClearSlot

; 570  : 	{
; 571  :  		pSlot->pSignImage->Hide();

  000a1	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000a4	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  000a7	e8 00 00 00 00	 call	 ?Hide@CWindow@UI@@QAEXXZ ; UI::CWindow::Hide
$LN5@ClearSlot:

; 572  : 	}
; 573  : 	if (pSlot->pFinishCoolTimeEffect)

  000ac	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000af	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  000b3	74 0b		 je	 SHORT $LN6@ClearSlot

; 574  : 	{
; 575  : 		pSlot->pFinishCoolTimeEffect->Hide();

  000b5	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000b8	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  000bb	e8 00 00 00 00	 call	 ?Hide@CWindow@UI@@QAEXXZ ; UI::CWindow::Hide
$LN6@ClearSlot:

; 576  : 	}
; 577  : }

  000c0	c9		 leave
  000c1	c2 04 00	 ret	 4
?ClearSlot@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ENDP	; UI::CSlotWindow::ClearSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?GetPickedSlotPointer@CSlotWindow@UI@@MAEHPAPAUSSlot@12@@Z
_TEXT	SEGMENT
$T1 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
___param0$ = -64					; size = 4
_ly$ = -60						; size = 4
_lx$ = -56						; size = 4
_iyLocal$ = -52						; size = 4
_iyCellSize$5 = -48					; size = 4
_ixLocal$ = -44						; size = 4
_ixCellSize$6 = -40					; size = 4
tv160 = -36						; size = 4
tv150 = -32						; size = 4
tv217 = -28						; size = 4
tv241 = -24						; size = 4
_this$ = -20						; size = 4
_itor$7 = -16						; size = 4
_this$ = -12						; size = 4
_rSlot$8 = -8						; size = 4
$T9 = -2						; size = 1
$T10 = -1						; size = 1
_ppSlot$ = 8						; size = 4
?GetPickedSlotPointer@CSlotWindow@UI@@MAEHPAPAUSSlot@12@@Z PROC ; UI::CSlotWindow::GetPickedSlotPointer, COMDAT
; _this$ = ecx

; 1214 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1215 : 	long lx, ly;
; 1216 : 	CWindowManager::Instance().GetMousePosition(lx, ly);

  00009	8d 45 c4	 lea	 eax, DWORD PTR _ly$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 c8	 lea	 eax, DWORD PTR _lx$[ebp]
  00010	50		 push	 eax
  00011	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00017	e8 00 00 00 00	 call	 ?GetMousePosition@CWindowManager@UI@@QAEXAAJ0@Z ; UI::CWindowManager::GetMousePosition

; 1217 : 
; 1218 : 	int ixLocal = lx - m_rect.left;

  0001c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 4d c8	 mov	 ecx, DWORD PTR _lx$[ebp]
  00022	2b 48 34	 sub	 ecx, DWORD PTR [eax+52]
  00025	89 4d d4	 mov	 DWORD PTR _ixLocal$[ebp], ecx

; 1219 : 	int iyLocal = ly - m_rect.top;

  00028	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d c4	 mov	 ecx, DWORD PTR _ly$[ebp]
  0002e	2b 48 38	 sub	 ecx, DWORD PTR [eax+56]
  00031	89 4d cc	 mov	 DWORD PTR _iyLocal$[ebp], ecx

; 1223 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00034	8d 45 f0	 lea	 eax, DWORD PTR _itor$7[ebp]
  00037	50		 push	 eax
  00038	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00041	e8 00 00 00 00	 call	 ?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
  00046	eb 08		 jmp	 SHORT $LN4@GetPickedS
$LN2@GetPickedS:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  00048	8b 45 f0	 mov	 eax, DWORD PTR _itor$7[ebp]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	89 45 f0	 mov	 DWORD PTR _itor$7[ebp], eax
$LN4@GetPickedS:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1223 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00053	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00058	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0005b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0005e	89 45 b0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00061	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 00		 mov	 eax, DWORD PTR [eax]
  00066	89 45 c0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00069	8b 45 c0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0006c	89 45 bc	 mov	 DWORD PTR $T4[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0006f	8d 45 bc	 lea	 eax, DWORD PTR $T4[ebp]
  00072	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00075	8b 45 b8	 mov	 eax, DWORD PTR $T3[ebp]
  00078	8b 4d f0	 mov	 ecx, DWORD PTR _itor$7[ebp]
  0007b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0007d	75 09		 jne	 SHORT $LN66@GetPickedS
  0007f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv241[ebp], 1
  00086	eb 04		 jmp	 SHORT $LN67@GetPickedS
$LN66@GetPickedS:
  00088	83 65 e8 00	 and	 DWORD PTR tv241[ebp], 0
$LN67@GetPickedS:
  0008c	8a 45 e8	 mov	 al, BYTE PTR tv241[ebp]
  0008f	88 45 ff	 mov	 BYTE PTR $T10[ebp], al

; 203  :         return !(*this == _Right);

  00092	0f b6 45 ff	 movzx	 eax, BYTE PTR $T10[ebp]
  00096	85 c0		 test	 eax, eax
  00098	75 09		 jne	 SHORT $LN61@GetPickedS
  0009a	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv217[ebp], 1
  000a1	eb 04		 jmp	 SHORT $LN62@GetPickedS
$LN61@GetPickedS:
  000a3	83 65 e4 00	 and	 DWORD PTR tv217[ebp], 0
$LN62@GetPickedS:
  000a7	8a 45 e4	 mov	 al, BYTE PTR tv217[ebp]
  000aa	88 45 fe	 mov	 BYTE PTR $T9[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1223 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  000ad	0f b6 45 fe	 movzx	 eax, BYTE PTR $T9[ebp]
  000b1	85 c0		 test	 eax, eax
  000b3	0f 84 ce 00 00
	00		 je	 $LN3@GetPickedS
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000b9	8b 45 f0	 mov	 eax, DWORD PTR _itor$7[ebp]
  000bc	83 c0 08	 add	 eax, 8
  000bf	89 45 b4	 mov	 DWORD PTR $T2[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000c2	8b 45 b4	 mov	 eax, DWORD PTR $T2[ebp]
  000c5	89 45 f8	 mov	 DWORD PTR _rSlot$8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1227 : 		int ixCellSize = rSlot.ixCellSize;

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  000cb	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000ce	89 45 d8	 mov	 DWORD PTR _ixCellSize$6[ebp], eax

; 1228 : 		int iyCellSize = rSlot.iyCellSize;

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  000d4	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  000d7	89 45 d0	 mov	 DWORD PTR _iyCellSize$5[ebp], eax

; 1229 : 
; 1230 : 		// NOTE : Item Hide   ..
; 1231 : 		if (rSlot.isItem)

  000da	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  000dd	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000e1	74 60		 je	 SHORT $LN5@GetPickedS

; 1232 : 		{
; 1233 : 			ixCellSize = max(rSlot.ixCellSize, int(rSlot.byxPlacedItemSize * ITEM_WIDTH));

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  000e6	0f b6 40 30	 movzx	 eax, BYTE PTR [eax+48]
  000ea	c1 e0 05	 shl	 eax, 5
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$8[ebp]
  000f0	39 41 28	 cmp	 DWORD PTR [ecx+40], eax
  000f3	7e 0b		 jle	 SHORT $LN11@GetPickedS
  000f5	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  000f8	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000fb	89 45 e0	 mov	 DWORD PTR tv150[ebp], eax
  000fe	eb 0d		 jmp	 SHORT $LN12@GetPickedS
$LN11@GetPickedS:
  00100	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  00103	0f b6 40 30	 movzx	 eax, BYTE PTR [eax+48]
  00107	c1 e0 05	 shl	 eax, 5
  0010a	89 45 e0	 mov	 DWORD PTR tv150[ebp], eax
$LN12@GetPickedS:
  0010d	8b 45 e0	 mov	 eax, DWORD PTR tv150[ebp]
  00110	89 45 d8	 mov	 DWORD PTR _ixCellSize$6[ebp], eax

; 1234 : 			iyCellSize = max(rSlot.iyCellSize, int(rSlot.byyPlacedItemSize * ITEM_HEIGHT));

  00113	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  00116	0f b6 40 31	 movzx	 eax, BYTE PTR [eax+49]
  0011a	c1 e0 05	 shl	 eax, 5
  0011d	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$8[ebp]
  00120	39 41 2c	 cmp	 DWORD PTR [ecx+44], eax
  00123	7e 0b		 jle	 SHORT $LN13@GetPickedS
  00125	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  00128	8b 40 2c	 mov	 eax, DWORD PTR [eax+44]
  0012b	89 45 dc	 mov	 DWORD PTR tv160[ebp], eax
  0012e	eb 0d		 jmp	 SHORT $LN14@GetPickedS
$LN13@GetPickedS:
  00130	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  00133	0f b6 40 31	 movzx	 eax, BYTE PTR [eax+49]
  00137	c1 e0 05	 shl	 eax, 5
  0013a	89 45 dc	 mov	 DWORD PTR tv160[ebp], eax
$LN14@GetPickedS:
  0013d	8b 45 dc	 mov	 eax, DWORD PTR tv160[ebp]
  00140	89 45 d0	 mov	 DWORD PTR _iyCellSize$5[ebp], eax
$LN5@GetPickedS:

; 1235 : 		}
; 1236 : 
; 1237 : 		if (ixLocal >= rSlot.ixPosition)

  00143	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  00146	8b 4d d4	 mov	 ecx, DWORD PTR _ixLocal$[ebp]
  00149	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  0014c	7c 34		 jl	 SHORT $LN6@GetPickedS

; 1238 : 		if (iyLocal >= rSlot.iyPosition)

  0014e	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  00151	8b 4d cc	 mov	 ecx, DWORD PTR _iyLocal$[ebp]
  00154	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  00157	7c 29		 jl	 SHORT $LN6@GetPickedS

; 1239 : 		if (ixLocal <= rSlot.ixPosition + ixCellSize)

  00159	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  0015c	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0015f	03 45 d8	 add	 eax, DWORD PTR _ixCellSize$6[ebp]
  00162	39 45 d4	 cmp	 DWORD PTR _ixLocal$[ebp], eax
  00165	7f 1b		 jg	 SHORT $LN6@GetPickedS

; 1240 : 		if (iyLocal <= rSlot.iyPosition + iyCellSize)

  00167	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  0016a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0016d	03 45 d0	 add	 eax, DWORD PTR _iyCellSize$5[ebp]
  00170	39 45 cc	 cmp	 DWORD PTR _iyLocal$[ebp], eax
  00173	7f 0d		 jg	 SHORT $LN6@GetPickedS

; 1241 : 		{
; 1242 : 			*ppSlot = &rSlot;

  00175	8b 45 08	 mov	 eax, DWORD PTR _ppSlot$[ebp]
  00178	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$8[ebp]
  0017b	89 08		 mov	 DWORD PTR [eax], ecx

; 1243 : 			return TRUE;

  0017d	33 c0		 xor	 eax, eax
  0017f	40		 inc	 eax
  00180	eb 07		 jmp	 SHORT $LN1@GetPickedS
$LN6@GetPickedS:

; 1244 : 		}
; 1245 : 	}

  00182	e9 c1 fe ff ff	 jmp	 $LN2@GetPickedS
$LN3@GetPickedS:

; 1246 : 
; 1247 : 	return FALSE;

  00187	33 c0		 xor	 eax, eax
$LN1@GetPickedS:

; 1248 : }

  00189	c9		 leave
  0018a	c2 04 00	 ret	 4
?GetPickedSlotPointer@CSlotWindow@UI@@MAEHPAPAUSSlot@12@@Z ENDP ; UI::CSlotWindow::GetPickedSlotPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?GetSelectedSlotPointer@CSlotWindow@UI@@IAEHPAPAUSSlot@12@@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
$T4 = -44						; size = 4
___param0$ = -40					; size = 4
_ly$ = -36						; size = 4
_lx$ = -32						; size = 4
tv184 = -28						; size = 4
tv208 = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_itor$5 = -12						; size = 4
_rSlot$6 = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
_ppSlot$ = 8						; size = 4
?GetSelectedSlotPointer@CSlotWindow@UI@@IAEHPAPAUSSlot@12@@Z PROC ; UI::CSlotWindow::GetSelectedSlotPointer, COMDAT
; _this$ = ecx

; 1192 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1193 : 	long lx, ly;
; 1194 : 	GetMouseLocalPosition(lx, ly);

  00009	8d 45 dc	 lea	 eax, DWORD PTR _ly$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 e0	 lea	 eax, DWORD PTR _lx$[ebp]
  00010	50		 push	 eax
  00011	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?GetMouseLocalPosition@CWindow@UI@@QAEXAAJ0@Z ; UI::CWindow::GetMouseLocalPosition

; 1196 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00019	8d 45 f4	 lea	 eax, DWORD PTR _itor$5[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00026	e8 00 00 00 00	 call	 ?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
  0002b	eb 08		 jmp	 SHORT $LN4@GetSelecte
$LN2@GetSelecte:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR _itor$5[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 f4	 mov	 DWORD PTR _itor$5[ebp], eax
$LN4@GetSelecte:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1196 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00035	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0003d	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00040	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00046	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 00		 mov	 eax, DWORD PTR [eax]
  0004b	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0004e	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T4[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00054	8d 45 d4	 lea	 eax, DWORD PTR $T4[ebp]
  00057	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0005a	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	8b 4d f4	 mov	 ecx, DWORD PTR _itor$5[ebp]
  00060	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00062	75 09		 jne	 SHORT $LN59@GetSelecte
  00064	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv208[ebp], 1
  0006b	eb 04		 jmp	 SHORT $LN60@GetSelecte
$LN59@GetSelecte:
  0006d	83 65 e8 00	 and	 DWORD PTR tv208[ebp], 0
$LN60@GetSelecte:
  00071	8a 45 e8	 mov	 al, BYTE PTR tv208[ebp]
  00074	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 203  :         return !(*this == _Right);

  00077	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0007b	85 c0		 test	 eax, eax
  0007d	75 09		 jne	 SHORT $LN54@GetSelecte
  0007f	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv184[ebp], 1
  00086	eb 04		 jmp	 SHORT $LN55@GetSelecte
$LN54@GetSelecte:
  00088	83 65 e4 00	 and	 DWORD PTR tv184[ebp], 0
$LN55@GetSelecte:
  0008c	8a 45 e4	 mov	 al, BYTE PTR tv184[ebp]
  0008f	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1196 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00092	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00096	85 c0		 test	 eax, eax
  00098	74 59		 je	 SHORT $LN3@GetSelecte
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0009a	8b 45 f4	 mov	 eax, DWORD PTR _itor$5[ebp]
  0009d	83 c0 08	 add	 eax, 8
  000a0	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000a3	8b 45 cc	 mov	 eax, DWORD PTR $T2[ebp]
  000a6	89 45 f8	 mov	 DWORD PTR _rSlot$6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1200 : 		if (lx >= rSlot.ixPosition)

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$6[ebp]
  000ac	8b 4d e0	 mov	 ecx, DWORD PTR _lx$[ebp]
  000af	3b 48 20	 cmp	 ecx, DWORD PTR [eax+32]
  000b2	7c 3a		 jl	 SHORT $LN5@GetSelecte

; 1201 : 		if (ly >= rSlot.iyPosition)

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$6[ebp]
  000b7	8b 4d dc	 mov	 ecx, DWORD PTR _ly$[ebp]
  000ba	3b 48 24	 cmp	 ecx, DWORD PTR [eax+36]
  000bd	7c 2f		 jl	 SHORT $LN5@GetSelecte

; 1202 : 		if (lx <= rSlot.ixPosition + rSlot.ixCellSize)

  000bf	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$6[ebp]
  000c2	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000c5	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  000c8	03 41 28	 add	 eax, DWORD PTR [ecx+40]
  000cb	39 45 e0	 cmp	 DWORD PTR _lx$[ebp], eax
  000ce	7f 1e		 jg	 SHORT $LN5@GetSelecte

; 1203 : 		if (ly <= rSlot.iyPosition + rSlot.iyCellSize)

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$6[ebp]
  000d3	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  000d6	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  000d9	03 41 2c	 add	 eax, DWORD PTR [ecx+44]
  000dc	39 45 dc	 cmp	 DWORD PTR _ly$[ebp], eax
  000df	7f 0d		 jg	 SHORT $LN5@GetSelecte

; 1204 : 		{
; 1205 : 			*ppSlot = &rSlot;

  000e1	8b 45 08	 mov	 eax, DWORD PTR _ppSlot$[ebp]
  000e4	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  000e7	89 08		 mov	 DWORD PTR [eax], ecx

; 1206 : 			return TRUE;

  000e9	33 c0		 xor	 eax, eax
  000eb	40		 inc	 eax
  000ec	eb 07		 jmp	 SHORT $LN1@GetSelecte
$LN5@GetSelecte:

; 1207 : 		}
; 1208 : 	}

  000ee	e9 3a ff ff ff	 jmp	 $LN2@GetSelecte
$LN3@GetSelecte:

; 1209 : 
; 1210 : 	return FALSE;

  000f3	33 c0		 xor	 eax, eax
$LN1@GetSelecte:

; 1211 : }

  000f5	c9		 leave
  000f6	c2 04 00	 ret	 4
?GetSelectedSlotPointer@CSlotWindow@UI@@IAEHPAPAUSSlot@12@@Z ENDP ; UI::CSlotWindow::GetSelectedSlotPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
___param0$ = -32					; size = 4
_rSlot$5 = -28						; size = 4
tv167 = -24						; size = 4
tv191 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_itor$6 = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
_dwIndex$ = 8						; size = 4
_ppSlot$ = 12						; size = 4
?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z PROC ; UI::CSlotWindow::GetSlotPointer, COMDAT
; _this$ = ecx

; 1176 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1177 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00009	8d 45 f8	 lea	 eax, DWORD PTR _itor$6[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00016	e8 00 00 00 00	 call	 ?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
  0001b	eb 08		 jmp	 SHORT $LN4@GetSlotPoi
$LN2@GetSlotPoi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _itor$6[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 45 f8	 mov	 DWORD PTR _itor$6[ebp], eax
$LN4@GetSlotPoi:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1177 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00025	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00028	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0003e	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00044	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00047	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0004a	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _itor$6[ebp]
  00050	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00052	75 09		 jne	 SHORT $LN56@GetSlotPoi
  00054	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv191[ebp], 1
  0005b	eb 04		 jmp	 SHORT $LN57@GetSlotPoi
$LN56@GetSlotPoi:
  0005d	83 65 ec 00	 and	 DWORD PTR tv191[ebp], 0
$LN57@GetSlotPoi:
  00061	8a 45 ec	 mov	 al, BYTE PTR tv191[ebp]
  00064	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 203  :         return !(*this == _Right);

  00067	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN51@GetSlotPoi
  0006f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv167[ebp], 1
  00076	eb 04		 jmp	 SHORT $LN52@GetSlotPoi
$LN51@GetSlotPoi:
  00078	83 65 e8 00	 and	 DWORD PTR tv167[ebp], 0
$LN52@GetSlotPoi:
  0007c	8a 45 e8	 mov	 al, BYTE PTR tv167[ebp]
  0007f	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1177 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00082	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00086	85 c0		 test	 eax, eax
  00088	74 2c		 je	 SHORT $LN3@GetSlotPoi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _itor$6[ebp]
  0008d	83 c0 08	 add	 eax, 8
  00090	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00093	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00096	89 45 e4	 mov	 DWORD PTR _rSlot$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1181 : 		if (dwIndex == rSlot.dwSlotNumber)

  00099	8b 45 e4	 mov	 eax, DWORD PTR _rSlot$5[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0009f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000a2	75 0d		 jne	 SHORT $LN5@GetSlotPoi

; 1182 : 		{
; 1183 : 			*ppSlot = &rSlot;

  000a4	8b 45 0c	 mov	 eax, DWORD PTR _ppSlot$[ebp]
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR _rSlot$5[ebp]
  000aa	89 08		 mov	 DWORD PTR [eax], ecx

; 1184 : 			return TRUE;

  000ac	33 c0		 xor	 eax, eax
  000ae	40		 inc	 eax
  000af	eb 07		 jmp	 SHORT $LN1@GetSlotPoi
$LN5@GetSlotPoi:

; 1185 : 		}
; 1186 : 	}

  000b1	e9 67 ff ff ff	 jmp	 $LN2@GetSlotPoi
$LN3@GetSlotPoi:

; 1187 : 
; 1188 : 	return FALSE;

  000b6	33 c0		 xor	 eax, eax
$LN1@GetSlotPoi:

; 1189 : }

  000b8	c9		 leave
  000b9	c2 08 00	 ret	 8
?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ENDP ; UI::CSlotWindow::GetSlotPointer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnUseSlot@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
?OnUseSlot@CSlotWindow@UI@@IAEXXZ PROC			; UI::CSlotWindow::OnUseSlot, COMDAT
; _this$ = ecx

; 906  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 907  : 	TSlot * pSlot;
; 908  : 	if (GetPickedSlotPointer(&pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 90 9c 00 00
	00		 call	 DWORD PTR [eax+156]
  0001a	85 c0		 test	 eax, eax
  0001c	74 30		 je	 SHORT $LN1@OnUseSlot

; 909  : 	if (pSlot->isItem)

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00021	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00025	74 27		 je	 SHORT $LN1@OnUseSlot

; 910  : 	{
; 911  : 		PyCallClassMemberFunc(m_poHandler, "OnUseSlot", Py_BuildValue("(i)", pSlot->dwSlotNumber));

  00027	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002a	ff 70 04	 push	 DWORD PTR [eax+4]
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ@
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
  0003a	50		 push	 eax
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_09HJIBPFCA@OnUseSlot@
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	ff 70 5c	 push	 DWORD PTR [eax+92]
  00046	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@OnUseSlot:

; 912  : 	}
; 913  : }

  0004e	c9		 leave
  0004f	c3		 ret	 0
?OnUseSlot@CSlotWindow@UI@@IAEXXZ ENDP			; UI::CSlotWindow::OnUseSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnUnselectItemSlot@CSlotWindow@UI@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iSlotNumber$ = 8					; size = 4
?OnUnselectItemSlot@CSlotWindow@UI@@IAEXH@Z PROC	; UI::CSlotWindow::OnUnselectItemSlot, COMDAT
; _this$ = ecx

; 902  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 903  : 	PyCallClassMemberFunc(m_poHandler, "OnUnselectItemSlot", Py_BuildValue("(i)", iSlotNumber));

  00007	ff 75 08	 push	 DWORD PTR _iSlotNumber$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ@
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EONLJJMO@OnUnselectItemSlot@
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	ff 70 5c	 push	 DWORD PTR [eax+92]
  00023	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 904  : }

  0002b	c9		 leave
  0002c	c2 04 00	 ret	 4
?OnUnselectItemSlot@CSlotWindow@UI@@IAEXH@Z ENDP	; UI::CSlotWindow::OnUnselectItemSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnUnselectEmptySlot@CSlotWindow@UI@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iSlotNumber$ = 8					; size = 4
?OnUnselectEmptySlot@CSlotWindow@UI@@IAEXH@Z PROC	; UI::CSlotWindow::OnUnselectEmptySlot, COMDAT
; _this$ = ecx

; 898  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 899  : 	PyCallClassMemberFunc(m_poHandler, "OnUnselectEmptySlot", Py_BuildValue("(i)", iSlotNumber));

  00007	ff 75 08	 push	 DWORD PTR _iSlotNumber$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ@
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@GMADJAFC@OnUnselectEmptySlot@
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	ff 70 5c	 push	 DWORD PTR [eax+92]
  00023	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 900  : }

  0002b	c9		 leave
  0002c	c2 04 00	 ret	 4
?OnUnselectEmptySlot@CSlotWindow@UI@@IAEXH@Z ENDP	; UI::CSlotWindow::OnUnselectEmptySlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnSelectItemSlot@CSlotWindow@UI@@IAEXH@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_iSlotNumber$ = 8					; size = 4
?OnSelectItemSlot@CSlotWindow@UI@@IAEXH@Z PROC		; UI::CSlotWindow::OnSelectItemSlot, COMDAT
; _this$ = ecx

; 890  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 891  : //	OnOverOutItem();
; 892  : 	PyCallClassMemberFunc(m_poHandler, "OnSelectItemSlot", Py_BuildValue("(i)", iSlotNumber));

  00008	ff 75 08	 push	 DWORD PTR _iSlotNumber$[ebp]
  0000b	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ@
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx
  00018	50		 push	 eax
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@PFHJJJ@OnSelectItemSlot@
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	ff 70 5c	 push	 DWORD PTR [eax+92]
  00024	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00031	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 894  : 	if (UI::CWindowManager::Instance().IsAttaching())

  00034	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00037	e8 00 00 00 00	 call	 ?IsAttaching@CWindowManager@UI@@QAEHXZ ; UI::CWindowManager::IsAttaching
  0003c	85 c0		 test	 eax, eax
  0003e	74 08		 je	 SHORT $LN1@OnSelectIt

; 895  : 		OnOverOutItem();

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?OnOverOutItem@CSlotWindow@UI@@QAEXXZ ; UI::CSlotWindow::OnOverOutItem
$LN1@OnSelectIt:

; 896  : }

  00048	c9		 leave
  00049	c2 04 00	 ret	 4
?OnSelectItemSlot@CSlotWindow@UI@@IAEXH@Z ENDP		; UI::CSlotWindow::OnSelectItemSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnSelectEmptySlot@CSlotWindow@UI@@IAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iSlotNumber$ = 8					; size = 4
?OnSelectEmptySlot@CSlotWindow@UI@@IAEXH@Z PROC		; UI::CSlotWindow::OnSelectEmptySlot, COMDAT
; _this$ = ecx

; 886  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  : 	PyCallClassMemberFunc(m_poHandler, "OnSelectEmptySlot", Py_BuildValue("(i)", iSlotNumber));

  00007	ff 75 08	 push	 DWORD PTR _iSlotNumber$[ebp]
  0000a	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ@
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx
  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@JJECHKOF@OnSelectEmptySlot@
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	ff 70 5c	 push	 DWORD PTR [eax+92]
  00023	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 888  : }

  0002b	c9		 leave
  0002c	c2 04 00	 ret	 4
?OnSelectEmptySlot@CSlotWindow@UI@@IAEXH@Z ENDP		; UI::CSlotWindow::OnSelectEmptySlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnRenderSelectedSlot@CSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
___param0$ = -32					; size = 4
tv231 = -28						; size = 4
tv255 = -24						; size = 4
_this$ = -20						; size = 4
_itor$ = -16						; size = 4
_pSlot$6 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
?OnRenderSelectedSlot@CSlotWindow@UI@@MAEXXZ PROC	; UI::CSlotWindow::OnRenderSelectedSlot, COMDAT
; _this$ = ecx

; 1137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1138 : 	std::list<DWORD>::iterator itor = m_dwSelectedSlotIndexList.begin();

  00009	8d 45 f0	 lea	 eax, DWORD PTR _itor$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00016	e8 00 00 00 00	 call	 ?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::begin

; 1139 : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  0001b	eb 08		 jmp	 SHORT $LN25@OnRenderSe
$LN2@OnRenderSe:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0001d	8b 45 f0	 mov	 eax, DWORD PTR _itor$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 45 f0	 mov	 DWORD PTR _itor$[ebp], eax
$LN25@OnRenderSe:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1139 : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  00025	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0002d	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00030	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0003e	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00044	8d 45 dc	 lea	 eax, DWORD PTR $T5[ebp]
  00047	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0004a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _itor$[ebp]
  00050	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00052	75 09		 jne	 SHORT $LN56@OnRenderSe
  00054	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv255[ebp], 1
  0005b	eb 04		 jmp	 SHORT $LN57@OnRenderSe
$LN56@OnRenderSe:
  0005d	83 65 e8 00	 and	 DWORD PTR tv255[ebp], 0
$LN57@OnRenderSe:
  00061	8a 45 e8	 mov	 al, BYTE PTR tv255[ebp]
  00064	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 203  :         return !(*this == _Right);

  00067	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN51@OnRenderSe
  0006f	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv231[ebp], 1
  00076	eb 04		 jmp	 SHORT $LN52@OnRenderSe
$LN51@OnRenderSe:
  00078	83 65 e4 00	 and	 DWORD PTR tv231[ebp], 0
$LN52@OnRenderSe:
  0007c	8a 45 e4	 mov	 al, BYTE PTR tv231[ebp]
  0007f	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1139 : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  00082	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00086	85 c0		 test	 eax, eax
  00088	0f 84 e9 00 00
	00		 je	 $LN3@OnRenderSe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0008e	8b 45 f0	 mov	 eax, DWORD PTR _itor$[ebp]
  00091	83 c0 08	 add	 eax, 8
  00094	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00097	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0009a	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1142 : 		if (!GetSlotPointer(*itor, &pSlot))

  0009d	8d 45 f4	 lea	 eax, DWORD PTR _pSlot$6[ebp]
  000a0	50		 push	 eax
  000a1	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  000a4	ff 30		 push	 DWORD PTR [eax]
  000a6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  000ae	85 c0		 test	 eax, eax
  000b0	75 05		 jne	 SHORT $LN5@OnRenderSe

; 1143 : 			continue;

  000b2	e9 66 ff ff ff	 jmp	 $LN2@OnRenderSe
$LN5@OnRenderSe:

; 1144 : 
; 1145 : 		CPythonGraphic::Instance().SetDiffuseColor(1.0f, 1.0f, 1.0f, 0.5f);

  000b7	51		 push	 ecx
  000b8	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c5	51		 push	 ecx
  000c6	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ce	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d3	51		 push	 ecx
  000d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e1	51		 push	 ecx
  000e2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  000ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  000f5	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor

; 1146 : 		CPythonGraphic::Instance().RenderBar2d(m_rect.left + pSlot->ixPosition,

  000fa	51		 push	 ecx
  000fb	0f 57 c0	 xorps	 xmm0, xmm0
  000fe	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00103	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00106	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00109	8b 4d f4	 mov	 ecx, DWORD PTR _pSlot$6[ebp]
  0010c	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  0010f	8b 4d f4	 mov	 ecx, DWORD PTR _pSlot$6[ebp]
  00112	03 41 2c	 add	 eax, DWORD PTR [ecx+44]
  00115	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00119	51		 push	 ecx
  0011a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0011f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00122	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00125	8b 4d f4	 mov	 ecx, DWORD PTR _pSlot$6[ebp]
  00128	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  0012b	8b 4d f4	 mov	 ecx, DWORD PTR _pSlot$6[ebp]
  0012e	03 41 28	 add	 eax, DWORD PTR [ecx+40]
  00131	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00135	51		 push	 ecx
  00136	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0013b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0013e	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00141	8b 4d f4	 mov	 ecx, DWORD PTR _pSlot$6[ebp]
  00144	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  00147	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0014b	51		 push	 ecx
  0014c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00151	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00154	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00157	8b 4d f4	 mov	 ecx, DWORD PTR _pSlot$6[ebp]
  0015a	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  0015d	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00161	51		 push	 ecx
  00162	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00167	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  0016d	e8 00 00 00 00	 call	 ?RenderBar2d@CScreen@@QAEXMMMMM@Z ; CScreen::RenderBar2d

; 1147 : 												m_rect.top + pSlot->iyPosition,
; 1148 : 												m_rect.left + pSlot->ixPosition + pSlot->ixCellSize,
; 1149 : 												m_rect.top + pSlot->iyPosition + pSlot->iyCellSize);
; 1150 : 	}

  00172	e9 a6 fe ff ff	 jmp	 $LN2@OnRenderSe
$LN3@OnRenderSe:

; 1151 : }

  00177	c9		 leave
  00178	c3		 ret	 0
?OnRenderSelectedSlot@CSlotWindow@UI@@MAEXXZ ENDP	; UI::CSlotWindow::OnRenderSelectedSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnRenderPickingSlot@CSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
?OnRenderPickingSlot@CSlotWindow@UI@@MAEXXZ PROC	; UI::CSlotWindow::OnRenderPickingSlot, COMDAT
; _this$ = ecx

; 1121 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0000e	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1122 : 	if (!UI::CWindowManager::Instance().IsAttaching())

  00011	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00014	e8 00 00 00 00	 call	 ?IsAttaching@CWindowManager@UI@@QAEHXZ ; UI::CWindowManager::IsAttaching
  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $LN2@OnRenderPi

; 1123 : 		return;

  0001d	e9 d0 00 00 00	 jmp	 $LN1@OnRenderPi
$LN2@OnRenderPi:

; 1124 : 
; 1125 : 	TSlot * pSlot;
; 1126 : 	if (!GetSelectedSlotPointer(&pSlot))

  00022	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  00025	50		 push	 eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?GetSelectedSlotPointer@CSlotWindow@UI@@IAEHPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSelectedSlotPointer
  0002e	85 c0		 test	 eax, eax
  00030	75 05		 jne	 SHORT $LN3@OnRenderPi

; 1127 : 		return;

  00032	e9 bb 00 00 00	 jmp	 $LN1@OnRenderPi
$LN3@OnRenderPi:

; 1128 : 
; 1129 : 	CPythonGraphic::Instance().SetDiffuseColor(1.0f, 1.0f, 1.0f, 0.5f);

  00037	51		 push	 ecx
  00038	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00040	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00045	51		 push	 ecx
  00046	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0004e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00053	51		 push	 ecx
  00054	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0005c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00061	51		 push	 ecx
  00062	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0006a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0006f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  00075	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor

; 1130 : 	CPythonGraphic::Instance().RenderBar2d(m_rect.left + pSlot->ixPosition,

  0007a	51		 push	 ecx
  0007b	0f 57 c0	 xorps	 xmm0, xmm0
  0007e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00083	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00086	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00089	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  0008c	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00092	03 41 2c	 add	 eax, DWORD PTR [ecx+44]
  00095	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00099	51		 push	 ecx
  0009a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  000a8	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  000ae	03 41 28	 add	 eax, DWORD PTR [ecx+40]
  000b1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000b5	51		 push	 ecx
  000b6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000bb	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000be	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  000c1	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  000c4	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  000c7	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000cb	51		 push	 ecx
  000cc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  000d7	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  000da	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  000dd	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e1	51		 push	 ecx
  000e2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  000ed	e8 00 00 00 00	 call	 ?RenderBar2d@CScreen@@QAEXMMMMM@Z ; CScreen::RenderBar2d
$LN1@OnRenderPi:

; 1131 : 											m_rect.top + pSlot->iyPosition,
; 1132 : 											m_rect.left + pSlot->ixPosition + pSlot->ixCellSize,
; 1133 : 											m_rect.top + pSlot->iyPosition + pSlot->iyCellSize);
; 1134 : }

  000f2	c9		 leave
  000f3	c3		 ret	 0
?OnRenderPickingSlot@CSlotWindow@UI@@MAEXXZ ENDP	; UI::CSlotWindow::OnRenderPickingSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?RenderLockedSlot@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
___param0$ = -32					; size = 4
tv231 = -28						; size = 4
tv255 = -24						; size = 4
_this$ = -20						; size = 4
_itor$5 = -16						; size = 4
_this$ = -12						; size = 4
_rSlot$6 = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
?RenderLockedSlot@CSlotWindow@UI@@IAEXXZ PROC		; UI::CSlotWindow::RenderLockedSlot, COMDAT
; _this$ = ecx

; 1154 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1155 : 	CPythonGraphic::Instance().SetDiffuseColor(0.0f, 0.0f, 0.0f, 0.5f);

  00009	51		 push	 ecx
  0000a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00012	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00017	51		 push	 ecx
  00018	0f 57 c0	 xorps	 xmm0, xmm0
  0001b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00020	51		 push	 ecx
  00021	0f 57 c0	 xorps	 xmm0, xmm0
  00024	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00029	51		 push	 ecx
  0002a	0f 57 c0	 xorps	 xmm0, xmm0
  0002d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  00038	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor

; 1156 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  0003d	8d 45 f0	 lea	 eax, DWORD PTR _itor$5[ebp]
  00040	50		 push	 eax
  00041	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  0004a	e8 00 00 00 00	 call	 ?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
  0004f	eb 08		 jmp	 SHORT $LN28@RenderLock
$LN2@RenderLock:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  00051	8b 45 f0	 mov	 eax, DWORD PTR _itor$5[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	89 45 f0	 mov	 DWORD PTR _itor$5[ebp], eax
$LN28@RenderLock:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1156 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00059	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00061	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00064	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00067	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0006a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00072	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00075	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00078	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  0007b	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0007e	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  00081	8b 4d f0	 mov	 ecx, DWORD PTR _itor$5[ebp]
  00084	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00086	75 09		 jne	 SHORT $LN59@RenderLock
  00088	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv255[ebp], 1
  0008f	eb 04		 jmp	 SHORT $LN60@RenderLock
$LN59@RenderLock:
  00091	83 65 e8 00	 and	 DWORD PTR tv255[ebp], 0
$LN60@RenderLock:
  00095	8a 45 e8	 mov	 al, BYTE PTR tv255[ebp]
  00098	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 203  :         return !(*this == _Right);

  0009b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0009f	85 c0		 test	 eax, eax
  000a1	75 09		 jne	 SHORT $LN54@RenderLock
  000a3	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv231[ebp], 1
  000aa	eb 04		 jmp	 SHORT $LN55@RenderLock
$LN54@RenderLock:
  000ac	83 65 e4 00	 and	 DWORD PTR tv231[ebp], 0
$LN55@RenderLock:
  000b0	8a 45 e4	 mov	 al, BYTE PTR tv231[ebp]
  000b3	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1156 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  000b6	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  000ba	85 c0		 test	 eax, eax
  000bc	0f 84 a4 00 00
	00		 je	 $LN3@RenderLock
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _itor$5[ebp]
  000c5	83 c0 08	 add	 eax, 8
  000c8	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000cb	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  000ce	89 45 f8	 mov	 DWORD PTR _rSlot$6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1160 : 		if (!rSlot.isItem)

  000d1	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$6[ebp]
  000d4	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000d8	75 05		 jne	 SHORT $LN5@RenderLock

; 1161 : 			continue;

  000da	e9 72 ff ff ff	 jmp	 $LN2@RenderLock
$LN5@RenderLock:

; 1162 : 
; 1163 : 		if (rSlot.dwState & SLOT_STATE_LOCK)

  000df	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$6[ebp]
  000e2	8b 00		 mov	 eax, DWORD PTR [eax]
  000e4	83 e0 01	 and	 eax, 1
  000e7	74 78		 je	 SHORT $LN6@RenderLock

; 1164 : 		{
; 1165 : 			CPythonGraphic::Instance().RenderBar2d(m_rect.left + rSlot.ixPosition,

  000e9	51		 push	 ecx
  000ea	0f 57 c0	 xorps	 xmm0, xmm0
  000ed	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000f2	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  000fb	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  000fe	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  00101	03 41 2c	 add	 eax, DWORD PTR [ecx+44]
  00104	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00108	51		 push	 ecx
  00109	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00111	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00114	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  00117	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  0011d	03 41 28	 add	 eax, DWORD PTR [ecx+40]
  00120	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00124	51		 push	 ecx
  00125	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0012a	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00130	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  00133	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  00136	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0013a	51		 push	 ecx
  0013b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00140	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00143	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  00146	8b 4d f8	 mov	 ecx, DWORD PTR _rSlot$6[ebp]
  00149	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  0014c	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00150	51		 push	 ecx
  00151	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00156	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  0015c	e8 00 00 00 00	 call	 ?RenderBar2d@CScreen@@QAEXMMMMM@Z ; CScreen::RenderBar2d
$LN6@RenderLock:

; 1166 : 												   m_rect.top  + rSlot.iyPosition,
; 1167 : 												   m_rect.left + rSlot.ixPosition + rSlot.ixCellSize,
; 1168 : 												   m_rect.top  + rSlot.iyPosition + rSlot.iyCellSize);
; 1169 : 		}
; 1170 : 	}

  00161	e9 eb fe ff ff	 jmp	 $LN2@RenderLock
$LN3@RenderLock:

; 1171 : }

  00166	c9		 leave
  00167	c3		 ret	 0
?RenderLockedSlot@CSlotWindow@UI@@IAEXXZ ENDP		; UI::CSlotWindow::RenderLockedSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?RenderSlotBaseImage@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
___param0$ = -32					; size = 4
tv194 = -28						; size = 4
tv218 = -24						; size = 4
_this$ = -20						; size = 4
_rSlot$5 = -16						; size = 4
_itor$6 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
?RenderSlotBaseImage@CSlotWindow@UI@@IAEXXZ PROC	; UI::CSlotWindow::RenderSlotBaseImage, COMDAT
; _this$ = ecx

; 1104 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1105 : 	if (!m_pBaseImageInstance)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00013	75 05		 jne	 SHORT $LN5@RenderSlot

; 1106 : 		return;

  00015	e9 ed 00 00 00	 jmp	 $LN1@RenderSlot
$LN5@RenderSlot:

; 1108 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  0001a	8d 45 f4	 lea	 eax, DWORD PTR _itor$6[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00027	e8 00 00 00 00	 call	 ?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
  0002c	eb 08		 jmp	 SHORT $LN26@RenderSlot
$LN2@RenderSlot:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0002e	8b 45 f4	 mov	 eax, DWORD PTR _itor$6[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	89 45 f4	 mov	 DWORD PTR _itor$6[ebp], eax
$LN26@RenderSlot:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1108 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0003e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00041	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00044	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0004f	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00052	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00055	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00058	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0005b	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _itor$6[ebp]
  00061	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00063	75 09		 jne	 SHORT $LN57@RenderSlot
  00065	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv218[ebp], 1
  0006c	eb 04		 jmp	 SHORT $LN58@RenderSlot
$LN57@RenderSlot:
  0006e	83 65 e8 00	 and	 DWORD PTR tv218[ebp], 0
$LN58@RenderSlot:
  00072	8a 45 e8	 mov	 al, BYTE PTR tv218[ebp]
  00075	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 203  :         return !(*this == _Right);

  00078	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0007c	85 c0		 test	 eax, eax
  0007e	75 09		 jne	 SHORT $LN52@RenderSlot
  00080	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv194[ebp], 1
  00087	eb 04		 jmp	 SHORT $LN53@RenderSlot
$LN52@RenderSlot:
  00089	83 65 e4 00	 and	 DWORD PTR tv194[ebp], 0
$LN53@RenderSlot:
  0008d	8a 45 e4	 mov	 al, BYTE PTR tv194[ebp]
  00090	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1108 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00093	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00097	85 c0		 test	 eax, eax
  00099	74 6c		 je	 SHORT $LN3@RenderSlot
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0009b	8b 45 f4	 mov	 eax, DWORD PTR _itor$6[ebp]
  0009e	83 c0 08	 add	 eax, 8
  000a1	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000a4	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  000a7	89 45 f0	 mov	 DWORD PTR _rSlot$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1112 : 		if (!rSlot.bRenderBaseSlotImage)

  000aa	8b 45 f0	 mov	 eax, DWORD PTR _rSlot$5[ebp]
  000ad	0f b6 40 3c	 movzx	 eax, BYTE PTR [eax+60]
  000b1	85 c0		 test	 eax, eax
  000b3	75 05		 jne	 SHORT $LN6@RenderSlot

; 1113 : 			continue;

  000b5	e9 74 ff ff ff	 jmp	 $LN2@RenderSlot
$LN6@RenderSlot:

; 1114 : 
; 1115 : 		m_pBaseImageInstance->SetPosition(m_rect.left + rSlot.ixPosition, m_rect.top + rSlot.iyPosition);

  000ba	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  000c0	8b 4d f0	 mov	 ecx, DWORD PTR _rSlot$5[ebp]
  000c3	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  000c6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000ca	51		 push	 ecx
  000cb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d3	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  000d6	8b 4d f0	 mov	 ecx, DWORD PTR _rSlot$5[ebp]
  000d9	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  000dc	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  000e0	51		 push	 ecx
  000e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e9	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  000ef	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 1116 : 		m_pBaseImageInstance->Render();

  000f4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  000fd	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render

; 1117 : 	}

  00102	e9 27 ff ff ff	 jmp	 $LN2@RenderSlot
$LN3@RenderSlot:
$LN1@RenderSlot:

; 1118 : }

  00107	c9		 leave
  00108	c3		 ret	 0
?RenderSlotBaseImage@CSlotWindow@UI@@IAEXXZ ENDP	; UI::CSlotWindow::RenderSlotBaseImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindowManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseOver@CSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
_pSlot$1 = -16						; size = 4
_pPointWindow$ = -12					; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?OnMouseOver@CSlotWindow@UI@@MAEXXZ PROC		; UI::CSlotWindow::OnMouseOver, COMDAT
; _this$ = ecx

; 864  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0000e	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindowManager.h

; 37   : 			CWindow *	GetPointWindow()	{ return m_pPointWindow; }

  00011	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00014	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00017	89 45 f4	 mov	 DWORD PTR _pPointWindow$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 872  : 	if (this == pPointWindow)

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	3b 45 f4	 cmp	 eax, DWORD PTR _pPointWindow$[ebp]
  00020	75 2a		 jne	 SHORT $LN2@OnMouseOve

; 873  : 	{
; 874  : 		TSlot * pSlot;
; 875  : 		if (GetPickedSlotPointer(&pSlot))

  00022	8d 45 f0	 lea	 eax, DWORD PTR _pSlot$1[ebp]
  00025	50		 push	 eax
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	ff 90 9c 00 00
	00		 call	 DWORD PTR [eax+156]
  00034	85 c0		 test	 eax, eax
  00036	74 14		 je	 SHORT $LN2@OnMouseOve

; 876  : 		{
; 877  : 			if (OnOverInItem(pSlot->dwSlotNumber))

  00038	8b 45 f0	 mov	 eax, DWORD PTR _pSlot$1[ebp]
  0003b	ff 70 04	 push	 DWORD PTR [eax+4]
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?OnOverInItem@CSlotWindow@UI@@QAEHK@Z ; UI::CSlotWindow::OnOverInItem
  00046	85 c0		 test	 eax, eax
  00048	74 02		 je	 SHORT $LN2@OnMouseOve

; 878  : 				return;

  0004a	eb 08		 jmp	 SHORT $LN1@OnMouseOve
$LN2@OnMouseOve:

; 879  : 		}
; 880  : 	}
; 881  : 
; 882  : 	OnOverOutItem();

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?OnOverOutItem@CSlotWindow@UI@@QAEXXZ ; UI::CSlotWindow::OnOverOutItem
$LN1@OnMouseOve:

; 883  : }

  00054	c9		 leave
  00055	c3		 ret	 0
?OnMouseOver@CSlotWindow@UI@@MAEXXZ ENDP		; UI::CSlotWindow::OnMouseOver
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseOverOut@CSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseOverOut@CSlotWindow@UI@@MAEXXZ PROC		; UI::CSlotWindow::OnMouseOverOut, COMDAT
; _this$ = ecx

; 859  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 860  : 	OnOverOutItem();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?OnOverOutItem@CSlotWindow@UI@@QAEXXZ ; UI::CSlotWindow::OnOverOutItem

; 861  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?OnMouseOverOut@CSlotWindow@UI@@MAEXXZ ENDP		; UI::CSlotWindow::OnMouseOverOut
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseLeftButtonDoubleClick@CSlotWindow@UI@@MAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMouseLeftButtonDoubleClick@CSlotWindow@UI@@MAEHXZ PROC ; UI::CSlotWindow::OnMouseLeftButtonDoubleClick, COMDAT
; _this$ = ecx

; 852  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 853  : 	OnUseSlot();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?OnUseSlot@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::OnUseSlot

; 854  : 
; 855  : 	return TRUE;

  0000f	33 c0		 xor	 eax, eax
  00011	40		 inc	 eax

; 856  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?OnMouseLeftButtonDoubleClick@CSlotWindow@UI@@MAEHXZ ENDP ; UI::CSlotWindow::OnMouseLeftButtonDoubleClick
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseRightButtonDown@CSlotWindow@UI@@MAEHXZ
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
?OnMouseRightButtonDown@CSlotWindow@UI@@MAEHXZ PROC	; UI::CSlotWindow::OnMouseRightButtonDown, COMDAT
; _this$ = ecx

; 834  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 835  : 	TSlot * pSlot;
; 836  : 	if (!GetPickedSlotPointer(&pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 90 9c 00 00
	00		 call	 DWORD PTR [eax+156]
  0001a	85 c0		 test	 eax, eax
  0001c	75 05		 jne	 SHORT $LN2@OnMouseRig

; 837  : 		return TRUE;

  0001e	33 c0		 xor	 eax, eax
  00020	40		 inc	 eax
  00021	eb 2a		 jmp	 SHORT $LN1@OnMouseRig
$LN2@OnMouseRig:

; 838  : 
; 839  : 	if (pSlot->isItem)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00026	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0002a	74 10		 je	 SHORT $LN3@OnMouseRig

; 840  : 	{
; 841  : 		OnUnselectItemSlot(pSlot->dwSlotNumber);

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002f	ff 70 04	 push	 DWORD PTR [eax+4]
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?OnUnselectItemSlot@CSlotWindow@UI@@IAEXH@Z ; UI::CSlotWindow::OnUnselectItemSlot

; 842  : 	}

  0003a	eb 0e		 jmp	 SHORT $LN4@OnMouseRig
$LN3@OnMouseRig:

; 843  : 	else
; 844  : 	{
; 845  : 		OnUnselectEmptySlot(pSlot->dwSlotNumber);

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0003f	ff 70 04	 push	 DWORD PTR [eax+4]
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?OnUnselectEmptySlot@CSlotWindow@UI@@IAEXH@Z ; UI::CSlotWindow::OnUnselectEmptySlot
$LN4@OnMouseRig:

; 846  : 	}
; 847  : 
; 848  : 	return TRUE;

  0004a	33 c0		 xor	 eax, eax
  0004c	40		 inc	 eax
$LN1@OnMouseRig:

; 849  : }

  0004d	c9		 leave
  0004e	c3		 ret	 0
?OnMouseRightButtonDown@CSlotWindow@UI@@MAEHXZ ENDP	; UI::CSlotWindow::OnMouseRightButtonDown
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindowManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseLeftButtonUp@CSlotWindow@UI@@MAEHXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_this$ = -24						; size = 4
$T2 = -20						; size = 4
$T3 = -16						; size = 4
_pSlot$4 = -12						; size = 4
_pWin$5 = -8						; size = 4
_pSlotWin$6 = -4					; size = 4
?OnMouseLeftButtonUp@CSlotWindow@UI@@MAEHXZ PROC	; UI::CSlotWindow::OnMouseLeftButtonUp, COMDAT
; _this$ = ecx

; 800  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0000e	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 801  : 	if (UI::CWindowManager::Instance().IsAttaching())

  00011	8b 4d f0	 mov	 ecx, DWORD PTR $T3[ebp]
  00014	e8 00 00 00 00	 call	 ?IsAttaching@CWindowManager@UI@@QAEHXZ ; UI::CWindowManager::IsAttaching
  00019	85 c0		 test	 eax, eax
  0001b	0f 84 b0 00 00
	00		 je	 $LN2@OnMouseLef
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00021	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00026	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 802  : 	if (UI::CWindowManager::Instance().IsDragging())

  00029	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  0002c	e8 00 00 00 00	 call	 ?IsDragging@CWindowManager@UI@@QAEHXZ ; UI::CWindowManager::IsDragging
  00031	85 c0		 test	 eax, eax
  00033	0f 84 98 00 00
	00		 je	 $LN2@OnMouseLef

; 803  : 	if (IsIn())

  00039	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?IsIn@CWindow@UI@@QAE_NXZ ; UI::CWindow::IsIn
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	0f 84 85 00 00
	00		 je	 $LN2@OnMouseLef
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00051	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindowManager.h

; 37   : 			CWindow *	GetPointWindow()	{ return m_pPointWindow; }

  00054	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00057	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  0005a	89 45 f8	 mov	 DWORD PTR _pWin$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 807  : 		if (pWin)

  0005d	83 7d f8 00	 cmp	 DWORD PTR _pWin$5[ebp], 0
  00061	74 6a		 je	 SHORT $LN5@OnMouseLef

; 808  : 		if (pWin->IsType(UI::CSlotWindow::Type()))

  00063	e8 00 00 00 00	 call	 ?Type@CSlotWindow@UI@@SAKXZ ; UI::CSlotWindow::Type
  00068	50		 push	 eax
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _pWin$5[ebp]
  0006c	e8 00 00 00 00	 call	 ?IsType@CWindow@UI@@QAEHK@Z ; UI::CWindow::IsType
  00071	85 c0		 test	 eax, eax
  00073	74 58		 je	 SHORT $LN5@OnMouseLef

; 809  : 		{
; 810  : 			UI::CSlotWindow * pSlotWin = (UI::CSlotWindow *)pWin;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _pWin$5[ebp]
  00078	89 45 fc	 mov	 DWORD PTR _pSlotWin$6[ebp], eax

; 811  : 
; 812  : 			TSlot * pSlot;
; 813  : 			if (!pSlotWin->GetPickedSlotPointer(&pSlot))

  0007b	8d 45 f4	 lea	 eax, DWORD PTR _pSlot$4[ebp]
  0007e	50		 push	 eax
  0007f	8b 45 fc	 mov	 eax, DWORD PTR _pSlotWin$6[ebp]
  00082	8b 00		 mov	 eax, DWORD PTR [eax]
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _pSlotWin$6[ebp]
  00087	ff 90 9c 00 00
	00		 call	 DWORD PTR [eax+156]
  0008d	85 c0		 test	 eax, eax
  0008f	75 10		 jne	 SHORT $LN7@OnMouseLef

; 814  : 			{
; 815  : 				UI::CWindowManager::Instance().DeattachIcon();

  00091	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00097	e8 00 00 00 00	 call	 ?DeattachIcon@CWindowManager@UI@@QAEXXZ ; UI::CWindowManager::DeattachIcon

; 816  : 				return TRUE;

  0009c	33 c0		 xor	 eax, eax
  0009e	40		 inc	 eax
  0009f	eb 32		 jmp	 SHORT $LN1@OnMouseLef
$LN7@OnMouseLef:

; 817  : 			}
; 818  : 
; 819  : 			if (pSlot->isItem)

  000a1	8b 45 f4	 mov	 eax, DWORD PTR _pSlot$4[ebp]
  000a4	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000a8	74 10		 je	 SHORT $LN8@OnMouseLef

; 820  : 				pSlotWin->OnSelectItemSlot(pSlot->dwSlotNumber);

  000aa	8b 45 f4	 mov	 eax, DWORD PTR _pSlot$4[ebp]
  000ad	ff 70 04	 push	 DWORD PTR [eax+4]
  000b0	8b 4d fc	 mov	 ecx, DWORD PTR _pSlotWin$6[ebp]
  000b3	e8 00 00 00 00	 call	 ?OnSelectItemSlot@CSlotWindow@UI@@IAEXH@Z ; UI::CSlotWindow::OnSelectItemSlot
  000b8	eb 0e		 jmp	 SHORT $LN9@OnMouseLef
$LN8@OnMouseLef:

; 821  : 			else
; 822  : 				pSlotWin->OnSelectEmptySlot(pSlot->dwSlotNumber);

  000ba	8b 45 f4	 mov	 eax, DWORD PTR _pSlot$4[ebp]
  000bd	ff 70 04	 push	 DWORD PTR [eax+4]
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR _pSlotWin$6[ebp]
  000c3	e8 00 00 00 00	 call	 ?OnSelectEmptySlot@CSlotWindow@UI@@IAEXH@Z ; UI::CSlotWindow::OnSelectEmptySlot
$LN9@OnMouseLef:

; 823  : 
; 824  : 			return TRUE;

  000c8	33 c0		 xor	 eax, eax
  000ca	40		 inc	 eax
  000cb	eb 06		 jmp	 SHORT $LN1@OnMouseLef
$LN5@OnMouseLef:

; 825  : 		}
; 826  : 
; 827  : 		return FALSE;

  000cd	33 c0		 xor	 eax, eax
  000cf	eb 02		 jmp	 SHORT $LN1@OnMouseLef
$LN2@OnMouseLef:

; 828  : 	}
; 829  : 
; 830  : 	return FALSE;

  000d1	33 c0		 xor	 eax, eax
$LN1@OnMouseLef:

; 831  : }

  000d3	c9		 leave
  000d4	c3		 ret	 0
?OnMouseLeftButtonUp@CSlotWindow@UI@@MAEHXZ ENDP	; UI::CSlotWindow::OnMouseLeftButtonUp
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnMouseLeftButtonDown@CSlotWindow@UI@@MAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
?OnMouseLeftButtonDown@CSlotWindow@UI@@MAEHXZ PROC	; UI::CSlotWindow::OnMouseLeftButtonDown, COMDAT
; _this$ = ecx

; 779  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 780  : 	TSlot * pSlot;
; 781  : 	if (!GetPickedSlotPointer(&pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 90 9c 00 00
	00		 call	 DWORD PTR [eax+156]
  0001a	85 c0		 test	 eax, eax
  0001c	75 10		 jne	 SHORT $LN2@OnMouseLef

; 782  : 	{
; 783  : 		UI::CWindowManager::Instance().DeattachIcon();

  0001e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00024	e8 00 00 00 00	 call	 ?DeattachIcon@CWindowManager@UI@@QAEXXZ ; UI::CWindowManager::DeattachIcon

; 784  : 		return TRUE;

  00029	33 c0		 xor	 eax, eax
  0002b	40		 inc	 eax
  0002c	eb 34		 jmp	 SHORT $LN1@OnMouseLef
$LN2@OnMouseLef:

; 785  : 	}
; 786  : 
; 787  : 	if (pSlot->isItem && !(pSlot->dwState & SLOT_STATE_LOCK))

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00031	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00035	74 1a		 je	 SHORT $LN3@OnMouseLef
  00037	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	83 e0 01	 and	 eax, 1
  0003f	75 10		 jne	 SHORT $LN3@OnMouseLef

; 788  : 	{
; 789  : 		OnSelectItemSlot(pSlot->dwSlotNumber);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00044	ff 70 04	 push	 DWORD PTR [eax+4]
  00047	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?OnSelectItemSlot@CSlotWindow@UI@@IAEXH@Z ; UI::CSlotWindow::OnSelectItemSlot

; 790  : 	}

  0004f	eb 0e		 jmp	 SHORT $LN4@OnMouseLef
$LN3@OnMouseLef:

; 791  : 	else
; 792  : 	{
; 793  : 		OnSelectEmptySlot(pSlot->dwSlotNumber);

  00051	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00054	ff 70 04	 push	 DWORD PTR [eax+4]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?OnSelectEmptySlot@CSlotWindow@UI@@IAEXH@Z ; UI::CSlotWindow::OnSelectEmptySlot
$LN4@OnMouseLef:

; 794  : 	}
; 795  : 
; 796  : 	return TRUE;

  0005f	33 c0		 xor	 eax, eax
  00061	40		 inc	 eax
$LN1@OnMouseLef:

; 797  : }

  00062	c9		 leave
  00063	c3		 ret	 0
?OnMouseLeftButtonDown@CSlotWindow@UI@@MAEHXZ ENDP	; UI::CSlotWindow::OnMouseLeftButtonDown
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnRender@CSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
$T5 = -20						; size = 4
_ix$6 = -16						; size = 4
_iy$7 = -12						; size = 4
_ix$8 = -8						; size = 4
_iy$9 = -4						; size = 4
_this$ = 0						; size = 4
_fPercentage$10 = 4					; size = 4
$T11 = 8						; size = 4
_this$ = 12						; size = 4
$T12 = 16						; size = 4
$T13 = 20						; size = 4
$T14 = 24						; size = 4
___param0$ = 28						; size = 4
$T15 = 32						; size = 4
$T16 = 36						; size = 4
___param0$ = 40						; size = 4
$T17 = 44						; size = 4
$T18 = 48						; size = 4
$T19 = 52						; size = 4
$T20 = 56						; size = 4
___param0$ = 60						; size = 4
$T21 = 64						; size = 4
___param0$ = 68						; size = 4
tv614 = 72						; size = 4
tv638 = 76						; size = 4
_this$ = 80						; size = 4
_this$ = 84						; size = 4
_this$ = 88						; size = 4
_this$ = 92						; size = 4
tv66 = 96						; size = 4
_fcurTime$22 = 100					; size = 4
_itor$ = 104						; size = 4
$T23 = 110						; size = 1
$T24 = 111						; size = 1
_this$ = 112						; size = 4
_rSlot$25 = 116						; size = 4
?OnRender@CSlotWindow@UI@@MAEXXZ PROC			; UI::CSlotWindow::OnRender, COMDAT
; _this$ = ecx

; 976  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  0000b	89 4d 70	 mov	 DWORD PTR _this$[ebp], ecx

; 977  : 	RenderSlotBaseImage();

  0000e	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?RenderSlotBaseImage@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::RenderSlotBaseImage

; 978  : 
; 979  : 	switch (m_dwSlotStyle)

  00016	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 40 7c	 mov	 eax, DWORD PTR [eax+124]
  0001c	89 45 60	 mov	 DWORD PTR tv66[ebp], eax
  0001f	83 7d 60 01	 cmp	 DWORD PTR tv66[ebp], 1
  00023	74 08		 je	 SHORT $LN7@OnRender
  00025	83 7d 60 02	 cmp	 DWORD PTR tv66[ebp], 2
  00029	74 12		 je	 SHORT $LN8@OnRender
  0002b	eb 1e		 jmp	 SHORT $LN2@OnRender
$LN7@OnRender:

; 980  : 	{
; 981  : 		case SLOT_STYLE_PICK_UP:
; 982  : 			OnRenderPickingSlot();

  0002d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	ff 90 94 00 00
	00		 call	 DWORD PTR [eax+148]

; 983  : 			break;

  0003b	eb 0e		 jmp	 SHORT $LN2@OnRender
$LN8@OnRender:

; 984  : 		case SLOT_STYLE_SELECT:
; 985  : 			OnRenderSelectedSlot();

  0003d	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]
  00042	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	ff 90 98 00 00
	00		 call	 DWORD PTR [eax+152]
$LN2@OnRender:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Stl.h

; 39   : 			: _Ptr(_Pm) {}

  0004b	c7 45 34 00 00
	00 00		 mov	 DWORD PTR $T19[ebp], OFFSET ??_9CWindow@UI@@$B3AE ; UI::CWindow::`vcall'{4}'
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 989  : 	std::for_each(m_pChildList.begin(), m_pChildList.end(), std::void_mem_fun(&CWindow::OnRender));

  00052	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00055	83 c0 64	 add	 eax, 100		; 00000064H
  00058	89 45 5c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0005b	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0005e	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00061	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 00		 mov	 eax, DWORD PTR [eax]
  00066	89 45 44	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00069	8b 45 44	 mov	 eax, DWORD PTR ___param0$[ebp]
  0006c	89 45 40	 mov	 DWORD PTR $T21[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0006f	8d 45 40	 lea	 eax, DWORD PTR $T21[ebp]
  00072	89 45 30	 mov	 DWORD PTR $T18[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 989  : 	std::for_each(m_pChildList.begin(), m_pChildList.end(), std::void_mem_fun(&CWindow::OnRender));

  00075	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 c0 64	 add	 eax, 100		; 00000064H
  0007b	89 45 58	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0007e	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00081	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00084	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 00		 mov	 eax, DWORD PTR [eax]
  00089	8b 00		 mov	 eax, DWORD PTR [eax]
  0008b	89 45 3c	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0008e	8b 45 3c	 mov	 eax, DWORD PTR ___param0$[ebp]
  00091	89 45 38	 mov	 DWORD PTR $T20[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00094	8d 45 38	 lea	 eax, DWORD PTR $T20[ebp]
  00097	89 45 2c	 mov	 DWORD PTR $T17[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 989  : 	std::for_each(m_pChildList.begin(), m_pChildList.end(), std::void_mem_fun(&CWindow::OnRender));

  0009a	ff 75 34	 push	 DWORD PTR $T19[ebp]
  0009d	8b 45 30	 mov	 eax, DWORD PTR $T18[ebp]
  000a0	ff 30		 push	 DWORD PTR [eax]
  000a2	8b 45 2c	 mov	 eax, DWORD PTR $T17[ebp]
  000a5	ff 30		 push	 DWORD PTR [eax]
  000a7	8d 45 e4	 lea	 eax, DWORD PTR $T3[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??$for_each@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@std@@V?$void_mem_fun_t@VCWindow@UI@@@2@@std@@YA?AV?$void_mem_fun_t@VCWindow@UI@@@0@V?$_List_iterator@V?$_List_val@U?$_List_simple_types@PAVCWindow@UI@@@std@@@std@@@0@0V10@@Z ; std::for_each<std::_List_iterator<std::_List_val<std::_List_simple_types<UI::CWindow *> > >,std::void_mem_fun_t<UI::CWindow> >
  000b0	83 c4 10	 add	 esp, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 37   :     _List_unchecked_const_iterator() noexcept : _Ptr() {}

  000b3	83 65 68 00	 and	 DWORD PTR _itor$[ebp], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1011 : 	for (itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  000b7	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	05 88 00 00 00	 add	 eax, 136		; 00000088H
  000bf	89 45 54	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000c2	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000c5	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000c8	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  000cb	8b 00		 mov	 eax, DWORD PTR [eax]
  000cd	8b 00		 mov	 eax, DWORD PTR [eax]
  000cf	89 45 28	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000d2	8b 45 28	 mov	 eax, DWORD PTR ___param0$[ebp]
  000d5	89 45 24	 mov	 DWORD PTR $T16[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000d8	8d 45 24	 lea	 eax, DWORD PTR $T16[ebp]
  000db	89 45 20	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1011 : 	for (itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  000de	8b 45 20	 mov	 eax, DWORD PTR $T15[ebp]
  000e1	8b 00		 mov	 eax, DWORD PTR [eax]
  000e3	89 45 68	 mov	 DWORD PTR _itor$[ebp], eax
  000e6	eb 08		 jmp	 SHORT $LN126@OnRender
$LN4@OnRender:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  000e8	8b 45 68	 mov	 eax, DWORD PTR _itor$[ebp]
  000eb	8b 00		 mov	 eax, DWORD PTR [eax]
  000ed	89 45 68	 mov	 DWORD PTR _itor$[ebp], eax
$LN126@OnRender:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1011 : 	for (itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  000f0	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  000f3	05 88 00 00 00	 add	 eax, 136		; 00000088H
  000f8	89 45 50	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000fb	8b 45 50	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000fe	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00101	8b 45 50	 mov	 eax, DWORD PTR _this$[ebp]
  00104	8b 00		 mov	 eax, DWORD PTR [eax]
  00106	89 45 1c	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00109	8b 45 1c	 mov	 eax, DWORD PTR ___param0$[ebp]
  0010c	89 45 18	 mov	 DWORD PTR $T14[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0010f	8d 45 18	 lea	 eax, DWORD PTR $T14[ebp]
  00112	89 45 14	 mov	 DWORD PTR $T13[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00115	8b 45 14	 mov	 eax, DWORD PTR $T13[ebp]
  00118	8b 4d 68	 mov	 ecx, DWORD PTR _itor$[ebp]
  0011b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0011d	75 09		 jne	 SHORT $LN157@OnRender
  0011f	c7 45 4c 01 00
	00 00		 mov	 DWORD PTR tv638[ebp], 1
  00126	eb 04		 jmp	 SHORT $LN158@OnRender
$LN157@OnRender:
  00128	83 65 4c 00	 and	 DWORD PTR tv638[ebp], 0
$LN158@OnRender:
  0012c	8a 45 4c	 mov	 al, BYTE PTR tv638[ebp]
  0012f	88 45 6f	 mov	 BYTE PTR $T24[ebp], al

; 203  :         return !(*this == _Right);

  00132	0f b6 45 6f	 movzx	 eax, BYTE PTR $T24[ebp]
  00136	85 c0		 test	 eax, eax
  00138	75 09		 jne	 SHORT $LN152@OnRender
  0013a	c7 45 48 01 00
	00 00		 mov	 DWORD PTR tv614[ebp], 1
  00141	eb 04		 jmp	 SHORT $LN153@OnRender
$LN152@OnRender:
  00143	83 65 48 00	 and	 DWORD PTR tv614[ebp], 0
$LN153@OnRender:
  00147	8a 45 48	 mov	 al, BYTE PTR tv614[ebp]
  0014a	88 45 6e	 mov	 BYTE PTR $T23[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1011 : 	for (itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  0014d	0f b6 45 6e	 movzx	 eax, BYTE PTR $T23[ebp]
  00151	85 c0		 test	 eax, eax
  00153	0f 84 d0 03 00
	00		 je	 $LN5@OnRender
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00159	8b 45 68	 mov	 eax, DWORD PTR _itor$[ebp]
  0015c	83 c0 08	 add	 eax, 8
  0015f	89 45 10	 mov	 DWORD PTR $T12[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00162	8b 45 10	 mov	 eax, DWORD PTR $T12[ebp]
  00165	89 45 74	 mov	 DWORD PTR _rSlot$25[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1015 : 		if (rSlot.pSlotButton)

  00168	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0016b	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  0016f	74 1d		 je	 SHORT $LN9@OnRender

; 1016 : 		{
; 1017 : 			rSlot.pSlotButton->SetPosition(rSlot.ixPosition + 1, rSlot.iyPosition + 19);

  00171	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00174	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  00177	83 c0 13	 add	 eax, 19			; 00000013H
  0017a	50		 push	 eax
  0017b	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0017e	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00181	40		 inc	 eax
  00182	50		 push	 eax
  00183	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00186	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00189	e8 00 00 00 00	 call	 ?SetPosition@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetPosition
$LN9@OnRender:

; 1018 : 		}
; 1019 : 		if (rSlot.pSignImage)

  0018e	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00191	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00195	74 1f		 je	 SHORT $LN10@OnRender

; 1020 : 		{
; 1021 : 			rSlot.pSignImage->SetPosition(rSlot.ixPosition - 7, rSlot.iyPosition + 10);

  00197	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0019a	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  0019d	83 c0 0a	 add	 eax, 10			; 0000000aH
  001a0	50		 push	 eax
  001a1	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  001a4	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  001a7	83 e8 07	 sub	 eax, 7
  001aa	50		 push	 eax
  001ab	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  001ae	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  001b1	e8 00 00 00 00	 call	 ?SetPosition@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetPosition
$LN10@OnRender:

; 1022 : 		}
; 1023 : 
; 1024 : 		if (rSlot.pInstance)

  001b6	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  001b9	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  001bd	74 42		 je	 SHORT $LN11@OnRender

; 1025 : 		{
; 1026 : 			rSlot.pInstance->SetPosition(m_rect.left + rSlot.ixPosition, m_rect.top + rSlot.iyPosition);

  001bf	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001c2	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  001c5	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  001c8	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  001cb	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001cf	51		 push	 ecx
  001d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001d5	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  001d8	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  001db	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  001de	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  001e1	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  001e5	51		 push	 ecx
  001e6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  001eb	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  001ee	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001f1	e8 00 00 00 00	 call	 ?SetPosition@CGraphicImageInstance@@QAEXMM@Z ; CGraphicImageInstance::SetPosition

; 1027 : 			rSlot.pInstance->Render();

  001f6	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  001f9	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  001fc	e8 00 00 00 00	 call	 ?Render@CGraphicImageInstance@@QAEXXZ ; CGraphicImageInstance::Render
$LN11@OnRender:

; 1028 : 		}
; 1029 : 
; 1030 : 		if (!rSlot.isItem)

  00201	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00204	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00208	75 42		 jne	 SHORT $LN12@OnRender

; 1031 : 		{
; 1032 : 			if (IS_SET(rSlot.dwState, SLOT_STATE_ALWAYS_RENDER_COVER))

  0020a	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0020d	8b 00		 mov	 eax, DWORD PTR [eax]
  0020f	83 e0 08	 and	 eax, 8
  00212	74 33		 je	 SHORT $LN166@OnRender

; 1033 : 			{
; 1034 : 				rSlot.pCoverButton->Show();

  00214	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00217	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0021a	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show

; 1035 : 				rSlot.pCoverButton->SetPosition(rSlot.ixPosition, rSlot.iyPosition);

  0021f	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00222	ff 70 24	 push	 DWORD PTR [eax+36]
  00225	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00228	ff 70 20	 push	 DWORD PTR [eax+32]
  0022b	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0022e	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00231	e8 00 00 00 00	 call	 ?SetPosition@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetPosition

; 1036 : 				rSlot.pCoverButton->RenderButton();

  00236	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00239	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  0023c	89 45 0c	 mov	 DWORD PTR _this$[ebp], eax

; 115  : 			CButton::OnRender();

  0023f	8b 4d 0c	 mov	 ecx, DWORD PTR _this$[ebp]
  00242	e8 00 00 00 00	 call	 ?OnRender@CButton@UI@@MAEXXZ ; UI::CButton::OnRender
$LN166@OnRender:

; 1037 : 			}
; 1038 : 
; 1039 : 			continue;

  00247	e9 9c fe ff ff	 jmp	 $LN4@OnRender
$LN12@OnRender:

; 1040 : 		}
; 1041 : 
; 1042 : 		if (IS_SET(rSlot.dwState, SLOT_STATE_DISABLE))

  0024c	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0024f	8b 00		 mov	 eax, DWORD PTR [eax]
  00251	83 e0 04	 and	 eax, 4
  00254	0f 84 b1 00 00
	00		 je	 $LN14@OnRender

; 1043 : 		{
; 1044 : 			CPythonGraphic::Instance().SetDiffuseColor(1.0f, 0.0f, 0.0f, 0.3f);

  0025a	51		 push	 ecx
  0025b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e99999a
  00263	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00268	51		 push	 ecx
  00269	0f 57 c0	 xorps	 xmm0, xmm0
  0026c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00271	51		 push	 ecx
  00272	0f 57 c0	 xorps	 xmm0, xmm0
  00275	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0027a	51		 push	 ecx
  0027b	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00283	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00288	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  0028e	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor

; 1045 : 			CPythonGraphic::Instance().RenderBar2d(m_rect.left + rSlot.ixPosition,

  00293	51		 push	 ecx
  00294	0f 57 c0	 xorps	 xmm0, xmm0
  00297	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0029c	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0029f	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  002a2	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  002a5	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  002a8	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  002ab	03 41 2c	 add	 eax, DWORD PTR [ecx+44]
  002ae	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002b2	51		 push	 ecx
  002b3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002b8	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002bb	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  002be	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  002c1	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  002c4	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  002c7	03 41 28	 add	 eax, DWORD PTR [ecx+40]
  002ca	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002ce	51		 push	 ecx
  002cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002d7	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  002da	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  002dd	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  002e0	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002e4	51		 push	 ecx
  002e5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ea	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  002ed	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  002f0	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  002f3	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  002f6	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  002fa	51		 push	 ecx
  002fb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00300	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  00306	e8 00 00 00 00	 call	 ?RenderBar2d@CScreen@@QAEXMMMMM@Z ; CScreen::RenderBar2d
$LN14@OnRender:

; 1046 : 				m_rect.top + rSlot.iyPosition,
; 1047 : 				m_rect.left + rSlot.ixPosition + rSlot.ixCellSize,
; 1048 : 				m_rect.top + rSlot.iyPosition + rSlot.iyCellSize);
; 1049 : 		}
; 1050 : 
; 1051 : 		if (rSlot.fCoolTime != 0.0f)

  0030b	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0030e	f3 0f 10 40 14	 movss	 xmm0, DWORD PTR [eax+20]
  00313	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  0031a	9f		 lahf
  0031b	f6 c4 44	 test	 ah, 68			; 00000044H
  0031e	0f 8b e6 00 00
	00		 jnp	 $LN16@OnRender
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00324	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00329	89 45 08	 mov	 DWORD PTR $T11[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1053 : 			float fcurTime = CTimer::Instance().GetCurrentSecond();

  0032c	8b 4d 08	 mov	 ecx, DWORD PTR $T11[ebp]
  0032f	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  00334	d9 5d 64	 fstp	 DWORD PTR _fcurTime$22[ebp]

; 1054 : 			float fPercentage = (fcurTime - rSlot.fStartCoolTime) / rSlot.fCoolTime;

  00337	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0033a	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _fcurTime$22[ebp]
  0033f	f3 0f 5c 40 18	 subss	 xmm0, DWORD PTR [eax+24]
  00344	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00347	f3 0f 5e 40 14	 divss	 xmm0, DWORD PTR [eax+20]
  0034c	f3 0f 11 45 04	 movss	 DWORD PTR _fPercentage$10[ebp], xmm0

; 1055 : 			CPythonGraphic::Instance().RenderCoolTimeBox(m_rect.left + rSlot.ixPosition + 16.0f, m_rect.top + rSlot.iyPosition + 16.0f, 16.0f, fPercentage);

  00351	51		 push	 ecx
  00352	f3 0f 10 45 04	 movss	 xmm0, DWORD PTR _fPercentage$10[ebp]
  00357	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0035c	51		 push	 ecx
  0035d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@41800000
  00365	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0036a	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0036d	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00370	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  00373	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  00376	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0037a	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@41800000
  00382	51		 push	 ecx
  00383	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00388	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0038b	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  0038e	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  00391	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  00394	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00398	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@41800000
  003a0	51		 push	 ecx
  003a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003a6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonGraphic@@@@0PAVCPythonGraphic@@A ; CSingleton<CPythonGraphic>::ms_singleton
  003ac	e8 00 00 00 00	 call	 ?RenderCoolTimeBox@CPythonGraphic@@QAEXMMMM@Z ; CPythonGraphic::RenderCoolTimeBox

; 1056 : 
; 1057 : 			if (fcurTime - rSlot.fStartCoolTime >= rSlot.fCoolTime)

  003b1	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  003b4	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _fcurTime$22[ebp]
  003b9	f3 0f 5c 40 18	 subss	 xmm0, DWORD PTR [eax+24]
  003be	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  003c1	0f 2f 40 14	 comiss	 xmm0, DWORD PTR [eax+20]
  003c5	72 43		 jb	 SHORT $LN16@OnRender

; 1058 : 			{
; 1059 : 				//   1 ..
; 1060 : 				if ((fcurTime - rSlot.fStartCoolTime) - rSlot.fCoolTime < 1.0f)

  003c7	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  003ca	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _fcurTime$22[ebp]
  003cf	f3 0f 5c 40 18	 subss	 xmm0, DWORD PTR [eax+24]
  003d4	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  003d7	f3 0f 5c 40 14	 subss	 xmm0, DWORD PTR [eax+20]
  003dc	f3 0f 10 0d 00
	00 00 00	 movss	 xmm1, DWORD PTR __real@3f800000
  003e4	0f 2f c8	 comiss	 xmm1, xmm0
  003e7	76 0b		 jbe	 SHORT $LN17@OnRender

; 1061 : 					__CreateFinishCoolTimeEffect(&rSlot);

  003e9	ff 75 74	 push	 DWORD PTR _rSlot$25[ebp]
  003ec	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  003ef	e8 00 00 00 00	 call	 ?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::__CreateFinishCoolTimeEffect
$LN17@OnRender:

; 1062 : 
; 1063 : 				rSlot.fCoolTime = 0.0f;

  003f4	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  003f7	0f 57 c0	 xorps	 xmm0, xmm0
  003fa	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0

; 1064 : 				rSlot.fStartCoolTime = 0.0f;

  003ff	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00402	0f 57 c0	 xorps	 xmm0, xmm0
  00405	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
$LN16@OnRender:

; 1065 : 			}
; 1066 : 		}
; 1067 : 
; 1068 : 		if (rSlot.pCoverButton)

  0040a	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0040d	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00411	74 28		 je	 SHORT $LN176@OnRender

; 1069 : 		{
; 1070 : 			rSlot.pCoverButton->SetPosition(rSlot.ixPosition, rSlot.iyPosition);

  00413	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00416	ff 70 24	 push	 DWORD PTR [eax+36]
  00419	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0041c	ff 70 20	 push	 DWORD PTR [eax+32]
  0041f	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00422	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00425	e8 00 00 00 00	 call	 ?SetPosition@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetPosition

; 1071 : 			rSlot.pCoverButton->RenderButton();

  0042a	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0042d	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  00430	89 45 00	 mov	 DWORD PTR _this$[ebp], eax

; 115  : 			CButton::OnRender();

  00433	8b 4d 00	 mov	 ecx, DWORD PTR _this$[ebp]
  00436	e8 00 00 00 00	 call	 ?OnRender@CButton@UI@@MAEXXZ ; UI::CButton::OnRender
$LN176@OnRender:

; 1072 : 		}
; 1073 : 
; 1074 : 		if (rSlot.pNumberLine)

  0043b	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0043e	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00442	74 55		 je	 SHORT $LN19@OnRender

; 1075 : 		{
; 1076 : 			int ix = rSlot.byxPlacedItemSize*ITEM_WIDTH + rSlot.ixPosition - 4;

  00444	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00447	0f b6 40 30	 movzx	 eax, BYTE PTR [eax+48]
  0044b	c1 e0 05	 shl	 eax, 5
  0044e	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  00451	8b 49 20	 mov	 ecx, DWORD PTR [ecx+32]
  00454	8d 44 08 fc	 lea	 eax, DWORD PTR [eax+ecx-4]
  00458	89 45 f8	 mov	 DWORD PTR _ix$8[ebp], eax

; 1077 : 			int iy = rSlot.iyPosition + rSlot.byyPlacedItemSize*ITEM_HEIGHT - 12 + 2;

  0045b	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0045e	0f b6 40 31	 movzx	 eax, BYTE PTR [eax+49]
  00462	c1 e0 05	 shl	 eax, 5
  00465	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  00468	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  0046b	8d 44 01 f6	 lea	 eax, DWORD PTR [ecx+eax-10]
  0046f	89 45 fc	 mov	 DWORD PTR _iy$9[ebp], eax

; 1078 : 			rSlot.pNumberLine->SetPosition(ix, iy);

  00472	ff 75 fc	 push	 DWORD PTR _iy$9[ebp]
  00475	ff 75 f8	 push	 DWORD PTR _ix$8[ebp]
  00478	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0047b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0047e	e8 00 00 00 00	 call	 ?SetPosition@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetPosition

; 1079 : 			rSlot.pNumberLine->Update();

  00483	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00486	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00489	e8 00 00 00 00	 call	 ?Update@CWindow@UI@@QAEXXZ ; UI::CWindow::Update

; 1080 : 			rSlot.pNumberLine->Render();

  0048e	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  00491	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00494	e8 00 00 00 00	 call	 ?Render@CWindow@UI@@QAEXXZ ; UI::CWindow::Render
$LN19@OnRender:

; 1081 : 		}
; 1082 : 
; 1083 : 		if (rSlot.pFinishCoolTimeEffect)

  00499	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  0049c	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  004a0	74 2d		 je	 SHORT $LN20@OnRender

; 1084 : 		{
; 1085 : 			rSlot.pFinishCoolTimeEffect->SetPosition(rSlot.ixPosition, rSlot.iyPosition);

  004a2	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  004a5	ff 70 24	 push	 DWORD PTR [eax+36]
  004a8	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  004ab	ff 70 20	 push	 DWORD PTR [eax+32]
  004ae	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  004b1	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  004b4	e8 00 00 00 00	 call	 ?SetPosition@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetPosition

; 1086 : 			rSlot.pFinishCoolTimeEffect->Update();

  004b9	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  004bc	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  004bf	e8 00 00 00 00	 call	 ?Update@CWindow@UI@@QAEXXZ ; UI::CWindow::Update

; 1087 : 			rSlot.pFinishCoolTimeEffect->Render();

  004c4	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  004c7	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  004ca	e8 00 00 00 00	 call	 ?Render@CWindow@UI@@QAEXXZ ; UI::CWindow::Render
$LN20@OnRender:

; 1088 : 		}
; 1089 : 
; 1090 : 		if (rSlot.bActive)

  004cf	8b 45 74	 mov	 eax, DWORD PTR _rSlot$25[ebp]
  004d2	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  004d6	74 4c		 je	 SHORT $LN22@OnRender

; 1091 : 		if (m_pSlotActiveEffect)

  004d8	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  004db	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  004e2	74 40		 je	 SHORT $LN22@OnRender

; 1092 : 		{
; 1093 : 			int ix = m_rect.left + rSlot.ixPosition;

  004e4	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  004e7	8b 40 34	 mov	 eax, DWORD PTR [eax+52]
  004ea	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  004ed	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  004f0	89 45 f0	 mov	 DWORD PTR _ix$6[ebp], eax

; 1094 : 			int iy = m_rect.top + rSlot.iyPosition;

  004f3	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  004f6	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  004f9	8b 4d 74	 mov	 ecx, DWORD PTR _rSlot$25[ebp]
  004fc	03 41 24	 add	 eax, DWORD PTR [ecx+36]
  004ff	89 45 f4	 mov	 DWORD PTR _iy$7[ebp], eax

; 1095 : 			m_pSlotActiveEffect->SetPosition(ix, iy);

  00502	ff 75 f4	 push	 DWORD PTR _iy$7[ebp]
  00505	ff 75 f0	 push	 DWORD PTR _ix$6[ebp]
  00508	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  0050b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00511	e8 00 00 00 00	 call	 ?SetPosition@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetPosition

; 1096 : 			m_pSlotActiveEffect->Render();

  00516	8b 45 70	 mov	 eax, DWORD PTR _this$[ebp]
  00519	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0051f	e8 00 00 00 00	 call	 ?Render@CWindow@UI@@QAEXXZ ; UI::CWindow::Render
$LN22@OnRender:

; 1097 : 		}
; 1098 : 	}

  00524	e9 bf fb ff ff	 jmp	 $LN4@OnRender
$LN5@OnRender:

; 1099 : 
; 1100 : 	RenderLockedSlot();

  00529	8b 4d 70	 mov	 ecx, DWORD PTR _this$[ebp]
  0052c	e8 00 00 00 00	 call	 ?RenderLockedSlot@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::RenderLockedSlot

; 1101 : }

  00531	83 c5 78	 add	 ebp, 120		; 00000078H
  00534	c9		 leave
  00535	c3		 ret	 0
?OnRender@CSlotWindow@UI@@MAEXXZ ENDP			; UI::CSlotWindow::OnRender
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnUpdate@CSlotWindow@UI@@MAEXXZ
_TEXT	SEGMENT
$T2 = -68						; size = 12
_itor$3 = -56						; size = 12
_pSlot$4 = -44						; size = 4
_dwSlotIndex$5 = -40					; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
tv241 = -28						; size = 4
tv209 = -24						; size = 4
_this$ = -20						; size = 4
$T8 = -14						; size = 1
$T9 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?OnUpdate@CSlotWindow@UI@@MAEXXZ PROC			; UI::CSlotWindow::OnUpdate, COMDAT
; _this$ = ecx

; 958  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?OnUpdate@CSlotWindow@UI@@MAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 959  : 	for (std::deque<DWORD>::iterator itor = m_ReserveDestroyEffectDeque.begin(); itor != m_ReserveDestroyEffectDeque.end(); ++itor)

  00028	8d 45 c8	 lea	 eax, DWORD PTR _itor$3[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00035	e8 00 00 00 00	 call	 ?begin@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ ; std::deque<unsigned long,std::allocator<unsigned long> >::begin
  0003a	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	eb 07		 jmp	 SHORT $LN4@OnUpdate
$LN2@OnUpdate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 284  :         ++_Myoff;

  00040	8b 45 d0	 mov	 eax, DWORD PTR _itor$3[ebp+8]
  00043	40		 inc	 eax
  00044	89 45 d0	 mov	 DWORD PTR _itor$3[ebp+8], eax
$LN4@OnUpdate:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 959  : 	for (std::deque<DWORD>::iterator itor = m_ReserveDestroyEffectDeque.begin(); itor != m_ReserveDestroyEffectDeque.end(); ++itor)

  00047	8d 45 bc	 lea	 eax, DWORD PTR $T2[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00054	e8 00 00 00 00	 call	 ?end@?$deque@KV?$allocator@K@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@2@XZ ; std::deque<unsigned long,std::allocator<unsigned long> >::end
  00059	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 351  :         return this->_Myoff == _Right._Myoff;

  0005c	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	8b 4d d0	 mov	 ecx, DWORD PTR _itor$3[ebp+8]
  00062	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00065	75 09		 jne	 SHORT $LN93@OnUpdate
  00067	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv209[ebp], 1
  0006e	eb 04		 jmp	 SHORT $LN94@OnUpdate
$LN93@OnUpdate:
  00070	83 65 e8 00	 and	 DWORD PTR tv209[ebp], 0
$LN94@OnUpdate:
  00074	8a 45 e8	 mov	 al, BYTE PTR tv209[ebp]
  00077	88 45 f3	 mov	 BYTE PTR $T9[ebp], al

; 355  :         return !(*this == _Right);

  0007a	0f b6 45 f3	 movzx	 eax, BYTE PTR $T9[ebp]
  0007e	85 c0		 test	 eax, eax
  00080	75 09		 jne	 SHORT $LN88@OnUpdate
  00082	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv241[ebp], 1
  00089	eb 04		 jmp	 SHORT $LN89@OnUpdate
$LN88@OnUpdate:
  0008b	83 65 e4 00	 and	 DWORD PTR tv241[ebp], 0
$LN89@OnUpdate:
  0008f	8a 45 e4	 mov	 al, BYTE PTR tv241[ebp]
  00092	88 45 f2	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 959  : 	for (std::deque<DWORD>::iterator itor = m_ReserveDestroyEffectDeque.begin(); itor != m_ReserveDestroyEffectDeque.end(); ++itor)

  00095	0f b6 45 f2	 movzx	 eax, BYTE PTR $T8[ebp]
  00099	85 c0		 test	 eax, eax
  0009b	74 3b		 je	 SHORT $LN3@OnUpdate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 446  :         return const_cast<reference>(_Mybase::operator*());

  0009d	8d 4d c8	 lea	 ecx, DWORD PTR _itor$3[ebp]
  000a0	e8 00 00 00 00	 call	 ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QBEABKXZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<unsigned long> > >::operator*
  000a5	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 961  : 		DWORD dwSlotIndex = *itor;

  000a8	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  000ab	8b 00		 mov	 eax, DWORD PTR [eax]
  000ad	89 45 d8	 mov	 DWORD PTR _dwSlotIndex$5[ebp], eax

; 962  : 
; 963  : 		TSlot * pSlot;
; 964  : 		if (!GetSlotPointer(dwSlotIndex, &pSlot))

  000b0	8d 45 d4	 lea	 eax, DWORD PTR _pSlot$4[ebp]
  000b3	50		 push	 eax
  000b4	ff 75 d8	 push	 DWORD PTR _dwSlotIndex$5[ebp]
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  000bf	85 c0		 test	 eax, eax
  000c1	75 05		 jne	 SHORT $LN5@OnUpdate

; 965  : 			continue;

  000c3	e9 78 ff ff ff	 jmp	 $LN2@OnUpdate
$LN5@OnUpdate:

; 966  : 
; 967  : 		__DestroyFinishCoolTimeEffect(pSlot);

  000c8	ff 75 d4	 push	 DWORD PTR _pSlot$4[ebp]
  000cb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ce	e8 00 00 00 00	 call	 ?__DestroyFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::__DestroyFinishCoolTimeEffect
  000d3	e9 68 ff ff ff	 jmp	 $LN2@OnUpdate
$LN3@OnUpdate:

; 968  : 	}

  000d8	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 969  : 	m_ReserveDestroyEffectDeque.clear();

  000dc	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1330 :         _Tidy();

  000e5	e8 00 00 00 00	 call	 ?_Tidy@?$deque@KV?$allocator@K@std@@@std@@AAEXXZ ; std::deque<unsigned long,std::allocator<unsigned long> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 971  : 	if (m_pSlotActiveEffect)

  000ea	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000ed	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  000f4	74 0e		 je	 SHORT $LN1@OnUpdate

; 972  : 		m_pSlotActiveEffect->Update();

  000f6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f9	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000ff	e8 00 00 00 00	 call	 ?Update@CWindow@UI@@QAEXXZ ; UI::CWindow::Update
$LN1@OnUpdate:

; 973  : }

  00104	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00107	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0010e	59		 pop	 ecx
  0010f	c9		 leave
  00110	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?OnUpdate@CSlotWindow@UI@@MAEXXZ$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _itor$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@K@std@@@std@@@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?OnUpdate@CSlotWindow@UI@@MAEXXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?OnUpdate@CSlotWindow@UI@@MAEXXZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?OnUpdate@CSlotWindow@UI@@MAEXXZ ENDP			; UI::CSlotWindow::OnUpdate
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__DestroyBaseImage@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__DestroyBaseImage@CSlotWindow@UI@@IAEXXZ PROC		; UI::CSlotWindow::__DestroyBaseImage, COMDAT
; _this$ = ecx

; 1372 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1373 : 	if (m_pBaseImageInstance)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [eax+156], 0
  00011	74 19		 je	 SHORT $LN1@DestroyBas

; 1374 : 	{
; 1375 : 		CGraphicImageInstance::Delete(m_pBaseImageInstance);

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff b0 9c 00 00
	00		 push	 DWORD PTR [eax+156]
  0001c	e8 00 00 00 00	 call	 ?Delete@CGraphicImageInstance@@SAXPAV1@@Z ; CGraphicImageInstance::Delete
  00021	59		 pop	 ecx

; 1376 : 		m_pBaseImageInstance = NULL;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 a0 9c 00 00
	00 00		 and	 DWORD PTR [eax+156], 0
$LN1@DestroyBas:

; 1377 : 	}
; 1378 : }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?__DestroyBaseImage@CSlotWindow@UI@@IAEXXZ ENDP		; UI::CSlotWindow::__DestroyBaseImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__DestroyFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv77 = -8						; size = 4
$T1 = -4						; size = 4
_pSlot$ = 8						; size = 4
?__DestroyFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z PROC ; UI::CSlotWindow::__DestroyFinishCoolTimeEffect, COMDAT
; _this$ = ecx

; 1363 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1364 : 	if (pSlot->pFinishCoolTimeEffect)

  00009	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0000c	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00010	74 2b		 je	 SHORT $LN1@DestroyFin

; 1365 : 	{
; 1366 : 		delete pSlot->pFinishCoolTimeEffect;

  00012	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00015	8b 40 4c	 mov	 eax, DWORD PTR [eax+76]
  00018	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0001f	74 11		 je	 SHORT $LN4@DestroyFin
  00021	6a 01		 push	 1
  00023	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0002b	ff 10		 call	 DWORD PTR [eax]
  0002d	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  00030	eb 04		 jmp	 SHORT $LN5@DestroyFin
$LN4@DestroyFin:
  00032	83 65 f8 00	 and	 DWORD PTR tv77[ebp], 0
$LN5@DestroyFin:

; 1367 : 		pSlot->pFinishCoolTimeEffect = NULL;

  00036	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00039	83 60 4c 00	 and	 DWORD PTR [eax+76], 0
$LN1@DestroyFin:

; 1368 : 	}
; 1369 : }

  0003d	c9		 leave
  0003e	c2 04 00	 ret	 4
?__DestroyFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ENDP ; UI::CSlotWindow::__DestroyFinishCoolTimeEffect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__DestroySlotEnableEffect@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
tv77 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
?__DestroySlotEnableEffect@CSlotWindow@UI@@IAEXXZ PROC	; UI::CSlotWindow::__DestroySlotEnableEffect, COMDAT
; _this$ = ecx

; 1354 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1355 : 	if (m_pSlotActiveEffect)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00013	74 31		 je	 SHORT $LN1@DestroySlo

; 1356 : 	{
; 1357 : 		delete m_pSlotActiveEffect;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]
  0001e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00021	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00025	74 11		 je	 SHORT $LN4@DestroySlo
  00027	6a 01		 push	 1
  00029	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00031	ff 10		 call	 DWORD PTR [eax]
  00033	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  00036	eb 04		 jmp	 SHORT $LN5@DestroySlo
$LN4@DestroySlo:
  00038	83 65 f4 00	 and	 DWORD PTR tv77[ebp], 0
$LN5@DestroySlo:

; 1358 : 		m_pSlotActiveEffect = NULL;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	83 a0 a4 00 00
	00 00		 and	 DWORD PTR [eax+164], 0
$LN1@DestroySlo:

; 1359 : 	}
; 1360 : }

  00046	c9		 leave
  00047	c3		 ret	 0
?__DestroySlotEnableEffect@CSlotWindow@UI@@IAEXXZ ENDP	; UI::CSlotWindow::__DestroySlotEnableEffect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__DestroyToggleSlotImage@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
tv77 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
?__DestroyToggleSlotImage@CSlotWindow@UI@@IAEXXZ PROC	; UI::CSlotWindow::__DestroyToggleSlotImage, COMDAT
; _this$ = ecx

; 1345 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1346 : 	if (m_pToggleSlotImage)

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [eax+160], 0
  00013	74 31		 je	 SHORT $LN1@DestroyTog

; 1347 : 	{
; 1348 : 		delete m_pToggleSlotImage;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  0001e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00021	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00025	74 11		 je	 SHORT $LN4@DestroyTog
  00027	6a 01		 push	 1
  00029	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00031	ff 10		 call	 DWORD PTR [eax]
  00033	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  00036	eb 04		 jmp	 SHORT $LN5@DestroyTog
$LN4@DestroyTog:
  00038	83 65 f4 00	 and	 DWORD PTR tv77[ebp], 0
$LN5@DestroyTog:

; 1349 : 		m_pToggleSlotImage = NULL;

  0003c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	83 a0 a0 00 00
	00 00		 and	 DWORD PTR [eax+160], 0
$LN1@DestroyTog:

; 1350 : 	}
; 1351 : }

  00046	c9		 leave
  00047	c3		 ret	 0
?__DestroyToggleSlotImage@CSlotWindow@UI@@IAEXXZ ENDP	; UI::CSlotWindow::__DestroyToggleSlotImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__CreateBaseImage@CSlotWindow@UI@@IAEXPBDMMMM@Z
_TEXT	SEGMENT
_pImage$ = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_c_szFileName$ = 8					; size = 4
_fr$ = 12						; size = 4
_fg$ = 16						; size = 4
_fb$ = 20						; size = 4
_fa$ = 24						; size = 4
?__CreateBaseImage@CSlotWindow@UI@@IAEXPBDMMMM@Z PROC	; UI::CSlotWindow::__CreateBaseImage, COMDAT
; _this$ = ecx

; 1335 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1336 : 	__DestroyBaseImage();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__DestroyBaseImage@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__DestroyBaseImage
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
  00016	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1338 : 	CGraphicImage * pImage = (CGraphicImage *)CResourceManager::Instance().GetResourcePointer(c_szFileName);

  00019	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0001f	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00024	89 45 f4	 mov	 DWORD PTR _pImage$[ebp], eax

; 1339 : 	m_pBaseImageInstance = CGraphicImageInstance::New();

  00027	e8 00 00 00 00	 call	 ?New@CGraphicImageInstance@@SAPAV1@XZ ; CGraphicImageInstance::New
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	89 81 9c 00 00
	00		 mov	 DWORD PTR [ecx+156], eax

; 1340 : 	m_pBaseImageInstance->SetImagePointer(pImage);

  00035	ff 75 f4	 push	 DWORD PTR _pImage$[ebp]
  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  00041	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer

; 1341 : 	m_pBaseImageInstance->SetDiffuseColor(fr, fg, fb, fa);

  00046	51		 push	 ecx
  00047	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _fa$[ebp]
  0004c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00051	51		 push	 ecx
  00052	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fb$[ebp]
  00057	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005c	51		 push	 ecx
  0005d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fg$[ebp]
  00062	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00067	51		 push	 ecx
  00068	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fr$[ebp]
  0006d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [eax+156]
  0007b	e8 00 00 00 00	 call	 ?SetDiffuseColor@CGraphicImageInstance@@QAEXMMMM@Z ; CGraphicImageInstance::SetDiffuseColor

; 1342 : }

  00080	c9		 leave
  00081	c2 14 00	 ret	 20			; 00000014H
?__CreateBaseImage@CSlotWindow@UI@@IAEXPBDMMMM@Z ENDP	; UI::CSlotWindow::__CreateBaseImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z
_TEXT	SEGMENT
$T2 = -36						; size = 4
_dwSlotIndex$ = -32					; size = 4
tv83 = -28						; size = 4
_this$ = -24						; size = 4
$T3 = -20						; size = 4
_pFinishCoolTimeEffect$ = -16				; size = 4
__$EHRec$ = -12						; size = 12
_pSlot$ = 8						; size = 4
?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z PROC ; UI::CSlotWindow::__CreateFinishCoolTimeEffect, COMDAT
; _this$ = ecx

; 1311 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 1312 : 	__DestroyFinishCoolTimeEffect(pSlot);

  00028	ff 75 08	 push	 DWORD PTR _pSlot$[ebp]
  0002b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?__DestroyFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::__DestroyFinishCoolTimeEffect

; 1313 : 
; 1314 : 	CAniImageBox * pFinishCoolTimeEffect = new CCoolTimeFinishEffect(this, pSlot->dwSlotNumber);

  00033	68 8c 00 00 00	 push	 140			; 0000008cH
  00038	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003d	59		 pop	 ecx
  0003e	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00045	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00049	74 39		 je	 SHORT $LN3@CreateFini
  0004b	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00051	89 45 e0	 mov	 DWORD PTR _dwSlotIndex$[ebp], eax

; 178  : 		CCoolTimeFinishEffect(CSlotWindow * pParent, DWORD dwSlotIndex) : CAniImageBox(NULL)

  00054	6a 00		 push	 0
  00056	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  00059	e8 00 00 00 00	 call	 ??0CAniImageBox@UI@@QAE@PAU_object@@@Z ; UI::CAniImageBox::CAniImageBox

; 179  : 		{

  0005e	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00061	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCoolTimeFinishEffect@CSlotWindow@UI@@6B@

; 180  : 			m_pParent = pParent;

  00067	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0006a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006d	89 48 60	 mov	 DWORD PTR [eax+96], ecx

; 181  : 			m_dwSlotIndex = dwSlotIndex;

  00070	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00073	8b 4d e0	 mov	 ecx, DWORD PTR _dwSlotIndex$[ebp]
  00076	89 88 88 00 00
	00		 mov	 DWORD PTR [eax+136], ecx

; 1313 : 
; 1314 : 	CAniImageBox * pFinishCoolTimeEffect = new CCoolTimeFinishEffect(this, pSlot->dwSlotNumber);

  0007c	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv83[ebp], eax
  00082	eb 04		 jmp	 SHORT $LN4@CreateFini
$LN3@CreateFini:
  00084	83 65 e4 00	 and	 DWORD PTR tv83[ebp], 0
$LN4@CreateFini:
  00088	8b 45 e4	 mov	 eax, DWORD PTR tv83[ebp]
  0008b	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  0008e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00092	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]
  00095	89 45 f0	 mov	 DWORD PTR _pFinishCoolTimeEffect$[ebp], eax

; 1315 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/00.sub");

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@EECLJILE@d?3?1ymir?5work?1ui?1public?1slotfini@
  0009d	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  000a0	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1316 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/01.sub");

  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@IPHHELBB@d?3?1ymir?5work?1ui?1public?1slotfini@
  000aa	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  000ad	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1317 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/02.sub");

  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@JODDJLP@d?3?1ymir?5work?1ui?1public?1slotfini@
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  000ba	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1318 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/03.sub");

  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@MCLPOKBK@d?3?1ymir?5work?1ui?1public?1slotfini@
  000c4	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  000c7	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1319 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/04.sub");

  000cc	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@NPLKNKKC@d?3?1ymir?5work?1ui?1public?1slotfini@
  000d1	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  000d4	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1320 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/05.sub");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@BEOGAJAH@d?3?1ymir?5work?1ui?1public?1slotfini@
  000de	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  000e1	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1321 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/06.sub");

  000e6	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@JCHCHLKJ@d?3?1ymir?5work?1ui?1public?1slotfini@
  000eb	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  000ee	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1322 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/07.sub");

  000f3	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@FJCOKIAM@d?3?1ymir?5work?1ui?1public?1slotfini@
  000f8	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  000fb	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1323 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/08.sub");

  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@KIHIBKNJ@d?3?1ymir?5work?1ui?1public?1slotfini@
  00105	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  00108	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1324 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/09.sub");

  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@GDCEMJHM@d?3?1ymir?5work?1ui?1public?1slotfini@
  00112	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  00115	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1325 : 	pFinishCoolTimeEffect->AppendImage("d:/ymir work/ui/public/slotfinishcooltimeeffect/10.sub");

  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@OCFMJDAA@d?3?1ymir?5work?1ui?1public?1slotfini@
  0011f	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  00122	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1326 : 	pFinishCoolTimeEffect->SetRenderingMode(CGraphicExpandedImageInstance::RENDERING_MODE_SCREEN);

  00127	6a 01		 push	 1
  00129	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  0012c	e8 00 00 00 00	 call	 ?SetRenderingMode@CAniImageBox@UI@@QAEXH@Z ; UI::CAniImageBox::SetRenderingMode

; 1327 : 	pFinishCoolTimeEffect->ResetFrame();

  00131	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  00134	e8 00 00 00 00	 call	 ?ResetFrame@CAniImageBox@UI@@QAEXXZ ; UI::CAniImageBox::ResetFrame

; 1328 : 	pFinishCoolTimeEffect->SetDelay(2);

  00139	6a 02		 push	 2
  0013b	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  0013e	e8 00 00 00 00	 call	 ?SetDelay@CAniImageBox@UI@@QAEXH@Z ; UI::CAniImageBox::SetDelay

; 1329 : 	pFinishCoolTimeEffect->Show();

  00143	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  00146	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show

; 1330 : 
; 1331 : 	pSlot->pFinishCoolTimeEffect = pFinishCoolTimeEffect;

  0014b	8b 45 08	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0014e	8b 4d f0	 mov	 ecx, DWORD PTR _pFinishCoolTimeEffect$[ebp]
  00151	89 48 4c	 mov	 DWORD PTR [eax+76], ecx

; 1332 : }

  00154	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00157	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0015e	59		 pop	 ecx
  0015f	c9		 leave
  00160	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z$0:
  00000	68 8c 00 00 00	 push	 140			; 0000008cH
  00005	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__CreateFinishCoolTimeEffect@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ENDP ; UI::CSlotWindow::__CreateFinishCoolTimeEffect
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv78 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ PROC	; UI::CSlotWindow::__CreateSlotEnableEffect, COMDAT
; _this$ = ecx

; 1289 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1290 : 	__DestroySlotEnableEffect();

  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?__DestroySlotEnableEffect@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__DestroySlotEnableEffect

; 1291 : 
; 1292 : 	m_pSlotActiveEffect = new CAniImageBox(NULL);

  00030	68 88 00 00 00	 push	 136			; 00000088H
  00035	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0003a	59		 pop	 ecx
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0003e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00042	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00046	74 0f		 je	 SHORT $LN3@CreateSlot
  00048	6a 00		 push	 0
  0004a	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0004d	e8 00 00 00 00	 call	 ??0CAniImageBox@UI@@QAE@PAU_object@@@Z ; UI::CAniImageBox::CAniImageBox
  00052	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00055	eb 04		 jmp	 SHORT $LN4@CreateSlot
$LN3@CreateSlot:
  00057	83 65 e8 00	 and	 DWORD PTR tv78[ebp], 0
$LN4@CreateSlot:
  0005b	8b 45 e8	 mov	 eax, DWORD PTR tv78[ebp]
  0005e	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  00061	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00065	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  0006b	89 88 a4 00 00
	00		 mov	 DWORD PTR [eax+164], ecx

; 1293 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/00.sub");

  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@LLEDDNBJ@d?3?1ymir?5work?1ui?1public?1slotacti@
  00076	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00079	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0007f	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1294 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/01.sub");

  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HABPOOLM@d?3?1ymir?5work?1ui?1public?1slotacti@
  00089	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00092	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1295 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/02.sub");

  00097	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@PGILJMBC@d?3?1ymir?5work?1ui?1public?1slotacti@
  0009c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000a5	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1296 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/03.sub");

  000aa	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DNNHEPLH@d?3?1ymir?5work?1ui?1public?1slotacti@
  000af	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b2	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000b8	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1297 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/04.sub");

  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@CANCHPAP@d?3?1ymir?5work?1ui?1public?1slotacti@
  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000cb	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1298 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/05.sub");

  000d0	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@OLIOKMKK@d?3?1ymir?5work?1ui?1public?1slotacti@
  000d5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000de	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1299 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/06.sub");

  000e3	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@GNBKNOAE@d?3?1ymir?5work?1ui?1public?1slotacti@
  000e8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  000f1	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1300 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/07.sub");

  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@KGEGANKB@d?3?1ymir?5work?1ui?1public?1slotacti@
  000fb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000fe	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00104	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1301 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/08.sub");

  00109	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FHBALPHE@d?3?1ymir?5work?1ui?1public?1slotacti@
  0010e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00111	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00117	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1302 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/09.sub");

  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@JMEMGMNB@d?3?1ymir?5work?1ui?1public?1slotacti@
  00121	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00124	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0012a	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1303 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/10.sub");

  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@BNDEDGKN@d?3?1ymir?5work?1ui?1public?1slotacti@
  00134	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00137	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  0013d	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1304 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/11.sub");

  00142	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@NGGIOFAI@d?3?1ymir?5work?1ui?1public?1slotacti@
  00147	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0014a	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00150	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1305 : 	m_pSlotActiveEffect->AppendImage("d:/ymir work/ui/public/slotactiveeffect/12.sub");

  00155	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@FAPMJHKG@d?3?1ymir?5work?1ui?1public?1slotacti@
  0015a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0015d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00163	e8 00 00 00 00	 call	 ?AppendImage@CAniImageBox@UI@@QAEXPBD@Z ; UI::CAniImageBox::AppendImage

; 1306 : 	m_pSlotActiveEffect->SetRenderingMode(CGraphicExpandedImageInstance::RENDERING_MODE_SCREEN);

  00168	6a 01		 push	 1
  0016a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0016d	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00173	e8 00 00 00 00	 call	 ?SetRenderingMode@CAniImageBox@UI@@QAEXH@Z ; UI::CAniImageBox::SetRenderingMode

; 1307 : 	m_pSlotActiveEffect->Show();

  00178	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0017b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00181	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show

; 1308 : }

  00186	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00189	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00190	59		 pop	 ecx
  00191	c9		 leave
  00192	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ$0:
  00000	68 88 00 00 00	 push	 136			; 00000088H
  00005	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ ENDP	; UI::CSlotWindow::__CreateSlotEnableEffect
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
$T2 = -28						; size = 4
tv78 = -24						; size = 4
$T3 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ PROC	; UI::CSlotWindow::__CreateToggleSlotImage, COMDAT
; _this$ = ecx

; 1280 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1281 : 	__DestroyToggleSlotImage();

  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?__DestroyToggleSlotImage@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__DestroyToggleSlotImage

; 1282 : 
; 1283 : 	m_pToggleSlotImage = new CImageBox(NULL);

  00030	6a 7c		 push	 124			; 0000007cH
  00032	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00037	59		 pop	 ecx
  00038	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  0003b	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003f	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  00043	74 0f		 je	 SHORT $LN3@CreateTogg
  00045	6a 00		 push	 0
  00047	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0004a	e8 00 00 00 00	 call	 ??0CImageBox@UI@@QAE@PAU_object@@@Z ; UI::CImageBox::CImageBox
  0004f	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00052	eb 04		 jmp	 SHORT $LN4@CreateTogg
$LN3@CreateTogg:
  00054	83 65 e8 00	 and	 DWORD PTR tv78[ebp], 0
$LN4@CreateTogg:
  00058	8b 45 e8	 mov	 eax, DWORD PTR tv78[ebp]
  0005b	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  0005e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00062	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00068	89 88 a0 00 00
	00		 mov	 DWORD PTR [eax+160], ecx

; 1284 : 	m_pToggleSlotImage->LoadImage("d:/ymir work/ui/public/slot_toggle.sub");

  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JJGPDFBJ@d?3?1ymir?5work?1ui?1public?1slot_tog@
  00073	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00076	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0007c	e8 00 00 00 00	 call	 ?LoadImageA@CImageBox@UI@@QAEHPBD@Z ; UI::CImageBox::LoadImageA

; 1285 : 	m_pToggleSlotImage->Show();

  00081	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [eax+160]
  0008a	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show

; 1286 : }

  0008f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00099	59		 pop	 ecx
  0009a	c9		 leave
  0009b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ$0:
  00000	6a 7c		 push	 124			; 0000007cH
  00002	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__CreateToggleSlotImage@CSlotWindow@UI@@IAEXXZ ENDP	; UI::CSlotWindow::__CreateToggleSlotImage
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?__Initialize@CSlotWindow@UI@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__Initialize@CSlotWindow@UI@@IAEXXZ PROC		; UI::CSlotWindow::__Initialize, COMDAT
; _this$ = ecx

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1382 : 	m_dwSlotType = 0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 78 00	 and	 DWORD PTR [eax+120], 0

; 1383 : 	m_dwSlotStyle = SLOT_STYLE_PICK_UP;

  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	c7 40 7c 01 00
	00 00		 mov	 DWORD PTR [eax+124], 1

; 1384 : 	m_dwToolTipSlotNumber = SLOT_NUMBER_NONE;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 88 90 00 00
	00 ff		 or	 DWORD PTR [eax+144], -1

; 1385 : 
; 1386 : 	m_isUseMode = FALSE;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 a0 94 00 00
	00 00		 and	 DWORD PTR [eax+148], 0

; 1387 : 	m_isUsableItem = FALSE;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 a0 98 00 00
	00 00		 and	 DWORD PTR [eax+152], 0

; 1388 : 
; 1389 : 	m_pToggleSlotImage = NULL;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00039	83 a0 a0 00 00
	00 00		 and	 DWORD PTR [eax+160], 0

; 1390 : 	m_pSlotActiveEffect = NULL;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 a0 a4 00 00
	00 00		 and	 DWORD PTR [eax+164], 0

; 1391 : 	m_pBaseImageInstance = NULL;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 a0 9c 00 00
	00 00		 and	 DWORD PTR [eax+156], 0

; 1392 : }

  00054	c9		 leave
  00055	c3		 ret	 0
?__Initialize@CSlotWindow@UI@@IAEXXZ ENDP		; UI::CSlotWindow::__Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ReserveDestroyCoolTimeFinishEffect@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_dwSlotIndex$ = 8					; size = 4
?ReserveDestroyCoolTimeFinishEffect@CSlotWindow@UI@@QAEXK@Z PROC ; UI::CSlotWindow::ReserveDestroyCoolTimeFinishEffect, COMDAT
; _this$ = ecx

; 1261 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1262 : 	m_ReserveDestroyEffectDeque.push_back(dwSlotIndex);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	05 a8 00 00 00	 add	 eax, 168		; 000000a8H
  00011	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\deque

; 1530 :         return _Mypair._Myval2;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1123 :         _Emplace_back_internal(_Val);

  0001a	8d 45 08	 lea	 eax, DWORD PTR _dwSlotIndex$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Emplace_back_internal@ABK@?$deque@KV?$allocator@K@std@@@std@@AAEXABK@Z ; std::deque<unsigned long,std::allocator<unsigned long> >::_Emplace_back_internal<unsigned long const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1263 : }

  00026	c9		 leave
  00027	c2 04 00	 ret	 4
?ReserveDestroyCoolTimeFinishEffect@CSlotWindow@UI@@QAEXK@Z ENDP ; UI::CSlotWindow::ReserveDestroyCoolTimeFinishEffect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetUsableItem@CSlotWindow@UI@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bFlag$ = 8						; size = 4
?SetUsableItem@CSlotWindow@UI@@QAEXH@Z PROC		; UI::CSlotWindow::SetUsableItem, COMDAT
; _this$ = ecx

; 1256 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1257 : 	m_isUsableItem = bFlag;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _bFlag$[ebp]
  0000d	89 88 98 00 00
	00		 mov	 DWORD PTR [eax+152], ecx

; 1258 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetUsableItem@CSlotWindow@UI@@QAEXH@Z ENDP		; UI::CSlotWindow::SetUsableItem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetUseMode@CSlotWindow@UI@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bFlag$ = 8						; size = 4
?SetUseMode@CSlotWindow@UI@@QAEXH@Z PROC		; UI::CSlotWindow::SetUseMode, COMDAT
; _this$ = ecx

; 1251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 : 	m_isUseMode = bFlag;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _bFlag$[ebp]
  0000d	89 88 94 00 00
	00		 mov	 DWORD PTR [eax+148], ecx

; 1253 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetUseMode@CSlotWindow@UI@@QAEXH@Z ENDP		; UI::CSlotWindow::SetUseMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnOverOutItem@CSlotWindow@UI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnOverOutItem@CSlotWindow@UI@@QAEXXZ PROC		; UI::CSlotWindow::OnOverOutItem, COMDAT
; _this$ = ecx

; 934  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 935  : 	if (SLOT_NUMBER_NONE == m_dwToolTipSlotNumber)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 90 00 00
	00 ff		 cmp	 DWORD PTR [eax+144], -1
  00011	75 02		 jne	 SHORT $LN2@OnOverOutI

; 936  : 		return;

  00013	eb 2a		 jmp	 SHORT $LN1@OnOverOutI
$LN2@OnOverOutI:

; 937  : 
; 938  : 	m_dwToolTipSlotNumber = SLOT_NUMBER_NONE;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 88 90 00 00
	00 ff		 or	 DWORD PTR [eax+144], -1

; 939  : 	PyCallClassMemberFunc(m_poHandler, "OnOverOutItem", Py_BuildValue("()"));

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002a	59		 pop	 ecx
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IBCIPGEP@OnOverOutItem@
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	ff 70 5c	 push	 DWORD PTR [eax+92]
  00037	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@OnOverOutI:

; 940  : }

  0003f	c9		 leave
  00040	c3		 ret	 0
?OnOverOutItem@CSlotWindow@UI@@QAEXXZ ENDP		; UI::CSlotWindow::OnOverOutItem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnOverInItem@CSlotWindow@UI@@QAEHK@Z
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
_dwSlotNumber$ = 8					; size = 4
?OnOverInItem@CSlotWindow@UI@@QAEHK@Z PROC		; UI::CSlotWindow::OnOverInItem, COMDAT
; _this$ = ecx

; 916  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 917  : 	TSlot * pSlot;
; 918  : 	if (!GetSlotPointer(dwSlotNumber, &pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwSlotNumber$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $LN2@OnOverInIt

; 919  : 		return FALSE;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 56		 jmp	 SHORT $LN1@OnOverInIt
$LN2@OnOverInIt:

; 920  : 
; 921  : 	if (!pSlot->isItem)

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00022	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00026	75 04		 jne	 SHORT $LN3@OnOverInIt

; 922  : 		return FALSE;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 49		 jmp	 SHORT $LN1@OnOverInIt
$LN3@OnOverInIt:

; 923  : 
; 924  : 	if (pSlot->dwSlotNumber == m_dwToolTipSlotNumber)

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00035	3b 81 90 00 00
	00		 cmp	 eax, DWORD PTR [ecx+144]
  0003b	75 05		 jne	 SHORT $LN4@OnOverInIt

; 925  : 		return TRUE;

  0003d	33 c0		 xor	 eax, eax
  0003f	40		 inc	 eax
  00040	eb 33		 jmp	 SHORT $LN1@OnOverInIt
$LN4@OnOverInIt:

; 926  : 
; 927  : 	m_dwToolTipSlotNumber = dwSlotNumber;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 4d 08	 mov	 ecx, DWORD PTR _dwSlotNumber$[ebp]
  00048	89 88 90 00 00
	00		 mov	 DWORD PTR [eax+144], ecx

; 928  : 	PyCallClassMemberFunc(m_poHandler, "OnOverInItem", Py_BuildValue("(i)", dwSlotNumber));

  0004e	ff 75 08	 push	 DWORD PTR _dwSlotNumber$[ebp]
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ@
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx
  0005e	50		 push	 eax
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0N@CBOPEHFH@OnOverInItem@
  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	ff 70 5c	 push	 DWORD PTR [eax+92]
  0006a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 929  : 
; 930  : 	return TRUE;

  00072	33 c0		 xor	 eax, eax
  00074	40		 inc	 eax
$LN1@OnOverInIt:

; 931  : }

  00075	c9		 leave
  00076	c2 04 00	 ret	 4
?OnOverInItem@CSlotWindow@UI@@QAEHK@Z ENDP		; UI::CSlotWindow::OnOverInItem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?HideRequirementSign@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwSlotNumber$ = 8					; size = 4
?HideRequirementSign@CSlotWindow@UI@@QAEXK@Z PROC	; UI::CSlotWindow::HideRequirementSign, COMDAT
; _this$ = ecx

; 765  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 766  : 	TSlot * pSlot;
; 767  : 	if (!GetSlotPointer(dwSlotNumber, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwSlotNumber$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@HideRequir

; 768  : 		return;

  0001b	eb 16		 jmp	 SHORT $LN1@HideRequir
$LN2@HideRequir:

; 769  : 
; 770  : 	if (!pSlot->pSignImage)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00024	75 02		 jne	 SHORT $LN3@HideRequir

; 771  : 		return;

  00026	eb 0b		 jmp	 SHORT $LN1@HideRequir
$LN3@HideRequir:

; 772  : 
; 773  : 	pSlot->pSignImage->Hide();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002b	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0002e	e8 00 00 00 00	 call	 ?Hide@CWindow@UI@@QAEXXZ ; UI::CWindow::Hide
$LN1@HideRequir:

; 774  : }

  00033	c9		 leave
  00034	c2 04 00	 ret	 4
?HideRequirementSign@CSlotWindow@UI@@QAEXK@Z ENDP	; UI::CSlotWindow::HideRequirementSign
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ShowRequirementSign@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwSlotNumber$ = 8					; size = 4
?ShowRequirementSign@CSlotWindow@UI@@QAEXK@Z PROC	; UI::CSlotWindow::ShowRequirementSign, COMDAT
; _this$ = ecx

; 753  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 754  : 	TSlot * pSlot;
; 755  : 	if (!GetSlotPointer(dwSlotNumber, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwSlotNumber$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@ShowRequir

; 756  : 		return;

  0001b	eb 16		 jmp	 SHORT $LN1@ShowRequir
$LN2@ShowRequir:

; 757  : 
; 758  : 	if (!pSlot->pSignImage)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00024	75 02		 jne	 SHORT $LN3@ShowRequir

; 759  : 		return;

  00026	eb 0b		 jmp	 SHORT $LN1@ShowRequir
$LN3@ShowRequir:

; 760  : 
; 761  : 	pSlot->pSignImage->Show();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002b	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0002e	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show
$LN1@ShowRequir:

; 762  : }

  00033	c9		 leave
  00034	c2 04 00	 ret	 4
?ShowRequirementSign@CSlotWindow@UI@@QAEXK@Z ENDP	; UI::CSlotWindow::ShowRequirementSign
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?OnPressedSlotButton@CSlotWindow@UI@@QAEXKKH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwType$ = 8						; size = 4
_dwSlotNumber$ = 12					; size = 4
_isLeft$ = 16						; size = 4
?OnPressedSlotButton@CSlotWindow@UI@@QAEXKKH@Z PROC	; UI::CSlotWindow::OnPressedSlotButton, COMDAT
; _this$ = ecx

; 943  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 944  : 	if (CSlotButton::SLOT_BUTTON_TYPE_PLUS == dwType)

  00007	83 7d 08 00	 cmp	 DWORD PTR _dwType$[ebp], 0
  0000b	75 26		 jne	 SHORT $LN2@OnPressedS

; 945  : 	{
; 946  : 		PyCallClassMemberFunc(m_poHandler, "OnPressedSlotButton", Py_BuildValue("(i)", dwSlotNumber));

  0000d	ff 75 0c	 push	 DWORD PTR _dwSlotNumber$[ebp]
  00010	68 00 00 00 00	 push	 OFFSET ??_C@_03LIHNMIHG@?$CIi?$CJ@
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001b	59		 pop	 ecx
  0001c	59		 pop	 ecx
  0001d	50		 push	 eax
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@MBGDMPNF@OnPressedSlotButton@
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	ff 70 5c	 push	 DWORD PTR [eax+92]
  00029	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 947  : 	}

  00031	eb 17		 jmp	 SHORT $LN1@OnPressedS
$LN2@OnPressedS:

; 948  : 	else if (CSlotButton::SLOT_BUTTON_TYPE_COVER == dwType)

  00033	83 7d 08 01	 cmp	 DWORD PTR _dwType$[ebp], 1
  00037	75 11		 jne	 SHORT $LN1@OnPressedS

; 949  : 	{
; 950  : 		if (isLeft)

  00039	83 7d 10 00	 cmp	 DWORD PTR _isLeft$[ebp], 0
  0003d	74 0b		 je	 SHORT $LN1@OnPressedS

; 951  : 		{
; 952  : 			OnMouseLeftButtonDown();

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	ff 50 58	 call	 DWORD PTR [eax+88]
$LN1@OnPressedS:

; 953  : 		}
; 954  : 	}
; 955  : }

  0004a	c9		 leave
  0004b	c2 0c 00	 ret	 12			; 0000000cH
?OnPressedSlotButton@CSlotWindow@UI@@QAEXKKH@Z ENDP	; UI::CSlotWindow::OnPressedSlotButton
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?HideAllSlotButton@CSlotWindow@UI@@QAEXXZ
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
___param0$ = -32					; size = 4
_rSlot$5 = -28						; size = 4
tv173 = -24						; size = 4
tv197 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_itor$6 = -8						; size = 4
$T7 = -2						; size = 1
$T8 = -1						; size = 1
?HideAllSlotButton@CSlotWindow@UI@@QAEXXZ PROC		; UI::CSlotWindow::HideAllSlotButton, COMDAT
; _this$ = ecx

; 740  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 741  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00009	8d 45 f8	 lea	 eax, DWORD PTR _itor$6[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00016	e8 00 00 00 00	 call	 ?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
  0001b	eb 08		 jmp	 SHORT $LN4@HideAllSlo
$LN2@HideAllSlo:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _itor$6[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 45 f8	 mov	 DWORD PTR _itor$6[ebp], eax
$LN4@HideAllSlo:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 741  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00025	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00028	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0003e	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00044	8d 45 dc	 lea	 eax, DWORD PTR $T4[ebp]
  00047	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0004a	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _itor$6[ebp]
  00050	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00052	75 09		 jne	 SHORT $LN56@HideAllSlo
  00054	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv197[ebp], 1
  0005b	eb 04		 jmp	 SHORT $LN57@HideAllSlo
$LN56@HideAllSlo:
  0005d	83 65 ec 00	 and	 DWORD PTR tv197[ebp], 0
$LN57@HideAllSlo:
  00061	8a 45 ec	 mov	 al, BYTE PTR tv197[ebp]
  00064	88 45 ff	 mov	 BYTE PTR $T8[ebp], al

; 203  :         return !(*this == _Right);

  00067	0f b6 45 ff	 movzx	 eax, BYTE PTR $T8[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN51@HideAllSlo
  0006f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv173[ebp], 1
  00076	eb 04		 jmp	 SHORT $LN52@HideAllSlo
$LN51@HideAllSlo:
  00078	83 65 e8 00	 and	 DWORD PTR tv173[ebp], 0
$LN52@HideAllSlo:
  0007c	8a 45 e8	 mov	 al, BYTE PTR tv173[ebp]
  0007f	88 45 fe	 mov	 BYTE PTR $T7[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 741  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00082	0f b6 45 fe	 movzx	 eax, BYTE PTR $T7[ebp]
  00086	85 c0		 test	 eax, eax
  00088	74 28		 je	 SHORT $LN1@HideAllSlo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _itor$6[ebp]
  0008d	83 c0 08	 add	 eax, 8
  00090	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00093	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00096	89 45 e4	 mov	 DWORD PTR _rSlot$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 745  : 		if (rSlot.pSlotButton)

  00099	8b 45 e4	 mov	 eax, DWORD PTR _rSlot$5[ebp]
  0009c	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  000a0	74 0b		 je	 SHORT $LN5@HideAllSlo

; 746  : 		{
; 747  : 			rSlot.pSlotButton->Hide();

  000a2	8b 45 e4	 mov	 eax, DWORD PTR _rSlot$5[ebp]
  000a5	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  000a8	e8 00 00 00 00	 call	 ?Hide@CWindow@UI@@QAEXXZ ; UI::CWindow::Hide
$LN5@HideAllSlo:

; 748  : 		}
; 749  : 	}

  000ad	e9 6b ff ff ff	 jmp	 $LN2@HideAllSlo
$LN1@HideAllSlo:

; 750  : }

  000b2	c9		 leave
  000b3	c3		 ret	 0
?HideAllSlotButton@CSlotWindow@UI@@QAEXXZ ENDP		; UI::CSlotWindow::HideAllSlotButton
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ShowSlotButton@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwSlotNumber$ = 8					; size = 4
?ShowSlotButton@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::ShowSlotButton, COMDAT
; _this$ = ecx

; 728  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 729  : 	TSlot * pSlot;
; 730  : 	if (!GetSlotPointer(dwSlotNumber, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwSlotNumber$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@ShowSlotBu

; 731  : 		return;

  0001b	eb 14		 jmp	 SHORT $LN1@ShowSlotBu
$LN2@ShowSlotBu:

; 732  : 
; 733  : 	if (pSlot->pSlotButton)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  00024	74 0b		 je	 SHORT $LN1@ShowSlotBu

; 734  : 	{
; 735  : 		pSlot->pSlotButton->Show();

  00026	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00029	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  0002c	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show
$LN1@ShowSlotBu:

; 736  : 	}
; 737  : }

  00031	c9		 leave
  00032	c2 04 00	 ret	 4
?ShowSlotButton@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::ShowSlotButton
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?GetSelectedSlotNumber@CSlotWindow@UI@@QAEKK@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
___param0$ = -44					; size = 4
___param0$ = -40					; size = 4
$T7 = -36						; size = 4
tv178 = -32						; size = 4
tv202 = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_dwCount$ = -16						; size = 4
_this$ = -12						; size = 4
_itor$ = -8						; size = 4
$T8 = -2						; size = 1
$T9 = -1						; size = 1
_dwIndex$ = 8						; size = 4
?GetSelectedSlotNumber@CSlotWindow@UI@@QAEKK@Z PROC	; UI::CSlotWindow::GetSelectedSlotNumber, COMDAT
; _this$ = ecx

; 710  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1191 :         return _Mypair._Myval2._Mysize;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]
  00012	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 711  : 	if (dwIndex >= m_dwSelectedSlotIndexList.size())

  00015	8b 45 08	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00018	3b 45 dc	 cmp	 eax, DWORD PTR $T7[ebp]
  0001b	72 08		 jb	 SHORT $LN5@GetSelecte

; 712  : 		return DWORD(-1);

  0001d	83 c8 ff	 or	 eax, -1
  00020	e9 bb 00 00 00	 jmp	 $LN1@GetSelecte
$LN5@GetSelecte:

; 713  : 
; 714  : 	DWORD dwCount = 0;

  00025	83 65 f0 00	 and	 DWORD PTR _dwCount$[ebp], 0

; 715  : 	std::list<DWORD>::iterator itor = m_dwSelectedSlotIndexList.begin();

  00029	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00031	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00034	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00037	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 d8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00044	8b 45 d8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 716  : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  0004a	eb 08		 jmp	 SHORT $LN4@GetSelecte
$LN2@GetSelecte:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  0004f	8b 00		 mov	 eax, DWORD PTR [eax]
  00051	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@GetSelecte:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 716  : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  00054	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00057	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0005c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0005f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00062	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00065	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0006d	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00070	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00073	8d 45 d0	 lea	 eax, DWORD PTR $T6[ebp]
  00076	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00079	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _itor$[ebp]
  0007f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00081	75 09		 jne	 SHORT $LN60@GetSelecte
  00083	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv202[ebp], 1
  0008a	eb 04		 jmp	 SHORT $LN61@GetSelecte
$LN60@GetSelecte:
  0008c	83 65 e4 00	 and	 DWORD PTR tv202[ebp], 0
$LN61@GetSelecte:
  00090	8a 45 e4	 mov	 al, BYTE PTR tv202[ebp]
  00093	88 45 ff	 mov	 BYTE PTR $T9[ebp], al

; 203  :         return !(*this == _Right);

  00096	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  0009a	85 c0		 test	 eax, eax
  0009c	75 09		 jne	 SHORT $LN55@GetSelecte
  0009e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv178[ebp], 1
  000a5	eb 04		 jmp	 SHORT $LN56@GetSelecte
$LN55@GetSelecte:
  000a7	83 65 e0 00	 and	 DWORD PTR tv178[ebp], 0
$LN56@GetSelecte:
  000ab	8a 45 e0	 mov	 al, BYTE PTR tv178[ebp]
  000ae	88 45 fe	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 716  : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  000b1	0f b6 45 fe	 movzx	 eax, BYTE PTR $T8[ebp]
  000b5	85 c0		 test	 eax, eax
  000b7	74 13		 je	 SHORT $LN3@GetSelecte

; 717  : 	{
; 718  : 		if (dwIndex == dwCount)

  000b9	8b 45 08	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  000bc	3b 45 f0	 cmp	 eax, DWORD PTR _dwCount$[ebp]
  000bf	75 02		 jne	 SHORT $LN6@GetSelecte

; 719  : 			break;

  000c1	eb 09		 jmp	 SHORT $LN3@GetSelecte
$LN6@GetSelecte:

; 720  : 
; 721  : 		++dwCount;

  000c3	8b 45 f0	 mov	 eax, DWORD PTR _dwCount$[ebp]
  000c6	40		 inc	 eax
  000c7	89 45 f0	 mov	 DWORD PTR _dwCount$[ebp], eax

; 722  : 	}

  000ca	eb 80		 jmp	 SHORT $LN2@GetSelecte
$LN3@GetSelecte:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000cc	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000cf	83 c0 08	 add	 eax, 8
  000d2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000d5	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
  000d8	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 724  : 	return *itor;

  000db	8b 45 c4	 mov	 eax, DWORD PTR $T3[ebp]
  000de	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@GetSelecte:

; 725  : }

  000e0	c9		 leave
  000e1	c2 04 00	 ret	 4
?GetSelectedSlotNumber@CSlotWindow@UI@@QAEKK@Z ENDP	; UI::CSlotWindow::GetSelectedSlotNumber
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?GetSelectedSlotCount@CSlotWindow@UI@@QAEKXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?GetSelectedSlotCount@CSlotWindow@UI@@QAEKXZ PROC	; UI::CSlotWindow::GetSelectedSlotCount, COMDAT
; _this$ = ecx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1191 :         return _Mypair._Myval2._Mysize;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [eax+132]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 706  : 	return m_dwSelectedSlotIndexList.size();

  00014	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 707  : }

  00017	c9		 leave
  00018	c3		 ret	 0
?GetSelectedSlotCount@CSlotWindow@UI@@QAEKXZ ENDP	; UI::CSlotWindow::GetSelectedSlotCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?isSelectedSlot@CSlotWindow@UI@@QAEHK@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
___param0$ = -28					; size = 4
tv166 = -24						; size = 4
tv190 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_itor$ = -8						; size = 4
$T6 = -2						; size = 1
$T7 = -1						; size = 1
_dwIndex$ = 8						; size = 4
?isSelectedSlot@CSlotWindow@UI@@QAEHK@Z PROC		; UI::CSlotWindow::isSelectedSlot, COMDAT
; _this$ = ecx

; 688  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 689  : 	std::list<DWORD>::iterator itor = m_dwSelectedSlotIndexList.begin();

  00009	8d 45 f8	 lea	 eax, DWORD PTR _itor$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00016	e8 00 00 00 00	 call	 ?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::begin

; 690  : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  0001b	eb 08		 jmp	 SHORT $LN4@isSelected
$LN2@isSelected:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN4@isSelected:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 690  : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  00025	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00028	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0002d	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00030	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00036	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	89 45 e4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0003e	8b 45 e4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00041	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00044	8d 45 e0	 lea	 eax, DWORD PTR $T5[ebp]
  00047	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0004a	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  0004d	8b 4d f8	 mov	 ecx, DWORD PTR _itor$[ebp]
  00050	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00052	75 09		 jne	 SHORT $LN56@isSelected
  00054	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv190[ebp], 1
  0005b	eb 04		 jmp	 SHORT $LN57@isSelected
$LN56@isSelected:
  0005d	83 65 ec 00	 and	 DWORD PTR tv190[ebp], 0
$LN57@isSelected:
  00061	8a 45 ec	 mov	 al, BYTE PTR tv190[ebp]
  00064	88 45 ff	 mov	 BYTE PTR $T7[ebp], al

; 203  :         return !(*this == _Right);

  00067	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN51@isSelected
  0006f	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv166[ebp], 1
  00076	eb 04		 jmp	 SHORT $LN52@isSelected
$LN51@isSelected:
  00078	83 65 e8 00	 and	 DWORD PTR tv166[ebp], 0
$LN52@isSelected:
  0007c	8a 45 e8	 mov	 al, BYTE PTR tv166[ebp]
  0007f	88 45 fe	 mov	 BYTE PTR $T6[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 690  : 	for (; itor != m_dwSelectedSlotIndexList.end(); ++itor)

  00082	0f b6 45 fe	 movzx	 eax, BYTE PTR $T6[ebp]
  00086	85 c0		 test	 eax, eax
  00088	74 23		 je	 SHORT $LN3@isSelected
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0008a	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  0008d	83 c0 08	 add	 eax, 8
  00090	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00093	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  00096	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 692  : 		if (dwIndex == *itor)

  00099	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR _dwIndex$[ebp]
  0009f	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a1	75 05		 jne	 SHORT $LN5@isSelected

; 693  : 			return TRUE;

  000a3	33 c0		 xor	 eax, eax
  000a5	40		 inc	 eax
  000a6	eb 07		 jmp	 SHORT $LN1@isSelected
$LN5@isSelected:

; 694  : 	}

  000a8	e9 70 ff ff ff	 jmp	 $LN2@isSelected
$LN3@isSelected:

; 695  : 
; 696  : 	return FALSE;

  000ad	33 c0		 xor	 eax, eax
$LN1@isSelected:

; 697  : }

  000af	c9		 leave
  000b0	c2 04 00	 ret	 4
?isSelectedSlot@CSlotWindow@UI@@QAEHK@Z ENDP		; UI::CSlotWindow::isSelectedSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SelectSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
$T1 = -64						; size = 4
$T2 = -60						; size = 4
_pSlot$ = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
___param0$ = -32					; size = 4
_this$ = -28						; size = 4
tv161 = -24						; size = 4
tv196 = -20						; size = 4
_this$ = -16						; size = 4
_this$ = -12						; size = 4
_itor$ = -8						; size = 4
$T8 = -2						; size = 1
$T9 = -1						; size = 1
_dwSelectingIndex$ = 8					; size = 4
?SelectSlot@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::SelectSlot, COMDAT
; _this$ = ecx

; 662  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 663  : 	std::list<DWORD>::iterator itor = m_dwSelectedSlotIndexList.begin();

  00009	8d 45 f8	 lea	 eax, DWORD PTR _itor$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00016	e8 00 00 00 00	 call	 ?begin@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::begin
$LN4@SelectSlot:

; 664  : 	for (; itor != m_dwSelectedSlotIndexList.end();)

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00023	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00029	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0002c	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b 00		 mov	 eax, DWORD PTR [eax]
  00031	89 45 e0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00034	8b 45 e0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00037	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0003a	8d 45 dc	 lea	 eax, DWORD PTR $T7[ebp]
  0003d	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00040	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _itor$[ebp]
  00046	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00048	75 09		 jne	 SHORT $LN53@SelectSlot
  0004a	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv196[ebp], 1
  00051	eb 04		 jmp	 SHORT $LN54@SelectSlot
$LN53@SelectSlot:
  00053	83 65 ec 00	 and	 DWORD PTR tv196[ebp], 0
$LN54@SelectSlot:
  00057	8a 45 ec	 mov	 al, BYTE PTR tv196[ebp]
  0005a	88 45 ff	 mov	 BYTE PTR $T9[ebp], al

; 203  :         return !(*this == _Right);

  0005d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  00061	85 c0		 test	 eax, eax
  00063	75 09		 jne	 SHORT $LN48@SelectSlot
  00065	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv161[ebp], 1
  0006c	eb 04		 jmp	 SHORT $LN49@SelectSlot
$LN48@SelectSlot:
  0006e	83 65 e8 00	 and	 DWORD PTR tv161[ebp], 0
$LN49@SelectSlot:
  00072	8a 45 e8	 mov	 al, BYTE PTR tv161[ebp]
  00075	88 45 fe	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 664  : 	for (; itor != m_dwSelectedSlotIndexList.end();)

  00078	0f b6 45 fe	 movzx	 eax, BYTE PTR $T8[ebp]
  0007c	85 c0		 test	 eax, eax
  0007e	74 4a		 je	 SHORT $LN3@SelectSlot
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00080	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  00083	83 c0 08	 add	 eax, 8
  00086	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00089	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  0008c	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 666  : 		if (dwSelectingIndex == *itor)

  0008f	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  00092	8b 4d 08	 mov	 ecx, DWORD PTR _dwSelectingIndex$[ebp]
  00095	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00097	75 24		 jne	 SHORT $LN5@SelectSlot

; 667  : 		{
; 668  : 			itor = m_dwSelectedSlotIndexList.erase(itor);

  00099	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  0009c	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0009f	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  000a2	8d 45 c0	 lea	 eax, DWORD PTR $T1[ebp]
  000a5	50		 push	 eax
  000a6	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  000af	e8 00 00 00 00	 call	 ?erase@?$list@KV?$allocator@K@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@V?$_List_const_iterator@V?$_List_val@U?$_List_simple_types@K@std@@@std@@@2@@Z ; std::list<unsigned long,std::allocator<unsigned long> >::erase
  000b4	8b 00		 mov	 eax, DWORD PTR [eax]
  000b6	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax

; 669  : 			return;

  000b9	eb 49		 jmp	 SHORT $LN1@SelectSlot

; 670  : 		}

  000bb	eb 08		 jmp	 SHORT $LN6@SelectSlot
$LN5@SelectSlot:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _itor$[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 f8	 mov	 DWORD PTR _itor$[ebp], eax
$LN6@SelectSlot:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 675  : 	}

  000c5	e9 51 ff ff ff	 jmp	 $LN4@SelectSlot
$LN3@SelectSlot:

; 676  : 
; 677  : 	TSlot * pSlot;
; 678  : 	if (GetSlotPointer(dwSelectingIndex, &pSlot))

  000ca	8d 45 c8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  000cd	50		 push	 eax
  000ce	ff 75 08	 push	 DWORD PTR _dwSelectingIndex$[ebp]
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d4	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  000d9	85 c0		 test	 eax, eax
  000db	74 27		 je	 SHORT $LN1@SelectSlot

; 679  : 	{
; 680  : 		if (!pSlot->isItem)

  000dd	8b 45 c8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000e0	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  000e4	75 02		 jne	 SHORT $LN8@SelectSlot

; 681  : 			return;

  000e6	eb 1c		 jmp	 SHORT $LN1@SelectSlot
$LN8@SelectSlot:

; 682  : 
; 683  : 		m_dwSelectedSlotIndexList.push_back(dwSelectingIndex);

  000e8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	05 80 00 00 00	 add	 eax, 128		; 00000080H
  000f0	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  000f3	8d 45 08	 lea	 eax, DWORD PTR _dwSelectingIndex$[ebp]
  000f6	50		 push	 eax
  000f7	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000fa	ff 30		 push	 DWORD PTR [eax]
  000fc	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ff	e8 00 00 00 00	 call	 ??$_Emplace@ABK@?$list@KV?$allocator@K@std@@@std@@QAEPAU?$_List_node@KPAX@1@QAU21@ABK@Z ; std::list<unsigned long,std::allocator<unsigned long> >::_Emplace<unsigned long const &>
$LN1@SelectSlot:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 685  : }

  00104	c9		 leave
  00105	c2 04 00	 ret	 4
?SelectSlot@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::SelectSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ClearSelected@CSlotWindow@UI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearSelected@CSlotWindow@UI@@QAEXXZ PROC		; UI::CSlotWindow::ClearSelected, COMDAT
; _this$ = ecx

; 700  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  : 	m_dwSelectedSlotIndexList.clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00010	e8 00 00 00 00	 call	 ?clear@?$list@KV?$allocator@K@std@@@std@@QAEXXZ ; std::list<unsigned long,std::allocator<unsigned long> >::clear

; 702  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?ClearSelected@CSlotWindow@UI@@QAEXXZ ENDP		; UI::CSlotWindow::ClearSelected
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?DisableSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?DisableSlot@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::DisableSlot, COMDAT
; _this$ = ecx

; 651  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 652  : 	TSlot * pSlot;
; 653  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@DisableSlo

; 654  : 		return;

  0001b	eb 0d		 jmp	 SHORT $LN1@DisableSlo
$LN2@DisableSlo:

; 655  : 	SET_BIT(pSlot->dwState, SLOT_STATE_DISABLE);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	83 c8 04	 or	 eax, 4
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@DisableSlo:

; 656  : 	//pSlot->dwState ^= SLOT_STATE_DISABLE;
; 657  : }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?DisableSlot@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::DisableSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?EnableSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?EnableSlot@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::EnableSlot, COMDAT
; _this$ = ecx

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 643  : 	TSlot * pSlot;
; 644  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@EnableSlot

; 645  : 		return;

  0001b	eb 0d		 jmp	 SHORT $LN1@EnableSlot
$LN2@EnableSlot:

; 646  : 
; 647  : 	REMOVE_BIT(pSlot->dwState, SLOT_STATE_DISABLE);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	83 e0 fb	 and	 eax, -5			; fffffffbH
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@EnableSlot:

; 648  : 	//pSlot->dwState |= SLOT_STATE_DISABLE;
; 649  : }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?EnableSlot@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::EnableSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetUseSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?SetUseSlot@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::SetUseSlot, COMDAT
; _this$ = ecx

; 634  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 635  : 	TSlot * pSlot;
; 636  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@SetUseSlot

; 637  : 		return;

  0001b	eb 0d		 jmp	 SHORT $LN1@SetUseSlot
$LN2@SetUseSlot:

; 638  : 
; 639  : 	pSlot->dwState ^= SLOT_STATE_CANT_USE;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	83 f0 02	 xor	 eax, 2
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@SetUseSlot:

; 640  : }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?SetUseSlot@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::SetUseSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetCantUseSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?SetCantUseSlot@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::SetCantUseSlot, COMDAT
; _this$ = ecx

; 626  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 627  : 	TSlot * pSlot;
; 628  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@SetCantUse

; 629  : 		return;

  0001b	eb 0d		 jmp	 SHORT $LN1@SetCantUse
$LN2@SetCantUse:

; 630  : 
; 631  : 	pSlot->dwState |= SLOT_STATE_CANT_USE;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	83 c8 02	 or	 eax, 2
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@SetCantUse:

; 632  : }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?SetCantUseSlot@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::SetCantUseSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?UnlockSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?UnlockSlot@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::UnlockSlot, COMDAT
; _this$ = ecx

; 618  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 619  : 	TSlot * pSlot;
; 620  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@UnlockSlot

; 621  : 		return;

  0001b	eb 0d		 jmp	 SHORT $LN1@UnlockSlot
$LN2@UnlockSlot:

; 622  : 
; 623  : 	pSlot->dwState ^= SLOT_STATE_LOCK;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	83 f0 01	 xor	 eax, 1
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@UnlockSlot:

; 624  : }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?UnlockSlot@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::UnlockSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?LockSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?LockSlot@CSlotWindow@UI@@QAEXK@Z PROC			; UI::CSlotWindow::LockSlot, COMDAT
; _this$ = ecx

; 610  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 611  : 	TSlot * pSlot;
; 612  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@LockSlot

; 613  : 		return;

  0001b	eb 0d		 jmp	 SHORT $LN1@LockSlot
$LN2@LockSlot:

; 614  : 
; 615  : 	pSlot->dwState |= SLOT_STATE_LOCK;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	83 c8 01	 or	 eax, 1
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00028	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@LockSlot:

; 616  : }

  0002a	c9		 leave
  0002b	c2 04 00	 ret	 4
?LockSlot@CSlotWindow@UI@@QAEXK@Z ENDP			; UI::CSlotWindow::LockSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?GetSlotCount@CSlotWindow@UI@@QAEKXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?GetSlotCount@CSlotWindow@UI@@QAEKXZ PROC		; UI::CSlotWindow::GetSlotCount, COMDAT
; _this$ = ecx

; 605  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1191 :         return _Mypair._Myval2._Mysize;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [eax+140]
  00011	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 606  : 	return m_SlotList.size();

  00014	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 607  : }

  00017	c9		 leave
  00018	c3		 ret	 0
?GetSlotCount@CSlotWindow@UI@@QAEKXZ ENDP		; UI::CSlotWindow::GetSlotCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?RefreshSlot@CSlotWindow@UI@@QAEXXZ
_TEXT	SEGMENT
_pSlot$1 = -8						; size = 4
_this$ = -4						; size = 4
?RefreshSlot@CSlotWindow@UI@@QAEXXZ PROC		; UI::CSlotWindow::RefreshSlot, COMDAT
; _this$ = ecx

; 585  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 586  : 	OnRefreshSlot();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 00		 mov	 eax, DWORD PTR [eax]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	ff 90 a0 00 00
	00		 call	 DWORD PTR [eax+160]

; 587  : 
; 588  : 	// NOTE : Refresh  ToolTip    - [levites]
; 589  : 	if (IsRendering())

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?IsRendering@CWindow@UI@@QAE_NXZ ; UI::CWindow::IsRendering
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	74 2c		 je	 SHORT $LN1@RefreshSlo

; 590  : 	{
; 591  : 		TSlot * pSlot;
; 592  : 		if (GetPickedSlotPointer(&pSlot))

  00025	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$1[ebp]
  00028	50		 push	 eax
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 00		 mov	 eax, DWORD PTR [eax]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	ff 90 9c 00 00
	00		 call	 DWORD PTR [eax+156]
  00037	85 c0		 test	 eax, eax
  00039	74 16		 je	 SHORT $LN1@RefreshSlo

; 593  : 		{
; 594  : 			OnOverOutItem();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?OnOverOutItem@CSlotWindow@UI@@QAEXXZ ; UI::CSlotWindow::OnOverOutItem

; 595  : 			OnOverInItem(pSlot->dwSlotNumber);

  00043	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$1[ebp]
  00046	ff 70 04	 push	 DWORD PTR [eax+4]
  00049	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	e8 00 00 00 00	 call	 ?OnOverInItem@CSlotWindow@UI@@QAEHK@Z ; UI::CSlotWindow::OnOverInItem
$LN1@RefreshSlo:

; 596  : 		}
; 597  : 	}
; 598  : }

  00051	c9		 leave
  00052	c3		 ret	 0
?RefreshSlot@CSlotWindow@UI@@QAEXXZ ENDP		; UI::CSlotWindow::RefreshSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?DeactivateSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?DeactivateSlot@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::DeactivateSlot, COMDAT
; _this$ = ecx

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 525  : 	TSlot * pSlot;
; 526  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@Deactivate

; 527  : 		return;

  0001b	eb 07		 jmp	 SHORT $LN1@Deactivate
$LN2@Deactivate:

; 528  : 
; 529  : 	pSlot->bActive = FALSE;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	83 60 1c 00	 and	 DWORD PTR [eax+28], 0
$LN1@Deactivate:

; 530  : }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?DeactivateSlot@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::DeactivateSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ActivateSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?ActivateSlot@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::ActivateSlot, COMDAT
; _this$ = ecx

; 510  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 511  : 	TSlot * pSlot;
; 512  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@ActivateSl

; 513  : 		return;

  0001b	eb 1e		 jmp	 SHORT $LN1@ActivateSl
$LN2@ActivateSl:

; 514  : 
; 515  : 	pSlot->bActive = TRUE;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [eax+28], 1

; 516  : 
; 517  : 	if (!m_pSlotActiveEffect)

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	83 b8 a4 00 00
	00 00		 cmp	 DWORD PTR [eax+164], 0
  00031	75 08		 jne	 SHORT $LN1@ActivateSl

; 518  : 	{
; 519  : 		__CreateSlotEnableEffect();

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?__CreateSlotEnableEffect@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__CreateSlotEnableEffect
$LN1@ActivateSl:

; 520  : 	}
; 521  : }

  0003b	c9		 leave
  0003c	c2 04 00	 ret	 4
?ActivateSlot@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::ActivateSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetSlotCoolTime@CSlotWindow@UI@@QAEXKMM@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
$T1 = -12						; size = 4
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
_fCoolTime$ = 12					; size = 4
_fElapsedTime$ = 16					; size = 4
?SetSlotCoolTime@CSlotWindow@UI@@QAEXKMM@Z PROC		; UI::CSlotWindow::SetSlotCoolTime, COMDAT
; _this$ = ecx

; 500  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 501  : 	TSlot * pSlot;
; 502  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00009	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  00010	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00018	85 c0		 test	 eax, eax
  0001a	75 02		 jne	 SHORT $LN2@SetSlotCoo

; 503  : 		return;

  0001c	eb 32		 jmp	 SHORT $LN1@SetSlotCoo
$LN2@SetSlotCoo:

; 504  : 
; 505  : 	pSlot->fCoolTime = fCoolTime;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00021	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fCoolTime$[ebp]
  00026	f3 0f 11 40 14	 movss	 DWORD PTR [eax+20], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCTimer@@@@0PAVCTimer@@A ; CSingleton<CTimer>::ms_singleton
  00030	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 506  : 	pSlot->fStartCoolTime = CTimer::Instance().GetCurrentSecond() - fElapsedTime;

  00033	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00036	e8 00 00 00 00	 call	 ?GetCurrentSecond@CTimer@@QAEMXZ ; CTimer::GetCurrentSecond
  0003b	d9 5d f0	 fstp	 DWORD PTR tv83[ebp]
  0003e	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR tv83[ebp]
  00043	f3 0f 5c 45 10	 subss	 xmm0, DWORD PTR _fElapsedTime$[ebp]
  00048	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0004b	f3 0f 11 40 18	 movss	 DWORD PTR [eax+24], xmm0
$LN1@SetSlotCoo:

; 507  : }

  00050	c9		 leave
  00051	c2 0c 00	 ret	 12			; 0000000cH
?SetSlotCoolTime@CSlotWindow@UI@@QAEXKMM@Z ENDP		; UI::CSlotWindow::SetSlotCoolTime
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z
_TEXT	SEGMENT
$T2 = -72						; size = 4
tv83 = -68						; size = 4
tv155 = -64						; size = 4
$T3 = -60						; size = 4
_this$ = -56						; size = 4
_pNumberLine$4 = -52					; size = 4
$T5 = -48						; size = 4
tv85 = -44						; size = 4
_pSlot$ = -40						; size = 4
_szCount$6 = -36					; size = 17
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwIndex$ = 8						; size = 4
_dwGrade$ = 12						; size = 4
_dwCount$ = 16						; size = 4
?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z PROC		; UI::CSlotWindow::SetSlotCountNew, COMDAT
; _this$ = ecx

; 454  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 455  : 	TSlot * pSlot;
; 456  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  0002b	8d 45 d8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0002e	50		 push	 eax
  0002f	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  00032	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  0003a	85 c0		 test	 eax, eax
  0003c	75 05		 jne	 SHORT $LN4@SetSlotCou

; 457  : 		return;

  0003e	e9 29 01 00 00	 jmp	 $LN1@SetSlotCou
$LN4@SetSlotCou:

; 458  : 
; 459  : 	if (dwCount <= 0)

  00043	83 7d 10 00	 cmp	 DWORD PTR _dwCount$[ebp], 0
  00047	77 39		 ja	 SHORT $LN5@SetSlotCou

; 460  : 	{
; 461  : 		if (pSlot->pNumberLine)

  00049	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0004c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00050	74 2b		 je	 SHORT $LN7@SetSlotCou

; 462  : 		{
; 463  : 			delete pSlot->pNumberLine;

  00052	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00055	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00058	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
  0005b	83 7d d0 00	 cmp	 DWORD PTR $T5[ebp], 0
  0005f	74 11		 je	 SHORT $LN14@SetSlotCou
  00061	6a 01		 push	 1
  00063	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  00066	8b 00		 mov	 eax, DWORD PTR [eax]
  00068	8b 4d d0	 mov	 ecx, DWORD PTR $T5[ebp]
  0006b	ff 10		 call	 DWORD PTR [eax]
  0006d	89 45 bc	 mov	 DWORD PTR tv83[ebp], eax
  00070	eb 04		 jmp	 SHORT $LN15@SetSlotCou
$LN14@SetSlotCou:
  00072	83 65 bc 00	 and	 DWORD PTR tv83[ebp], 0
$LN15@SetSlotCou:

; 464  : 			pSlot->pNumberLine = NULL;

  00076	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00079	83 60 38 00	 and	 DWORD PTR [eax+56], 0
$LN7@SetSlotCou:

; 465  : 		}
; 466  : 	}

  0007d	e9 ea 00 00 00	 jmp	 $LN1@SetSlotCou
$LN5@SetSlotCou:

; 467  : 	else
; 468  : 	{
; 469  : 		char szCount[16+1];
; 470  : 
; 471  : 		switch (dwGrade)

  00082	8b 45 0c	 mov	 eax, DWORD PTR _dwGrade$[ebp]
  00085	89 45 d4	 mov	 DWORD PTR tv85[ebp], eax
  00088	83 7d d4 00	 cmp	 DWORD PTR tv85[ebp], 0
  0008c	74 14		 je	 SHORT $LN8@SetSlotCou
  0008e	83 7d d4 01	 cmp	 DWORD PTR tv85[ebp], 1
  00092	74 26		 je	 SHORT $LN9@SetSlotCou
  00094	83 7d d4 02	 cmp	 DWORD PTR tv85[ebp], 2
  00098	74 38		 je	 SHORT $LN10@SetSlotCou
  0009a	83 7d d4 03	 cmp	 DWORD PTR tv85[ebp], 3
  0009e	74 4a		 je	 SHORT $LN11@SetSlotCou
  000a0	eb 5b		 jmp	 SHORT $LN2@SetSlotCou
$LN8@SetSlotCou:

; 472  : 		{
; 473  : 			case 0:
; 474  : 				_snprintf(szCount, sizeof(szCount), "%d", dwCount);

  000a2	ff 75 10	 push	 DWORD PTR _dwCount$[ebp]
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  000aa	6a 11		 push	 17			; 00000011H
  000ac	8d 45 dc	 lea	 eax, DWORD PTR _szCount$6[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 __snprintf
  000b5	83 c4 10	 add	 esp, 16			; 00000010H

; 475  : 				break;

  000b8	eb 43		 jmp	 SHORT $LN2@SetSlotCou
$LN9@SetSlotCou:

; 476  : 			case 1:
; 477  : 				_snprintf(szCount, sizeof(szCount), "m%d", dwCount);

  000ba	ff 75 10	 push	 DWORD PTR _dwCount$[ebp]
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_03CIOACFJF@m?$CFd@
  000c2	6a 11		 push	 17			; 00000011H
  000c4	8d 45 dc	 lea	 eax, DWORD PTR _szCount$6[ebp]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 __snprintf
  000cd	83 c4 10	 add	 esp, 16			; 00000010H

; 478  : 				break;

  000d0	eb 2b		 jmp	 SHORT $LN2@SetSlotCou
$LN10@SetSlotCou:

; 479  : 			case 2:
; 480  : 				_snprintf(szCount, sizeof(szCount), "g%d", dwCount);

  000d2	ff 75 10	 push	 DWORD PTR _dwCount$[ebp]
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_03EHFNMFPB@g?$CFd@
  000da	6a 11		 push	 17			; 00000011H
  000dc	8d 45 dc	 lea	 eax, DWORD PTR _szCount$6[ebp]
  000df	50		 push	 eax
  000e0	e8 00 00 00 00	 call	 __snprintf
  000e5	83 c4 10	 add	 esp, 16			; 00000010H

; 481  : 				break;

  000e8	eb 13		 jmp	 SHORT $LN2@SetSlotCou
$LN11@SetSlotCou:

; 482  : 			case 3:
; 483  : 				_snprintf(szCount, sizeof(szCount), "p");

  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_01JBBJJEPG@p@
  000ef	6a 11		 push	 17			; 00000011H
  000f1	8d 45 dc	 lea	 eax, DWORD PTR _szCount$6[ebp]
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 __snprintf
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@SetSlotCou:

; 484  : 				break;
; 485  : 		}
; 486  : 
; 487  : 		if (!pSlot->pNumberLine)

  000fd	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00100	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00104	75 57		 jne	 SHORT $LN12@SetSlotCou

; 488  : 		{
; 489  : 			CNumberLine * pNumberLine = new UI::CNumberLine(this);

  00106	68 bc 00 00 00	 push	 188			; 000000bcH
  0010b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00110	59		 pop	 ecx
  00111	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
  00114	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00118	83 7d c4 00	 cmp	 DWORD PTR $T3[ebp], 0
  0011c	74 10		 je	 SHORT $LN16@SetSlotCou
  0011e	ff 75 c8	 push	 DWORD PTR _this$[ebp]
  00121	8b 4d c4	 mov	 ecx, DWORD PTR $T3[ebp]
  00124	e8 00 00 00 00	 call	 ??0CNumberLine@UI@@QAE@PAVCWindow@1@@Z ; UI::CNumberLine::CNumberLine
  00129	89 45 c0	 mov	 DWORD PTR tv155[ebp], eax
  0012c	eb 04		 jmp	 SHORT $LN17@SetSlotCou
$LN16@SetSlotCou:
  0012e	83 65 c0 00	 and	 DWORD PTR tv155[ebp], 0
$LN17@SetSlotCou:
  00132	8b 45 c0	 mov	 eax, DWORD PTR tv155[ebp]
  00135	89 45 b8	 mov	 DWORD PTR $T2[ebp], eax
  00138	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0013c	8b 45 b8	 mov	 eax, DWORD PTR $T2[ebp]
  0013f	89 45 cc	 mov	 DWORD PTR _pNumberLine$4[ebp], eax

; 490  : 			pNumberLine->SetHorizontalAlign(CNumberLine::HORIZONTAL_ALIGN_RIGHT);

  00142	6a 02		 push	 2
  00144	8b 4d cc	 mov	 ecx, DWORD PTR _pNumberLine$4[ebp]
  00147	e8 00 00 00 00	 call	 ?SetHorizontalAlign@CNumberLine@UI@@QAEXH@Z ; UI::CNumberLine::SetHorizontalAlign

; 491  : 			pNumberLine->Show();

  0014c	8b 4d cc	 mov	 ecx, DWORD PTR _pNumberLine$4[ebp]
  0014f	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show

; 492  : 			pSlot->pNumberLine = pNumberLine;

  00154	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00157	8b 4d cc	 mov	 ecx, DWORD PTR _pNumberLine$4[ebp]
  0015a	89 48 38	 mov	 DWORD PTR [eax+56], ecx
$LN12@SetSlotCou:

; 493  : 		}
; 494  : 
; 495  : 		pSlot->pNumberLine->SetNumber(szCount);

  0015d	8d 45 dc	 lea	 eax, DWORD PTR _szCount$6[ebp]
  00160	50		 push	 eax
  00161	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00164	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00167	e8 00 00 00 00	 call	 ?SetNumber@CNumberLine@UI@@QAEXPBD@Z ; UI::CNumberLine::SetNumber
$LN1@SetSlotCou:

; 496  : 	}
; 497  : }

  0016c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0016f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00176	59		 pop	 ecx
  00177	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0017a	33 cd		 xor	 ecx, ebp
  0017c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00181	c9		 leave
  00182	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z$0:
  00000	68 bc 00 00 00	 push	 188			; 000000bcH
  00005	ff 75 c4	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetSlotCountNew@CSlotWindow@UI@@QAEXKKK@Z ENDP		; UI::CSlotWindow::SetSlotCountNew
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z
_TEXT	SEGMENT
$T2 = -68						; size = 4
tv83 = -64						; size = 4
tv139 = -60						; size = 4
$T3 = -56						; size = 4
_this$ = -52						; size = 4
_pNumberLine$4 = -48					; size = 4
$T5 = -44						; size = 4
_pSlot$ = -40						; size = 4
_szCount$6 = -36					; size = 17
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwIndex$ = 8						; size = 4
_dwCount$ = 12						; size = 4
?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z PROC		; UI::CSlotWindow::SetSlotCount, COMDAT
; _this$ = ecx

; 423  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 424  : 	TSlot * pSlot;
; 425  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  0002b	8d 45 d8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0002e	50		 push	 eax
  0002f	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  00032	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  0003a	85 c0		 test	 eax, eax
  0003c	75 05		 jne	 SHORT $LN2@SetSlotCou

; 426  : 		return;

  0003e	e9 c4 00 00 00	 jmp	 $LN1@SetSlotCou
$LN2@SetSlotCou:

; 427  : 
; 428  : 	if (dwCount <= 0)

  00043	83 7d 0c 00	 cmp	 DWORD PTR _dwCount$[ebp], 0
  00047	77 39		 ja	 SHORT $LN3@SetSlotCou

; 429  : 	{
; 430  : 		if (pSlot->pNumberLine)

  00049	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0004c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00050	74 2b		 je	 SHORT $LN5@SetSlotCou

; 431  : 		{
; 432  : 			delete pSlot->pNumberLine;

  00052	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00055	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00058	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
  0005b	83 7d d4 00	 cmp	 DWORD PTR $T5[ebp], 0
  0005f	74 11		 je	 SHORT $LN8@SetSlotCou
  00061	6a 01		 push	 1
  00063	8b 45 d4	 mov	 eax, DWORD PTR $T5[ebp]
  00066	8b 00		 mov	 eax, DWORD PTR [eax]
  00068	8b 4d d4	 mov	 ecx, DWORD PTR $T5[ebp]
  0006b	ff 10		 call	 DWORD PTR [eax]
  0006d	89 45 c0	 mov	 DWORD PTR tv83[ebp], eax
  00070	eb 04		 jmp	 SHORT $LN9@SetSlotCou
$LN8@SetSlotCou:
  00072	83 65 c0 00	 and	 DWORD PTR tv83[ebp], 0
$LN9@SetSlotCou:

; 433  : 			pSlot->pNumberLine = NULL;

  00076	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00079	83 60 38 00	 and	 DWORD PTR [eax+56], 0
$LN5@SetSlotCou:

; 434  : 		}
; 435  : 	}

  0007d	e9 85 00 00 00	 jmp	 $LN1@SetSlotCou
$LN3@SetSlotCou:

; 436  : 	else
; 437  : 	{
; 438  : 		char szCount[16+1];
; 439  : 		_snprintf(szCount, sizeof(szCount), "%d", dwCount);

  00082	ff 75 0c	 push	 DWORD PTR _dwCount$[ebp]
  00085	68 00 00 00 00	 push	 OFFSET ??_C@_02DPKJAMEF@?$CFd@
  0008a	6a 11		 push	 17			; 00000011H
  0008c	8d 45 dc	 lea	 eax, DWORD PTR _szCount$6[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 __snprintf
  00095	83 c4 10	 add	 esp, 16			; 00000010H

; 440  : 
; 441  : 		if (!pSlot->pNumberLine)

  00098	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0009b	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0009f	75 57		 jne	 SHORT $LN6@SetSlotCou

; 442  : 		{
; 443  : 			CNumberLine * pNumberLine = new UI::CNumberLine(this);

  000a1	68 bc 00 00 00	 push	 188			; 000000bcH
  000a6	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ab	59		 pop	 ecx
  000ac	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  000af	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000b3	83 7d c8 00	 cmp	 DWORD PTR $T3[ebp], 0
  000b7	74 10		 je	 SHORT $LN10@SetSlotCou
  000b9	ff 75 cc	 push	 DWORD PTR _this$[ebp]
  000bc	8b 4d c8	 mov	 ecx, DWORD PTR $T3[ebp]
  000bf	e8 00 00 00 00	 call	 ??0CNumberLine@UI@@QAE@PAVCWindow@1@@Z ; UI::CNumberLine::CNumberLine
  000c4	89 45 c4	 mov	 DWORD PTR tv139[ebp], eax
  000c7	eb 04		 jmp	 SHORT $LN11@SetSlotCou
$LN10@SetSlotCou:
  000c9	83 65 c4 00	 and	 DWORD PTR tv139[ebp], 0
$LN11@SetSlotCou:
  000cd	8b 45 c4	 mov	 eax, DWORD PTR tv139[ebp]
  000d0	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
  000d3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000d7	8b 45 bc	 mov	 eax, DWORD PTR $T2[ebp]
  000da	89 45 d0	 mov	 DWORD PTR _pNumberLine$4[ebp], eax

; 444  : 			pNumberLine->SetHorizontalAlign(CNumberLine::HORIZONTAL_ALIGN_RIGHT);

  000dd	6a 02		 push	 2
  000df	8b 4d d0	 mov	 ecx, DWORD PTR _pNumberLine$4[ebp]
  000e2	e8 00 00 00 00	 call	 ?SetHorizontalAlign@CNumberLine@UI@@QAEXH@Z ; UI::CNumberLine::SetHorizontalAlign

; 445  : 			pNumberLine->Show();

  000e7	8b 4d d0	 mov	 ecx, DWORD PTR _pNumberLine$4[ebp]
  000ea	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show

; 446  : 			pSlot->pNumberLine = pNumberLine;

  000ef	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000f2	8b 4d d0	 mov	 ecx, DWORD PTR _pNumberLine$4[ebp]
  000f5	89 48 38	 mov	 DWORD PTR [eax+56], ecx
$LN6@SetSlotCou:

; 447  : 		}
; 448  : 
; 449  : 		pSlot->pNumberLine->SetNumber(szCount);

  000f8	8d 45 dc	 lea	 eax, DWORD PTR _szCount$6[ebp]
  000fb	50		 push	 eax
  000fc	8b 45 d8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000ff	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00102	e8 00 00 00 00	 call	 ?SetNumber@CNumberLine@UI@@QAEXPBD@Z ; UI::CNumberLine::SetNumber
$LN1@SetSlotCou:

; 450  : 	}
; 451  : }

  00107	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0010a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00111	59		 pop	 ecx
  00112	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00115	33 cd		 xor	 ecx, ebp
  00117	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0011c	c9		 leave
  0011d	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z$0:
  00000	68 bc 00 00 00	 push	 188			; 000000bcH
  00005	ff 75 c8	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetSlotCount@CSlotWindow@UI@@QAEXKK@Z ENDP		; UI::CSlotWindow::SetSlotCount
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetSlot@CSlotWindow@UI@@QAEXKKEEPAVCGraphicImage@@AAUD3DXCOLOR@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
_dwVirtualNumber$ = 12					; size = 4
_byWidth$ = 16						; size = 1
_byHeight$ = 20						; size = 1
_pImage$ = 24						; size = 4
_diffuseColor$ = 28					; size = 4
?SetSlot@CSlotWindow@UI@@QAEXKKEEPAVCGraphicImage@@AAUD3DXCOLOR@@@Z PROC ; UI::CSlotWindow::SetSlot, COMDAT
; _this$ = ecx

; 383  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 384  : 	TSlot * pSlot;
; 385  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 05		 jne	 SHORT $LN2@SetSlot

; 386  : 		return;

  0001b	e9 f1 00 00 00	 jmp	 $LN1@SetSlot
$LN2@SetSlot:

; 387  : 
; 388  : 	if (pSlot->isItem)

  00020	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00023	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00027	74 3d		 je	 SHORT $LN4@SetSlot

; 389  : 	if (pSlot->dwItemIndex == dwVirtualNumber)

  00029	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002f	3b 45 0c	 cmp	 eax, DWORD PTR _dwVirtualNumber$[ebp]
  00032	75 32		 jne	 SHORT $LN4@SetSlot

; 390  : 	{
; 391  : 		pSlot->dwState = 0;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00037	83 20 00	 and	 DWORD PTR [eax], 0

; 392  : 		pSlot->isItem = TRUE;

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0003d	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 393  : 		if (pImage && pSlot->pInstance)

  00044	83 7d 18 00	 cmp	 DWORD PTR _pImage$[ebp], 0
  00048	74 17		 je	 SHORT $LN5@SetSlot
  0004a	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0004d	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  00051	74 0e		 je	 SHORT $LN5@SetSlot

; 394  : 		{
; 395  : 			pSlot->pInstance->SetImagePointer(pImage);

  00053	ff 75 18	 push	 DWORD PTR _pImage$[ebp]
  00056	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00059	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  0005c	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
$LN5@SetSlot:

; 396  : 		}
; 397  : 		return;

  00061	e9 ab 00 00 00	 jmp	 $LN1@SetSlot
$LN4@SetSlot:

; 398  : 	}
; 399  : 
; 400  : 	ClearSlot(pSlot);

  00066	ff 75 fc	 push	 DWORD PTR _pSlot$[ebp]
  00069	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?ClearSlot@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::ClearSlot

; 401  : 	pSlot->dwState = 0;

  00071	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00074	83 20 00	 and	 DWORD PTR [eax], 0

; 402  : 	pSlot->isItem = TRUE;

  00077	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0007a	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 403  : 	pSlot->dwItemIndex = dwVirtualNumber;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00084	8b 4d 0c	 mov	 ecx, DWORD PTR _dwVirtualNumber$[ebp]
  00087	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 404  : 
; 405  : 	if (pImage)

  0008a	83 7d 18 00	 cmp	 DWORD PTR _pImage$[ebp], 0
  0008e	74 5b		 je	 SHORT $LN6@SetSlot

; 406  : 	{
; 407  : 		assert(NULL == pSlot->pInstance);
; 408  : 		pSlot->pInstance = CGraphicImageInstance::New();

  00090	e8 00 00 00 00	 call	 ?New@CGraphicImageInstance@@SAPAV1@XZ ; CGraphicImageInstance::New
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00098	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 409  : 		pSlot->pInstance->SetDiffuseColor(diffuseColor.r, diffuseColor.g, diffuseColor.b, diffuseColor.a);

  0009b	8b 45 1c	 mov	 eax, DWORD PTR _diffuseColor$[ebp]
  0009e	51		 push	 ecx
  0009f	f3 0f 10 40 0c	 movss	 xmm0, DWORD PTR [eax+12]
  000a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a9	8b 45 1c	 mov	 eax, DWORD PTR _diffuseColor$[ebp]
  000ac	51		 push	 ecx
  000ad	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000b2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000b7	8b 45 1c	 mov	 eax, DWORD PTR _diffuseColor$[ebp]
  000ba	51		 push	 ecx
  000bb	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c5	8b 45 1c	 mov	 eax, DWORD PTR _diffuseColor$[ebp]
  000c8	51		 push	 ecx
  000c9	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d2	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000d5	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000d8	e8 00 00 00 00	 call	 ?SetDiffuseColor@CGraphicImageInstance@@QAEXMMMM@Z ; CGraphicImageInstance::SetDiffuseColor

; 410  : 		pSlot->pInstance->SetImagePointer(pImage);

  000dd	ff 75 18	 push	 DWORD PTR _pImage$[ebp]
  000e0	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000e3	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000e6	e8 00 00 00 00	 call	 ?SetImagePointer@CGraphicImageInstance@@QAEXPAVCGraphicImage@@@Z ; CGraphicImageInstance::SetImagePointer
$LN6@SetSlot:

; 411  : 	}
; 412  : 
; 413  : 	pSlot->byxPlacedItemSize = byWidth;

  000eb	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000ee	8a 4d 10	 mov	 cl, BYTE PTR _byWidth$[ebp]
  000f1	88 48 30	 mov	 BYTE PTR [eax+48], cl

; 414  : 	pSlot->byyPlacedItemSize = byHeight;

  000f4	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  000f7	8a 4d 14	 mov	 cl, BYTE PTR _byHeight$[ebp]
  000fa	88 48 31	 mov	 BYTE PTR [eax+49], cl

; 415  : 
; 416  : 	if (pSlot->pCoverButton)

  000fd	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00100	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00104	74 0b		 je	 SHORT $LN7@SetSlot

; 417  : 	{
; 418  : 		pSlot->pCoverButton->Show();

  00106	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00109	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0010c	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show
$LN7@SetSlot:
$LN1@SetSlot:

; 419  : 	}
; 420  : }

  00111	c9		 leave
  00112	c2 18 00	 ret	 24			; 00000018H
?SetSlot@CSlotWindow@UI@@QAEXKKEEPAVCGraphicImage@@AAUD3DXCOLOR@@@Z ENDP ; UI::CSlotWindow::SetSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ClearSlot@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?ClearSlot@CSlotWindow@UI@@QAEXK@Z PROC			; UI::CSlotWindow::ClearSlot, COMDAT
; _this$ = ecx

; 533  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 534  : 	TSlot * pSlot;
; 535  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@ClearSlot

; 536  : 		return;

  0001b	eb 0b		 jmp	 SHORT $LN1@ClearSlot
$LN2@ClearSlot:

; 537  : 
; 538  : 	ClearSlot(pSlot);

  0001d	ff 75 f8	 push	 DWORD PTR _pSlot$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?ClearSlot@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::ClearSlot
$LN1@ClearSlot:

; 539  : }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?ClearSlot@CSlotWindow@UI@@QAEXK@Z ENDP			; UI::CSlotWindow::ClearSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ClearAllSlot@CSlotWindow@UI@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?ClearAllSlot@CSlotWindow@UI@@QAEXXZ PROC		; UI::CSlotWindow::ClearAllSlot, COMDAT
; _this$ = ecx

; 580  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 581  : 	Destroy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Destroy@CSlotWindow@UI@@QAEXXZ ; UI::CSlotWindow::Destroy

; 582  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?ClearAllSlot@CSlotWindow@UI@@QAEXXZ ENDP		; UI::CSlotWindow::ClearAllSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?HasSlot@CSlotWindow@UI@@QAEHK@Z
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?HasSlot@CSlotWindow@UI@@QAEHK@Z PROC			; UI::CSlotWindow::HasSlot, COMDAT
; _this$ = ecx

; 374  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 375  : 	TSlot * pSlot;
; 376  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $LN2@HasSlot

; 377  : 		return FALSE;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 03		 jmp	 SHORT $LN1@HasSlot
$LN2@HasSlot:

; 378  : 
; 379  : 	return TRUE;

  0001f	33 c0		 xor	 eax, eax
  00021	40		 inc	 eax
$LN1@HasSlot:

; 380  : }

  00022	c9		 leave
  00023	c2 04 00	 ret	 4
?HasSlot@CSlotWindow@UI@@QAEHK@Z ENDP			; UI::CSlotWindow::HasSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?IsDisableCoverButton@CSlotWindow@UI@@QAEHK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?IsDisableCoverButton@CSlotWindow@UI@@QAEHK@Z PROC	; UI::CSlotWindow::IsDisableCoverButton, COMDAT
; _this$ = ecx

; 317  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 318  : 	TSlot * pSlot;
; 319  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $LN2@IsDisableC

; 320  : 		return FALSE;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 18		 jmp	 SHORT $LN1@IsDisableC
$LN2@IsDisableC:

; 321  : 
; 322  : 	if (!pSlot->pCoverButton)

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00022	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00026	75 04		 jne	 SHORT $LN3@IsDisableC

; 323  : 		return FALSE;

  00028	33 c0		 xor	 eax, eax
  0002a	eb 0b		 jmp	 SHORT $LN1@IsDisableC
$LN3@IsDisableC:

; 324  : 
; 325  : 	return pSlot->pCoverButton->IsDisable();

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002f	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00032	e8 00 00 00 00	 call	 ?IsDisable@CButton@UI@@QAEHXZ ; UI::CButton::IsDisable
$LN1@IsDisableC:

; 326  : }

  00037	c9		 leave
  00038	c2 04 00	 ret	 4
?IsDisableCoverButton@CSlotWindow@UI@@QAEHK@Z ENDP	; UI::CSlotWindow::IsDisableCoverButton
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?HideSlotBaseImage@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?HideSlotBaseImage@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::HideSlotBaseImage, COMDAT
; _this$ = ecx

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 309  : 	TSlot * pSlot;
; 310  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@HideSlotBa

; 311  : 		return;

  0001b	eb 07		 jmp	 SHORT $LN1@HideSlotBa
$LN2@HideSlotBa:

; 312  : 
; 313  : 	pSlot->bRenderBaseSlotImage = false;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	c6 40 3c 00	 mov	 BYTE PTR [eax+60], 0
$LN1@HideSlotBa:

; 314  : }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?HideSlotBaseImage@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::HideSlotBaseImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?ShowSlotBaseImage@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_pSlot$ = -8						; size = 4
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?ShowSlotBaseImage@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::ShowSlotBaseImage, COMDAT
; _this$ = ecx

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 300  : 	TSlot * pSlot;
; 301  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@ShowSlotBa

; 302  : 		return;

  0001b	eb 07		 jmp	 SHORT $LN1@ShowSlotBa
$LN2@ShowSlotBa:

; 303  : 
; 304  : 	pSlot->bRenderBaseSlotImage = true;

  0001d	8b 45 f8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	c6 40 3c 01	 mov	 BYTE PTR [eax+60], 1
$LN1@ShowSlotBa:

; 305  : }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?ShowSlotBaseImage@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::ShowSlotBaseImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetAlwaysRenderCoverButton@CSlotWindow@UI@@QAEXK_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
_bAlwaysRender$ = 12					; size = 1
?SetAlwaysRenderCoverButton@CSlotWindow@UI@@QAEXK_N@Z PROC ; UI::CSlotWindow::SetAlwaysRenderCoverButton, COMDAT
; _this$ = ecx

; 287  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 288  : 	TSlot * pSlot;
; 289  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@SetAlwaysR

; 290  : 		return;

  0001b	eb 24		 jmp	 SHORT $LN1@SetAlwaysR
$LN2@SetAlwaysR:

; 291  : 
; 292  : 	if (bAlwaysRender)

  0001d	0f b6 45 0c	 movzx	 eax, BYTE PTR _bAlwaysRender$[ebp]
  00021	85 c0		 test	 eax, eax
  00023	74 0f		 je	 SHORT $LN3@SetAlwaysR

; 293  : 		SET_BIT(pSlot->dwState, SLOT_STATE_ALWAYS_RENDER_COVER);

  00025	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	83 c8 08	 or	 eax, 8
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  00030	89 01		 mov	 DWORD PTR [ecx], eax
  00032	eb 0d		 jmp	 SHORT $LN1@SetAlwaysR
$LN3@SetAlwaysR:

; 294  : 	else
; 295  : 		REMOVE_BIT(pSlot->dwState, SLOT_STATE_ALWAYS_RENDER_COVER);

  00034	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	83 e0 f7	 and	 eax, -9			; fffffff7H
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _pSlot$[ebp]
  0003f	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@SetAlwaysR:

; 296  : }

  00041	c9		 leave
  00042	c2 08 00	 ret	 8
?SetAlwaysRenderCoverButton@CSlotWindow@UI@@QAEXK_N@Z ENDP ; UI::CSlotWindow::SetAlwaysRenderCoverButton
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?DisableCoverButton@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?DisableCoverButton@CSlotWindow@UI@@QAEXK@Z PROC	; UI::CSlotWindow::DisableCoverButton, COMDAT
; _this$ = ecx

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 276  : 	TSlot * pSlot;
; 277  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@DisableCov

; 278  : 		return;

  0001b	eb 16		 jmp	 SHORT $LN1@DisableCov
$LN2@DisableCov:

; 279  : 
; 280  : 	if (!pSlot->pCoverButton)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00024	75 02		 jne	 SHORT $LN3@DisableCov

; 281  : 		return;

  00026	eb 0b		 jmp	 SHORT $LN1@DisableCov
$LN3@DisableCov:

; 282  : 
; 283  : 	pSlot->pCoverButton->Disable();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002b	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0002e	e8 00 00 00 00	 call	 ?Disable@CButton@UI@@QAEXXZ ; UI::CButton::Disable
$LN1@DisableCov:

; 284  : }

  00033	c9		 leave
  00034	c2 04 00	 ret	 4
?DisableCoverButton@CSlotWindow@UI@@QAEXK@Z ENDP	; UI::CSlotWindow::DisableCoverButton
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?EnableCoverButton@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pSlot$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
?EnableCoverButton@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::EnableCoverButton, COMDAT
; _this$ = ecx

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 264  : 	TSlot * pSlot;
; 265  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0000f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00017	85 c0		 test	 eax, eax
  00019	75 02		 jne	 SHORT $LN2@EnableCove

; 266  : 		return;

  0001b	eb 16		 jmp	 SHORT $LN1@EnableCove
$LN2@EnableCove:

; 267  : 
; 268  : 	if (!pSlot->pCoverButton)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00020	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00024	75 02		 jne	 SHORT $LN3@EnableCove

; 269  : 		return;

  00026	eb 0b		 jmp	 SHORT $LN1@EnableCove
$LN3@EnableCove:

; 270  : 
; 271  : 	pSlot->pCoverButton->Enable();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0002b	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0002e	e8 00 00 00 00	 call	 ?Enable@CButton@UI@@QAEXXZ ; UI::CButton::Enable
$LN1@EnableCove:

; 272  : }

  00033	c9		 leave
  00034	c2 04 00	 ret	 4
?EnableCoverButton@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::EnableCoverButton
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z
_TEXT	SEGMENT
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
_rSlot$5 = -76						; size = 4
$T6 = -72						; size = 4
$T7 = -68						; size = 4
$T8 = -64						; size = 4
___param0$ = -60					; size = 4
___param0$ = -56					; size = 4
tv133 = -52						; size = 4
$T9 = -48						; size = 4
tv205 = -44						; size = 4
tv229 = -40						; size = 4
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_itor$10 = -24						; size = 4
_rpSignImage$11 = -20					; size = 4
$T12 = -14						; size = 1
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_c_szImageName$ = 8					; size = 4
?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z PROC ; UI::CSlotWindow::AppendRequirementSignImage, COMDAT
; _this$ = ecx

; 356  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 357  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00028	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00030	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00033	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	89 45 ac	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00039	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 45 c8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00043	8b 45 c8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00046	89 45 e8	 mov	 DWORD PTR _itor$10[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 357  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00049	eb 08		 jmp	 SHORT $LN4@AppendRequ
$LN2@AppendRequ:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0004b	8b 45 e8	 mov	 eax, DWORD PTR _itor$10[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	89 45 e8	 mov	 DWORD PTR _itor$10[ebp], eax
$LN4@AppendRequ:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 357  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00053	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00056	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0005b	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0005e	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00061	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00064	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 00		 mov	 eax, DWORD PTR [eax]
  00069	89 45 c4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0006c	8b 45 c4	 mov	 eax, DWORD PTR ___param0$[ebp]
  0006f	89 45 c0	 mov	 DWORD PTR $T8[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00072	8d 45 c0	 lea	 eax, DWORD PTR $T8[ebp]
  00075	89 45 bc	 mov	 DWORD PTR $T7[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00078	8b 45 bc	 mov	 eax, DWORD PTR $T7[ebp]
  0007b	8b 4d e8	 mov	 ecx, DWORD PTR _itor$10[ebp]
  0007e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00080	75 09		 jne	 SHORT $LN59@AppendRequ
  00082	c7 45 d8 01 00
	00 00		 mov	 DWORD PTR tv229[ebp], 1
  00089	eb 04		 jmp	 SHORT $LN60@AppendRequ
$LN59@AppendRequ:
  0008b	83 65 d8 00	 and	 DWORD PTR tv229[ebp], 0
$LN60@AppendRequ:
  0008f	8a 45 d8	 mov	 al, BYTE PTR tv229[ebp]
  00092	88 45 f3	 mov	 BYTE PTR $T13[ebp], al

; 203  :         return !(*this == _Right);

  00095	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00099	85 c0		 test	 eax, eax
  0009b	75 09		 jne	 SHORT $LN54@AppendRequ
  0009d	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR tv205[ebp], 1
  000a4	eb 04		 jmp	 SHORT $LN55@AppendRequ
$LN54@AppendRequ:
  000a6	83 65 d4 00	 and	 DWORD PTR tv205[ebp], 0
$LN55@AppendRequ:
  000aa	8a 45 d4	 mov	 al, BYTE PTR tv205[ebp]
  000ad	88 45 f2	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 357  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  000b0	0f b6 45 f2	 movzx	 eax, BYTE PTR $T12[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	0f 84 89 00 00
	00		 je	 $LN1@AppendRequ
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000bc	8b 45 e8	 mov	 eax, DWORD PTR _itor$10[ebp]
  000bf	83 c0 08	 add	 eax, 8
  000c2	89 45 b8	 mov	 DWORD PTR $T6[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000c5	8b 45 b8	 mov	 eax, DWORD PTR $T6[ebp]
  000c8	89 45 b4	 mov	 DWORD PTR _rSlot$5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 360  : 		CImageBox *& rpSignImage = rSlot.pSignImage;

  000cb	8b 45 b4	 mov	 eax, DWORD PTR _rSlot$5[ebp]
  000ce	83 c0 48	 add	 eax, 72			; 00000048H
  000d1	89 45 ec	 mov	 DWORD PTR _rpSignImage$11[ebp], eax

; 361  : 
; 362  : 		if (!rpSignImage)

  000d4	8b 45 ec	 mov	 eax, DWORD PTR _rpSignImage$11[ebp]
  000d7	83 38 00	 cmp	 DWORD PTR [eax], 0
  000da	75 4d		 jne	 SHORT $LN5@AppendRequ

; 363  : 		{
; 364  : 			rpSignImage = new CImageBox(NULL);

  000dc	6a 7c		 push	 124			; 0000007cH
  000de	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000e3	59		 pop	 ecx
  000e4	89 45 d0	 mov	 DWORD PTR $T9[ebp], eax
  000e7	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000eb	83 7d d0 00	 cmp	 DWORD PTR $T9[ebp], 0
  000ef	74 0f		 je	 SHORT $LN7@AppendRequ
  000f1	6a 00		 push	 0
  000f3	8b 4d d0	 mov	 ecx, DWORD PTR $T9[ebp]
  000f6	e8 00 00 00 00	 call	 ??0CImageBox@UI@@QAE@PAU_object@@@Z ; UI::CImageBox::CImageBox
  000fb	89 45 cc	 mov	 DWORD PTR tv133[ebp], eax
  000fe	eb 04		 jmp	 SHORT $LN8@AppendRequ
$LN7@AppendRequ:
  00100	83 65 cc 00	 and	 DWORD PTR tv133[ebp], 0
$LN8@AppendRequ:
  00104	8b 45 cc	 mov	 eax, DWORD PTR tv133[ebp]
  00107	89 45 b0	 mov	 DWORD PTR $T4[ebp], eax
  0010a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0010e	8b 45 ec	 mov	 eax, DWORD PTR _rpSignImage$11[ebp]
  00111	8b 4d b0	 mov	 ecx, DWORD PTR $T4[ebp]
  00114	89 08		 mov	 DWORD PTR [eax], ecx

; 365  : 			CWindowManager::Instance().SetParent(rpSignImage, this);

  00116	ff 75 e4	 push	 DWORD PTR _this$[ebp]
  00119	8b 45 ec	 mov	 eax, DWORD PTR _rpSignImage$11[ebp]
  0011c	ff 30		 push	 DWORD PTR [eax]
  0011e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00124	e8 00 00 00 00	 call	 ?SetParent@CWindowManager@UI@@QAEXPAVCWindow@2@0@Z ; UI::CWindowManager::SetParent
$LN5@AppendRequ:

; 366  : 		}
; 367  : 
; 368  : 		rpSignImage->LoadImage(c_szImageName);

  00129	ff 75 08	 push	 DWORD PTR _c_szImageName$[ebp]
  0012c	8b 45 ec	 mov	 eax, DWORD PTR _rpSignImage$11[ebp]
  0012f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00131	e8 00 00 00 00	 call	 ?LoadImageA@CImageBox@UI@@QAEHPBD@Z ; UI::CImageBox::LoadImageA

; 369  : 		rpSignImage->Hide();

  00136	8b 45 ec	 mov	 eax, DWORD PTR _rpSignImage$11[ebp]
  00139	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013b	e8 00 00 00 00	 call	 ?Hide@CWindow@UI@@QAEXXZ ; UI::CWindow::Hide

; 370  : 	}

  00140	e9 06 ff ff ff	 jmp	 $LN2@AppendRequ
$LN1@AppendRequ:

; 371  : }

  00145	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00148	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0014f	59		 pop	 ecx
  00150	c9		 leave
  00151	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z$0:
  00000	6a 7c		 push	 124			; 0000007cH
  00002	ff 75 d0	 push	 DWORD PTR $T9[ebp]
  00005	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000a	59		 pop	 ecx
  0000b	59		 pop	 ecx
  0000c	c3		 ret	 0
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
__ehhandler$?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z:
  00012	90		 npad	 1
  00013	90		 npad	 1
  00014	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00018	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001b	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  0001e	33 c8		 xor	 ecx, eax
  00020	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00025	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z
  0002a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AppendRequirementSignImage@CSlotWindow@UI@@QAEXPBD@Z ENDP ; UI::CSlotWindow::AppendRequirementSignImage
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z
_TEXT	SEGMENT
$T2 = -96						; size = 4
$T3 = -92						; size = 4
$T4 = -88						; size = 4
_dwSlotNumber$ = -84					; size = 4
$T5 = -80						; size = 4
$T6 = -76						; size = 4
$T7 = -72						; size = 4
___param0$ = -68					; size = 4
___param0$ = -64					; size = 4
_this$ = -60						; size = 4
tv136 = -56						; size = 4
tv241 = -52						; size = 4
tv265 = -48						; size = 4
_this$ = -44						; size = 4
_this$ = -40						; size = 4
_rSlot$8 = -36						; size = 4
_this$ = -32						; size = 4
_itor$9 = -28						; size = 4
$T10 = -24						; size = 4
_rpSlotButton$11 = -20					; size = 4
$T12 = -14						; size = 1
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_c_szUpImageName$ = 8					; size = 4
_c_szOverImageName$ = 12				; size = 4
_c_szDownImageName$ = 16				; size = 4
?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z PROC	; UI::CSlotWindow::AppendSlotButton, COMDAT
; _this$ = ecx

; 334  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 54	 sub	 esp, 84			; 00000054H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 335  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00028	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00030	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00033	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	89 45 a4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00039	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 45 c0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00043	8b 45 c0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00046	89 45 e4	 mov	 DWORD PTR _itor$9[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 335  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00049	eb 08		 jmp	 SHORT $LN4@AppendSlot
$LN2@AppendSlot:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0004b	8b 45 e4	 mov	 eax, DWORD PTR _itor$9[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]
  00050	89 45 e4	 mov	 DWORD PTR _itor$9[ebp], eax
$LN4@AppendSlot:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 335  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00053	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00056	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0005b	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0005e	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00061	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00064	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 00		 mov	 eax, DWORD PTR [eax]
  00069	89 45 bc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0006c	8b 45 bc	 mov	 eax, DWORD PTR ___param0$[ebp]
  0006f	89 45 b8	 mov	 DWORD PTR $T7[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00072	8d 45 b8	 lea	 eax, DWORD PTR $T7[ebp]
  00075	89 45 b4	 mov	 DWORD PTR $T6[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00078	8b 45 b4	 mov	 eax, DWORD PTR $T6[ebp]
  0007b	8b 4d e4	 mov	 ecx, DWORD PTR _itor$9[ebp]
  0007e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00080	75 09		 jne	 SHORT $LN59@AppendSlot
  00082	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR tv265[ebp], 1
  00089	eb 04		 jmp	 SHORT $LN60@AppendSlot
$LN59@AppendSlot:
  0008b	83 65 d0 00	 and	 DWORD PTR tv265[ebp], 0
$LN60@AppendSlot:
  0008f	8a 45 d0	 mov	 al, BYTE PTR tv265[ebp]
  00092	88 45 f3	 mov	 BYTE PTR $T13[ebp], al

; 203  :         return !(*this == _Right);

  00095	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00099	85 c0		 test	 eax, eax
  0009b	75 09		 jne	 SHORT $LN54@AppendSlot
  0009d	c7 45 cc 01 00
	00 00		 mov	 DWORD PTR tv241[ebp], 1
  000a4	eb 04		 jmp	 SHORT $LN55@AppendSlot
$LN54@AppendSlot:
  000a6	83 65 cc 00	 and	 DWORD PTR tv241[ebp], 0
$LN55@AppendSlot:
  000aa	8a 45 cc	 mov	 al, BYTE PTR tv241[ebp]
  000ad	88 45 f2	 mov	 BYTE PTR $T12[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 335  : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  000b0	0f b6 45 f2	 movzx	 eax, BYTE PTR $T12[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	0f 84 16 01 00
	00		 je	 $LN1@AppendSlot
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  000bc	8b 45 e4	 mov	 eax, DWORD PTR _itor$9[ebp]
  000bf	83 c0 08	 add	 eax, 8
  000c2	89 45 b0	 mov	 DWORD PTR $T5[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000c5	8b 45 b0	 mov	 eax, DWORD PTR $T5[ebp]
  000c8	89 45 dc	 mov	 DWORD PTR _rSlot$8[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 338  : 		CSlotButton *& rpSlotButton = rSlot.pSlotButton;

  000cb	8b 45 dc	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  000ce	83 c0 44	 add	 eax, 68			; 00000044H
  000d1	89 45 ec	 mov	 DWORD PTR _rpSlotButton$11[ebp], eax

; 339  : 
; 340  : 		if (!rpSlotButton)

  000d4	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  000d7	83 38 00	 cmp	 DWORD PTR [eax], 0
  000da	0f 85 a0 00 00
	00		 jne	 $LN5@AppendSlot

; 341  : 		{
; 342  : 			rpSlotButton = new CSlotButton(CSlotButton::SLOT_BUTTON_TYPE_PLUS, rSlot.dwSlotNumber, this);

  000e0	68 14 01 00 00	 push	 276			; 00000114H
  000e5	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000ea	59		 pop	 ecx
  000eb	89 45 e8	 mov	 DWORD PTR $T10[ebp], eax
  000ee	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000f2	83 7d e8 00	 cmp	 DWORD PTR $T10[ebp], 0
  000f6	74 46		 je	 SHORT $LN7@AppendSlot
  000f8	8b 45 dc	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  000fb	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000fe	89 45 ac	 mov	 DWORD PTR _dwSlotNumber$[ebp], eax

; 21   : 		CSlotButton(ESlotButtonType dwType, DWORD dwSlotNumber, CSlotWindow * pParent) : CButton(NULL)

  00101	6a 00		 push	 0
  00103	8b 4d e8	 mov	 ecx, DWORD PTR $T10[ebp]
  00106	e8 00 00 00 00	 call	 ??0CButton@UI@@QAE@PAU_object@@@Z ; UI::CButton::CButton

; 22   : 		{

  0010b	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  0010e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSlotButton@CSlotWindow@UI@@6B@

; 23   : 			m_dwSlotButtonType = dwType;

  00114	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  00117	83 a0 08 01 00
	00 00		 and	 DWORD PTR [eax+264], 0

; 24   : 			m_dwSlotNumber = dwSlotNumber;

  0011e	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  00121	8b 4d ac	 mov	 ecx, DWORD PTR _dwSlotNumber$[ebp]
  00124	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 25   : 			m_pParent = pParent;

  0012a	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  0012d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00130	89 88 10 01 00
	00		 mov	 DWORD PTR [eax+272], ecx

; 341  : 		{
; 342  : 			rpSlotButton = new CSlotButton(CSlotButton::SLOT_BUTTON_TYPE_PLUS, rSlot.dwSlotNumber, this);

  00136	8b 45 e8	 mov	 eax, DWORD PTR $T10[ebp]
  00139	89 45 c8	 mov	 DWORD PTR tv136[ebp], eax
  0013c	eb 04		 jmp	 SHORT $LN8@AppendSlot
$LN7@AppendSlot:
  0013e	83 65 c8 00	 and	 DWORD PTR tv136[ebp], 0
$LN8@AppendSlot:
  00142	8b 45 c8	 mov	 eax, DWORD PTR tv136[ebp]
  00145	89 45 a8	 mov	 DWORD PTR $T4[ebp], eax
  00148	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0014c	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  0014f	8b 4d a8	 mov	 ecx, DWORD PTR $T4[ebp]
  00152	89 08		 mov	 DWORD PTR [eax], ecx

; 343  : 			rpSlotButton->AddFlag(FLAG_FLOAT);

  00154	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  00157	8b 00		 mov	 eax, DWORD PTR [eax]
  00159	89 45 c4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h

; 99   : 			void			AddFlag(DWORD flag)		{ SET_BIT(m_dwFlag, flag);		}

  0015c	8b 45 c4	 mov	 eax, DWORD PTR _this$[ebp]
  0015f	8b 40 58	 mov	 eax, DWORD PTR [eax+88]
  00162	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  00167	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	89 41 58	 mov	 DWORD PTR [ecx+88], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 344  : 			CWindowManager::Instance().SetParent(rpSlotButton, this);

  0016d	ff 75 e0	 push	 DWORD PTR _this$[ebp]
  00170	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  00173	ff 30		 push	 DWORD PTR [eax]
  00175	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0017b	e8 00 00 00 00	 call	 ?SetParent@CWindowManager@UI@@QAEXPAVCWindow@2@0@Z ; UI::CWindowManager::SetParent
$LN5@AppendSlot:

; 345  : 		}
; 346  : 
; 347  : 		rpSlotButton->SetUpVisual(c_szUpImageName);

  00180	ff 75 08	 push	 DWORD PTR _c_szUpImageName$[ebp]
  00183	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  00186	8b 08		 mov	 ecx, DWORD PTR [eax]
  00188	e8 00 00 00 00	 call	 ?SetUpVisual@CButton@UI@@QAEHPBD@Z ; UI::CButton::SetUpVisual

; 348  : 		rpSlotButton->SetOverVisual(c_szOverImageName);

  0018d	ff 75 0c	 push	 DWORD PTR _c_szOverImageName$[ebp]
  00190	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  00193	8b 08		 mov	 ecx, DWORD PTR [eax]
  00195	e8 00 00 00 00	 call	 ?SetOverVisual@CButton@UI@@QAEHPBD@Z ; UI::CButton::SetOverVisual

; 349  : 		rpSlotButton->SetDownVisual(c_szDownImageName);

  0019a	ff 75 10	 push	 DWORD PTR _c_szDownImageName$[ebp]
  0019d	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  001a0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a2	e8 00 00 00 00	 call	 ?SetDownVisual@CButton@UI@@QAEHPBD@Z ; UI::CButton::SetDownVisual

; 350  : 		rpSlotButton->SetPosition(rSlot.ixPosition + 1, rSlot.iyPosition + 19);

  001a7	8b 45 dc	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  001aa	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  001ad	83 c0 13	 add	 eax, 19			; 00000013H
  001b0	50		 push	 eax
  001b1	8b 45 dc	 mov	 eax, DWORD PTR _rSlot$8[ebp]
  001b4	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  001b7	40		 inc	 eax
  001b8	50		 push	 eax
  001b9	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  001bc	8b 08		 mov	 ecx, DWORD PTR [eax]
  001be	e8 00 00 00 00	 call	 ?SetPosition@CWindow@UI@@QAEXJJ@Z ; UI::CWindow::SetPosition

; 351  : 		rpSlotButton->Hide();

  001c3	8b 45 ec	 mov	 eax, DWORD PTR _rpSlotButton$11[ebp]
  001c6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c8	e8 00 00 00 00	 call	 ?Hide@CWindow@UI@@QAEXXZ ; UI::CWindow::Hide

; 352  : 	}

  001cd	e9 79 fe ff ff	 jmp	 $LN2@AppendSlot
$LN1@AppendSlot:

; 353  : }

  001d2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001d5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001dc	59		 pop	 ecx
  001dd	c9		 leave
  001de	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z$0:
  00000	68 14 01 00 00	 push	 276			; 00000114H
  00005	ff 75 e8	 push	 DWORD PTR $T10[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AppendSlotButton@CSlotWindow@UI@@QAEXPBD00@Z ENDP	; UI::CSlotWindow::AppendSlotButton
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetSlotBaseImage@CSlotWindow@UI@@QAEXPBDMMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_szFileName$ = 8					; size = 4
_fr$ = 12						; size = 4
_fg$ = 16						; size = 4
_fb$ = 20						; size = 4
_fa$ = 24						; size = 4
?SetSlotBaseImage@CSlotWindow@UI@@QAEXPBDMMMM@Z PROC	; UI::CSlotWindow::SetSlotBaseImage, COMDAT
; _this$ = ecx

; 329  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 330  : 	__CreateBaseImage(c_szFileName, fr, fg, fb, fa);

  00007	51		 push	 ecx
  00008	f3 0f 10 45 18	 movss	 xmm0, DWORD PTR _fa$[ebp]
  0000d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00012	51		 push	 ecx
  00013	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fb$[ebp]
  00018	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001d	51		 push	 ecx
  0001e	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fg$[ebp]
  00023	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00028	51		 push	 ecx
  00029	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fr$[ebp]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__CreateBaseImage@CSlotWindow@UI@@IAEXPBDMMMM@Z ; UI::CSlotWindow::__CreateBaseImage

; 331  : }

  0003e	c9		 leave
  0003f	c2 14 00	 ret	 20			; 00000014H
?SetSlotBaseImage@CSlotWindow@UI@@QAEXPBDMMMM@Z ENDP	; UI::CSlotWindow::SetSlotBaseImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
_this$ = -44						; size = 4
$T2 = -40						; size = 4
_dwSlotNumber$ = -36					; size = 4
tv86 = -32						; size = 4
_this$ = -28						; size = 4
_pSlot$ = -24						; size = 4
$T3 = -20						; size = 4
_rpCoverButton$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwIndex$ = 8						; size = 4
_c_szUpImageName$ = 12					; size = 4
_c_szOverImageName$ = 16				; size = 4
_c_szDownImageName$ = 20				; size = 4
_c_szDisableImageName$ = 24				; size = 4
_bLeftButtonEnable$ = 28				; size = 4
_bRightButtonEnable$ = 32				; size = 4
?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z PROC	; UI::CSlotWindow::SetCoverButton, COMDAT
; _this$ = ecx

; 233  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 234  : 	TSlot * pSlot;
; 235  : 	if (!GetSlotPointer(dwIndex, &pSlot))

  00028	8d 45 e8	 lea	 eax, DWORD PTR _pSlot$[ebp]
  0002b	50		 push	 eax
  0002c	ff 75 08	 push	 DWORD PTR _dwIndex$[ebp]
  0002f	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?GetSlotPointer@CSlotWindow@UI@@IAEHKPAPAUSSlot@12@@Z ; UI::CSlotWindow::GetSlotPointer
  00037	85 c0		 test	 eax, eax
  00039	75 05		 jne	 SHORT $LN2@SetCoverBu

; 236  : 		return;

  0003b	e9 49 01 00 00	 jmp	 $LN1@SetCoverBu
$LN2@SetCoverBu:

; 237  : 
; 238  : 	CCoverButton *& rpCoverButton = pSlot->pCoverButton;

  00040	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00043	83 c0 40	 add	 eax, 64			; 00000040H
  00046	89 45 f0	 mov	 DWORD PTR _rpCoverButton$[ebp], eax

; 239  : 
; 240  : 	if (!rpCoverButton)

  00049	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  0004c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0004f	0f 85 ad 00 00
	00		 jne	 $LN3@SetCoverBu

; 241  : 	{
; 242  : 		rpCoverButton = new CCoverButton(CSlotButton::SLOT_BUTTON_TYPE_COVER, pSlot->dwSlotNumber, this);

  00055	68 1c 01 00 00	 push	 284			; 0000011cH
  0005a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0005f	59		 pop	 ecx
  00060	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax
  00063	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00067	83 7d ec 00	 cmp	 DWORD PTR $T3[ebp], 0
  0006b	74 6c		 je	 SHORT $LN6@SetCoverBu
  0006d	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00070	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00073	89 45 dc	 mov	 DWORD PTR _dwSlotNumber$[ebp], eax

; 21   : 		CSlotButton(ESlotButtonType dwType, DWORD dwSlotNumber, CSlotWindow * pParent) : CButton(NULL)

  00076	6a 00		 push	 0
  00078	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0007b	e8 00 00 00 00	 call	 ??0CButton@UI@@QAE@PAU_object@@@Z ; UI::CButton::CButton

; 22   : 		{

  00080	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00083	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSlotButton@CSlotWindow@UI@@6B@

; 23   : 			m_dwSlotButtonType = dwType;

  00089	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  0008c	c7 80 08 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+264], 1

; 24   : 			m_dwSlotNumber = dwSlotNumber;

  00096	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  00099	8b 4d dc	 mov	 ecx, DWORD PTR _dwSlotNumber$[ebp]
  0009c	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 25   : 			m_pParent = pParent;

  000a2	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  000a5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	89 88 10 01 00
	00		 mov	 DWORD PTR [eax+272], ecx

; 92   : 		{

  000ae	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  000b1	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CCoverButton@CSlotWindow@UI@@6B@

; 93   : 			m_bLeftButtonEnable = TRUE;

  000b7	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  000ba	c7 80 14 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+276], 1

; 94   : 			m_bRightButtonEnable = TRUE;

  000c4	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  000c7	c7 80 18 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+280], 1

; 241  : 	{
; 242  : 		rpCoverButton = new CCoverButton(CSlotButton::SLOT_BUTTON_TYPE_COVER, pSlot->dwSlotNumber, this);

  000d1	8b 45 ec	 mov	 eax, DWORD PTR $T3[ebp]
  000d4	89 45 e0	 mov	 DWORD PTR tv86[ebp], eax
  000d7	eb 04		 jmp	 SHORT $LN7@SetCoverBu
$LN6@SetCoverBu:
  000d9	83 65 e0 00	 and	 DWORD PTR tv86[ebp], 0
$LN7@SetCoverBu:
  000dd	8b 45 e0	 mov	 eax, DWORD PTR tv86[ebp]
  000e0	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  000e3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000e7	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  000ea	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
  000ed	89 08		 mov	 DWORD PTR [eax], ecx

; 243  : 		CWindowManager::Instance().SetParent(rpCoverButton, this);

  000ef	ff 75 e4	 push	 DWORD PTR _this$[ebp]
  000f2	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  000f5	ff 30		 push	 DWORD PTR [eax]
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  000fd	e8 00 00 00 00	 call	 ?SetParent@CWindowManager@UI@@QAEXPAVCWindow@2@0@Z ; UI::CWindowManager::SetParent
$LN3@SetCoverBu:

; 244  : 	}
; 245  : 
; 246  : 	rpCoverButton->SetLeftButtonEnable(bLeftButtonEnable);

  00102	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  00105	8b 00		 mov	 eax, DWORD PTR [eax]
  00107	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax

; 102  : 			m_bLeftButtonEnable = bEnable;

  0010a	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	8b 4d 1c	 mov	 ecx, DWORD PTR _bLeftButtonEnable$[ebp]
  00110	89 88 14 01 00
	00		 mov	 DWORD PTR [eax+276], ecx

; 247  : 	rpCoverButton->SetRightButtonEnable(bRightButtonEnable);

  00116	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  00119	8b 00		 mov	 eax, DWORD PTR [eax]
  0011b	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax

; 106  : 			m_bRightButtonEnable = bEnable;

  0011e	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00121	8b 4d 20	 mov	 ecx, DWORD PTR _bRightButtonEnable$[ebp]
  00124	89 88 18 01 00
	00		 mov	 DWORD PTR [eax+280], ecx

; 248  : 	rpCoverButton->SetUpVisual(c_szUpImageName);

  0012a	ff 75 0c	 push	 DWORD PTR _c_szUpImageName$[ebp]
  0012d	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	e8 00 00 00 00	 call	 ?SetUpVisual@CButton@UI@@QAEHPBD@Z ; UI::CButton::SetUpVisual

; 249  : 	rpCoverButton->SetOverVisual(c_szOverImageName);

  00137	ff 75 10	 push	 DWORD PTR _c_szOverImageName$[ebp]
  0013a	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  0013d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013f	e8 00 00 00 00	 call	 ?SetOverVisual@CButton@UI@@QAEHPBD@Z ; UI::CButton::SetOverVisual

; 250  : 	rpCoverButton->SetDownVisual(c_szDownImageName);

  00144	ff 75 14	 push	 DWORD PTR _c_szDownImageName$[ebp]
  00147	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  0014a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014c	e8 00 00 00 00	 call	 ?SetDownVisual@CButton@UI@@QAEHPBD@Z ; UI::CButton::SetDownVisual

; 251  : 	rpCoverButton->SetDisableVisual(c_szDisableImageName);

  00151	ff 75 18	 push	 DWORD PTR _c_szDisableImageName$[ebp]
  00154	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  00157	8b 08		 mov	 ecx, DWORD PTR [eax]
  00159	e8 00 00 00 00	 call	 ?SetDisableVisual@CButton@UI@@QAEHPBD@Z ; UI::CButton::SetDisableVisual

; 252  : 	rpCoverButton->Enable();

  0015e	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  00161	8b 08		 mov	 ecx, DWORD PTR [eax]
  00163	e8 00 00 00 00	 call	 ?Enable@CButton@UI@@QAEXXZ ; UI::CButton::Enable

; 253  : 	rpCoverButton->Show();

  00168	8b 45 f0	 mov	 eax, DWORD PTR _rpCoverButton$[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	e8 00 00 00 00	 call	 ?Show@CWindow@UI@@QAEXXZ ; UI::CWindow::Show

; 254  : 
; 255  : 	// NOTE : Cover  Plus    ..
; 256  : 	if (pSlot->pSlotButton)

  00172	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  00175	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  00179	74 0e		 je	 SHORT $LN1@SetCoverBu

; 257  : 	{
; 258  : 		SetTop(pSlot->pSlotButton);

  0017b	8b 45 e8	 mov	 eax, DWORD PTR _pSlot$[ebp]
  0017e	ff 70 44	 push	 DWORD PTR [eax+68]
  00181	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00184	e8 00 00 00 00	 call	 ?SetTop@CWindow@UI@@QAEXPAV12@@Z ; UI::CWindow::SetTop
$LN1@SetCoverBu:

; 259  : 	}
; 260  : }

  00189	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0018c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00193	59		 pop	 ecx
  00194	c9		 leave
  00195	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z$0:
  00000	68 1c 01 00 00	 push	 284			; 0000011cH
  00005	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?SetCoverButton@CSlotWindow@UI@@QAEXKPBD000HH@Z ENDP	; UI::CSlotWindow::SetCoverButton
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?AppendSlot@CSlotWindow@UI@@QAEXKHHHH@Z
_TEXT	SEGMENT
_Slot$ = -88						; size = 80
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_dwIndex$ = 8						; size = 4
_ixPosition$ = 12					; size = 4
_iyPosition$ = 16					; size = 4
_ixCellSize$ = 20					; size = 4
_iyCellSize$ = 24					; size = 4
?AppendSlot@CSlotWindow@UI@@QAEXKHHHH@Z PROC		; UI::CSlotWindow::AppendSlot, COMDAT
; _this$ = ecx

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 214  : 	TSlot Slot;
; 215  : 	Slot.pInstance = NULL;

  00009	83 65 dc 00	 and	 DWORD PTR _Slot$[ebp+52], 0

; 216  : 	Slot.pNumberLine = NULL;

  0000d	83 65 e0 00	 and	 DWORD PTR _Slot$[ebp+56], 0

; 217  : 	Slot.pCoverButton = NULL;

  00011	83 65 e8 00	 and	 DWORD PTR _Slot$[ebp+64], 0

; 218  : 	Slot.pSlotButton = NULL;

  00015	83 65 ec 00	 and	 DWORD PTR _Slot$[ebp+68], 0

; 219  : 	Slot.pSignImage = NULL;

  00019	83 65 f0 00	 and	 DWORD PTR _Slot$[ebp+72], 0

; 220  : 	Slot.pFinishCoolTimeEffect = NULL;

  0001d	83 65 f4 00	 and	 DWORD PTR _Slot$[ebp+76], 0

; 221  : 
; 222  : 	ClearSlot(&Slot);

  00021	8d 45 a8	 lea	 eax, DWORD PTR _Slot$[ebp]
  00024	50		 push	 eax
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?ClearSlot@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::ClearSlot

; 223  : 	Slot.dwSlotNumber = dwIndex;

  0002d	8b 45 08	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00030	89 45 ac	 mov	 DWORD PTR _Slot$[ebp+4], eax

; 224  : 	Slot.dwCenterSlotNumber = dwIndex;

  00033	8b 45 08	 mov	 eax, DWORD PTR _dwIndex$[ebp]
  00036	89 45 b0	 mov	 DWORD PTR _Slot$[ebp+8], eax

; 225  : 	Slot.ixPosition = ixPosition;

  00039	8b 45 0c	 mov	 eax, DWORD PTR _ixPosition$[ebp]
  0003c	89 45 c8	 mov	 DWORD PTR _Slot$[ebp+32], eax

; 226  : 	Slot.iyPosition = iyPosition;

  0003f	8b 45 10	 mov	 eax, DWORD PTR _iyPosition$[ebp]
  00042	89 45 cc	 mov	 DWORD PTR _Slot$[ebp+36], eax

; 227  : 	Slot.ixCellSize = ixCellSize;

  00045	8b 45 14	 mov	 eax, DWORD PTR _ixCellSize$[ebp]
  00048	89 45 d0	 mov	 DWORD PTR _Slot$[ebp+40], eax

; 228  : 	Slot.iyCellSize = iyCellSize;

  0004b	8b 45 18	 mov	 eax, DWORD PTR _iyCellSize$[ebp]
  0004e	89 45 d4	 mov	 DWORD PTR _Slot$[ebp+44], eax

; 229  : 	m_SlotList.push_back(Slot);

  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	05 88 00 00 00	 add	 eax, 136		; 00000088H
  00059	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  0005c	8d 45 a8	 lea	 eax, DWORD PTR _Slot$[ebp]
  0005f	50		 push	 eax
  00060	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00063	ff 30		 push	 DWORD PTR [eax]
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ??$_Emplace@ABUSSlot@CSlotWindow@UI@@@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@1@QAU21@ABUSSlot@CSlotWindow@UI@@@Z ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Emplace<UI::CSlotWindow::SSlot const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 230  : }

  0006d	c9		 leave
  0006e	c2 14 00	 ret	 20			; 00000014H
?AppendSlot@CSlotWindow@UI@@QAEXKHHHH@Z ENDP		; UI::CSlotWindow::AppendSlot
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetSlotStyle@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwStyle$ = 8						; size = 4
?SetSlotStyle@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::SetSlotStyle, COMDAT
; _this$ = ecx

; 208  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  : 	m_dwSlotStyle = dwStyle;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwStyle$[ebp]
  0000d	89 48 7c	 mov	 DWORD PTR [eax+124], ecx

; 210  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetSlotStyle@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::SetSlotStyle
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?SetSlotType@CSlotWindow@UI@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwType$ = 8						; size = 4
?SetSlotType@CSlotWindow@UI@@QAEXK@Z PROC		; UI::CSlotWindow::SetSlotType, COMDAT
; _this$ = ecx

; 203  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  : 	m_dwSlotType = dwType;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwType$[ebp]
  0000d	89 48 78	 mov	 DWORD PTR [eax+120], ecx

; 205  : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?SetSlotType@CSlotWindow@UI@@QAEXK@Z ENDP		; UI::CSlotWindow::SetSlotType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?Destroy@CSlotWindow@UI@@QAEXXZ
_TEXT	SEGMENT
$T1 = -56						; size = 4
tv134 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
___param0$ = -36					; size = 4
tv228 = -32						; size = 4
tv252 = -28						; size = 4
_this$ = -24						; size = 4
$T5 = -20						; size = 4
_itor$6 = -16						; size = 4
_this$ = -12						; size = 4
_rSlot$7 = -8						; size = 4
$T8 = -2						; size = 1
$T9 = -1						; size = 1
?Destroy@CSlotWindow@UI@@QAEXXZ PROC			; UI::CSlotWindow::Destroy, COMDAT
; _this$ = ecx

; 1395 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1396 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00009	8d 45 f0	 lea	 eax, DWORD PTR _itor$6[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00016	e8 00 00 00 00	 call	 ?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
  0001b	eb 08		 jmp	 SHORT $LN4@Destroy
$LN2@Destroy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0001d	8b 45 f0	 mov	 eax, DWORD PTR _itor$6[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	89 45 f0	 mov	 DWORD PTR _itor$6[ebp], eax
$LN4@Destroy:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1396 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00025	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00028	05 88 00 00 00	 add	 eax, 136		; 00000088H
  0002d	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00030	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00036	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	89 45 dc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0003e	8b 45 dc	 mov	 eax, DWORD PTR ___param0$[ebp]
  00041	89 45 d8	 mov	 DWORD PTR $T4[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00044	8d 45 d8	 lea	 eax, DWORD PTR $T4[ebp]
  00047	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  0004a	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _itor$6[ebp]
  00050	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00052	75 09		 jne	 SHORT $LN62@Destroy
  00054	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv252[ebp], 1
  0005b	eb 04		 jmp	 SHORT $LN63@Destroy
$LN62@Destroy:
  0005d	83 65 e4 00	 and	 DWORD PTR tv252[ebp], 0
$LN63@Destroy:
  00061	8a 45 e4	 mov	 al, BYTE PTR tv252[ebp]
  00064	88 45 ff	 mov	 BYTE PTR $T9[ebp], al

; 203  :         return !(*this == _Right);

  00067	0f b6 45 ff	 movzx	 eax, BYTE PTR $T9[ebp]
  0006b	85 c0		 test	 eax, eax
  0006d	75 09		 jne	 SHORT $LN57@Destroy
  0006f	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv228[ebp], 1
  00076	eb 04		 jmp	 SHORT $LN58@Destroy
$LN57@Destroy:
  00078	83 65 e0 00	 and	 DWORD PTR tv228[ebp], 0
$LN58@Destroy:
  0007c	8a 45 e0	 mov	 al, BYTE PTR tv228[ebp]
  0007f	88 45 fe	 mov	 BYTE PTR $T8[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1396 : 	for (TSlotListIterator itor = m_SlotList.begin(); itor != m_SlotList.end(); ++itor)

  00082	0f b6 45 fe	 movzx	 eax, BYTE PTR $T8[ebp]
  00086	85 c0		 test	 eax, eax
  00088	0f 84 bb 00 00
	00		 je	 $LN3@Destroy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0008e	8b 45 f0	 mov	 eax, DWORD PTR _itor$6[ebp]
  00091	83 c0 08	 add	 eax, 8
  00094	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00097	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0009a	89 45 f8	 mov	 DWORD PTR _rSlot$7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1400 : 		ClearSlot(&rSlot);

  0009d	ff 75 f8	 push	 DWORD PTR _rSlot$7[ebp]
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	e8 00 00 00 00	 call	 ?ClearSlot@CSlotWindow@UI@@IAEXPAUSSlot@12@@Z ; UI::CSlotWindow::ClearSlot

; 1401 : 
; 1402 : 		if (rSlot.pNumberLine)

  000a8	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  000ab	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  000af	74 2b		 je	 SHORT $LN5@Destroy

; 1403 : 		{
; 1404 : 			delete rSlot.pNumberLine;

  000b1	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  000b4	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  000b7	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
  000ba	83 7d ec 00	 cmp	 DWORD PTR $T5[ebp], 0
  000be	74 11		 je	 SHORT $LN11@Destroy
  000c0	6a 01		 push	 1
  000c2	8b 45 ec	 mov	 eax, DWORD PTR $T5[ebp]
  000c5	8b 00		 mov	 eax, DWORD PTR [eax]
  000c7	8b 4d ec	 mov	 ecx, DWORD PTR $T5[ebp]
  000ca	ff 10		 call	 DWORD PTR [eax]
  000cc	89 45 cc	 mov	 DWORD PTR tv134[ebp], eax
  000cf	eb 04		 jmp	 SHORT $LN12@Destroy
$LN11@Destroy:
  000d1	83 65 cc 00	 and	 DWORD PTR tv134[ebp], 0
$LN12@Destroy:

; 1405 : 			rSlot.pNumberLine = NULL;

  000d5	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  000d8	83 60 38 00	 and	 DWORD PTR [eax+56], 0
$LN5@Destroy:

; 1406 : 		}
; 1407 : 		if (rSlot.pCoverButton)

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  000df	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  000e3	74 11		 je	 SHORT $LN6@Destroy

; 1408 : 		{
; 1409 : 			CWindowManager::Instance().DestroyWindow(rSlot.pCoverButton);

  000e5	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  000e8	ff 70 40	 push	 DWORD PTR [eax+64]
  000eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  000f1	e8 00 00 00 00	 call	 ?DestroyWindow@CWindowManager@UI@@QAEXPAVCWindow@2@@Z ; UI::CWindowManager::DestroyWindow
$LN6@Destroy:

; 1410 : 		}
; 1411 : 		if (rSlot.pSlotButton)

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  000f9	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  000fd	74 11		 je	 SHORT $LN7@Destroy

; 1412 : 		{
; 1413 : 			CWindowManager::Instance().DestroyWindow(rSlot.pSlotButton);

  000ff	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  00102	ff 70 44	 push	 DWORD PTR [eax+68]
  00105	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0010b	e8 00 00 00 00	 call	 ?DestroyWindow@CWindowManager@UI@@QAEXPAVCWindow@2@@Z ; UI::CWindowManager::DestroyWindow
$LN7@Destroy:

; 1414 : 		}
; 1415 : 		if (rSlot.pSignImage)

  00110	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  00113	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00117	74 11		 je	 SHORT $LN8@Destroy

; 1416 : 		{
; 1417 : 			CWindowManager::Instance().DestroyWindow(rSlot.pSignImage);

  00119	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  0011c	ff 70 48	 push	 DWORD PTR [eax+72]
  0011f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  00125	e8 00 00 00 00	 call	 ?DestroyWindow@CWindowManager@UI@@QAEXPAVCWindow@2@@Z ; UI::CWindowManager::DestroyWindow
$LN8@Destroy:

; 1418 : 		}
; 1419 : 		if (rSlot.pFinishCoolTimeEffect)

  0012a	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  0012d	83 78 4c 00	 cmp	 DWORD PTR [eax+76], 0
  00131	74 11		 je	 SHORT $LN9@Destroy

; 1420 : 		{
; 1421 : 			CWindowManager::Instance().DestroyWindow(rSlot.pFinishCoolTimeEffect);

  00133	8b 45 f8	 mov	 eax, DWORD PTR _rSlot$7[ebp]
  00136	ff 70 4c	 push	 DWORD PTR [eax+76]
  00139	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCWindowManager@UI@@@@0PAVCWindowManager@UI@@A ; CSingleton<UI::CWindowManager>::ms_singleton
  0013f	e8 00 00 00 00	 call	 ?DestroyWindow@CWindowManager@UI@@QAEXPAVCWindow@2@@Z ; UI::CWindowManager::DestroyWindow
$LN9@Destroy:

; 1422 : 		}
; 1423 : 	}

  00144	e9 d4 fe ff ff	 jmp	 $LN2@Destroy
$LN3@Destroy:

; 1424 : 
; 1425 : 	m_SlotList.clear();

  00149	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00152	e8 00 00 00 00	 call	 ?clear@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::clear

; 1426 : 
; 1427 : 	__DestroyToggleSlotImage();

  00157	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?__DestroyToggleSlotImage@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__DestroyToggleSlotImage

; 1428 : 	__DestroySlotEnableEffect();

  0015f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	e8 00 00 00 00	 call	 ?__DestroySlotEnableEffect@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__DestroySlotEnableEffect

; 1429 : 	__DestroyBaseImage();

  00167	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	e8 00 00 00 00	 call	 ?__DestroyBaseImage@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__DestroyBaseImage

; 1430 : 
; 1431 : 	__Initialize();

  0016f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00172	e8 00 00 00 00	 call	 ?__Initialize@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__Initialize

; 1432 : }

  00177	c9		 leave
  00178	c3		 ret	 0
?Destroy@CSlotWindow@UI@@QAEXXZ ENDP			; UI::CSlotWindow::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ??1CSlotWindow@UI@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CSlotWindow@UI@@UAE@XZ PROC				; UI::CSlotWindow::~CSlotWindow, COMDAT
; _this$ = ecx

; 1440 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CSlotWindow@UI@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSlotWindow@UI@@6B@

; 1441 : 	Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@CSlotWindow@UI@@QAEXXZ ; UI::CSlotWindow::Destroy

; 1442 : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  00040	e8 00 00 00 00	 call	 ??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ ; std::deque<unsigned long,std::allocator<unsigned long> >::~deque<unsigned long,std::allocator<unsigned long> >
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0004e	e8 00 00 00 00	 call	 ?_Tidy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1442 : }

  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0005c	e8 00 00 00 00	 call	 ?_Tidy@?$list@KV?$allocator@K@std@@@std@@AAEXXZ ; std::list<unsigned long,std::allocator<unsigned long> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp

; 1442 : }

  00061	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ??1CWindow@UI@@UAE@XZ	; UI::CWindow::~CWindow
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	c9		 leave
  00075	c3		 ret	 0
  00076	cc		 int	 3
  00077	cc		 int	 3
  00078	cc		 int	 3
  00079	cc		 int	 3
  0007a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CSlotWindow@UI@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CSlotWindow@UI@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CSlotWindow@UI@@UAE@XZ ENDP				; UI::CSlotWindow::~CSlotWindow
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ??0CSlotWindow@UI@@QAE@PAU_object@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_ppyObject$ = 8						; size = 4
??0CSlotWindow@UI@@QAE@PAU_object@@@Z PROC		; UI::CSlotWindow::CSlotWindow, COMDAT
; _this$ = ecx

; 1435 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CSlotWindow@UI@@QAE@PAU_object@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1434 : CSlotWindow::CSlotWindow(PyObject * ppyObject) : CWindow(ppyObject)

  00026	ff 75 08	 push	 DWORD PTR _ppyObject$[ebp]
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0CWindow@UI@@QAE@PAU_object@@@Z ; UI::CWindow::CWindow
  00031	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 1435 : {

  00035	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CSlotWindow@UI@@6B@
  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00047	e8 00 00 00 00	 call	 ??0?$list@KV?$allocator@K@std@@@std@@QAE@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::list<unsigned long,std::allocator<unsigned long> >
  0004c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  00059	e8 00 00 00 00	 call	 ??0?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >
  0005e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00062	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0006b	e8 00 00 00 00	 call	 ??0?$deque@KV?$allocator@K@std@@@std@@QAE@XZ ; std::deque<unsigned long,std::allocator<unsigned long> >::deque<unsigned long,std::allocator<unsigned long> >
  00070	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1436 : 	__Initialize();

  00074	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?__Initialize@CSlotWindow@UI@@IAEXXZ ; UI::CSlotWindow::__Initialize

; 1437 : }

  0007c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	c9		 leave
  0008f	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CSlotWindow@UI@@QAE@PAU_object@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CWindow@UI@@UAE@XZ	; UI::CWindow::~CWindow
__unwindfunclet$??0CSlotWindow@UI@@QAE@PAU_object@@@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 80 00 00
	00		 add	 ecx, 128		; 00000080H
  00011	e9 00 00 00 00	 jmp	 ??1?$list@KV?$allocator@K@std@@@std@@QAE@XZ ; std::list<unsigned long,std::allocator<unsigned long> >::~list<unsigned long,std::allocator<unsigned long> >
__unwindfunclet$??0CSlotWindow@UI@@QAE@PAU_object@@@Z$2:
  00016	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 88 00 00
	00		 add	 ecx, 136		; 00000088H
  0001f	e9 00 00 00 00	 jmp	 ??1?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::~list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >
__unwindfunclet$??0CSlotWindow@UI@@QAE@PAU_object@@@Z$3:
  00024	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0002d	e9 00 00 00 00	 jmp	 ??1?$deque@KV?$allocator@K@std@@@std@@QAE@XZ ; std::deque<unsigned long,std::allocator<unsigned long> >::~deque<unsigned long,std::allocator<unsigned long> >
  00032	cc		 int	 3
  00033	cc		 int	 3
  00034	cc		 int	 3
  00035	cc		 int	 3
  00036	cc		 int	 3
__ehhandler$??0CSlotWindow@UI@@QAE@PAU_object@@@Z:
  00037	90		 npad	 1
  00038	90		 npad	 1
  00039	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0003d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00040	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00043	33 c8		 xor	 ecx, eax
  00045	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CSlotWindow@UI@@QAE@PAU_object@@@Z
  0004f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CSlotWindow@UI@@QAE@PAU_object@@@Z ENDP		; UI::CSlotWindow::CSlotWindow
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S13$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ PROC ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S13$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc 2e ba
	e8 02		 mov	 DWORD PTR __Max_possible$1[ebp], 48806446 ; 02e8ba2eH

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d 2e ba e8 02	 cmp	 eax, 48806446		; 02e8ba2eH
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 58	 imul	 eax, eax, 88
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USSlot@CSlotWindow@UI@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<UI::CSlotWindow::SSlot,void *> *,std::_List_node<UI::CSlotWindow::SSlot,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ENDP ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ PROC ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Freenode0<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ENDP ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ PROC ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@std@@@?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USSlot@CSlotWindow@UI@@PAX@std@@@1@PAU01@@Z ; std::_List_node<UI::CSlotWindow::SSlot,void *>::_Free_non_head<std::allocator<std::_List_node<UI::CSlotWindow::SSlot,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAEXXZ ENDP ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
___param0$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ PROC ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin, COMDAT
; _this$ = ecx

; 1091 :     _NODISCARD iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	89 45 f8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0001f	89 08		 mov	 DWORD PTR [eax], ecx

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1093 :     }

  00024	c9		 leave
  00025	c2 04 00	 ret	 4
?begin@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE?AV?$_List_iterator@V?$_List_val@U?$_List_simple_types@USSlot@CSlotWindow@UI@@@std@@@std@@@2@XZ ENDP ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::begin
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ PROC ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::~list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ENDP ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::~list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ PROC ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@AAEXXZ ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@USSlot@CSlotWindow@UI@@V?$allocator@USSlot@CSlotWindow@UI@@@std@@@std@@QAE@XZ ENDP ; std::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >::list<UI::CSlotWindow::SSlot,std::allocator<UI::CSlotWindow::SSlot> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonSlotWindow.cpp
;	COMDAT ?Type@CSlotWindow@UI@@SAKXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?Type@CSlotWindow@UI@@SAKXZ PROC			; UI::CSlotWindow::Type, COMDAT

; 1266 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Type@CSlotWindow@UI@@SAKXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1267 : 	static int s_Type = GetCRC32("CSlotWindow", strlen("CSlotWindow"));

  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00027	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0002e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?1??Type@CSlotWindow@UI@@SAKXZ@4HA
  00037	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  0003d	7e 44		 jle	 SHORT $LN2@Type
  0003f	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CSlotWindow@UI@@SAKXZ@4HA
  00044	e8 00 00 00 00	 call	 __Init_thread_header
  00049	59		 pop	 ecx
  0004a	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?1??Type@CSlotWindow@UI@@SAKXZ@4HA, -1
  00051	75 30		 jne	 SHORT $LN2@Type
  00053	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DKKKJBKL@CSlotWindow@
  0005c	e8 00 00 00 00	 call	 _strlen
  00061	59		 pop	 ecx
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0M@DKKKJBKL@CSlotWindow@
  00068	e8 00 00 00 00	 call	 ?GetCRC32@@YAKPBDI@Z	; GetCRC32
  0006d	59		 pop	 ecx
  0006e	59		 pop	 ecx
  0006f	a3 00 00 00 00	 mov	 DWORD PTR ?s_Type@?1??Type@CSlotWindow@UI@@SAKXZ@4HA, eax
  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CSlotWindow@UI@@SAKXZ@4HA
  0007d	e8 00 00 00 00	 call	 __Init_thread_footer
  00082	59		 pop	 ecx
$LN2@Type:

; 1268 : 	return s_Type;

  00083	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_Type@?1??Type@CSlotWindow@UI@@SAKXZ@4HA

; 1269 : }

  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	c9		 leave
  00094	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Type@CSlotWindow@UI@@SAKXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?1??Type@CSlotWindow@UI@@SAKXZ@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Type@CSlotWindow@UI@@SAKXZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Type@CSlotWindow@UI@@SAKXZ
  00029	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Type@CSlotWindow@UI@@SAKXZ ENDP			; UI::CSlotWindow::Type
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
;	COMDAT ?IsWindow@CWindow@UI@@UAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWindow@CWindow@UI@@UAEHXZ PROC			; UI::CWindow::IsWindow, COMDAT
; _this$ = ecx

; 161  : 			virtual BOOL	IsWindow() { return TRUE; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	40		 inc	 eax
  0000a	c9		 leave
  0000b	c3		 ret	 0
?IsWindow@CWindow@UI@@UAEHXZ ENDP			; UI::CWindow::IsWindow
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
;	COMDAT ?SetColor@CWindow@UI@@UAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwColor$ = 8						; size = 4
?SetColor@CWindow@UI@@UAEXK@Z PROC			; UI::CWindow::SetColor, COMDAT
; _this$ = ecx

; 157  : 			virtual void	SetColor(DWORD dwColor){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 04 00	 ret	 4
?SetColor@CWindow@UI@@UAEXK@Z ENDP			; UI::CWindow::SetColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterPythonLib\PythonWindow.h
;	COMDAT ?OnChangePosition@CWindow@UI@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnChangePosition@CWindow@UI@@UAEXXZ PROC		; UI::CWindow::OnChangePosition, COMDAT
; _this$ = ecx

; 106  : 			virtual void	OnChangePosition(){}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?OnChangePosition@CWindow@UI@@UAEXXZ ENDP		; UI::CWindow::OnChangePosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c9 01	 or	 ecx, 1
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
  00037	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003e	7d 06		 jge	 SHORT $LN7@snprintf
  00040	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00049	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1975 :         __crt_va_end(_ArgList);

  00052	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00059	c9		 leave
  0005a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
