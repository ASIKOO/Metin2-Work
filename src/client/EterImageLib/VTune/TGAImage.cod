; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	_printf
PUBLIC	??0CTGAImage@@QAE@XZ				; CTGAImage::CTGAImage
PUBLIC	??0CTGAImage@@QAE@AAVCImage@@@Z			; CTGAImage::CTGAImage
PUBLIC	??1CTGAImage@@UAE@XZ				; CTGAImage::~CTGAImage
PUBLIC	?Create@CTGAImage@@UAEXHH@Z			; CTGAImage::Create
PUBLIC	?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z		; CTGAImage::LoadFromMemory
PUBLIC	?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z		; CTGAImage::LoadFromDiskFile
PUBLIC	?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z		; CTGAImage::SaveToDiskFile
PUBLIC	?SetCompressed@CTGAImage@@QAEX_N@Z		; CTGAImage::SetCompressed
PUBLIC	?SetAlphaChannel@CTGAImage@@QAEX_N@Z		; CTGAImage::SetAlphaChannel
PUBLIC	?GetHeader@CTGAImage@@QAEAAUTGA_HEADER@@XZ	; CTGAImage::GetHeader
PUBLIC	?GetRawPixelCount@CTGAImage@@IAEHPBK@Z		; CTGAImage::GetRawPixelCount
PUBLIC	?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z		; CTGAImage::GetRLEPixelCount
PUBLIC	??_GCTGAImage@@UAEPAXI@Z			; CTGAImage::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7CTGAImage@@6B@				; CTGAImage::`vftable'
PUBLIC	??_C@_0N@HGIAMHNL@RLE?5overflow@		; `string'
PUBLIC	??_C@_02GMLFBBN@wb@				; `string'
PUBLIC	??_R4CTGAImage@@6B@				; CTGAImage::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCTGAImage@@@8				; CTGAImage `RTTI Type Descriptor'
PUBLIC	??_R3CTGAImage@@8				; CTGAImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CTGAImage@@8				; CTGAImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CTGAImage@@8			; CTGAImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CImage@@8				; CImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCImage@@@8				; CImage `RTTI Type Descriptor'
PUBLIC	??_R3CImage@@8					; CImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CImage@@8					; CImage::`RTTI Base Class Array'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___acrt_iob_func:PROC
EXTRN	_fclose:PROC
EXTRN	_fopen:PROC
EXTRN	_fputc:PROC
EXTRN	_fwrite:PROC
EXTRN	___stdio_common_vfprintf:PROC
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Create@CMappedFile@@QAEHPBDPAPBXHH@Z:PROC	; CMappedFile::Create
EXTRN	?Size@CMappedFile@@QAEKXZ:PROC			; CMappedFile::Size
EXTRN	??0CImage@@QAE@XZ:PROC				; CImage::CImage
EXTRN	??1CImage@@UAE@XZ:PROC				; CImage::~CImage
EXTRN	?Create@CImage@@QAEXHH@Z:PROC			; CImage::Create
EXTRN	?GetWidth@CImage@@QBEHXZ:PROC			; CImage::GetWidth
EXTRN	?GetHeight@CImage@@QBEHXZ:PROC			; CImage::GetHeight
EXTRN	?GetBasePointer@CImage@@QAEPAKXZ:PROC		; CImage::GetBasePointer
EXTRN	?FlipTopToBottom@CImage@@QAEXXZ:PROC		; CImage::FlipTopToBottom
EXTRN	??_ECTGAImage@@UAEPAXI@Z:PROC			; CTGAImage::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ??_R2CImage@@8
rdata$r	SEGMENT
??_R2CImage@@8 DD FLAT:??_R1A@?0A@EA@CImage@@8		; CImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CImage@@8
rdata$r	SEGMENT
??_R3CImage@@8 DD 00H					; CImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCImage@@@8
data$rs	SEGMENT
??_R0?AVCImage@@@8 DD FLAT:??_7type_info@@6B@		; CImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCImage@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CImage@@8 DD FLAT:??_R0?AVCImage@@@8	; CImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CImage@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CTGAImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CTGAImage@@8 DD FLAT:??_R0?AVCTGAImage@@@8 ; CTGAImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CTGAImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CTGAImage@@8
rdata$r	SEGMENT
??_R2CTGAImage@@8 DD FLAT:??_R1A@?0A@EA@CTGAImage@@8	; CTGAImage::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CImage@@8
rdata$r	ENDS
;	COMDAT ??_R3CTGAImage@@8
rdata$r	SEGMENT
??_R3CTGAImage@@8 DD 00H				; CTGAImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CTGAImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCTGAImage@@@8
data$rs	SEGMENT
??_R0?AVCTGAImage@@@8 DD FLAT:??_7type_info@@6B@	; CTGAImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCTGAImage@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CTGAImage@@6B@
rdata$r	SEGMENT
??_R4CTGAImage@@6B@ DD 00H				; CTGAImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCTGAImage@@@8
	DD	FLAT:??_R3CTGAImage@@8
rdata$r	ENDS
;	COMDAT ??_C@_02GMLFBBN@wb@
CONST	SEGMENT
??_C@_02GMLFBBN@wb@ DB 'wb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HGIAMHNL@RLE?5overflow@
CONST	SEGMENT
??_C@_0N@HGIAMHNL@RLE?5overflow@ DB 'RLE overflow', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7CTGAImage@@6B@
CONST	SEGMENT
??_7CTGAImage@@6B@ DD FLAT:??_R4CTGAImage@@6B@		; CTGAImage::`vftable'
	DD	FLAT:??_ECTGAImage@@UAEPAXI@Z
	DD	FLAT:?Create@CTGAImage@@UAEXHH@Z
	DD	FLAT:?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z
	DD	FLAT:?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
	DD	FLAT:?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z$0
__ehfuncinfo$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CTGAImage@@QAE@AAVCImage@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CTGAImage@@QAE@AAVCImage@@@Z$0
__ehfuncinfo$??0CTGAImage@@QAE@AAVCImage@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CTGAImage@@QAE@AAVCImage@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCTGAImage@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCTGAImage@@UAEPAXI@Z PROC				; CTGAImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CTGAImage@@UAE@XZ	; CTGAImage::~CTGAImage
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 44		 push	 68			; 00000044H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_GCTGAImage@@UAEPAXI@Z ENDP				; CTGAImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z
_TEXT	SEGMENT
_pixel$ = -12						; size = 4
_this$ = -8						; size = 4
_r$ = -4						; size = 4
_data$ = 8						; size = 4
?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z PROC		; CTGAImage::GetRLEPixelCount, COMDAT
; _this$ = ecx

; 250  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 251  :     int r = 0;

  00009	83 65 fc 00	 and	 DWORD PTR _r$[ebp], 0

; 252  : 	DWORD pixel;
; 253  :     
; 254  :     r = 1;

  0000d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _r$[ebp], 1

; 255  : 	
; 256  :     if (data >= m_pdwEndPtr)

  00014	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  0001a	3b 48 40	 cmp	 ecx, DWORD PTR [eax+64]
  0001d	72 04		 jb	 SHORT $LN4@GetRLEPixe

; 257  :         return 0;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 3d		 jmp	 SHORT $LN1@GetRLEPixe
$LN4@GetRLEPixe:

; 258  :     
; 259  : 	pixel = *data;

  00023	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]
  00028	89 45 f4	 mov	 DWORD PTR _pixel$[ebp], eax
$LN2@GetRLEPixe:

; 260  :     
; 261  :     while ((r < 127) && (data < m_pdwEndPtr))

  0002b	83 7d fc 7f	 cmp	 DWORD PTR _r$[ebp], 127	; 0000007fH
  0002f	7d 2c		 jge	 SHORT $LN3@GetRLEPixe
  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00037	3b 48 40	 cmp	 ecx, DWORD PTR [eax+64]
  0003a	73 21		 jae	 SHORT $LN3@GetRLEPixe

; 262  :     {
; 263  : 		if (pixel != *(++data))

  0003c	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  0003f	83 c0 04	 add	 eax, 4
  00042	89 45 08	 mov	 DWORD PTR _data$[ebp], eax
  00045	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00048	8b 4d f4	 mov	 ecx, DWORD PTR _pixel$[ebp]
  0004b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0004d	74 05		 je	 SHORT $LN5@GetRLEPixe

; 264  : 			return r;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  00052	eb 0c		 jmp	 SHORT $LN1@GetRLEPixe
$LN5@GetRLEPixe:

; 265  : 		
; 266  :         r++;

  00054	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
  00057	40		 inc	 eax
  00058	89 45 fc	 mov	 DWORD PTR _r$[ebp], eax

; 267  :     }

  0005b	eb ce		 jmp	 SHORT $LN2@GetRLEPixe
$LN3@GetRLEPixe:

; 268  : 	
; 269  : 	return r;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR _r$[ebp]
$LN1@GetRLEPixe:

; 270  : }

  00060	c9		 leave
  00061	c2 04 00	 ret	 4
?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z ENDP		; CTGAImage::GetRLEPixelCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?GetRawPixelCount@CTGAImage@@IAEHPBK@Z
_TEXT	SEGMENT
_rle$1 = -12						; size = 4
_this$ = -8						; size = 4
_i$ = -4						; size = 4
_data$ = 8						; size = 4
?GetRawPixelCount@CTGAImage@@IAEHPBK@Z PROC		; CTGAImage::GetRawPixelCount, COMDAT
; _this$ = ecx

; 273  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 274  :     int i = 0;

  00009	83 65 fc 00	 and	 DWORD PTR _i$[ebp], 0

; 275  :     
; 276  :     if (data >= m_pdwEndPtr)

  0000d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00013	3b 48 40	 cmp	 ecx, DWORD PTR [eax+64]
  00016	72 04		 jb	 SHORT $LN2@GetRawPixe

; 277  :         return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	eb 3c		 jmp	 SHORT $LN1@GetRawPixe
$LN2@GetRawPixe:

; 278  : 	
; 279  :     while ((data < m_pdwEndPtr) && (i < 127))

  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _data$[ebp]
  00022	3b 48 40	 cmp	 ecx, DWORD PTR [eax+64]
  00025	73 2e		 jae	 SHORT $LN3@GetRawPixe
  00027	83 7d fc 7f	 cmp	 DWORD PTR _i$[ebp], 127	; 0000007fH
  0002b	7d 28		 jge	 SHORT $LN3@GetRawPixe

; 280  :     {
; 281  : 		int rle = GetRLEPixelCount(data);

  0002d	ff 75 08	 push	 DWORD PTR _data$[ebp]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z ; CTGAImage::GetRLEPixelCount
  00038	89 45 f4	 mov	 DWORD PTR _rle$1[ebp], eax

; 282  : 		
; 283  : 		if (rle >= 4)

  0003b	83 7d f4 04	 cmp	 DWORD PTR _rle$1[ebp], 4
  0003f	7c 02		 jl	 SHORT $LN5@GetRawPixe

; 284  : 			break;

  00041	eb 12		 jmp	 SHORT $LN3@GetRawPixe
$LN5@GetRawPixe:

; 285  : 
; 286  :         data++;

  00043	8b 45 08	 mov	 eax, DWORD PTR _data$[ebp]
  00046	83 c0 04	 add	 eax, 4
  00049	89 45 08	 mov	 DWORD PTR _data$[ebp], eax

; 287  :         i++;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004f	40		 inc	 eax
  00050	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax

; 288  :     }

  00053	eb c7		 jmp	 SHORT $LN2@GetRawPixe
$LN3@GetRawPixe:

; 289  : 	
; 290  :     return i;

  00055	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
$LN1@GetRawPixe:

; 291  : }

  00058	c9		 leave
  00059	c2 04 00	 ret	 4
?GetRawPixelCount@CTGAImage@@IAEHPBK@Z ENDP		; CTGAImage::GetRawPixelCount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?GetHeader@CTGAImage@@QAEAAUTGA_HEADER@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetHeader@CTGAImage@@QAEAAUTGA_HEADER@@XZ PROC		; CTGAImage::GetHeader, COMDAT
; _this$ = ecx

; 362  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 363  : 	return m_Header;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 28	 add	 eax, 40			; 00000028H

; 364  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetHeader@CTGAImage@@QAEAAUTGA_HEADER@@XZ ENDP		; CTGAImage::GetHeader
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?SetAlphaChannel@CTGAImage@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_isExist$ = 8						; size = 1
?SetAlphaChannel@CTGAImage@@QAEX_N@Z PROC		; CTGAImage::SetAlphaChannel, COMDAT
; _this$ = ecx

; 302  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 303  : 	if (isExist)

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _isExist$[ebp]
  0000b	85 c0		 test	 eax, eax
  0000d	74 12		 je	 SHORT $LN2@SetAlphaCh

; 304  : 		m_Header.desc |= 0x08;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	0f be 40 39	 movsx	 eax, BYTE PTR [eax+57]
  00016	83 c8 08	 or	 eax, 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	88 41 39	 mov	 BYTE PTR [ecx+57], al
  0001f	eb 10		 jmp	 SHORT $LN1@SetAlphaCh
$LN2@SetAlphaCh:

; 305  : 	else
; 306  : 		m_Header.desc &= ~0x08;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	0f be 40 39	 movsx	 eax, BYTE PTR [eax+57]
  00028	83 e0 f7	 and	 eax, -9			; fffffff7H
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	88 41 39	 mov	 BYTE PTR [ecx+57], al
$LN1@SetAlphaCh:

; 307  : }

  00031	c9		 leave
  00032	c2 04 00	 ret	 4
?SetAlphaChannel@CTGAImage@@QAEX_N@Z ENDP		; CTGAImage::SetAlphaChannel
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?SetCompressed@CTGAImage@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_isCompress$ = 8					; size = 1
?SetCompressed@CTGAImage@@QAEX_N@Z PROC			; CTGAImage::SetCompressed, COMDAT
; _this$ = ecx

; 294  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 295  : 	if (isCompress)

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR _isCompress$[ebp]
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@SetCompres

; 296  : 		m_Header.imgType = 10;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c6 40 2a 0a	 mov	 BYTE PTR [eax+42], 10	; 0000000aH
  00016	eb 07		 jmp	 SHORT $LN1@SetCompres
$LN2@SetCompres:

; 297  : 	else
; 298  : 		m_Header.imgType = 2;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c6 40 2a 02	 mov	 BYTE PTR [eax+42], 2
$LN1@SetCompres:

; 299  : }

  0001f	c9		 leave
  00020	c2 04 00	 ret	 4
?SetCompressed@CTGAImage@@QAEX_N@Z ENDP			; CTGAImage::SetCompressed
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z
_TEXT	SEGMENT
_size$1 = -24						; size = 4
_rle$2 = -20						; size = 4
_raw$3 = -16						; size = 4
_fp$ = -12						; size = 4
_this$ = -8						; size = 4
_data$4 = -4						; size = 4
_c_szFileName$ = 8					; size = 4
?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z PROC		; CTGAImage::SaveToDiskFile, COMDAT
; _this$ = ecx

; 310  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 311  : 	FILE * fp = fopen(c_szFileName, "wb");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_02GMLFBBN@wb@
  0000e	ff 75 08	 push	 DWORD PTR _c_szFileName$[ebp]
  00011	e8 00 00 00 00	 call	 _fopen
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx
  00018	89 45 f4	 mov	 DWORD PTR _fp$[ebp], eax

; 312  : 	
; 313  : 	if (!fp)

  0001b	83 7d f4 00	 cmp	 DWORD PTR _fp$[ebp], 0
  0001f	75 07		 jne	 SHORT $LN6@SaveToDisk

; 314  : 		return false;

  00021	32 c0		 xor	 al, al
  00023	e9 1f 01 00 00	 jmp	 $LN1@SaveToDisk
$LN6@SaveToDisk:

; 315  : 
; 316  : 	fwrite(&m_Header, 18, 1, fp);

  00028	ff 75 f4	 push	 DWORD PTR _fp$[ebp]
  0002b	6a 01		 push	 1
  0002d	6a 12		 push	 18			; 00000012H
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 c0 28	 add	 eax, 40			; 00000028H
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 _fwrite
  0003b	83 c4 10	 add	 esp, 16			; 00000010H

; 317  : 	
; 318  : 	if (m_Header.imgType == 10)	// RLE 압축으로 저장

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	0f be 40 2a	 movsx	 eax, BYTE PTR [eax+42]
  00045	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  00048	0f 85 b8 00 00
	00		 jne	 $LN7@SaveToDisk

; 319  : 	{
; 320  : 		DWORD * data = GetBasePointer();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer
  00056	89 45 fc	 mov	 DWORD PTR _data$4[ebp], eax
$LN2@SaveToDisk:

; 321  : 		
; 322  : 		while (data < m_pdwEndPtr)

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d fc	 mov	 ecx, DWORD PTR _data$4[ebp]
  0005f	3b 48 40	 cmp	 ecx, DWORD PTR [eax+64]
  00062	0f 83 9c 00 00
	00		 jae	 $LN3@SaveToDisk

; 323  : 		{
; 324  : 			int rle = GetRLEPixelCount(data);

  00068	ff 75 fc	 push	 DWORD PTR _data$4[ebp]
  0006b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?GetRLEPixelCount@CTGAImage@@IAEHPBK@Z ; CTGAImage::GetRLEPixelCount
  00073	89 45 ec	 mov	 DWORD PTR _rle$2[ebp], eax

; 325  : 			
; 326  : 			if (rle < 4)

  00076	83 7d ec 04	 cmp	 DWORD PTR _rle$2[ebp], 4
  0007a	7d 51		 jge	 SHORT $LN9@SaveToDisk

; 327  : 			{
; 328  : 				int raw = GetRawPixelCount(data);

  0007c	ff 75 fc	 push	 DWORD PTR _data$4[ebp]
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ?GetRawPixelCount@CTGAImage@@IAEHPBK@Z ; CTGAImage::GetRawPixelCount
  00087	89 45 f0	 mov	 DWORD PTR _raw$3[ebp], eax

; 329  : 				
; 330  : 				if (raw == 0)

  0008a	83 7d f0 00	 cmp	 DWORD PTR _raw$3[ebp], 0
  0008e	75 02		 jne	 SHORT $LN11@SaveToDisk

; 331  : 					break;

  00090	eb 72		 jmp	 SHORT $LN3@SaveToDisk
$LN11@SaveToDisk:

; 332  : 				
; 333  : 				fputc(raw - 1, fp);

  00092	ff 75 f4	 push	 DWORD PTR _fp$[ebp]
  00095	8b 45 f0	 mov	 eax, DWORD PTR _raw$3[ebp]
  00098	48		 dec	 eax
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 _fputc
  0009f	59		 pop	 ecx
  000a0	59		 pop	 ecx
$LN4@SaveToDisk:

; 334  : 				
; 335  : 				while (raw)

  000a1	83 7d f0 00	 cmp	 DWORD PTR _raw$3[ebp], 0
  000a5	74 24		 je	 SHORT $LN5@SaveToDisk

; 336  : 				{
; 337  : 					fwrite(data, sizeof(DWORD), 1, fp);

  000a7	ff 75 f4	 push	 DWORD PTR _fp$[ebp]
  000aa	6a 01		 push	 1
  000ac	6a 04		 push	 4
  000ae	ff 75 fc	 push	 DWORD PTR _data$4[ebp]
  000b1	e8 00 00 00 00	 call	 _fwrite
  000b6	83 c4 10	 add	 esp, 16			; 00000010H

; 338  : 					data++;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _data$4[ebp]
  000bc	83 c0 04	 add	 eax, 4
  000bf	89 45 fc	 mov	 DWORD PTR _data$4[ebp], eax

; 339  : 					raw--;

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _raw$3[ebp]
  000c5	48		 dec	 eax
  000c6	89 45 f0	 mov	 DWORD PTR _raw$3[ebp], eax

; 340  : 				}

  000c9	eb d6		 jmp	 SHORT $LN4@SaveToDisk
$LN5@SaveToDisk:

; 341  : 			}

  000cb	eb 32		 jmp	 SHORT $LN10@SaveToDisk
$LN9@SaveToDisk:

; 342  : 			else
; 343  : 			{
; 344  : 				fputc((rle - 1) | 0x80, fp);

  000cd	ff 75 f4	 push	 DWORD PTR _fp$[ebp]
  000d0	8b 45 ec	 mov	 eax, DWORD PTR _rle$2[ebp]
  000d3	48		 dec	 eax
  000d4	0d 80 00 00 00	 or	 eax, 128		; 00000080H
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 _fputc
  000df	59		 pop	 ecx
  000e0	59		 pop	 ecx

; 345  : 				fwrite(data, sizeof(DWORD), 1, fp);

  000e1	ff 75 f4	 push	 DWORD PTR _fp$[ebp]
  000e4	6a 01		 push	 1
  000e6	6a 04		 push	 4
  000e8	ff 75 fc	 push	 DWORD PTR _data$4[ebp]
  000eb	e8 00 00 00 00	 call	 _fwrite
  000f0	83 c4 10	 add	 esp, 16			; 00000010H

; 346  : 				data += rle;

  000f3	8b 45 ec	 mov	 eax, DWORD PTR _rle$2[ebp]
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR _data$4[ebp]
  000f9	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000fc	89 45 fc	 mov	 DWORD PTR _data$4[ebp], eax
$LN10@SaveToDisk:

; 347  : 			}
; 348  : 		}

  000ff	e9 55 ff ff ff	 jmp	 $LN2@SaveToDisk
$LN3@SaveToDisk:

; 349  : 	}

  00104	eb 36		 jmp	 SHORT $LN8@SaveToDisk
$LN7@SaveToDisk:

; 350  : 	else
; 351  : 	{
; 352  : 		int size = GetWidth();

  00106	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?GetWidth@CImage@@QBEHXZ ; CImage::GetWidth
  0010e	89 45 e8	 mov	 DWORD PTR _size$1[ebp], eax

; 353  : 		size *= GetHeight() * 4;

  00111	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	e8 00 00 00 00	 call	 ?GetHeight@CImage@@QBEHXZ ; CImage::GetHeight
  00119	c1 e0 02	 shl	 eax, 2
  0011c	0f af 45 e8	 imul	 eax, DWORD PTR _size$1[ebp]
  00120	89 45 e8	 mov	 DWORD PTR _size$1[ebp], eax

; 354  : 		fwrite(GetBasePointer(), size, 1, fp);

  00123	ff 75 f4	 push	 DWORD PTR _fp$[ebp]
  00126	6a 01		 push	 1
  00128	ff 75 e8	 push	 DWORD PTR _size$1[ebp]
  0012b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _fwrite
  00139	83 c4 10	 add	 esp, 16			; 00000010H
$LN8@SaveToDisk:

; 355  : 	}
; 356  : 
; 357  : 	fclose(fp);

  0013c	ff 75 f4	 push	 DWORD PTR _fp$[ebp]
  0013f	e8 00 00 00 00	 call	 _fclose
  00144	59		 pop	 ecx

; 358  : 	return true;

  00145	b0 01		 mov	 al, 1
$LN1@SaveToDisk:

; 359  : }

  00147	c9		 leave
  00148	c2 04 00	 ret	 4
?SaveToDiskFile@CTGAImage@@UAE_NPBD@Z ENDP		; CTGAImage::SaveToDiskFile
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
_TEXT	SEGMENT
_c_pbMap$ = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -14						; size = 1
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_file$ = 0						; size = 324
__$ArrayPad$ = 324					; size = 4
_c_szFileName$ = 336					; size = 4
?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z PROC		; CTGAImage::LoadFromDiskFile, COMDAT
; _this$ = ecx

; 238  : {

  00000	55		 push	 ebp
  00001	8d ac 24 b8 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-328]
  00008	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 44 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 	CMappedFile file;

  00039	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  00041	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 240  : 
; 241  : 	const BYTE * c_pbMap;
; 242  : 
; 243  : 	if (!file.Create(c_szFileName, (const void **) &c_pbMap, 0, 0))

  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8d 45 e8	 lea	 eax, DWORD PTR _c_pbMap$[ebp]
  0004c	50		 push	 eax
  0004d	ff b5 50 01 00
	00		 push	 DWORD PTR _c_szFileName$[ebp]
  00053	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00056	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  0005b	85 c0		 test	 eax, eax
  0005d	75 15		 jne	 SHORT $LN2@LoadFromDi

; 244  : 		return false;

  0005f	c6 45 f3 00	 mov	 BYTE PTR $T3[ebp], 0
  00063	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00067	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0006a	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0006f	8a 45 f3	 mov	 al, BYTE PTR $T3[ebp]
  00072	eb 29		 jmp	 SHORT $LN1@LoadFromDi
$LN2@LoadFromDi:

; 245  : 
; 246  : 	return LoadFromMemory(file.Size(), c_pbMap);

  00074	ff 75 e8	 push	 DWORD PTR _c_pbMap$[ebp]
  00077	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  0007a	e8 00 00 00 00	 call	 ?Size@CMappedFile@@QAEKXZ ; CMappedFile::Size
  0007f	50		 push	 eax
  00080	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]
  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	ff 50 08	 call	 DWORD PTR [eax+8]
  0008b	88 45 f2	 mov	 BYTE PTR $T2[ebp], al
  0008e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00092	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00095	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  0009a	8a 45 f2	 mov	 al, BYTE PTR $T2[ebp]
$LN1@LoadFromDi:

; 247  : }

  0009d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a7	59		 pop	 ecx
  000a8	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ae	33 cd		 xor	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	81 c5 48 01 00
	00		 add	 ebp, 328		; 00000148H
  000bb	c9		 leave
  000bc	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _file$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadFromDiskFile@CTGAImage@@UAE_NPBD@Z ENDP		; CTGAImage::LoadFromDiskFile
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z
_TEXT	SEGMENT
tv131 = -36						; size = 4
_size$1 = -32						; size = 4
_pdwDest$ = -28						; size = 4
_hxw$ = -24						; size = 4
_this$ = -20						; size = 4
_i$ = -16						; size = 4
_w$2 = -12						; size = 2
_b$ = -5						; size = 1
_g$ = -4						; size = 1
_r$ = -3						; size = 1
_a$ = -2						; size = 1
_rle$3 = -1						; size = 1
_iSize$ = 8						; size = 4
_c_pbMem$ = 12						; size = 4
?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z PROC		; CTGAImage::LoadFromMemory, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 43   : 	memcpy(&m_Header, c_pbMem, 18);

  00009	6a 12		 push	 18			; 00000012H
  0000b	ff 75 0c	 push	 DWORD PTR _c_pbMem$[ebp]
  0000e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 c0 28	 add	 eax, 40			; 00000028H
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _memcpy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 44   : 	c_pbMem += 18;

  0001d	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00020	83 c0 12	 add	 eax, 18			; 00000012H
  00023	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax

; 45   : 	iSize -= 18;

  00026	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00029	83 e8 12	 sub	 eax, 18			; 00000012H
  0002c	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 46   : 
; 47   : 	CImage::Create(m_Header.width, m_Header.height);

  0002f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00032	0f b7 40 36	 movzx	 eax, WORD PTR [eax+54]
  00036	50		 push	 eax
  00037	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	0f b7 40 34	 movzx	 eax, WORD PTR [eax+52]
  0003e	50		 push	 eax
  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?Create@CImage@@QAEXHH@Z ; CImage::Create

; 48   : 
; 49   : 	UINT hxw = m_Header.width * m_Header.height;

  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	0f b7 40 34	 movzx	 eax, WORD PTR [eax+52]
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	0f b7 49 36	 movzx	 ecx, WORD PTR [ecx+54]
  00055	0f af c1	 imul	 eax, ecx
  00058	89 45 e8	 mov	 DWORD PTR _hxw$[ebp], eax

; 50   : 	BYTE r, g, b, a;
; 51   : 	DWORD i;
; 52   : 
; 53   : 	DWORD * pdwDest = GetBasePointer();

  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer
  00063	89 45 e4	 mov	 DWORD PTR _pdwDest$[ebp], eax

; 54   : 
; 55   : 	switch (m_Header.imgType)

  00066	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8a 40 2a	 mov	 al, BYTE PTR [eax+42]
  0006c	88 45 dc	 mov	 BYTE PTR tv131[ebp], al
  0006f	80 7d dc 02	 cmp	 BYTE PTR tv131[ebp], 2
  00073	74 68		 je	 SHORT $LN26@LoadFromMe
  00075	80 7d dc 03	 cmp	 BYTE PTR tv131[ebp], 3
  00079	74 0f		 je	 SHORT $LN25@LoadFromMe
  0007b	80 7d dc 0a	 cmp	 BYTE PTR tv131[ebp], 10	; 0000000aH
  0007f	0f 84 ff 01 00
	00		 je	 $LN32@LoadFromMe
  00085	e9 74 05 00 00	 jmp	 $LN2@LoadFromMe
$LN25@LoadFromMe:

; 56   : 	{
; 57   : 		case 3:	// 알파만 있는 것 (1bytes per pixel, 거의 안쓰임)
; 58   : 			{
; 59   : 				for (i = 0; i < hxw; ++i)

  0008a	83 65 f0 00	 and	 DWORD PTR _i$[ebp], 0
  0008e	eb 07		 jmp	 SHORT $LN6@LoadFromMe
$LN4@LoadFromMe:
  00090	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00093	40		 inc	 eax
  00094	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN6@LoadFromMe:
  00097	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0009a	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  0009d	73 39		 jae	 SHORT $LN5@LoadFromMe

; 60   : 				{
; 61   : 					a = (char) *(c_pbMem++);

  0009f	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  000a2	8a 00		 mov	 al, BYTE PTR [eax]
  000a4	88 45 fe	 mov	 BYTE PTR _a$[ebp], al
  000a7	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  000aa	40		 inc	 eax
  000ab	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax

; 62   : 					pdwDest[i] = (a << 24) | (a << 16) | (a << 8) | a;

  000ae	0f b6 45 fe	 movzx	 eax, BYTE PTR _a$[ebp]
  000b2	c1 e0 18	 shl	 eax, 24			; 00000018H
  000b5	0f b6 4d fe	 movzx	 ecx, BYTE PTR _a$[ebp]
  000b9	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000bc	0b c1		 or	 eax, ecx
  000be	0f b6 4d fe	 movzx	 ecx, BYTE PTR _a$[ebp]
  000c2	c1 e1 08	 shl	 ecx, 8
  000c5	0b c1		 or	 eax, ecx
  000c7	0f b6 4d fe	 movzx	 ecx, BYTE PTR _a$[ebp]
  000cb	0b c1		 or	 eax, ecx
  000cd	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  000d0	8b 55 e4	 mov	 edx, DWORD PTR _pdwDest$[ebp]
  000d3	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 63   : 				}

  000d6	eb b8		 jmp	 SHORT $LN4@LoadFromMe
$LN5@LoadFromMe:

; 64   : 			}
; 65   : 			break;

  000d8	e9 21 05 00 00	 jmp	 $LN2@LoadFromMe
$LN26@LoadFromMe:

; 66   : 
; 67   : 		case 2:	// 압축 안된 TGA
; 68   : 			{
; 69   : 				if (m_Header.colorBits == 16)	// 16bit

  000dd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e0	0f be 40 38	 movsx	 eax, BYTE PTR [eax+56]
  000e4	83 f8 10	 cmp	 eax, 16			; 00000010H
  000e7	0f 85 af 00 00
	00		 jne	 $LN27@LoadFromMe

; 70   : 				{
; 71   : 					for (i = 0; i < hxw; ++i)

  000ed	83 65 f0 00	 and	 DWORD PTR _i$[ebp], 0
  000f1	eb 07		 jmp	 SHORT $LN9@LoadFromMe
$LN7@LoadFromMe:
  000f3	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000f6	40		 inc	 eax
  000f7	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN9@LoadFromMe:
  000fa	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  000fd	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  00100	0f 83 91 00 00
	00		 jae	 $LN8@LoadFromMe

; 72   : 					{
; 73   : 						WORD w;
; 74   : 
; 75   : 						memcpy(&w, c_pbMem, sizeof(WORD));

  00106	6a 02		 push	 2
  00108	ff 75 0c	 push	 DWORD PTR _c_pbMem$[ebp]
  0010b	8d 45 f4	 lea	 eax, DWORD PTR _w$2[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 _memcpy
  00114	83 c4 0c	 add	 esp, 12			; 0000000cH

; 76   : 						c_pbMem += sizeof(WORD);

  00117	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  0011a	40		 inc	 eax
  0011b	40		 inc	 eax
  0011c	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax

; 77   : 						iSize -= sizeof(WORD);

  0011f	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00122	48		 dec	 eax
  00123	48		 dec	 eax
  00124	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 78   : 						
; 79   : 						b = (BYTE) (w & 0x1F);

  00127	0f b7 45 f4	 movzx	 eax, WORD PTR _w$2[ebp]
  0012b	83 e0 1f	 and	 eax, 31			; 0000001fH
  0012e	88 45 fb	 mov	 BYTE PTR _b$[ebp], al

; 80   : 						g = (BYTE) ((w >> 5) & 0x1F);

  00131	0f b7 45 f4	 movzx	 eax, WORD PTR _w$2[ebp]
  00135	c1 f8 05	 sar	 eax, 5
  00138	83 e0 1f	 and	 eax, 31			; 0000001fH
  0013b	88 45 fc	 mov	 BYTE PTR _g$[ebp], al

; 81   : 						r = (BYTE) ((w >> 10) & 0x1F);

  0013e	0f b7 45 f4	 movzx	 eax, WORD PTR _w$2[ebp]
  00142	c1 f8 0a	 sar	 eax, 10			; 0000000aH
  00145	83 e0 1f	 and	 eax, 31			; 0000001fH
  00148	88 45 fd	 mov	 BYTE PTR _r$[ebp], al

; 82   : 						
; 83   : 						b <<= 3;

  0014b	8a 45 fb	 mov	 al, BYTE PTR _b$[ebp]
  0014e	c0 e0 03	 shl	 al, 3
  00151	88 45 fb	 mov	 BYTE PTR _b$[ebp], al

; 84   : 						g <<= 3;

  00154	8a 45 fc	 mov	 al, BYTE PTR _g$[ebp]
  00157	c0 e0 03	 shl	 al, 3
  0015a	88 45 fc	 mov	 BYTE PTR _g$[ebp], al

; 85   : 						r <<= 3;

  0015d	8a 45 fd	 mov	 al, BYTE PTR _r$[ebp]
  00160	c0 e0 03	 shl	 al, 3
  00163	88 45 fd	 mov	 BYTE PTR _r$[ebp], al

; 86   : 						a = 0xff;

  00166	c6 45 fe ff	 mov	 BYTE PTR _a$[ebp], 255	; 000000ffH

; 87   : 						
; 88   : 						pdwDest[i] = (a << 24) | (r << 16) | (g << 8) | b;

  0016a	0f b6 45 fe	 movzx	 eax, BYTE PTR _a$[ebp]
  0016e	c1 e0 18	 shl	 eax, 24			; 00000018H
  00171	0f b6 4d fd	 movzx	 ecx, BYTE PTR _r$[ebp]
  00175	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00178	0b c1		 or	 eax, ecx
  0017a	0f b6 4d fc	 movzx	 ecx, BYTE PTR _g$[ebp]
  0017e	c1 e1 08	 shl	 ecx, 8
  00181	0b c1		 or	 eax, ecx
  00183	0f b6 4d fb	 movzx	 ecx, BYTE PTR _b$[ebp]
  00187	0b c1		 or	 eax, ecx
  00189	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  0018c	8b 55 e4	 mov	 edx, DWORD PTR _pdwDest$[ebp]
  0018f	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 89   : 					}

  00192	e9 5c ff ff ff	 jmp	 $LN7@LoadFromMe
$LN8@LoadFromMe:

; 90   : 				}

  00197	e9 e3 00 00 00	 jmp	 $LN28@LoadFromMe
$LN27@LoadFromMe:

; 91   : 				else if (m_Header.colorBits == 24)	// 24bit

  0019c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0019f	0f be 40 38	 movsx	 eax, BYTE PTR [eax+56]
  001a3	83 f8 18	 cmp	 eax, 24			; 00000018H
  001a6	0f 85 87 00 00
	00		 jne	 $LN29@LoadFromMe

; 92   : 				{
; 93   : 					for (i = 0; i < hxw; ++i)

  001ac	83 65 f0 00	 and	 DWORD PTR _i$[ebp], 0
  001b0	eb 07		 jmp	 SHORT $LN12@LoadFromMe
$LN10@LoadFromMe:
  001b2	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  001b5	40		 inc	 eax
  001b6	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax
$LN12@LoadFromMe:
  001b9	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  001bc	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  001bf	73 70		 jae	 SHORT $LN11@LoadFromMe

; 94   : 					{
; 95   : 						r = (BYTE) *(c_pbMem++); --iSize;

  001c1	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  001c4	8a 00		 mov	 al, BYTE PTR [eax]
  001c6	88 45 fd	 mov	 BYTE PTR _r$[ebp], al
  001c9	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  001cc	40		 inc	 eax
  001cd	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  001d0	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  001d3	48		 dec	 eax
  001d4	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 96   : 						g = (BYTE) *(c_pbMem++); --iSize;

  001d7	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  001da	8a 00		 mov	 al, BYTE PTR [eax]
  001dc	88 45 fc	 mov	 BYTE PTR _g$[ebp], al
  001df	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  001e2	40		 inc	 eax
  001e3	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  001e6	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  001e9	48		 dec	 eax
  001ea	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 97   : 						b = (BYTE) *(c_pbMem++); --iSize;

  001ed	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  001f0	8a 00		 mov	 al, BYTE PTR [eax]
  001f2	88 45 fb	 mov	 BYTE PTR _b$[ebp], al
  001f5	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  001f8	40		 inc	 eax
  001f9	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  001fc	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  001ff	48		 dec	 eax
  00200	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 98   : 						a = 0xff;

  00203	c6 45 fe ff	 mov	 BYTE PTR _a$[ebp], 255	; 000000ffH

; 99   : 						
; 100  : 						pdwDest[i] = (a << 24) | (r << 16) | (g << 8) | b;

  00207	0f b6 45 fe	 movzx	 eax, BYTE PTR _a$[ebp]
  0020b	c1 e0 18	 shl	 eax, 24			; 00000018H
  0020e	0f b6 4d fd	 movzx	 ecx, BYTE PTR _r$[ebp]
  00212	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00215	0b c1		 or	 eax, ecx
  00217	0f b6 4d fc	 movzx	 ecx, BYTE PTR _g$[ebp]
  0021b	c1 e1 08	 shl	 ecx, 8
  0021e	0b c1		 or	 eax, ecx
  00220	0f b6 4d fb	 movzx	 ecx, BYTE PTR _b$[ebp]
  00224	0b c1		 or	 eax, ecx
  00226	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00229	8b 55 e4	 mov	 edx, DWORD PTR _pdwDest$[ebp]
  0022c	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 101  : 					}

  0022f	eb 81		 jmp	 SHORT $LN10@LoadFromMe
$LN11@LoadFromMe:

; 102  : 				}

  00231	eb 4c		 jmp	 SHORT $LN28@LoadFromMe
$LN29@LoadFromMe:

; 103  : 				else if (m_Header.colorBits == 32)	// 32bit

  00233	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00236	0f be 40 38	 movsx	 eax, BYTE PTR [eax+56]
  0023a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0023d	75 40		 jne	 SHORT $LN28@LoadFromMe

; 104  : 				{
; 105  : 					int size = GetWidth();

  0023f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00242	e8 00 00 00 00	 call	 ?GetWidth@CImage@@QBEHXZ ; CImage::GetWidth
  00247	89 45 e0	 mov	 DWORD PTR _size$1[ebp], eax

; 106  : 					size *= GetHeight() * 4;

  0024a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0024d	e8 00 00 00 00	 call	 ?GetHeight@CImage@@QBEHXZ ; CImage::GetHeight
  00252	c1 e0 02	 shl	 eax, 2
  00255	0f af 45 e0	 imul	 eax, DWORD PTR _size$1[ebp]
  00259	89 45 e0	 mov	 DWORD PTR _size$1[ebp], eax

; 107  : 
; 108  : 					memcpy(pdwDest, c_pbMem, size);

  0025c	ff 75 e0	 push	 DWORD PTR _size$1[ebp]
  0025f	ff 75 0c	 push	 DWORD PTR _c_pbMem$[ebp]
  00262	ff 75 e4	 push	 DWORD PTR _pdwDest$[ebp]
  00265	e8 00 00 00 00	 call	 _memcpy
  0026a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 109  : 					c_pbMem += size;

  0026d	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00270	03 45 e0	 add	 eax, DWORD PTR _size$1[ebp]
  00273	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax

; 110  : 					iSize -= size;

  00276	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00279	2b 45 e0	 sub	 eax, DWORD PTR _size$1[ebp]
  0027c	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax
$LN28@LoadFromMe:

; 111  : 				}
; 112  : 			}
; 113  : 			break;

  0027f	e9 7a 03 00 00	 jmp	 $LN2@LoadFromMe
$LN32@LoadFromMe:

; 114  : 
; 115  : 		case 10: // 압축 된 TGA (RLE)
; 116  : 			{
; 117  : 				BYTE rle;
; 118  : 
; 119  : 				if (m_Header.colorBits == 24)

  00284	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00287	0f be 40 38	 movsx	 eax, BYTE PTR [eax+56]
  0028b	83 f8 18	 cmp	 eax, 24			; 00000018H
  0028e	0f 85 9f 01 00
	00		 jne	 $LN33@LoadFromMe

; 120  : 				{
; 121  : 					i = 0;

  00294	83 65 f0 00	 and	 DWORD PTR _i$[ebp], 0
$LN13@LoadFromMe:

; 122  : 					while (i < hxw)

  00298	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0029b	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  0029e	0f 83 8a 01 00
	00		 jae	 $LN14@LoadFromMe

; 123  : 					{
; 124  : 						rle = (BYTE) *(c_pbMem++); --iSize;

  002a4	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  002a7	8a 00		 mov	 al, BYTE PTR [eax]
  002a9	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al
  002ac	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  002af	40		 inc	 eax
  002b0	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  002b3	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  002b6	48		 dec	 eax
  002b7	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 125  : 
; 126  : 						if (rle < 0x80)	// 압축 안된 곳

  002ba	0f b6 45 ff	 movzx	 eax, BYTE PTR _rle$3[ebp]
  002be	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002c3	0f 8d b5 00 00
	00		 jge	 $LN35@LoadFromMe

; 127  : 						{
; 128  : 							rle++;

  002c9	8a 45 ff	 mov	 al, BYTE PTR _rle$3[ebp]
  002cc	04 01		 add	 al, 1
  002ce	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al
$LN15@LoadFromMe:

; 129  : 
; 130  : 							while (rle)

  002d1	0f b6 45 ff	 movzx	 eax, BYTE PTR _rle$3[ebp]
  002d5	85 c0		 test	 eax, eax
  002d7	0f 84 9c 00 00
	00		 je	 $LN16@LoadFromMe

; 131  : 							{
; 132  : 								b = (BYTE) *(c_pbMem++); --iSize;

  002dd	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  002e0	8a 00		 mov	 al, BYTE PTR [eax]
  002e2	88 45 fb	 mov	 BYTE PTR _b$[ebp], al
  002e5	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  002e8	40		 inc	 eax
  002e9	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  002ec	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  002ef	48		 dec	 eax
  002f0	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 133  : 								g = (BYTE) *(c_pbMem++); --iSize;

  002f3	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  002f6	8a 00		 mov	 al, BYTE PTR [eax]
  002f8	88 45 fc	 mov	 BYTE PTR _g$[ebp], al
  002fb	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  002fe	40		 inc	 eax
  002ff	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  00302	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00305	48		 dec	 eax
  00306	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 134  : 								r = (BYTE) *(c_pbMem++); --iSize;

  00309	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  0030c	8a 00		 mov	 al, BYTE PTR [eax]
  0030e	88 45 fd	 mov	 BYTE PTR _r$[ebp], al
  00311	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00314	40		 inc	 eax
  00315	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  00318	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  0031b	48		 dec	 eax
  0031c	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 135  : 								a = 0xff;

  0031f	c6 45 fe ff	 mov	 BYTE PTR _a$[ebp], 255	; 000000ffH

; 136  : 								pdwDest[i++] = (a << 24) | (r << 16) | (g << 8) | b;

  00323	0f b6 45 fe	 movzx	 eax, BYTE PTR _a$[ebp]
  00327	c1 e0 18	 shl	 eax, 24			; 00000018H
  0032a	0f b6 4d fd	 movzx	 ecx, BYTE PTR _r$[ebp]
  0032e	c1 e1 10	 shl	 ecx, 16			; 00000010H
  00331	0b c1		 or	 eax, ecx
  00333	0f b6 4d fc	 movzx	 ecx, BYTE PTR _g$[ebp]
  00337	c1 e1 08	 shl	 ecx, 8
  0033a	0b c1		 or	 eax, ecx
  0033c	0f b6 4d fb	 movzx	 ecx, BYTE PTR _b$[ebp]
  00340	0b c1		 or	 eax, ecx
  00342	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00345	8b 55 e4	 mov	 edx, DWORD PTR _pdwDest$[ebp]
  00348	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  0034b	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0034e	40		 inc	 eax
  0034f	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 137  : 
; 138  : 								if (i > hxw)

  00352	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00355	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  00358	76 12		 jbe	 SHORT $LN37@LoadFromMe

; 139  : 								{
; 140  : 									assert(!"RLE overflow");
; 141  : 									printf("RLE overflow");

  0035a	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HGIAMHNL@RLE?5overflow@
  0035f	e8 00 00 00 00	 call	 _printf
  00364	59		 pop	 ecx

; 142  : 									return false;

  00365	32 c0		 xor	 al, al
  00367	e9 a8 02 00 00	 jmp	 $LN1@LoadFromMe
$LN37@LoadFromMe:

; 143  : 								}
; 144  : 								--rle;

  0036c	8a 45 ff	 mov	 al, BYTE PTR _rle$3[ebp]
  0036f	2c 01		 sub	 al, 1
  00371	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al

; 145  : 							}

  00374	e9 58 ff ff ff	 jmp	 $LN15@LoadFromMe
$LN16@LoadFromMe:

; 146  : 						}

  00379	e9 ab 00 00 00	 jmp	 $LN36@LoadFromMe
$LN35@LoadFromMe:

; 147  : 						else
; 148  : 						{
; 149  : 							// 압축 된 곳
; 150  : 							rle -= 127;

  0037e	0f b6 45 ff	 movzx	 eax, BYTE PTR _rle$3[ebp]
  00382	83 e8 7f	 sub	 eax, 127		; 0000007fH
  00385	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al

; 151  : 
; 152  : 							b = (BYTE) *(c_pbMem++); --iSize;

  00388	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  0038b	8a 00		 mov	 al, BYTE PTR [eax]
  0038d	88 45 fb	 mov	 BYTE PTR _b$[ebp], al
  00390	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00393	40		 inc	 eax
  00394	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  00397	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  0039a	48		 dec	 eax
  0039b	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 153  : 							g = (BYTE) *(c_pbMem++); --iSize;

  0039e	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  003a1	8a 00		 mov	 al, BYTE PTR [eax]
  003a3	88 45 fc	 mov	 BYTE PTR _g$[ebp], al
  003a6	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  003a9	40		 inc	 eax
  003aa	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  003ad	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  003b0	48		 dec	 eax
  003b1	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 154  : 							r = (BYTE) *(c_pbMem++); --iSize;

  003b4	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  003b7	8a 00		 mov	 al, BYTE PTR [eax]
  003b9	88 45 fd	 mov	 BYTE PTR _r$[ebp], al
  003bc	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  003bf	40		 inc	 eax
  003c0	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  003c3	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  003c6	48		 dec	 eax
  003c7	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 155  : 							a = 0xff;

  003ca	c6 45 fe ff	 mov	 BYTE PTR _a$[ebp], 255	; 000000ffH
$LN17@LoadFromMe:

; 156  : 
; 157  : 							while (rle)

  003ce	0f b6 45 ff	 movzx	 eax, BYTE PTR _rle$3[ebp]
  003d2	85 c0		 test	 eax, eax
  003d4	74 53		 je	 SHORT $LN36@LoadFromMe

; 158  : 							{
; 159  : 								pdwDest[i++] = (a << 24) | (r << 16) | (g << 8) | b;

  003d6	0f b6 45 fe	 movzx	 eax, BYTE PTR _a$[ebp]
  003da	c1 e0 18	 shl	 eax, 24			; 00000018H
  003dd	0f b6 4d fd	 movzx	 ecx, BYTE PTR _r$[ebp]
  003e1	c1 e1 10	 shl	 ecx, 16			; 00000010H
  003e4	0b c1		 or	 eax, ecx
  003e6	0f b6 4d fc	 movzx	 ecx, BYTE PTR _g$[ebp]
  003ea	c1 e1 08	 shl	 ecx, 8
  003ed	0b c1		 or	 eax, ecx
  003ef	0f b6 4d fb	 movzx	 ecx, BYTE PTR _b$[ebp]
  003f3	0b c1		 or	 eax, ecx
  003f5	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  003f8	8b 55 e4	 mov	 edx, DWORD PTR _pdwDest$[ebp]
  003fb	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  003fe	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00401	40		 inc	 eax
  00402	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 160  : 
; 161  : 								if (i > hxw)

  00405	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00408	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  0040b	76 12		 jbe	 SHORT $LN38@LoadFromMe

; 162  : 								{
; 163  : 									assert(!"RLE overflow");
; 164  : 									printf("RLE overflow");

  0040d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HGIAMHNL@RLE?5overflow@
  00412	e8 00 00 00 00	 call	 _printf
  00417	59		 pop	 ecx

; 165  : 									return false;

  00418	32 c0		 xor	 al, al
  0041a	e9 f5 01 00 00	 jmp	 $LN1@LoadFromMe
$LN38@LoadFromMe:

; 166  : 								}
; 167  : 								--rle;

  0041f	8a 45 ff	 mov	 al, BYTE PTR _rle$3[ebp]
  00422	2c 01		 sub	 al, 1
  00424	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al

; 168  : 							}

  00427	eb a5		 jmp	 SHORT $LN17@LoadFromMe
$LN36@LoadFromMe:

; 169  : 						}
; 170  : 					}

  00429	e9 6a fe ff ff	 jmp	 $LN13@LoadFromMe
$LN14@LoadFromMe:

; 171  : 				}

  0042e	e9 cb 01 00 00	 jmp	 $LN2@LoadFromMe
$LN33@LoadFromMe:

; 172  : 				else if (m_Header.colorBits == 32)

  00433	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00436	0f be 40 38	 movsx	 eax, BYTE PTR [eax+56]
  0043a	83 f8 20	 cmp	 eax, 32			; 00000020H
  0043d	0f 85 bb 01 00
	00		 jne	 $LN2@LoadFromMe

; 173  : 				{
; 174  : 					i = 0;

  00443	83 65 f0 00	 and	 DWORD PTR _i$[ebp], 0
$LN19@LoadFromMe:

; 175  : 					while (i < hxw)

  00447	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0044a	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  0044d	0f 83 ab 01 00
	00		 jae	 $LN2@LoadFromMe

; 176  : 					{
; 177  : 						rle = (BYTE) *(c_pbMem++); --iSize;

  00453	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00456	8a 00		 mov	 al, BYTE PTR [eax]
  00458	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al
  0045b	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  0045e	40		 inc	 eax
  0045f	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  00462	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00465	48		 dec	 eax
  00466	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 178  : 						
; 179  : 						if (rle < 0x80)

  00469	0f b6 45 ff	 movzx	 eax, BYTE PTR _rle$3[ebp]
  0046d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00472	0f 8d c7 00 00
	00		 jge	 $LN40@LoadFromMe

; 180  : 						{
; 181  : 							rle++;

  00478	8a 45 ff	 mov	 al, BYTE PTR _rle$3[ebp]
  0047b	04 01		 add	 al, 1
  0047d	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al
$LN21@LoadFromMe:

; 182  : 							
; 183  : 							while (rle)

  00480	0f b6 45 ff	 movzx	 eax, BYTE PTR _rle$3[ebp]
  00484	85 c0		 test	 eax, eax
  00486	0f 84 ae 00 00
	00		 je	 $LN22@LoadFromMe

; 184  : 							{
; 185  : 								b = (BYTE) *(c_pbMem++); --iSize;

  0048c	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  0048f	8a 00		 mov	 al, BYTE PTR [eax]
  00491	88 45 fb	 mov	 BYTE PTR _b$[ebp], al
  00494	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00497	40		 inc	 eax
  00498	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  0049b	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  0049e	48		 dec	 eax
  0049f	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 186  : 								g = (BYTE) *(c_pbMem++); --iSize;

  004a2	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  004a5	8a 00		 mov	 al, BYTE PTR [eax]
  004a7	88 45 fc	 mov	 BYTE PTR _g$[ebp], al
  004aa	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  004ad	40		 inc	 eax
  004ae	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  004b1	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  004b4	48		 dec	 eax
  004b5	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 187  : 								r = (BYTE) *(c_pbMem++); --iSize;

  004b8	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  004bb	8a 00		 mov	 al, BYTE PTR [eax]
  004bd	88 45 fd	 mov	 BYTE PTR _r$[ebp], al
  004c0	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  004c3	40		 inc	 eax
  004c4	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  004c7	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  004ca	48		 dec	 eax
  004cb	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 188  : 								a = (BYTE) *(c_pbMem++); --iSize;

  004ce	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  004d1	8a 00		 mov	 al, BYTE PTR [eax]
  004d3	88 45 fe	 mov	 BYTE PTR _a$[ebp], al
  004d6	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  004d9	40		 inc	 eax
  004da	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  004dd	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  004e0	48		 dec	 eax
  004e1	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 189  : 								pdwDest[i++] = (a << 24) | (r << 16) | (g << 8) | b;

  004e4	0f b6 45 fe	 movzx	 eax, BYTE PTR _a$[ebp]
  004e8	c1 e0 18	 shl	 eax, 24			; 00000018H
  004eb	0f b6 4d fd	 movzx	 ecx, BYTE PTR _r$[ebp]
  004ef	c1 e1 10	 shl	 ecx, 16			; 00000010H
  004f2	0b c1		 or	 eax, ecx
  004f4	0f b6 4d fc	 movzx	 ecx, BYTE PTR _g$[ebp]
  004f8	c1 e1 08	 shl	 ecx, 8
  004fb	0b c1		 or	 eax, ecx
  004fd	0f b6 4d fb	 movzx	 ecx, BYTE PTR _b$[ebp]
  00501	0b c1		 or	 eax, ecx
  00503	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  00506	8b 55 e4	 mov	 edx, DWORD PTR _pdwDest$[ebp]
  00509	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  0050c	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  0050f	40		 inc	 eax
  00510	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 190  : 								
; 191  : 								if (i > hxw)

  00513	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  00516	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  00519	76 12		 jbe	 SHORT $LN42@LoadFromMe

; 192  : 								{
; 193  : 									assert(!"RLE overflow");
; 194  : 									printf("RLE overflow");

  0051b	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HGIAMHNL@RLE?5overflow@
  00520	e8 00 00 00 00	 call	 _printf
  00525	59		 pop	 ecx

; 195  : 									return false;

  00526	32 c0		 xor	 al, al
  00528	e9 e7 00 00 00	 jmp	 $LN1@LoadFromMe
$LN42@LoadFromMe:

; 196  : 								}
; 197  : 								--rle;

  0052d	8a 45 ff	 mov	 al, BYTE PTR _rle$3[ebp]
  00530	2c 01		 sub	 al, 1
  00532	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al

; 198  : 							}

  00535	e9 46 ff ff ff	 jmp	 $LN21@LoadFromMe
$LN22@LoadFromMe:

; 199  : 						}

  0053a	e9 ba 00 00 00	 jmp	 $LN41@LoadFromMe
$LN40@LoadFromMe:

; 200  : 						else
; 201  : 						{
; 202  : 							rle -= 127;

  0053f	0f b6 45 ff	 movzx	 eax, BYTE PTR _rle$3[ebp]
  00543	83 e8 7f	 sub	 eax, 127		; 0000007fH
  00546	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al

; 203  : 							
; 204  : 							b = (BYTE) *(c_pbMem++); --iSize;

  00549	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  0054c	8a 00		 mov	 al, BYTE PTR [eax]
  0054e	88 45 fb	 mov	 BYTE PTR _b$[ebp], al
  00551	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00554	40		 inc	 eax
  00555	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  00558	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  0055b	48		 dec	 eax
  0055c	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 205  : 							g = (BYTE) *(c_pbMem++); --iSize;

  0055f	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00562	8a 00		 mov	 al, BYTE PTR [eax]
  00564	88 45 fc	 mov	 BYTE PTR _g$[ebp], al
  00567	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  0056a	40		 inc	 eax
  0056b	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  0056e	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00571	48		 dec	 eax
  00572	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 206  : 							r = (BYTE) *(c_pbMem++); --iSize;

  00575	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00578	8a 00		 mov	 al, BYTE PTR [eax]
  0057a	88 45 fd	 mov	 BYTE PTR _r$[ebp], al
  0057d	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00580	40		 inc	 eax
  00581	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  00584	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  00587	48		 dec	 eax
  00588	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax

; 207  : 							a = (BYTE) *(c_pbMem++); --iSize;

  0058b	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  0058e	8a 00		 mov	 al, BYTE PTR [eax]
  00590	88 45 fe	 mov	 BYTE PTR _a$[ebp], al
  00593	8b 45 0c	 mov	 eax, DWORD PTR _c_pbMem$[ebp]
  00596	40		 inc	 eax
  00597	89 45 0c	 mov	 DWORD PTR _c_pbMem$[ebp], eax
  0059a	8b 45 08	 mov	 eax, DWORD PTR _iSize$[ebp]
  0059d	48		 dec	 eax
  0059e	89 45 08	 mov	 DWORD PTR _iSize$[ebp], eax
$LN23@LoadFromMe:

; 208  : 							
; 209  : 							while (rle)

  005a1	0f b6 45 ff	 movzx	 eax, BYTE PTR _rle$3[ebp]
  005a5	85 c0		 test	 eax, eax
  005a7	74 50		 je	 SHORT $LN41@LoadFromMe

; 210  : 							{
; 211  : 								pdwDest[i++] = (a << 24) | (r << 16) | (g << 8) | b;

  005a9	0f b6 45 fe	 movzx	 eax, BYTE PTR _a$[ebp]
  005ad	c1 e0 18	 shl	 eax, 24			; 00000018H
  005b0	0f b6 4d fd	 movzx	 ecx, BYTE PTR _r$[ebp]
  005b4	c1 e1 10	 shl	 ecx, 16			; 00000010H
  005b7	0b c1		 or	 eax, ecx
  005b9	0f b6 4d fc	 movzx	 ecx, BYTE PTR _g$[ebp]
  005bd	c1 e1 08	 shl	 ecx, 8
  005c0	0b c1		 or	 eax, ecx
  005c2	0f b6 4d fb	 movzx	 ecx, BYTE PTR _b$[ebp]
  005c6	0b c1		 or	 eax, ecx
  005c8	8b 4d f0	 mov	 ecx, DWORD PTR _i$[ebp]
  005cb	8b 55 e4	 mov	 edx, DWORD PTR _pdwDest$[ebp]
  005ce	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax
  005d1	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  005d4	40		 inc	 eax
  005d5	89 45 f0	 mov	 DWORD PTR _i$[ebp], eax

; 212  : 								
; 213  : 								if (i > hxw)

  005d8	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  005db	3b 45 e8	 cmp	 eax, DWORD PTR _hxw$[ebp]
  005de	76 0f		 jbe	 SHORT $LN43@LoadFromMe

; 214  : 								{
; 215  : 									assert(!"RLE overflow");
; 216  : 									printf("RLE overflow");

  005e0	68 00 00 00 00	 push	 OFFSET ??_C@_0N@HGIAMHNL@RLE?5overflow@
  005e5	e8 00 00 00 00	 call	 _printf
  005ea	59		 pop	 ecx

; 217  : 									return false;

  005eb	32 c0		 xor	 al, al
  005ed	eb 25		 jmp	 SHORT $LN1@LoadFromMe
$LN43@LoadFromMe:

; 218  : 								}
; 219  : 
; 220  : 								--rle;

  005ef	8a 45 ff	 mov	 al, BYTE PTR _rle$3[ebp]
  005f2	2c 01		 sub	 al, 1
  005f4	88 45 ff	 mov	 BYTE PTR _rle$3[ebp], al

; 221  : 							}

  005f7	eb a8		 jmp	 SHORT $LN23@LoadFromMe
$LN41@LoadFromMe:

; 222  : 						}
; 223  : 					}

  005f9	e9 49 fe ff ff	 jmp	 $LN19@LoadFromMe
$LN2@LoadFromMe:

; 224  : 				}
; 225  : 			}
; 226  : 			break;
; 227  : 	}
; 228  : 	
; 229  : 	if (!(m_Header.desc & 0x20))

  005fe	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00601	0f be 40 39	 movsx	 eax, BYTE PTR [eax+57]
  00605	83 e0 20	 and	 eax, 32			; 00000020H
  00608	75 08		 jne	 SHORT $LN44@LoadFromMe

; 230  : 	{
; 231  : 		FlipTopToBottom();

  0060a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0060d	e8 00 00 00 00	 call	 ?FlipTopToBottom@CImage@@QAEXXZ ; CImage::FlipTopToBottom
$LN44@LoadFromMe:

; 232  : 	}
; 233  : 
; 234  : 	return true;

  00612	b0 01		 mov	 al, 1
$LN1@LoadFromMe:

; 235  : }

  00614	c9		 leave
  00615	c2 08 00	 ret	 8
?LoadFromMemory@CTGAImage@@UAE_NHPBE@Z ENDP		; CTGAImage::LoadFromMemory
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ?Create@CTGAImage@@UAEXHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_width$ = 8						; size = 4
_height$ = 12						; size = 4
?Create@CTGAImage@@UAEXHH@Z PROC			; CTGAImage::Create, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 	memset(&m_Header, 0, sizeof(m_Header));

  00007	6a 12		 push	 18			; 00000012H
  00009	6a 00		 push	 0
  0000b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	83 c0 28	 add	 eax, 40			; 00000028H
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 _memset
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 31   : 
; 32   : 	m_Header.imgType	= 2;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	c6 40 2a 02	 mov	 BYTE PTR [eax+42], 2

; 33   : 	m_Header.width		= (short) width;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	66 8b 4d 08	 mov	 cx, WORD PTR _width$[ebp]
  00028	66 89 48 34	 mov	 WORD PTR [eax+52], cx

; 34   : 	m_Header.height		= (short) height;

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	66 8b 4d 0c	 mov	 cx, WORD PTR _height$[ebp]
  00033	66 89 48 36	 mov	 WORD PTR [eax+54], cx

; 35   : 	m_Header.colorBits	= 32;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	c6 40 38 20	 mov	 BYTE PTR [eax+56], 32	; 00000020H

; 36   : 	m_Header.desc		= 0x08;	// alpha channel 있음

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c6 40 39 08	 mov	 BYTE PTR [eax+57], 8

; 37   : 
; 38   : 	CImage::Create(width, height);

  00045	ff 75 0c	 push	 DWORD PTR _height$[ebp]
  00048	ff 75 08	 push	 DWORD PTR _width$[ebp]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?Create@CImage@@QAEXHH@Z ; CImage::Create

; 39   : }

  00053	c9		 leave
  00054	c2 08 00	 ret	 8
?Create@CTGAImage@@UAEXHH@Z ENDP			; CTGAImage::Create
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ??1CTGAImage@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1CTGAImage@@UAE@XZ PROC				; CTGAImage::~CTGAImage, COMDAT
; _this$ = ecx

; 13   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTGAImage@@6B@

; 14   : }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1CImage@@UAE@XZ	; CImage::~CImage
  00018	c9		 leave
  00019	c3		 ret	 0
??1CTGAImage@@UAE@XZ ENDP				; CTGAImage::~CTGAImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ??0CTGAImage@@QAE@AAVCImage@@@Z
_TEXT	SEGMENT
_pdwDest$ = -28						; size = 4
_h$ = -24						; size = 4
_w$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_image$ = 8						; size = 4
??0CTGAImage@@QAE@AAVCImage@@@Z PROC			; CTGAImage::CTGAImage, COMDAT
; _this$ = ecx

; 17   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CTGAImage@@QAE@AAVCImage@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CImage@@QAE@XZ	; CImage::CImage
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTGAImage@@6B@

; 16   : CTGAImage::CTGAImage(CImage &image) : m_dwFlag(0)

  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 60 3c 00	 and	 DWORD PTR [eax+60], 0

; 18   : 	int w = image.GetWidth();

  00044	8b 4d 08	 mov	 ecx, DWORD PTR _image$[ebp]
  00047	e8 00 00 00 00	 call	 ?GetWidth@CImage@@QBEHXZ ; CImage::GetWidth
  0004c	89 45 ec	 mov	 DWORD PTR _w$[ebp], eax

; 19   : 	int h = image.GetHeight();

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _image$[ebp]
  00052	e8 00 00 00 00	 call	 ?GetHeight@CImage@@QBEHXZ ; CImage::GetHeight
  00057	89 45 e8	 mov	 DWORD PTR _h$[ebp], eax

; 20   : 
; 21   : 	Create(w, h);

  0005a	ff 75 e8	 push	 DWORD PTR _h$[ebp]
  0005d	ff 75 ec	 push	 DWORD PTR _w$[ebp]
  00060	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?Create@CTGAImage@@UAEXHH@Z ; CTGAImage::Create

; 22   : 
; 23   : 	DWORD * pdwDest = GetBasePointer();

  00068	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer
  00070	89 45 e4	 mov	 DWORD PTR _pdwDest$[ebp], eax

; 24   : 	memcpy(pdwDest, image.GetBasePointer(), w * h * sizeof(DWORD));

  00073	8b 45 ec	 mov	 eax, DWORD PTR _w$[ebp]
  00076	0f af 45 e8	 imul	 eax, DWORD PTR _h$[ebp]
  0007a	c1 e0 02	 shl	 eax, 2
  0007d	50		 push	 eax
  0007e	8b 4d 08	 mov	 ecx, DWORD PTR _image$[ebp]
  00081	e8 00 00 00 00	 call	 ?GetBasePointer@CImage@@QAEPAKXZ ; CImage::GetBasePointer
  00086	50		 push	 eax
  00087	ff 75 e4	 push	 DWORD PTR _pdwDest$[ebp]
  0008a	e8 00 00 00 00	 call	 _memcpy
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 25   : 	FlipTopToBottom();

  00092	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?FlipTopToBottom@CImage@@QAEXXZ ; CImage::FlipTopToBottom

; 26   : }

  0009a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0009e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ab	59		 pop	 ecx
  000ac	c9		 leave
  000ad	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CTGAImage@@QAE@AAVCImage@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CImage@@UAE@XZ	; CImage::~CImage
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0CTGAImage@@QAE@AAVCImage@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CTGAImage@@QAE@AAVCImage@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CTGAImage@@QAE@AAVCImage@@@Z ENDP			; CTGAImage::CTGAImage
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\TGAImage.cpp
;	COMDAT ??0CTGAImage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0CTGAImage@@QAE@XZ PROC				; CTGAImage::CTGAImage, COMDAT
; _this$ = ecx

; 9    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0CImage@@QAE@XZ	; CImage::CImage
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CTGAImage@@6B@

; 8    : CTGAImage::CTGAImage() : m_dwFlag(0)

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 60 3c 00	 and	 DWORD PTR [eax+60], 0

; 10   : }

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	c9		 leave
  00023	c3		 ret	 0
??0CTGAImage@@QAE@XZ ENDP				; CTGAImage::CTGAImage
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__Stream$ = -12						; size = 4
__Format$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 954  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR __Format$[ebp], eax
  00012	6a 01		 push	 1
  00014	e8 00 00 00 00	 call	 ___acrt_iob_func
  00019	59		 pop	 ecx
  0001a	89 45 f4	 mov	 DWORD PTR __Stream$[ebp], eax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0001d	ff 75 fc	 push	 DWORD PTR __ArgList$[ebp]
  00020	6a 00		 push	 0
  00022	ff 75 f8	 push	 DWORD PTR __Format$[ebp]
  00025	ff 75 f4	 push	 DWORD PTR __Stream$[ebp]
  00028	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0002d	ff 70 04	 push	 DWORD PTR [eax+4]
  00030	ff 30		 push	 DWORD PTR [eax]
  00032	e8 00 00 00 00	 call	 ___stdio_common_vfprintf
  00037	83 c4 18	 add	 esp, 24			; 00000018H

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0003a	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 959  :         __crt_va_end(_ArgList);

  0003d	83 65 fc 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 960  :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 961  :     }

  00044	c9		 leave
  00045	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
