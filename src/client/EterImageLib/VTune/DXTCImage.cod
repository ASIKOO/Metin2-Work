; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	___local_stdio_printf_options
PUBLIC	__snprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0CDXTCImage@@QAE@XZ				; CDXTCImage::CDXTCImage
PUBLIC	??1CDXTCImage@@UAE@XZ				; CDXTCImage::~CDXTCImage
PUBLIC	?Initialize@CDXTCImage@@QAEXXZ			; CDXTCImage::Initialize
PUBLIC	?Clear@CDXTCImage@@QAEXXZ			; CDXTCImage::Clear
PUBLIC	?deallocate@?$allocator@E@std@@QAEXQAEI@Z	; std::allocator<unsigned char>::deallocate
PUBLIC	??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
PUBLIC	?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
PUBLIC	?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
PUBLIC	?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
PUBLIC	?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
PUBLIC	?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
PUBLIC	?LoadFromFile@CDXTCImage@@QAE_NPBD@Z		; CDXTCImage::LoadFromFile
PUBLIC	?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z		; CDXTCImage::LoadFromMemory
PUBLIC	?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z	; CDXTCImage::LoadHeaderFromMemory
PUBLIC	?Copy@CDXTCImage@@QAE_NHPAEJ@Z			; CDXTCImage::Copy
PUBLIC	?Decompress@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::Decompress
PUBLIC	?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT1
PUBLIC	?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT3
PUBLIC	?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressDXT5
PUBLIC	?DecompressARGB@CDXTCImage@@QAEXHPAK@Z		; CDXTCImage::DecompressARGB
PUBLIC	?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ; CDXTCImage::DecodePixelFormat
PUBLIC	?Unextract@CDXTCImage@@QAEXPAEHHH@Z		; CDXTCImage::Unextract
PUBLIC	??_GCDXTCImage@@UAEPAXI@Z			; CDXTCImage::`scalar deleting destructor'
PUBLIC	?GetColorBlockColors@@YAXPAUDXTColBlock@@PAUColor8888@@111AAG@Z ; GetColorBlockColors
PUBLIC	?DecodeColorBlock@@YAXPAKPAUDXTColBlock@@H0000@Z ; DecodeColorBlock
PUBLIC	?DecodeAlphaExplicit@@YAXPAKPAUDXTAlphaBlockExplicit@@HK@Z ; DecodeAlphaExplicit
PUBLIC	?DecodeAlpha3BitLinear@@YAXPAKPAUDXTAlphaBlock3BitLinear@@HK@Z ; DecodeAlpha3BitLinear
PUBLIC	??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
PUBLIC	??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Zero_range@PAE@std@@YAPAEQAE0@Z		; std::_Zero_range<unsigned char *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
PUBLIC	??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z	; std::_Copy_memmove<unsigned char *,unsigned char *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7CDXTCImage@@6B@				; CDXTCImage::`vftable'
PUBLIC	??_C@_04LFFPHNGG@?4DDS@				; `string'
PUBLIC	??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@ ; `string'
PUBLIC	??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@ ; `string'
PUBLIC	??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@ ; `string'
PUBLIC	??_C@_07FBMAHCAD@?9premul@			; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@ ; `string'
PUBLIC	??_C@_04DHPPFAPI@DXT1@				; `string'
PUBLIC	??_C@_04BMNCADDL@DXT2@				; `string'
PUBLIC	??_C@_04FMJDCHK@DXT3@				; `string'
PUBLIC	??_C@_04EKIIKELN@DXT4@				; `string'
PUBLIC	??_C@_04FDJDJFPM@DXT5@				; `string'
PUBLIC	??_C@_0P@NBMDABNO@Format?5Unknown@		; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CDXTCImage@@6B@				; CDXTCImage::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCDXTCImage@@@8				; CDXTCImage `RTTI Type Descriptor'
PUBLIC	??_R3CDXTCImage@@8				; CDXTCImage::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CDXTCImage@@8				; CDXTCImage::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CDXTCImage@@8			; CDXTCImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strstr:PROC
EXTRN	_strcpy:PROC
EXTRN	_strncpy:PROC
EXTRN	_strupr:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	??0CMappedFile@@QAE@XZ:PROC			; CMappedFile::CMappedFile
EXTRN	??1CMappedFile@@UAE@XZ:PROC			; CMappedFile::~CMappedFile
EXTRN	?Create@CMappedFile@@QAEHPBDPAPBXHH@Z:PROC	; CMappedFile::Create
EXTRN	?Tracef@@YAXPBDZZ:PROC				; Tracef
EXTRN	??_ECDXTCImage@@UAEPAXI@Z:PROC			; CDXTCImage::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
_BSS	SEGMENT
?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA DB 0105H DUP (?) ; `CDXTCImage::LoadFromFile'::`2'::fileupper
_BSS	ENDS
_BSS	SEGMENT
?gBits@@3PAY03EA DB 010H DUP (?)			; gBits
?gAlphas@@3PAGA DW 08H DUP (?)				; gAlphas
?gACol@@3PAY03UColor8888@@A DD 010H DUP (?)		; gACol
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@CDXTCImage@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CDXTCImage@@8 DD FLAT:??_R0?AVCDXTCImage@@@8 ; CDXTCImage::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R2CDXTCImage@@8
rdata$r	SEGMENT
??_R2CDXTCImage@@8 DD FLAT:??_R1A@?0A@EA@CDXTCImage@@8	; CDXTCImage::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CDXTCImage@@8
rdata$r	SEGMENT
??_R3CDXTCImage@@8 DD 00H				; CDXTCImage::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCDXTCImage@@@8
data$rs	SEGMENT
??_R0?AVCDXTCImage@@@8 DD FLAT:??_7type_info@@6B@	; CDXTCImage `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCDXTCImage@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CDXTCImage@@6B@
rdata$r	SEGMENT
??_R4CDXTCImage@@6B@ DD 00H				; CDXTCImage::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCDXTCImage@@@8
	DD	FLAT:??_R3CDXTCImage@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NBMDABNO@Format?5Unknown@
CONST	SEGMENT
??_C@_0P@NBMDABNO@Format?5Unknown@ DB 'Format Unknown', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04FDJDJFPM@DXT5@
CONST	SEGMENT
??_C@_04FDJDJFPM@DXT5@ DB 'DXT5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EKIIKELN@DXT4@
CONST	SEGMENT
??_C@_04EKIIKELN@DXT4@ DB 'DXT4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FMJDCHK@DXT3@
CONST	SEGMENT
??_C@_04FMJDCHK@DXT3@ DB 'DXT3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04BMNCADDL@DXT2@
CONST	SEGMENT
??_C@_04BMNCADDL@DXT2@ DB 'DXT2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DHPPFAPI@DXT1@
CONST	SEGMENT
??_C@_04DHPPFAPI@DXT1@ DB 'DXT1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@
CONST	SEGMENT
??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@ DB 'ARGB-%d%d%d%d%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBMAHCAD@?9premul@
CONST	SEGMENT
??_C@_07FBMAHCAD@?9premul@ DB '-premul', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
CONST	SEGMENT
??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@ DB 'Yo'
	DB	'ur logic is jacked! bits == 0x%x', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@
CONST	SEGMENT
??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@ DB 'Ca'
	DB	'n''t open file for reading! [%s]', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@
CONST	SEGMENT
??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@ DB 'Unknown file f'
	DB	'ormat encountered! [%s]', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LFFPHNGG@?4DDS@
CONST	SEGMENT
??_C@_04LFFPHNGG@?4DDS@ DB '.DDS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7CDXTCImage@@6B@
CONST	SEGMENT
??_7CDXTCImage@@6B@ DD FLAT:??_R4CDXTCImage@@6B@	; CDXTCImage::`vftable'
	DD	FLAT:??_ECDXTCImage@@UAEPAXI@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$26
__ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z$0
__ehfuncinfo$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CDXTCImage@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CDXTCImage@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CDXTCImage@@QAE@XZ$0
__ehfuncinfo$??0CDXTCImage@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0CDXTCImage@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z PROC		; std::_Copy_memmove<unsigned char *,unsigned char *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ENDP		; std::_Copy_memmove<unsigned char *,unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_memmove<unsigned char *,unsigned char *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	03 45 10	 add	 eax, DWORD PTR __Dest$[ebp]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00032	c9		 leave
  00033	c3		 ret	 0
??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Zero_range@PAE@std@@YAPAEQAE0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAE@std@@YAPAEQAE0@Z PROC		; std::_Zero_range<unsigned char *>, COMDAT

; 1852 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 1853 :     char* const _First_ch = reinterpret_cast<char*>(_First);

  00005	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1854 :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000e	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1855 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	8b 45 f8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00014	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00017	50		 push	 eax
  00018	6a 00		 push	 0
  0001a	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  0001d	e8 00 00 00 00	 call	 _memset
  00022	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1856 :     return _Last;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1857 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$_Zero_range@PAE@std@@YAPAEQAE0@Z ENDP		; std::_Zero_range<unsigned char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__PFirst$1 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >, COMDAT

; 1862 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00004	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR __PFirst$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1867 :         _Zero_range(_PFirst, _PFirst + _Count);

  0000a	8b 45 fc	 mov	 eax, DWORD PTR __PFirst$1[ebp]
  0000d	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00010	50		 push	 eax
  00011	ff 75 fc	 push	 DWORD PTR __PFirst$1[ebp]
  00014	e8 00 00 00 00	 call	 ??$_Zero_range@PAE@std@@YAPAEQAE0@Z ; std::_Zero_range<unsigned char *>
  00019	59		 pop	 ecx
  0001a	59		 pop	 ecx

; 1868 :         return _First + _Count;

  0001b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001e	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 1869 :     } else {
; 1870 :         _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};
; 1871 :         for (; 0 < _Count; --_Count) {
; 1872 :             _Backout._Emplace_back();
; 1873 :         }
; 1874 : 
; 1875 :         return _Backout._Release();
; 1876 :     }
; 1877 : }

  00021	c9		 leave
  00022	c3		 ret	 0
??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
$T2 = -136						; size = 4
$T3 = -132						; size = 4
__First$ = -128						; size = 4
__Last$ = -124						; size = 4
$T4 = -120						; size = 4
$T5 = -116						; size = 4
tv238 = -112						; size = 4
$T6 = -108						; size = 4
$T7 = -104						; size = 4
$T8 = -100						; size = 4
$T9 = -96						; size = 4
$T10 = -92						; size = 4
$T11 = -88						; size = 4
$T12 = -84						; size = 4
$T13 = -80						; size = 4
__Appended_last$ = -76					; size = 4
__Myfirst$ = -72					; size = 4
__Mylast$ = -68						; size = 4
__Oldsize$ = -64					; size = 4
__My_data$ = -60					; size = 4
tv145 = -56						; size = 4
$T14 = -52						; size = 4
$T15 = -48						; size = 4
__Newcapacity$ = -44					; size = 4
__Appended_first$ = -40					; size = 4
__Newvec$ = -36						; size = 4
_this$ = -32						; size = 4
___formal$ = -28					; size = 1
___formal$ = -24					; size = 1
__Overflow_is_possible$16 = -18				; size = 1
$T17 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1182 :     void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 78	 sub	 esp, 120		; 00000078H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1737 :         return _Mypair._Get_first();

  0002f	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00032	89 45 b0	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00035	8b 45 b0	 mov	 eax, DWORD PTR $T13[ebp]
  00038	89 85 7c ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0003e	83 4d d0 ff	 or	 DWORD PTR $T15[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00042	c7 45 ac ff ff
	ff 7f		 mov	 DWORD PTR $T12[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00049	8b 45 ac	 mov	 eax, DWORD PTR $T12[ebp]
  0004c	89 45 cc	 mov	 DWORD PTR $T14[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0004f	8b 45 d0	 mov	 eax, DWORD PTR $T15[ebp]
  00052	3b 45 cc	 cmp	 eax, DWORD PTR $T14[ebp]
  00055	73 08		 jae	 SHORT $LN26@Resize_rea
  00057	8d 45 d0	 lea	 eax, DWORD PTR $T15[ebp]
  0005a	89 45 c8	 mov	 DWORD PTR tv145[ebp], eax
  0005d	eb 06		 jmp	 SHORT $LN27@Resize_rea
$LN26@Resize_rea:
  0005f	8d 45 cc	 lea	 eax, DWORD PTR $T14[ebp]
  00062	89 45 c8	 mov	 DWORD PTR tv145[ebp], eax
$LN27@Resize_rea:
  00065	8b 45 c8	 mov	 eax, DWORD PTR tv145[ebp]
  00068	89 45 a8	 mov	 DWORD PTR $T11[ebp], eax
  0006b	8b 45 a8	 mov	 eax, DWORD PTR $T11[ebp]
  0006e	89 45 a4	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00071	8b 45 a4	 mov	 eax, DWORD PTR $T10[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	89 45 a0	 mov	 DWORD PTR $T9[ebp], eax

; 1183 :         if (_Newsize > max_size()) {

  00079	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0007c	3b 45 a0	 cmp	 eax, DWORD PTR $T9[ebp]
  0007f	76 05		 jbe	 SHORT $LN2@Resize_rea

; 1184 :             _Xlength();

  00081	e8 00 00 00 00	 call	 ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
$LN2@Resize_rea:

; 1185 :         }
; 1186 : 
; 1187 :         auto& _My_data    = _Mypair._Myval2;

  00086	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	89 45 c4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1188 :         pointer& _Myfirst = _My_data._Myfirst;

  0008c	8b 45 c4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0008f	89 45 b8	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1189 :         pointer& _Mylast  = _My_data._Mylast;

  00092	8b 45 c4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00095	83 c0 04	 add	 eax, 4
  00098	89 45 bc	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1190 : 
; 1191 :         const auto _Oldsize          = static_cast<size_type>(_Mylast - _Myfirst);

  0009b	8b 45 bc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009e	8b 4d b8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	2b 01		 sub	 eax, DWORD PTR [ecx]
  000a5	89 45 c0	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1192 :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000a8	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  000ab	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
  000b3	89 45 d4	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  000b6	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b9	89 45 9c	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000bc	8b 45 9c	 mov	 eax, DWORD PTR $T8[ebp]
  000bf	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000c5	c6 45 ee 00	 mov	 BYTE PTR __Overflow_is_possible$16[ebp], 0

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000c9	ff 75 d4	 push	 DWORD PTR __Newcapacity$[ebp]
  000cc	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  000d1	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1194 :         const pointer _Newvec         = _Getal().allocate(_Newcapacity);

  000d2	89 45 dc	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1195 :         const pointer _Appended_first = _Newvec + _Oldsize;

  000d5	8b 45 dc	 mov	 eax, DWORD PTR __Newvec$[ebp]
  000d8	03 45 c0	 add	 eax, DWORD PTR __Oldsize$[ebp]
  000db	89 45 d8	 mov	 DWORD PTR __Appended_first$[ebp], eax

; 1196 :         pointer _Appended_last        = _Appended_first;

  000de	8b 45 d8	 mov	 eax, DWORD PTR __Appended_first$[ebp]
  000e1	89 45 b4	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1197 : 
; 1198 :         _TRY_BEGIN

  000e4	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000e8	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000eb	8a 00		 mov	 al, BYTE PTR [eax]
  000ed	88 45 e8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000f0	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000f3	89 45 98	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000f6	8b 45 98	 mov	 eax, DWORD PTR $T7[ebp]
  000f9	89 45 94	 mov	 DWORD PTR $T6[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000fc	ff 75 94	 push	 DWORD PTR $T6[ebp]

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  000ff	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00102	2b 45 c0	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00105	50		 push	 eax
  00106	ff 75 d8	 push	 DWORD PTR __Appended_first$[ebp]
  00109	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00111	89 45 90	 mov	 DWORD PTR tv238[ebp], eax

; 1199 :         _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);

  00114	8b 45 90	 mov	 eax, DWORD PTR tv238[ebp]
  00117	89 45 b4	 mov	 DWORD PTR __Appended_last$[ebp], eax

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  0011a	8b 45 bc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0011d	8b 00		 mov	 eax, DWORD PTR [eax]
  0011f	89 45 84	 mov	 DWORD PTR __Last$[ebp], eax
  00122	8b 45 b8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00125	8b 00		 mov	 eax, DWORD PTR [eax]
  00127	89 45 80	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  0012a	33 c0		 xor	 eax, eax
  0012c	88 45 ef	 mov	 BYTE PTR $T17[ebp], al
  0012f	8a 45 ef	 mov	 al, BYTE PTR $T17[ebp]
  00132	88 45 e4	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  00135	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00138	89 45 8c	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0013b	8b 45 8c	 mov	 eax, DWORD PTR $T5[ebp]
  0013e	89 45 88	 mov	 DWORD PTR $T4[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00141	ff 75 88	 push	 DWORD PTR $T4[ebp]
  00144	ff 75 dc	 push	 DWORD PTR __Newvec$[ebp]
  00147	ff 75 84	 push	 DWORD PTR __Last$[ebp]
  0014a	ff 75 80	 push	 DWORD PTR __First$[ebp]
  0014d	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAEV?$allocator@E@std@@@std@@YAPAEQAE0PAEAAV?$allocator@E@0@@Z ; std::_Uninitialized_move<unsigned char *,std::allocator<unsigned char> >
  00152	83 c4 10	 add	 esp, 16			; 00000010H

; 1200 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00155	eb 32		 jmp	 SHORT $LN5@Resize_rea
__catch$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:

; 1201 :         _CATCH_ALL
; 1202 :         _Destroy(_Appended_first, _Appended_last);

  00157	ff 75 b4	 push	 DWORD PTR __Appended_last$[ebp]
  0015a	ff 75 d8	 push	 DWORD PTR __Appended_first$[ebp]
  0015d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	e8 00 00 00 00	 call	 ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy

; 1203 :         _Getal().deallocate(_Newvec, _Newcapacity);

  00165	ff 75 d4	 push	 DWORD PTR __Newcapacity$[ebp]
  00168	ff 75 dc	 push	 DWORD PTR __Newvec$[ebp]
  0016b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
  00173	8b c8		 mov	 ecx, eax
  00175	e8 00 00 00 00	 call	 ?deallocate@?$allocator@E@std@@QAEXQAEI@Z ; std::allocator<unsigned char>::deallocate

; 1204 :         _RERAISE;

  0017a	6a 00		 push	 0
  0017c	6a 00		 push	 0
  0017e	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1205 :         _CATCH_END

  00183	b8 00 00 00 00	 mov	 eax, $LN8@Resize_rea
  00188	c3		 ret	 0
$LN5@Resize_rea:
  00189	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0018d	eb 04		 jmp	 SHORT __tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
$LN8@Resize_rea:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  0018f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1206 : 
; 1207 :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00193	ff 75 d4	 push	 DWORD PTR __Newcapacity$[ebp]
  00196	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00199	ff 75 dc	 push	 DWORD PTR __Newvec$[ebp]
  0019c	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0019f	e8 00 00 00 00	 call	 ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
$LN4@Resize_rea:

; 1208 :     }

  001a4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ae	59		 pop	 ecx
  001af	5f		 pop	 edi
  001b0	5e		 pop	 esi
  001b1	5b		 pop	 ebx
  001b2	c9		 leave
  001b3	c2 08 00	 ret	 8
  001b6	cc		 int	 3
  001b7	cc		 int	 3
  001b8	cc		 int	 3
  001b9	cc		 int	 3
  001ba	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 74 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-140]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned char> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__Oldlast$1 = -56					; size = 4
$T2 = -52						; size = 4
$T3 = -48						; size = 4
__Oldcapacity$4 = -44					; size = 4
__Last$ = -40						; size = 4
$T5 = -36						; size = 4
$T6 = -32						; size = 4
__Newlast$7 = -28					; size = 4
__Oldsize$ = -24					; size = 4
__Myfirst$ = -20					; size = 4
__My_data$ = -16					; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
___formal$ = -4						; size = 1
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 1211 :     void _Resize(const size_type _Newsize, const _Ty2& _Val) { // trim or append elements, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1212 :         auto& _My_data      = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1213 :         pointer& _Myfirst   = _My_data._Myfirst;

  0000f	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 ec	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1214 :         pointer& _Mylast    = _My_data._Mylast;

  00015	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1215 :         const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	2b 01		 sub	 eax, DWORD PTR [ecx]
  00028	89 45 e8	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1216 :         if (_Newsize < _Oldsize) { // trim

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002e	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00031	73 3a		 jae	 SHORT $LN2@Resize

; 1217 :             const pointer _Newlast = _Myfirst + _Newsize;

  00033	8b 45 ec	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  0003b	89 45 e4	 mov	 DWORD PTR __Newlast$7[ebp], eax

; 1218 :             _Orphan_range(_Newlast, _Mylast);
; 1219 :             _Destroy(_Newlast, _Mylast);

  0003e	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00041	8b 00		 mov	 eax, DWORD PTR [eax]
  00043	89 45 d8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00046	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00049	89 45 e0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0004c	8b 45 e0	 mov	 eax, DWORD PTR $T6[ebp]
  0004f	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00052	ff 75 dc	 push	 DWORD PTR $T5[ebp]
  00055	ff 75 d8	 push	 DWORD PTR __Last$[ebp]
  00058	ff 75 e4	 push	 DWORD PTR __Newlast$7[ebp]
  0005b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1220 :             _Mylast = _Newlast;

  00063	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d e4	 mov	 ecx, DWORD PTR __Newlast$7[ebp]
  00069	89 08		 mov	 DWORD PTR [eax], ecx

; 1221 :             return;

  0006b	eb 64		 jmp	 SHORT $LN1@Resize
$LN2@Resize:

; 1222 :         }
; 1223 : 
; 1224 :         if (_Newsize > _Oldsize) { // append

  0006d	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00070	3b 45 e8	 cmp	 eax, DWORD PTR __Oldsize$[ebp]
  00073	76 5c		 jbe	 SHORT $LN1@Resize

; 1225 :             const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

  00075	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00078	8b 4d ec	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0007b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0007e	2b 01		 sub	 eax, DWORD PTR [ecx]
  00080	89 45 d4	 mov	 DWORD PTR __Oldcapacity$4[ebp], eax

; 1226 :             if (_Newsize > _Oldcapacity) { // reallocate

  00083	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00086	3b 45 d4	 cmp	 eax, DWORD PTR __Oldcapacity$4[ebp]
  00089	76 10		 jbe	 SHORT $LN4@Resize

; 1227 :                 _Resize_reallocate(_Newsize, _Val);

  0008b	ff 75 0c	 push	 DWORD PTR __Val$[ebp]
  0008e	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  00091	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ??$_Resize_reallocate@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize_reallocate<std::_Value_init_tag>

; 1228 :                 return;

  00099	eb 36		 jmp	 SHORT $LN1@Resize
$LN4@Resize:

; 1229 :             }
; 1230 : 
; 1231 :             const pointer _Oldlast = _Mylast;

  0009b	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009e	8b 00		 mov	 eax, DWORD PTR [eax]
  000a0	89 45 c8	 mov	 DWORD PTR __Oldlast$1[ebp], eax

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000a3	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  000a6	8a 00		 mov	 al, BYTE PTR [eax]
  000a8	88 45 fc	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000ab	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ae	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000b1	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  000b4	89 45 cc	 mov	 DWORD PTR $T2[ebp], eax

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000b7	ff 75 cc	 push	 DWORD PTR $T2[ebp]

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000ba	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  000bd	2b 45 e8	 sub	 eax, DWORD PTR __Oldsize$[ebp]

; 1583 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  000c0	50		 push	 eax
  000c1	ff 75 c8	 push	 DWORD PTR __Oldlast$1[ebp]
  000c4	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@E@std@@@std@@YAPAEPAEIAAV?$allocator@E@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<unsigned char> >
  000c9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1232 :             _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);

  000cc	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cf	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@Resize:

; 1233 :             _Orphan_range(_Oldlast, _Oldlast);
; 1234 :         }
; 1235 : 
; 1236 :         // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
; 1237 :     }

  000d1	c9		 leave
  000d2	c2 08 00	 ret	 8
??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?GetNumberOfBits@@YAGK@Z
_TEXT	SEGMENT
_wBits$ = -4						; size = 2
_dwMask$ = 8						; size = 4
?GetNumberOfBits@@YAGK@Z PROC				; GetNumberOfBits, COMDAT

; 899  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 900  : 	WORD wBits;
; 901  :     for (wBits = 0; dwMask; wBits++)

  00004	33 c0		 xor	 eax, eax
  00006	66 89 45 fc	 mov	 WORD PTR _wBits$[ebp], ax
  0000a	eb 0c		 jmp	 SHORT $LN4@GetNumberO
$LN2@GetNumberO:
  0000c	66 8b 45 fc	 mov	 ax, WORD PTR _wBits$[ebp]
  00010	66 83 c0 01	 add	 ax, 1
  00014	66 89 45 fc	 mov	 WORD PTR _wBits$[ebp], ax
$LN4@GetNumberO:
  00018	83 7d 08 00	 cmp	 DWORD PTR _dwMask$[ebp], 0
  0001c	74 0c		 je	 SHORT $LN3@GetNumberO

; 902  :         dwMask = (dwMask & (dwMask - 1)); 

  0001e	8b 45 08	 mov	 eax, DWORD PTR _dwMask$[ebp]
  00021	48		 dec	 eax
  00022	23 45 08	 and	 eax, DWORD PTR _dwMask$[ebp]
  00025	89 45 08	 mov	 DWORD PTR _dwMask$[ebp], eax
  00028	eb e2		 jmp	 SHORT $LN2@GetNumberO
$LN3@GetNumberO:

; 903  : 	
; 904  :     return wBits;

  0002a	66 8b 45 fc	 mov	 ax, WORD PTR _wBits$[ebp]

; 905  : }

  0002e	c9		 leave
  0002f	c3		 ret	 0
?GetNumberOfBits@@YAGK@Z ENDP				; GetNumberOfBits
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecodeAlpha3BitLinear@@YAXPAKPAUDXTAlphaBlock3BitLinear@@HK@Z
_TEXT	SEGMENT
_mask$ = -20						; size = 4
$T1 = -16						; size = 4
_pix$ = -12						; size = 4
_row$ = -8						; size = 4
_bits$ = -4						; size = 4
_pImPos$ = 8						; size = 4
_pAlphaBlock$ = 12					; size = 4
_width$ = 16						; size = 4
_alphazero$ = 20					; size = 4
?DecodeAlpha3BitLinear@@YAXPAKPAUDXTAlphaBlock3BitLinear@@HK@Z PROC ; DecodeAlpha3BitLinear, COMDAT

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 548  : 	gAlphas[0] = pAlphaBlock->alpha0;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _pAlphaBlock$[ebp]
  00009	66 0f b6 00	 movzx	 ax, BYTE PTR [eax]
  0000d	6a 02		 push	 2
  0000f	59		 pop	 ecx
  00010	6b c9 00	 imul	 ecx, ecx, 0
  00013	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 549  : 	gAlphas[1] = pAlphaBlock->alpha1;

  0001a	8b 45 0c	 mov	 eax, DWORD PTR _pAlphaBlock$[ebp]
  0001d	66 0f b6 40 01	 movzx	 ax, BYTE PTR [eax+1]
  00022	6a 02		 push	 2
  00024	59		 pop	 ecx
  00025	c1 e1 00	 shl	 ecx, 0
  00028	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 550  : 
; 551  : 	// 8-alpha or 6-alpha block?    
; 552  : 	if (gAlphas[0] > gAlphas[1])

  0002f	6a 02		 push	 2
  00031	58		 pop	 eax
  00032	6b c0 00	 imul	 eax, eax, 0
  00035	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  0003c	6a 02		 push	 2
  0003e	59		 pop	 ecx
  0003f	c1 e1 00	 shl	 ecx, 0
  00042	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  00049	3b c1		 cmp	 eax, ecx
  0004b	0f 8e 34 01 00
	00		 jle	 $LN14@DecodeAlph

; 553  : 	{
; 554  : 		// 8-alpha block:  derive the other 6 alphas.    
; 555  : 		// 000 = alpha_0, 001 = alpha_1, others are interpolated
; 556  : 		gAlphas[2] = (WORD) ((6 * gAlphas[0] +     gAlphas[1]) / 7);	// Bit code 010

  00051	6a 02		 push	 2
  00053	58		 pop	 eax
  00054	6b c0 00	 imul	 eax, eax, 0
  00057	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  0005e	6b c0 06	 imul	 eax, eax, 6
  00061	6a 02		 push	 2
  00063	59		 pop	 ecx
  00064	c1 e1 00	 shl	 ecx, 0
  00067	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  0006e	03 c1		 add	 eax, ecx
  00070	99		 cdq
  00071	6a 07		 push	 7
  00073	59		 pop	 ecx
  00074	f7 f9		 idiv	 ecx
  00076	6a 02		 push	 2
  00078	59		 pop	 ecx
  00079	d1 e1		 shl	 ecx, 1
  0007b	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 557  : 		gAlphas[3] = (WORD) ((5 * gAlphas[0] + 2 * gAlphas[1]) / 7);	// Bit code 011    

  00082	6a 02		 push	 2
  00084	58		 pop	 eax
  00085	6b c0 00	 imul	 eax, eax, 0
  00088	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  0008f	6b c0 05	 imul	 eax, eax, 5
  00092	6a 02		 push	 2
  00094	59		 pop	 ecx
  00095	c1 e1 00	 shl	 ecx, 0
  00098	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  0009f	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  000a2	99		 cdq
  000a3	6a 07		 push	 7
  000a5	59		 pop	 ecx
  000a6	f7 f9		 idiv	 ecx
  000a8	6a 02		 push	 2
  000aa	59		 pop	 ecx
  000ab	6b c9 03	 imul	 ecx, ecx, 3
  000ae	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 558  : 		gAlphas[4] = (WORD) ((4 * gAlphas[0] + 3 * gAlphas[1]) / 7);	// Bit code 100    

  000b5	6a 02		 push	 2
  000b7	58		 pop	 eax
  000b8	6b c0 00	 imul	 eax, eax, 0
  000bb	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  000c2	6a 02		 push	 2
  000c4	59		 pop	 ecx
  000c5	c1 e1 00	 shl	 ecx, 0
  000c8	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  000cf	6b c9 03	 imul	 ecx, ecx, 3
  000d2	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000d5	99		 cdq
  000d6	6a 07		 push	 7
  000d8	59		 pop	 ecx
  000d9	f7 f9		 idiv	 ecx
  000db	6a 02		 push	 2
  000dd	59		 pop	 ecx
  000de	c1 e1 02	 shl	 ecx, 2
  000e1	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 559  : 		gAlphas[5] = (WORD) ((3 * gAlphas[0] + 4 * gAlphas[1]) / 7);	// Bit code 101

  000e8	6a 02		 push	 2
  000ea	58		 pop	 eax
  000eb	6b c0 00	 imul	 eax, eax, 0
  000ee	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  000f5	6b c0 03	 imul	 eax, eax, 3
  000f8	6a 02		 push	 2
  000fa	59		 pop	 ecx
  000fb	c1 e1 00	 shl	 ecx, 0
  000fe	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  00105	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00108	99		 cdq
  00109	6a 07		 push	 7
  0010b	59		 pop	 ecx
  0010c	f7 f9		 idiv	 ecx
  0010e	6a 02		 push	 2
  00110	59		 pop	 ecx
  00111	6b c9 05	 imul	 ecx, ecx, 5
  00114	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 560  : 		gAlphas[6] = (WORD) ((2 * gAlphas[0] + 5 * gAlphas[1]) / 7);	// Bit code 110    

  0011b	6a 02		 push	 2
  0011d	58		 pop	 eax
  0011e	6b c0 00	 imul	 eax, eax, 0
  00121	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  00128	6a 02		 push	 2
  0012a	59		 pop	 ecx
  0012b	c1 e1 00	 shl	 ecx, 0
  0012e	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  00135	6b c9 05	 imul	 ecx, ecx, 5
  00138	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  0013b	99		 cdq
  0013c	6a 07		 push	 7
  0013e	59		 pop	 ecx
  0013f	f7 f9		 idiv	 ecx
  00141	6a 02		 push	 2
  00143	59		 pop	 ecx
  00144	6b c9 06	 imul	 ecx, ecx, 6
  00147	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 561  : 		gAlphas[7] = (WORD) ((    gAlphas[0] + 6 * gAlphas[1]) / 7);	// Bit code 111

  0014e	6a 02		 push	 2
  00150	58		 pop	 eax
  00151	6b c0 00	 imul	 eax, eax, 0
  00154	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  0015b	6a 02		 push	 2
  0015d	59		 pop	 ecx
  0015e	c1 e1 00	 shl	 ecx, 0
  00161	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  00168	6b c9 06	 imul	 ecx, ecx, 6
  0016b	03 c1		 add	 eax, ecx
  0016d	99		 cdq
  0016e	6a 07		 push	 7
  00170	59		 pop	 ecx
  00171	f7 f9		 idiv	 ecx
  00173	6a 02		 push	 2
  00175	59		 pop	 ecx
  00176	6b c9 07	 imul	 ecx, ecx, 7
  00179	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 562  : 	}    

  00180	e9 f9 00 00 00	 jmp	 $LN15@DecodeAlph
$LN14@DecodeAlph:

; 563  : 	else
; 564  : 	{
; 565  : 		// 6-alpha block:  derive the other alphas.    
; 566  : 		// 000 = alpha_0, 001 = alpha_1, others are interpolated
; 567  : 		gAlphas[2] = (WORD) ((4 * gAlphas[0] +     gAlphas[1]) / 5);	// Bit code 010

  00185	6a 02		 push	 2
  00187	58		 pop	 eax
  00188	6b c0 00	 imul	 eax, eax, 0
  0018b	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  00192	6a 02		 push	 2
  00194	59		 pop	 ecx
  00195	c1 e1 00	 shl	 ecx, 0
  00198	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  0019f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001a2	99		 cdq
  001a3	6a 05		 push	 5
  001a5	59		 pop	 ecx
  001a6	f7 f9		 idiv	 ecx
  001a8	6a 02		 push	 2
  001aa	59		 pop	 ecx
  001ab	d1 e1		 shl	 ecx, 1
  001ad	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 568  : 		gAlphas[3] = (WORD) ((3 * gAlphas[0] + 2 * gAlphas[1]) / 5);	// Bit code 011    

  001b4	6a 02		 push	 2
  001b6	58		 pop	 eax
  001b7	6b c0 00	 imul	 eax, eax, 0
  001ba	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  001c1	6b c0 03	 imul	 eax, eax, 3
  001c4	6a 02		 push	 2
  001c6	59		 pop	 ecx
  001c7	c1 e1 00	 shl	 ecx, 0
  001ca	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  001d1	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  001d4	99		 cdq
  001d5	6a 05		 push	 5
  001d7	59		 pop	 ecx
  001d8	f7 f9		 idiv	 ecx
  001da	6a 02		 push	 2
  001dc	59		 pop	 ecx
  001dd	6b c9 03	 imul	 ecx, ecx, 3
  001e0	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 569  : 		gAlphas[4] = (WORD) ((2 * gAlphas[0] + 3 * gAlphas[1]) / 5);	// Bit code 100    

  001e7	6a 02		 push	 2
  001e9	58		 pop	 eax
  001ea	6b c0 00	 imul	 eax, eax, 0
  001ed	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  001f4	6a 02		 push	 2
  001f6	59		 pop	 ecx
  001f7	c1 e1 00	 shl	 ecx, 0
  001fa	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  00201	6b c9 03	 imul	 ecx, ecx, 3
  00204	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00207	99		 cdq
  00208	6a 05		 push	 5
  0020a	59		 pop	 ecx
  0020b	f7 f9		 idiv	 ecx
  0020d	6a 02		 push	 2
  0020f	59		 pop	 ecx
  00210	c1 e1 02	 shl	 ecx, 2
  00213	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 570  : 		gAlphas[5] = (WORD) ((   gAlphas[0] + 4 * gAlphas[1]) / 5);		// Bit code 101

  0021a	6a 02		 push	 2
  0021c	58		 pop	 eax
  0021d	6b c0 00	 imul	 eax, eax, 0
  00220	0f b7 80 00 00
	00 00		 movzx	 eax, WORD PTR ?gAlphas@@3PAGA[eax]
  00227	6a 02		 push	 2
  00229	59		 pop	 ecx
  0022a	c1 e1 00	 shl	 ecx, 0
  0022d	0f b7 89 00 00
	00 00		 movzx	 ecx, WORD PTR ?gAlphas@@3PAGA[ecx]
  00234	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00237	99		 cdq
  00238	6a 05		 push	 5
  0023a	59		 pop	 ecx
  0023b	f7 f9		 idiv	 ecx
  0023d	6a 02		 push	 2
  0023f	59		 pop	 ecx
  00240	6b c9 05	 imul	 ecx, ecx, 5
  00243	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 571  : 		gAlphas[6] = 0;													// Bit code 110

  0024a	6a 02		 push	 2
  0024c	58		 pop	 eax
  0024d	6b c0 06	 imul	 eax, eax, 6
  00250	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00253	83 7d f0 10	 cmp	 DWORD PTR $T1[ebp], 16	; 00000010H
  00257	73 02		 jae	 SHORT $LN17@DecodeAlph
  00259	eb 05		 jmp	 SHORT $LN18@DecodeAlph
$LN17@DecodeAlph:
  0025b	e8 00 00 00 00	 call	 ___report_rangecheckfailure
$LN18@DecodeAlph:
  00260	33 c0		 xor	 eax, eax
  00262	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00265	66 89 81 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[ecx], ax

; 572  : 		gAlphas[7] = 255;												// Bit code 111

  0026c	6a 02		 push	 2
  0026e	58		 pop	 eax
  0026f	6b c0 07	 imul	 eax, eax, 7
  00272	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00277	66 89 88 00 00
	00 00		 mov	 WORD PTR ?gAlphas@@3PAGA[eax], cx
$LN15@DecodeAlph:

; 573  : 	}
; 574  : 	
; 575  : 	// Decode 3-bit fields into array of 16 BYTES with same value
; 576  : 	
; 577  : 	// first two rows of 4 pixels each:
; 578  : 	// pRows = (Alpha3BitRows*) & (pAlphaBlock->stuff[0]);
; 579  : 	const DWORD mask = 0x00000007;		// bits = 00 00 01 11

  0027e	c7 45 ec 07 00
	00 00		 mov	 DWORD PTR _mask$[ebp], 7

; 580  : 	DWORD bits = *((DWORD*) & (pAlphaBlock->stuff[0]));

  00285	33 c0		 xor	 eax, eax
  00287	40		 inc	 eax
  00288	6b c0 00	 imul	 eax, eax, 0
  0028b	8b 4d 0c	 mov	 ecx, DWORD PTR _pAlphaBlock$[ebp]
  0028e	8b 44 01 02	 mov	 eax, DWORD PTR [ecx+eax+2]
  00292	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 581  : 	
; 582  : 	gBits[0][0] = (BYTE) (bits & mask);

  00295	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00298	83 e0 07	 and	 eax, 7
  0029b	6a 04		 push	 4
  0029d	59		 pop	 ecx
  0029e	6b c9 00	 imul	 ecx, ecx, 0
  002a1	33 d2		 xor	 edx, edx
  002a3	42		 inc	 edx
  002a4	6b d2 00	 imul	 edx, edx, 0
  002a7	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 583  : 	bits >>= 3;

  002ae	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  002b1	c1 e8 03	 shr	 eax, 3
  002b4	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 584  : 	gBits[0][1] = (BYTE) (bits & mask);

  002b7	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  002ba	83 e0 07	 and	 eax, 7
  002bd	6a 04		 push	 4
  002bf	59		 pop	 ecx
  002c0	6b c9 00	 imul	 ecx, ecx, 0
  002c3	33 d2		 xor	 edx, edx
  002c5	42		 inc	 edx
  002c6	c1 e2 00	 shl	 edx, 0
  002c9	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 585  : 	bits >>= 3;

  002d0	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  002d3	c1 e8 03	 shr	 eax, 3
  002d6	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 586  : 	gBits[0][2] = (BYTE) (bits & mask);

  002d9	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  002dc	83 e0 07	 and	 eax, 7
  002df	6a 04		 push	 4
  002e1	59		 pop	 ecx
  002e2	6b c9 00	 imul	 ecx, ecx, 0
  002e5	33 d2		 xor	 edx, edx
  002e7	42		 inc	 edx
  002e8	d1 e2		 shl	 edx, 1
  002ea	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 587  : 	bits >>= 3;

  002f1	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  002f4	c1 e8 03	 shr	 eax, 3
  002f7	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 588  : 	gBits[0][3] = (BYTE) (bits & mask);

  002fa	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  002fd	83 e0 07	 and	 eax, 7
  00300	6a 04		 push	 4
  00302	59		 pop	 ecx
  00303	6b c9 00	 imul	 ecx, ecx, 0
  00306	33 d2		 xor	 edx, edx
  00308	42		 inc	 edx
  00309	6b d2 03	 imul	 edx, edx, 3
  0030c	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 589  : 	bits >>= 3;

  00313	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00316	c1 e8 03	 shr	 eax, 3
  00319	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 590  : 	gBits[1][0] = (BYTE) (bits & mask);

  0031c	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  0031f	83 e0 07	 and	 eax, 7
  00322	6a 04		 push	 4
  00324	59		 pop	 ecx
  00325	c1 e1 00	 shl	 ecx, 0
  00328	33 d2		 xor	 edx, edx
  0032a	42		 inc	 edx
  0032b	6b d2 00	 imul	 edx, edx, 0
  0032e	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 591  : 	bits >>= 3;

  00335	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00338	c1 e8 03	 shr	 eax, 3
  0033b	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 592  : 	gBits[1][1] = (BYTE) (bits & mask);

  0033e	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00341	83 e0 07	 and	 eax, 7
  00344	6a 04		 push	 4
  00346	59		 pop	 ecx
  00347	c1 e1 00	 shl	 ecx, 0
  0034a	33 d2		 xor	 edx, edx
  0034c	42		 inc	 edx
  0034d	c1 e2 00	 shl	 edx, 0
  00350	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 593  : 	bits >>= 3;

  00357	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  0035a	c1 e8 03	 shr	 eax, 3
  0035d	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 594  : 	gBits[1][2] = (BYTE) (bits & mask);

  00360	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00363	83 e0 07	 and	 eax, 7
  00366	6a 04		 push	 4
  00368	59		 pop	 ecx
  00369	c1 e1 00	 shl	 ecx, 0
  0036c	33 d2		 xor	 edx, edx
  0036e	42		 inc	 edx
  0036f	d1 e2		 shl	 edx, 1
  00371	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 595  : 	bits >>= 3;

  00378	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  0037b	c1 e8 03	 shr	 eax, 3
  0037e	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 596  : 	gBits[1][3] = (BYTE) (bits & mask);

  00381	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00384	83 e0 07	 and	 eax, 7
  00387	6a 04		 push	 4
  00389	59		 pop	 ecx
  0038a	c1 e1 00	 shl	 ecx, 0
  0038d	33 d2		 xor	 edx, edx
  0038f	42		 inc	 edx
  00390	6b d2 03	 imul	 edx, edx, 3
  00393	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 597  : 	
; 598  : 	// now for last two rows:
; 599  : 	bits = *((DWORD*) & (pAlphaBlock->stuff[3]));		// last 3 bytes

  0039a	33 c0		 xor	 eax, eax
  0039c	40		 inc	 eax
  0039d	6b c0 03	 imul	 eax, eax, 3
  003a0	8b 4d 0c	 mov	 ecx, DWORD PTR _pAlphaBlock$[ebp]
  003a3	8b 44 01 02	 mov	 eax, DWORD PTR [ecx+eax+2]
  003a7	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 600  : 	
; 601  : 	gBits[2][0] = (BYTE) (bits & mask);

  003aa	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  003ad	83 e0 07	 and	 eax, 7
  003b0	6a 04		 push	 4
  003b2	59		 pop	 ecx
  003b3	d1 e1		 shl	 ecx, 1
  003b5	33 d2		 xor	 edx, edx
  003b7	42		 inc	 edx
  003b8	6b d2 00	 imul	 edx, edx, 0
  003bb	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 602  : 	bits >>= 3;

  003c2	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  003c5	c1 e8 03	 shr	 eax, 3
  003c8	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 603  : 	gBits[2][1] = (BYTE) (bits & mask);

  003cb	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  003ce	83 e0 07	 and	 eax, 7
  003d1	6a 04		 push	 4
  003d3	59		 pop	 ecx
  003d4	d1 e1		 shl	 ecx, 1
  003d6	33 d2		 xor	 edx, edx
  003d8	42		 inc	 edx
  003d9	c1 e2 00	 shl	 edx, 0
  003dc	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 604  : 	bits >>= 3;

  003e3	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  003e6	c1 e8 03	 shr	 eax, 3
  003e9	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 605  : 	gBits[2][2] = (BYTE) (bits & mask);

  003ec	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  003ef	83 e0 07	 and	 eax, 7
  003f2	6a 04		 push	 4
  003f4	59		 pop	 ecx
  003f5	d1 e1		 shl	 ecx, 1
  003f7	33 d2		 xor	 edx, edx
  003f9	42		 inc	 edx
  003fa	d1 e2		 shl	 edx, 1
  003fc	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 606  : 	bits >>= 3;

  00403	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00406	c1 e8 03	 shr	 eax, 3
  00409	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 607  : 	gBits[2][3] = (BYTE) (bits & mask);

  0040c	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  0040f	83 e0 07	 and	 eax, 7
  00412	6a 04		 push	 4
  00414	59		 pop	 ecx
  00415	d1 e1		 shl	 ecx, 1
  00417	33 d2		 xor	 edx, edx
  00419	42		 inc	 edx
  0041a	6b d2 03	 imul	 edx, edx, 3
  0041d	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 608  : 	bits >>= 3;

  00424	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00427	c1 e8 03	 shr	 eax, 3
  0042a	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 609  : 	gBits[3][0] = (BYTE) (bits & mask);

  0042d	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00430	83 e0 07	 and	 eax, 7
  00433	6a 04		 push	 4
  00435	59		 pop	 ecx
  00436	6b c9 03	 imul	 ecx, ecx, 3
  00439	33 d2		 xor	 edx, edx
  0043b	42		 inc	 edx
  0043c	6b d2 00	 imul	 edx, edx, 0
  0043f	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 610  : 	bits >>= 3;

  00446	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00449	c1 e8 03	 shr	 eax, 3
  0044c	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 611  : 	gBits[3][1] = (BYTE) (bits & mask);

  0044f	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00452	83 e0 07	 and	 eax, 7
  00455	6a 04		 push	 4
  00457	59		 pop	 ecx
  00458	6b c9 03	 imul	 ecx, ecx, 3
  0045b	33 d2		 xor	 edx, edx
  0045d	42		 inc	 edx
  0045e	c1 e2 00	 shl	 edx, 0
  00461	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 612  : 	bits >>= 3;

  00468	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  0046b	c1 e8 03	 shr	 eax, 3
  0046e	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 613  : 	gBits[3][2] = (BYTE) (bits & mask);

  00471	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00474	83 e0 07	 and	 eax, 7
  00477	6a 04		 push	 4
  00479	59		 pop	 ecx
  0047a	6b c9 03	 imul	 ecx, ecx, 3
  0047d	33 d2		 xor	 edx, edx
  0047f	42		 inc	 edx
  00480	d1 e2		 shl	 edx, 1
  00482	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 614  : 	bits >>= 3;

  00489	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  0048c	c1 e8 03	 shr	 eax, 3
  0048f	89 45 fc	 mov	 DWORD PTR _bits$[ebp], eax

; 615  : 	gBits[3][3] = (BYTE) (bits & mask);

  00492	8b 45 fc	 mov	 eax, DWORD PTR _bits$[ebp]
  00495	83 e0 07	 and	 eax, 7
  00498	6a 04		 push	 4
  0049a	59		 pop	 ecx
  0049b	6b c9 03	 imul	 ecx, ecx, 3
  0049e	33 d2		 xor	 edx, edx
  004a0	42		 inc	 edx
  004a1	6b d2 03	 imul	 edx, edx, 3
  004a4	88 84 11 00 00
	00 00		 mov	 BYTE PTR ?gBits@@3PAY03EA[ecx+edx], al

; 616  : 	
; 617  : 	// decode the codes into alpha values
; 618  : 	int row, pix;
; 619  : 	
; 620  : 	for (row = 0; row < 4; ++row)

  004ab	83 65 f8 00	 and	 DWORD PTR _row$[ebp], 0
  004af	eb 07		 jmp	 SHORT $LN4@DecodeAlph
$LN2@DecodeAlph:
  004b1	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  004b4	40		 inc	 eax
  004b5	89 45 f8	 mov	 DWORD PTR _row$[ebp], eax
$LN4@DecodeAlph:
  004b8	83 7d f8 04	 cmp	 DWORD PTR _row$[ebp], 4
  004bc	7d 3c		 jge	 SHORT $LN3@DecodeAlph

; 621  : 	{
; 622  : 		for (pix = 0; pix < 4; ++pix)

  004be	83 65 f4 00	 and	 DWORD PTR _pix$[ebp], 0
  004c2	eb 07		 jmp	 SHORT $LN7@DecodeAlph
$LN5@DecodeAlph:
  004c4	8b 45 f4	 mov	 eax, DWORD PTR _pix$[ebp]
  004c7	40		 inc	 eax
  004c8	89 45 f4	 mov	 DWORD PTR _pix$[ebp], eax
$LN7@DecodeAlph:
  004cb	83 7d f4 04	 cmp	 DWORD PTR _pix$[ebp], 4
  004cf	7d 27		 jge	 SHORT $LN6@DecodeAlph

; 623  : 		{
; 624  : 			gACol[row][pix].a = (BYTE) gAlphas[gBits[row][pix]];

  004d1	8b 45 f4	 mov	 eax, DWORD PTR _pix$[ebp]
  004d4	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  004d7	0f b6 84 88 00
	00 00 00	 movzx	 eax, BYTE PTR ?gBits@@3PAY03EA[eax+ecx*4]
  004df	8b 4d f8	 mov	 ecx, DWORD PTR _row$[ebp]
  004e2	c1 e1 04	 shl	 ecx, 4
  004e5	8b 55 f4	 mov	 edx, DWORD PTR _pix$[ebp]
  004e8	8a 04 45 00 00
	00 00		 mov	 al, BYTE PTR ?gAlphas@@3PAGA[eax*2]
  004ef	88 84 91 03 00
	00 00		 mov	 BYTE PTR ?gACol@@3PAY03UColor8888@@A[ecx+edx*4+3], al

; 625  : 			
; 626  : 			assert(gACol[row][pix].r == 0);
; 627  : 			assert(gACol[row][pix].g == 0);
; 628  : 			assert(gACol[row][pix].b == 0);
; 629  : 		}

  004f6	eb cc		 jmp	 SHORT $LN5@DecodeAlph
$LN6@DecodeAlph:

; 630  : 	}

  004f8	eb b7		 jmp	 SHORT $LN2@DecodeAlph
$LN3@DecodeAlph:

; 631  : 	
; 632  : 	// Write out alpha values to the image bits	
; 633  : 	for (row = 0; row < 4; ++row, pImPos += width - 4)

  004fa	83 65 f8 00	 and	 DWORD PTR _row$[ebp], 0
  004fe	eb 14		 jmp	 SHORT $LN10@DecodeAlph
$LN8@DecodeAlph:
  00500	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  00503	40		 inc	 eax
  00504	89 45 f8	 mov	 DWORD PTR _row$[ebp], eax
  00507	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  0050a	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$[ebp]
  0050d	8d 44 81 f0	 lea	 eax, DWORD PTR [ecx+eax*4-16]
  00511	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax
$LN10@DecodeAlph:
  00514	83 7d f8 04	 cmp	 DWORD PTR _row$[ebp], 4
  00518	7d 47		 jge	 SHORT $LN16@DecodeAlph

; 634  : 	{
; 635  : 		// pImPow += pImPos += width - 4 moves to next row down
; 636  : 		for (pix = 0; pix < 4; ++pix)

  0051a	83 65 f4 00	 and	 DWORD PTR _pix$[ebp], 0
  0051e	eb 07		 jmp	 SHORT $LN13@DecodeAlph
$LN11@DecodeAlph:
  00520	8b 45 f4	 mov	 eax, DWORD PTR _pix$[ebp]
  00523	40		 inc	 eax
  00524	89 45 f4	 mov	 DWORD PTR _pix$[ebp], eax
$LN13@DecodeAlph:
  00527	83 7d f4 04	 cmp	 DWORD PTR _pix$[ebp], 4
  0052b	7d 32		 jge	 SHORT $LN12@DecodeAlph

; 637  : 		{
; 638  : 			// zero the alpha bits of image pixel
; 639  : 			*pImPos &= alphazero;

  0052d	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  00530	8b 00		 mov	 eax, DWORD PTR [eax]
  00532	23 45 14	 and	 eax, DWORD PTR _alphazero$[ebp]
  00535	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$[ebp]
  00538	89 01		 mov	 DWORD PTR [ecx], eax

; 640  : 			*pImPos |= *((DWORD*) &(gACol[row][pix]));	// or the bits into the prev. nulled alpha

  0053a	8b 45 f8	 mov	 eax, DWORD PTR _row$[ebp]
  0053d	c1 e0 04	 shl	 eax, 4
  00540	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$[ebp]
  00543	8b 55 f4	 mov	 edx, DWORD PTR _pix$[ebp]
  00546	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00548	0b 8c 90 00 00
	00 00		 or	 ecx, DWORD PTR ?gACol@@3PAY03UColor8888@@A[eax+edx*4]
  0054f	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  00552	89 08		 mov	 DWORD PTR [eax], ecx

; 641  : 			pImPos++;

  00554	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  00557	83 c0 04	 add	 eax, 4
  0055a	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax

; 642  : 		}

  0055d	eb c1		 jmp	 SHORT $LN11@DecodeAlph
$LN12@DecodeAlph:

; 643  : 	}

  0055f	eb 9f		 jmp	 SHORT $LN8@DecodeAlph
$LN16@DecodeAlph:

; 644  : }

  00561	c9		 leave
  00562	c3		 ret	 0
?DecodeAlpha3BitLinear@@YAXPAKPAUDXTAlphaBlock3BitLinear@@HK@Z ENDP ; DecodeAlpha3BitLinear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecodeAlphaExplicit@@YAXPAKPAUDXTAlphaBlockExplicit@@HK@Z
_TEXT	SEGMENT
_pix$ = -16						; size = 4
_row$ = -12						; size = 4
_col$ = -8						; size = 4
_wrd$ = -4						; size = 2
_pImPos$ = 8						; size = 4
_pAlphaBlock$ = 12					; size = 4
_width$ = 16						; size = 4
_alphazero$ = 20					; size = 4
?DecodeAlphaExplicit@@YAXPAKPAUDXTAlphaBlockExplicit@@HK@Z PROC ; DecodeAlphaExplicit, COMDAT

; 493  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 494  : 	// alphazero is a bit mask that when & with the image color
; 495  : 	//  will zero the alpha bits, so if the image DWORDs  are
; 496  : 	//  ARGB then alphazero will be 0x00ffffff or if
; 497  : 	//  RGBA then alphazero will be 0xffffff00
; 498  : 	//  alphazero constructed automaticaly from field order of Color8888 structure
; 499  : 
; 500  : 	// decodes to 32 bit format only
; 501  : 	int row, pix;
; 502  : 
; 503  : 	WORD wrd;
; 504  : 
; 505  : 	Color8888 col;
; 506  : 	col.r = col.g = col.b = 0;

  00006	c6 45 f8 00	 mov	 BYTE PTR _col$[ebp], 0
  0000a	8a 45 f8	 mov	 al, BYTE PTR _col$[ebp]
  0000d	88 45 f9	 mov	 BYTE PTR _col$[ebp+1], al
  00010	8a 45 f9	 mov	 al, BYTE PTR _col$[ebp+1]
  00013	88 45 fa	 mov	 BYTE PTR _col$[ebp+2], al

; 507  : 
; 508  : 	//Tracef("\n");	
; 509  : 	for (row = 0; row < 4; row++, pImPos += width - 4)

  00016	83 65 f4 00	 and	 DWORD PTR _row$[ebp], 0
  0001a	eb 14		 jmp	 SHORT $LN4@DecodeAlph
$LN2@DecodeAlph:
  0001c	8b 45 f4	 mov	 eax, DWORD PTR _row$[ebp]
  0001f	40		 inc	 eax
  00020	89 45 f4	 mov	 DWORD PTR _row$[ebp], eax
  00023	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$[ebp]
  00029	8d 44 81 f0	 lea	 eax, DWORD PTR [ecx+eax*4-16]
  0002d	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax
$LN4@DecodeAlph:
  00030	83 7d f4 04	 cmp	 DWORD PTR _row$[ebp], 4
  00034	7d 71		 jge	 SHORT $LN1@DecodeAlph

; 510  : 	{
; 511  : 		// pImPow += pImPos += width-4 moves to next row down
; 512  : 		wrd = pAlphaBlock->row[row];

  00036	8b 45 f4	 mov	 eax, DWORD PTR _row$[ebp]
  00039	8b 4d 0c	 mov	 ecx, DWORD PTR _pAlphaBlock$[ebp]
  0003c	66 8b 04 41	 mov	 ax, WORD PTR [ecx+eax*2]
  00040	66 89 45 fc	 mov	 WORD PTR _wrd$[ebp], ax

; 513  : 
; 514  : 		// Tracef("0x%.8x\t\t", wrd);
; 515  : 		for (pix = 0; pix < 4; ++pix)

  00044	83 65 f0 00	 and	 DWORD PTR _pix$[ebp], 0
  00048	eb 07		 jmp	 SHORT $LN7@DecodeAlph
$LN5@DecodeAlph:
  0004a	8b 45 f0	 mov	 eax, DWORD PTR _pix$[ebp]
  0004d	40		 inc	 eax
  0004e	89 45 f0	 mov	 DWORD PTR _pix$[ebp], eax
$LN7@DecodeAlph:
  00051	83 7d f0 04	 cmp	 DWORD PTR _pix$[ebp], 4
  00055	7d 4b		 jge	 SHORT $LN6@DecodeAlph

; 516  : 		{
; 517  : 			// zero the alpha bits of image pixel
; 518  : 			*pImPos &= alphazero;

  00057	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	23 45 14	 and	 eax, DWORD PTR _alphazero$[ebp]
  0005f	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$[ebp]
  00062	89 01		 mov	 DWORD PTR [ecx], eax

; 519  : 
; 520  : 			col.a = (BYTE) (wrd & 0x000f);		// get only low 4 bits

  00064	0f b7 45 fc	 movzx	 eax, WORD PTR _wrd$[ebp]
  00068	83 e0 0f	 and	 eax, 15			; 0000000fH
  0006b	88 45 fb	 mov	 BYTE PTR _col$[ebp+3], al

; 521  : 			//			col.a <<= 4;				// shift to full byte precision
; 522  : 			// NOTE:  with just a << 4 you'll never have alpha
; 523  : 			// of 0xff,  0xf0 is max so pure shift doesn't quite
; 524  : 			// cover full alpha range.
; 525  : 			// It's much cheaper than divide & scale though.
; 526  : 			// To correct for this, and get 0xff for max alpha,
; 527  : 			//  or the low bits back in after left shifting
; 528  : 			col.a = (BYTE) (col.a | (col.a << 4));	// This allows max 4 bit alpha to be 0xff alpha

  0006e	0f b6 45 fb	 movzx	 eax, BYTE PTR _col$[ebp+3]
  00072	0f b6 4d fb	 movzx	 ecx, BYTE PTR _col$[ebp+3]
  00076	c1 e1 04	 shl	 ecx, 4
  00079	0b c1		 or	 eax, ecx
  0007b	88 45 fb	 mov	 BYTE PTR _col$[ebp+3], al

; 529  : 			//  in final image, and is crude approach to full 
; 530  : 			//  range scale
; 531  : 
; 532  : 			*pImPos |= *((DWORD*)&col);	// or the bits into the prev. nulled alpha

  0007e	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  00081	8b 00		 mov	 eax, DWORD PTR [eax]
  00083	0b 45 f8	 or	 eax, DWORD PTR _col$[ebp]
  00086	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$[ebp]
  00089	89 01		 mov	 DWORD PTR [ecx], eax

; 533  : 
; 534  : 			wrd >>= 4; // move next bits to lowest 4

  0008b	66 8b 45 fc	 mov	 ax, WORD PTR _wrd$[ebp]
  0008f	66 c1 e8 04	 shr	 ax, 4
  00093	66 89 45 fc	 mov	 WORD PTR _wrd$[ebp], ax

; 535  : 
; 536  : 			pImPos++; // move to next pixel in the row

  00097	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  0009a	83 c0 04	 add	 eax, 4
  0009d	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax

; 537  : 		}

  000a0	eb a8		 jmp	 SHORT $LN5@DecodeAlph
$LN6@DecodeAlph:

; 538  : 	}

  000a2	e9 75 ff ff ff	 jmp	 $LN2@DecodeAlph
$LN1@DecodeAlph:

; 539  : }

  000a7	c9		 leave
  000a8	c3		 ret	 0
?DecodeAlphaExplicit@@YAXPAKPAUDXTAlphaBlockExplicit@@HK@Z ENDP ; DecodeAlphaExplicit
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecodeColorBlock@@YAXPAKPAUDXTColBlock@@H0000@Z
_TEXT	SEGMENT
_bits$ = -52						; size = 4
tv81 = -48						; size = 4
_y$ = -44						; size = 4
_n$ = -40						; size = 4
_shift$ = -36						; size = 16
_masks$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_pImPos$ = 8						; size = 4
_pColorBlock$ = 12					; size = 4
_width$ = 16						; size = 4
_col_0$ = 20						; size = 4
_col_1$ = 24						; size = 4
_col_2$ = 28						; size = 4
_col_3$ = 32						; size = 4
?DecodeColorBlock@@YAXPAKPAUDXTColBlock@@H0000@Z PROC	; DecodeColorBlock, COMDAT

; 437  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 438  : 	// width is width of image in pixels
; 439  : 	DWORD bits;
; 440  : 	int y, n;
; 441  : 	
; 442  : 	// bit masks = 00000011, 00001100, 00110000, 11000000
; 443  : 	const DWORD masks[] = { 3, 12, 3 << 4, 3 << 6 };

  00010	c7 45 ec 03 00
	00 00		 mov	 DWORD PTR _masks$[ebp], 3
  00017	c7 45 f0 0c 00
	00 00		 mov	 DWORD PTR _masks$[ebp+4], 12 ; 0000000cH
  0001e	c7 45 f4 30 00
	00 00		 mov	 DWORD PTR _masks$[ebp+8], 48 ; 00000030H
  00025	c7 45 f8 c0 00
	00 00		 mov	 DWORD PTR _masks$[ebp+12], 192 ; 000000c0H

; 444  : 	const int   shift[] = { 0, 2, 4, 6 };

  0002c	83 65 dc 00	 and	 DWORD PTR _shift$[ebp], 0
  00030	c7 45 e0 02 00
	00 00		 mov	 DWORD PTR _shift$[ebp+4], 2
  00037	c7 45 e4 04 00
	00 00		 mov	 DWORD PTR _shift$[ebp+8], 4
  0003e	c7 45 e8 06 00
	00 00		 mov	 DWORD PTR _shift$[ebp+12], 6

; 445  : 	
; 446  : 	// r steps through lines in y
; 447  : 	for (y = 0; y < 4; ++y, pImPos += width - 4) // no width * 4 as DWORD ptr inc will * 4

  00045	83 65 d4 00	 and	 DWORD PTR _y$[ebp], 0
  00049	eb 14		 jmp	 SHORT $LN4@DecodeColo
$LN2@DecodeColo:
  0004b	8b 45 d4	 mov	 eax, DWORD PTR _y$[ebp]
  0004e	40		 inc	 eax
  0004f	89 45 d4	 mov	 DWORD PTR _y$[ebp], eax
  00052	8b 45 10	 mov	 eax, DWORD PTR _width$[ebp]
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pImPos$[ebp]
  00058	8d 44 81 f0	 lea	 eax, DWORD PTR [ecx+eax*4-16]
  0005c	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax
$LN4@DecodeColo:
  0005f	83 7d d4 04	 cmp	 DWORD PTR _y$[ebp], 4
  00063	0f 8d d0 00 00
	00		 jge	 $LN1@DecodeColo

; 448  : 	{
; 449  : 		// width * 4 bytes per pixel per line
; 450  : 		// each j dxtc row is 4 lines of pixels
; 451  : 		
; 452  : 		// pImPos = (DWORD*) ((DWORD) pBase + i * 16 + (y + j * 4) * m_nWidth * 4);
; 453  : 
; 454  : 		// n steps through pixels
; 455  : 		for (n = 0; n < 4; ++n)

  00069	83 65 d8 00	 and	 DWORD PTR _n$[ebp], 0
  0006d	eb 07		 jmp	 SHORT $LN7@DecodeColo
$LN5@DecodeColo:
  0006f	8b 45 d8	 mov	 eax, DWORD PTR _n$[ebp]
  00072	40		 inc	 eax
  00073	89 45 d8	 mov	 DWORD PTR _n$[ebp], eax
$LN7@DecodeColo:
  00076	83 7d d8 04	 cmp	 DWORD PTR _n$[ebp], 4
  0007a	0f 8d b4 00 00
	00		 jge	 $LN6@DecodeColo

; 456  : 		{
; 457  : 			bits = pColorBlock->row[y] & masks[n];

  00080	8b 45 0c	 mov	 eax, DWORD PTR _pColorBlock$[ebp]
  00083	03 45 d4	 add	 eax, DWORD PTR _y$[ebp]
  00086	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]
  0008a	8b 4d d8	 mov	 ecx, DWORD PTR _n$[ebp]
  0008d	23 44 8d ec	 and	 eax, DWORD PTR _masks$[ebp+ecx*4]
  00091	89 45 cc	 mov	 DWORD PTR _bits$[ebp], eax

; 458  : 			bits >>= shift[n];

  00094	8b 45 d8	 mov	 eax, DWORD PTR _n$[ebp]
  00097	8b 55 cc	 mov	 edx, DWORD PTR _bits$[ebp]
  0009a	8b 4c 85 dc	 mov	 ecx, DWORD PTR _shift$[ebp+eax*4]
  0009e	d3 ea		 shr	 edx, cl
  000a0	89 55 cc	 mov	 DWORD PTR _bits$[ebp], edx

; 459  : 
; 460  : 			switch (bits)

  000a3	8b 45 cc	 mov	 eax, DWORD PTR _bits$[ebp]
  000a6	89 45 d0	 mov	 DWORD PTR tv81[ebp], eax
  000a9	83 7d d0 00	 cmp	 DWORD PTR tv81[ebp], 0
  000ad	74 14		 je	 SHORT $LN10@DecodeColo
  000af	83 7d d0 01	 cmp	 DWORD PTR tv81[ebp], 1
  000b3	74 23		 je	 SHORT $LN11@DecodeColo
  000b5	83 7d d0 02	 cmp	 DWORD PTR tv81[ebp], 2
  000b9	74 32		 je	 SHORT $LN12@DecodeColo
  000bb	83 7d d0 03	 cmp	 DWORD PTR tv81[ebp], 3
  000bf	74 41		 je	 SHORT $LN13@DecodeColo
  000c1	eb 54		 jmp	 SHORT $LN14@DecodeColo
$LN10@DecodeColo:

; 461  : 			{
; 462  : 				case 0:
; 463  : 					*pImPos = *col_0;

  000c3	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  000c6	8b 4d 14	 mov	 ecx, DWORD PTR _col_0$[ebp]
  000c9	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000cb	89 08		 mov	 DWORD PTR [eax], ecx

; 464  : 					pImPos++; // increment to next DWORD

  000cd	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  000d0	83 c0 04	 add	 eax, 4
  000d3	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax

; 465  : 					break;

  000d6	eb 57		 jmp	 SHORT $LN8@DecodeColo
$LN11@DecodeColo:

; 466  : 
; 467  : 				case 1:
; 468  : 					*pImPos = *col_1;

  000d8	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  000db	8b 4d 18	 mov	 ecx, DWORD PTR _col_1$[ebp]
  000de	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e0	89 08		 mov	 DWORD PTR [eax], ecx

; 469  : 					pImPos++;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  000e5	83 c0 04	 add	 eax, 4
  000e8	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax

; 470  : 					break;

  000eb	eb 42		 jmp	 SHORT $LN8@DecodeColo
$LN12@DecodeColo:

; 471  : 
; 472  : 				case 2:
; 473  : 					*pImPos = *col_2;

  000ed	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  000f0	8b 4d 1c	 mov	 ecx, DWORD PTR _col_2$[ebp]
  000f3	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000f5	89 08		 mov	 DWORD PTR [eax], ecx

; 474  : 					pImPos++;

  000f7	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  000fa	83 c0 04	 add	 eax, 4
  000fd	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax

; 475  : 					break;

  00100	eb 2d		 jmp	 SHORT $LN8@DecodeColo
$LN13@DecodeColo:

; 476  : 
; 477  : 				case 3:
; 478  : 					*pImPos = *col_3;

  00102	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  00105	8b 4d 20	 mov	 ecx, DWORD PTR _col_3$[ebp]
  00108	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0010a	89 08		 mov	 DWORD PTR [eax], ecx

; 479  : 					pImPos++;

  0010c	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  0010f	83 c0 04	 add	 eax, 4
  00112	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax

; 480  : 					break;

  00115	eb 18		 jmp	 SHORT $LN8@DecodeColo
$LN14@DecodeColo:

; 481  : 
; 482  : 				default:
; 483  : 					Tracef("Your logic is jacked! bits == 0x%x\n", bits);

  00117	ff 75 cc	 push	 DWORD PTR _bits$[ebp]
  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EEHKBLDL@Your?5logic?5is?5jacked?$CB?5bits?5?$DN?$DN?50@
  0011f	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00124	59		 pop	 ecx
  00125	59		 pop	 ecx

; 484  : 					pImPos++;

  00126	8b 45 08	 mov	 eax, DWORD PTR _pImPos$[ebp]
  00129	83 c0 04	 add	 eax, 4
  0012c	89 45 08	 mov	 DWORD PTR _pImPos$[ebp], eax
$LN8@DecodeColo:

; 485  : 					break;
; 486  : 			}
; 487  : 		}

  0012f	e9 3b ff ff ff	 jmp	 $LN5@DecodeColo
$LN6@DecodeColo:

; 488  : 	}

  00134	e9 12 ff ff ff	 jmp	 $LN2@DecodeColo
$LN1@DecodeColo:

; 489  : }

  00139	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013c	33 cd		 xor	 ecx, ebp
  0013e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00143	c9		 leave
  00144	c3		 ret	 0
?DecodeColorBlock@@YAXPAKPAUDXTColBlock@@H0000@Z ENDP	; DecodeColorBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?GetColorBlockColors@@YAXPAUDXTColBlock@@PAUColor8888@@111AAG@Z
_TEXT	SEGMENT
_pCol$ = -4						; size = 4
_pBlock$ = 8						; size = 4
_col_0$ = 12						; size = 4
_col_1$ = 16						; size = 4
_col_2$ = 20						; size = 4
_col_3$ = 24						; size = 4
_wrd$ = 28						; size = 4
?GetColorBlockColors@@YAXPAUDXTColBlock@@PAUColor8888@@111AAG@Z PROC ; GetColorBlockColors, COMDAT

; 342  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 343  : 	// There are 4 methods to use - see the Time_ functions.
; 344  : 	// 1st = shift = does normal approach per byte for color comps
; 345  : 	// 2nd = use freak variable bit field color565 for component extraction
; 346  : 	// 3rd = use super-freak DWORD adds BEFORE shifting the color components
; 347  : 	//  This lets you do only 1 add per color instead of 3 BYTE adds and
; 348  : 	//  might be faster
; 349  : 	// Call RunTimingSession() to run each of them & output result to txt file
; 350  : 	
; 351  : 	// freak variable bit structure method
; 352  : 	// normal math
; 353  : 	// This method is fastest
; 354  : 	Color565 * pCol;
; 355  : 	
; 356  : 	pCol = (Color565*) & (pBlock->col0);

  00004	8b 45 08	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _pCol$[ebp], eax

; 357  : 	
; 358  : 	col_0->a = 0xff;

  0000a	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  0000d	c6 40 03 ff	 mov	 BYTE PTR [eax+3], 255	; 000000ffH

; 359  : 	col_0->r = pCol->nRed;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _pCol$[ebp]
  00014	8b 00		 mov	 eax, DWORD PTR [eax]
  00016	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00019	83 e0 1f	 and	 eax, 31			; 0000001fH
  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _col_0$[ebp]
  0001f	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 360  : 	col_0->r <<= 3;				// shift to full precision

  00022	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  00025	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  00028	c0 e0 03	 shl	 al, 3
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR _col_0$[ebp]
  0002e	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 361  : 	col_0->g = pCol->nGreen;

  00031	8b 45 fc	 mov	 eax, DWORD PTR _pCol$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	c1 e8 05	 shr	 eax, 5
  00039	83 e0 3f	 and	 eax, 63			; 0000003fH
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _col_0$[ebp]
  0003f	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 362  : 	col_0->g <<= 2;

  00042	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  00045	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  00048	c0 e0 02	 shl	 al, 2
  0004b	8b 4d 0c	 mov	 ecx, DWORD PTR _col_0$[ebp]
  0004e	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 363  : 	col_0->b = pCol->nBlue;

  00051	8b 45 fc	 mov	 eax, DWORD PTR _pCol$[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]
  00056	83 e0 1f	 and	 eax, 31			; 0000001fH
  00059	8b 4d 0c	 mov	 ecx, DWORD PTR _col_0$[ebp]
  0005c	88 01		 mov	 BYTE PTR [ecx], al

; 364  : 	col_0->b <<= 3;

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  00061	8a 00		 mov	 al, BYTE PTR [eax]
  00063	c0 e0 03	 shl	 al, 3
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR _col_0$[ebp]
  00069	88 01		 mov	 BYTE PTR [ecx], al

; 365  : 	
; 366  : 	pCol = (Color565*) & (pBlock->col1);

  0006b	8b 45 08	 mov	 eax, DWORD PTR _pBlock$[ebp]
  0006e	40		 inc	 eax
  0006f	40		 inc	 eax
  00070	89 45 fc	 mov	 DWORD PTR _pCol$[ebp], eax

; 367  : 	col_1->a = 0xff;

  00073	8b 45 10	 mov	 eax, DWORD PTR _col_1$[ebp]
  00076	c6 40 03 ff	 mov	 BYTE PTR [eax+3], 255	; 000000ffH

; 368  : 	col_1->r = pCol->nRed;

  0007a	8b 45 fc	 mov	 eax, DWORD PTR _pCol$[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	c1 e8 0b	 shr	 eax, 11			; 0000000bH
  00082	83 e0 1f	 and	 eax, 31			; 0000001fH
  00085	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  00088	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 369  : 	col_1->r <<= 3;				// shift to full precision

  0008b	8b 45 10	 mov	 eax, DWORD PTR _col_1$[ebp]
  0008e	8a 40 02	 mov	 al, BYTE PTR [eax+2]
  00091	c0 e0 03	 shl	 al, 3
  00094	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  00097	88 41 02	 mov	 BYTE PTR [ecx+2], al

; 370  : 	col_1->g = pCol->nGreen;

  0009a	8b 45 fc	 mov	 eax, DWORD PTR _pCol$[ebp]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	c1 e8 05	 shr	 eax, 5
  000a2	83 e0 3f	 and	 eax, 63			; 0000003fH
  000a5	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  000a8	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 371  : 	col_1->g <<= 2;

  000ab	8b 45 10	 mov	 eax, DWORD PTR _col_1$[ebp]
  000ae	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  000b1	c0 e0 02	 shl	 al, 2
  000b4	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  000b7	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 372  : 	col_1->b = pCol->nBlue;

  000ba	8b 45 fc	 mov	 eax, DWORD PTR _pCol$[ebp]
  000bd	8b 00		 mov	 eax, DWORD PTR [eax]
  000bf	83 e0 1f	 and	 eax, 31			; 0000001fH
  000c2	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  000c5	88 01		 mov	 BYTE PTR [ecx], al

; 373  : 	col_1->b <<= 3;

  000c7	8b 45 10	 mov	 eax, DWORD PTR _col_1$[ebp]
  000ca	8a 00		 mov	 al, BYTE PTR [eax]
  000cc	c0 e0 03	 shl	 al, 3
  000cf	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  000d2	88 01		 mov	 BYTE PTR [ecx], al

; 374  : 	
; 375  : 	if (pBlock->col0 > pBlock->col1)

  000d4	8b 45 08	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000d7	0f b7 00	 movzx	 eax, WORD PTR [eax]
  000da	8b 4d 08	 mov	 ecx, DWORD PTR _pBlock$[ebp]
  000dd	0f b7 49 02	 movzx	 ecx, WORD PTR [ecx+2]
  000e1	3b c1		 cmp	 eax, ecx
  000e3	0f 8e fd 00 00
	00		 jle	 $LN2@GetColorBl

; 376  : 	{
; 377  : 		// Four-color block: derive the other two colors.    
; 378  : 		// 00 = color_0, 01 = color_1, 10 = color_2, 11 = color_3
; 379  : 		// These two bit codes correspond to the 2-bit fields 
; 380  : 		// stored in the 64-bit block.
; 381  : 		wrd = (WORD) (((WORD) col_0->r * 2 + (WORD) col_1->r) / 3);

  000e9	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  000ec	0f b6 40 02	 movzx	 eax, BYTE PTR [eax+2]
  000f0	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  000f3	0f b6 49 02	 movzx	 ecx, BYTE PTR [ecx+2]
  000f7	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000fa	99		 cdq
  000fb	6a 03		 push	 3
  000fd	59		 pop	 ecx
  000fe	f7 f9		 idiv	 ecx
  00100	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  00103	66 89 01	 mov	 WORD PTR [ecx], ax

; 382  : 		// no +1 for rounding
; 383  : 		// as bits have been shifted to 888
; 384  : 		col_2->r = (BYTE)wrd;

  00106	8b 45 14	 mov	 eax, DWORD PTR _col_2$[ebp]
  00109	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  0010c	8a 09		 mov	 cl, BYTE PTR [ecx]
  0010e	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 385  : 		
; 386  : 		wrd = (WORD) (((WORD) col_0->g * 2 + (WORD) col_1->g) / 3);

  00111	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  00114	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  00118	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  0011b	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  0011f	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00122	99		 cdq
  00123	6a 03		 push	 3
  00125	59		 pop	 ecx
  00126	f7 f9		 idiv	 ecx
  00128	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  0012b	66 89 01	 mov	 WORD PTR [ecx], ax

; 387  : 		col_2->g = (BYTE)wrd;

  0012e	8b 45 14	 mov	 eax, DWORD PTR _col_2$[ebp]
  00131	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  00134	8a 09		 mov	 cl, BYTE PTR [ecx]
  00136	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 388  : 		
; 389  : 		wrd = (WORD) (((WORD) col_0->b * 2 + (WORD) col_1->b) / 3);

  00139	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  0013c	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  0013f	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  00142	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  00145	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  00148	99		 cdq
  00149	6a 03		 push	 3
  0014b	59		 pop	 ecx
  0014c	f7 f9		 idiv	 ecx
  0014e	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  00151	66 89 01	 mov	 WORD PTR [ecx], ax

; 390  : 		col_2->b = (BYTE)wrd;

  00154	8b 45 14	 mov	 eax, DWORD PTR _col_2$[ebp]
  00157	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  0015a	8a 09		 mov	 cl, BYTE PTR [ecx]
  0015c	88 08		 mov	 BYTE PTR [eax], cl

; 391  : 		col_2->a = 0xff;

  0015e	8b 45 14	 mov	 eax, DWORD PTR _col_2$[ebp]
  00161	c6 40 03 ff	 mov	 BYTE PTR [eax+3], 255	; 000000ffH

; 392  : 		
; 393  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r * 2) / 3);

  00165	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  00168	0f b6 40 02	 movzx	 eax, BYTE PTR [eax+2]
  0016c	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  0016f	0f b6 49 02	 movzx	 ecx, BYTE PTR [ecx+2]
  00173	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  00176	99		 cdq
  00177	6a 03		 push	 3
  00179	59		 pop	 ecx
  0017a	f7 f9		 idiv	 ecx
  0017c	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  0017f	66 89 01	 mov	 WORD PTR [ecx], ax

; 394  : 		col_3->r = (BYTE)wrd;

  00182	8b 45 18	 mov	 eax, DWORD PTR _col_3$[ebp]
  00185	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  00188	8a 09		 mov	 cl, BYTE PTR [ecx]
  0018a	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 395  : 		
; 396  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g * 2) / 3);

  0018d	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  00190	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  00194	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  00197	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  0019b	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  0019e	99		 cdq
  0019f	6a 03		 push	 3
  001a1	59		 pop	 ecx
  001a2	f7 f9		 idiv	 ecx
  001a4	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  001a7	66 89 01	 mov	 WORD PTR [ecx], ax

; 397  : 		col_3->g = (BYTE)wrd;

  001aa	8b 45 18	 mov	 eax, DWORD PTR _col_3$[ebp]
  001ad	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  001b0	8a 09		 mov	 cl, BYTE PTR [ecx]
  001b2	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 398  : 		
; 399  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b * 2) / 3);

  001b5	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  001b8	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  001bb	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  001be	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  001c1	8d 04 48	 lea	 eax, DWORD PTR [eax+ecx*2]
  001c4	99		 cdq
  001c5	6a 03		 push	 3
  001c7	59		 pop	 ecx
  001c8	f7 f9		 idiv	 ecx
  001ca	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  001cd	66 89 01	 mov	 WORD PTR [ecx], ax

; 400  : 		col_3->b = (BYTE)wrd;

  001d0	8b 45 18	 mov	 eax, DWORD PTR _col_3$[ebp]
  001d3	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  001d6	8a 09		 mov	 cl, BYTE PTR [ecx]
  001d8	88 08		 mov	 BYTE PTR [eax], cl

; 401  : 		col_3->a = 0xff;

  001da	8b 45 18	 mov	 eax, DWORD PTR _col_3$[ebp]
  001dd	c6 40 03 ff	 mov	 BYTE PTR [eax+3], 255	; 000000ffH

; 402  : 	}

  001e1	e9 91 00 00 00	 jmp	 $LN1@GetColorBl
$LN2@GetColorBl:

; 403  : 	else
; 404  : 	{
; 405  : 		// Three-color block: derive the other color.
; 406  : 		// 00 = color_0,  01 = color_1,  10 = color_2,  
; 407  : 		// 11 = transparent.
; 408  : 		// These two bit codes correspond to the 2-bit fields 
; 409  : 		// stored in the 64-bit block. 
; 410  : 		
; 411  : 		// explicit for each component, unlike some refrasts...
; 412  : 		
; 413  : 		// Tracef("block has alpha\n");
; 414  : 		wrd = (WORD) (((WORD) col_0->r + (WORD) col_1->r) / 2);

  001e6	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  001e9	0f b6 40 02	 movzx	 eax, BYTE PTR [eax+2]
  001ed	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  001f0	0f b6 49 02	 movzx	 ecx, BYTE PTR [ecx+2]
  001f4	03 c1		 add	 eax, ecx
  001f6	99		 cdq
  001f7	2b c2		 sub	 eax, edx
  001f9	d1 f8		 sar	 eax, 1
  001fb	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  001fe	66 89 01	 mov	 WORD PTR [ecx], ax

; 415  : 		col_2->r = (BYTE)wrd;

  00201	8b 45 14	 mov	 eax, DWORD PTR _col_2$[ebp]
  00204	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  00207	8a 09		 mov	 cl, BYTE PTR [ecx]
  00209	88 48 02	 mov	 BYTE PTR [eax+2], cl

; 416  : 		wrd = (WORD) (((WORD) col_0->g + (WORD) col_1->g) / 2);

  0020c	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  0020f	0f b6 40 01	 movzx	 eax, BYTE PTR [eax+1]
  00213	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  00216	0f b6 49 01	 movzx	 ecx, BYTE PTR [ecx+1]
  0021a	03 c1		 add	 eax, ecx
  0021c	99		 cdq
  0021d	2b c2		 sub	 eax, edx
  0021f	d1 f8		 sar	 eax, 1
  00221	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  00224	66 89 01	 mov	 WORD PTR [ecx], ax

; 417  : 		col_2->g = (BYTE)wrd;

  00227	8b 45 14	 mov	 eax, DWORD PTR _col_2$[ebp]
  0022a	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  0022d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0022f	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 418  : 		wrd = (WORD) (((WORD) col_0->b + (WORD) col_1->b) / 2);

  00232	8b 45 0c	 mov	 eax, DWORD PTR _col_0$[ebp]
  00235	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00238	8b 4d 10	 mov	 ecx, DWORD PTR _col_1$[ebp]
  0023b	0f b6 09	 movzx	 ecx, BYTE PTR [ecx]
  0023e	03 c1		 add	 eax, ecx
  00240	99		 cdq
  00241	2b c2		 sub	 eax, edx
  00243	d1 f8		 sar	 eax, 1
  00245	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  00248	66 89 01	 mov	 WORD PTR [ecx], ax

; 419  : 		col_2->b = (BYTE)wrd;

  0024b	8b 45 14	 mov	 eax, DWORD PTR _col_2$[ebp]
  0024e	8b 4d 1c	 mov	 ecx, DWORD PTR _wrd$[ebp]
  00251	8a 09		 mov	 cl, BYTE PTR [ecx]
  00253	88 08		 mov	 BYTE PTR [eax], cl

; 420  : 		col_2->a = 0xff;

  00255	8b 45 14	 mov	 eax, DWORD PTR _col_2$[ebp]
  00258	c6 40 03 ff	 mov	 BYTE PTR [eax+3], 255	; 000000ffH

; 421  : 		
; 422  : 		col_3->r = 0x00;		// random color to indicate alpha

  0025c	8b 45 18	 mov	 eax, DWORD PTR _col_3$[ebp]
  0025f	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0

; 423  : 		col_3->g = 0x00;

  00263	8b 45 18	 mov	 eax, DWORD PTR _col_3$[ebp]
  00266	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0

; 424  : 		col_3->b = 0x00;

  0026a	8b 45 18	 mov	 eax, DWORD PTR _col_3$[ebp]
  0026d	c6 00 00	 mov	 BYTE PTR [eax], 0

; 425  : 		col_3->a = 0x00;

  00270	8b 45 18	 mov	 eax, DWORD PTR _col_3$[ebp]
  00273	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
$LN1@GetColorBl:

; 426  : 	}
; 427  : } // Get color block colors (...)

  00277	c9		 leave
  00278	c3		 ret	 0
?GetColorBlockColors@@YAXPAUDXTColBlock@@PAUColor8888@@111AAG@Z ENDP ; GetColorBlockColors
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCDXTCImage@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCDXTCImage@@UAEPAXI@Z PROC				; CDXTCImage::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CDXTCImage@@UAE@XZ	; CDXTCImage::~CDXTCImage
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 28 01 00 00	 push	 296			; 00000128H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCDXTCImage@@UAEPAXI@Z ENDP				; CDXTCImage::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Unextract@CDXTCImage@@QAEXPAEHHH@Z
_TEXT	SEGMENT
_pBlock$ = -24						; size = 4
_pPos$ = -20						; size = 4
_yblocks$ = -16						; size = 4
_xblocks$ = -12						; size = 4
_y$1 = -8						; size = 4
_this$ = -4						; size = 4
_pbDest$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
_iPitch$ = 20						; size = 4
?Unextract@CDXTCImage@@QAEXPAEHHH@Z PROC		; CDXTCImage::Unextract, COMDAT
; _this$ = ecx

; 288  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 289  : 	if (!m_pbCompBufferByLevels[0])

  0000a	6a 04		 push	 4
  0000c	58		 pop	 eax
  0000d	6b c0 00	 imul	 eax, eax, 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 7c 01 04 00	 cmp	 DWORD PTR [ecx+eax+4], 0
  00018	75 05		 jne	 SHORT $LN5@Unextract

; 290  : 		return;

  0001a	e9 9f 00 00 00	 jmp	 $LN1@Unextract
$LN5@Unextract:

; 291  : 
; 292  : 	DXTColBlock * pBlock;
; 293  : 	BYTE * pPos = (BYTE *) &m_pbCompBufferByLevels[0][0];

  0001f	6a 04		 push	 4
  00021	58		 pop	 eax
  00022	6b c0 00	 imul	 eax, eax, 0
  00025	33 c9		 xor	 ecx, ecx
  00027	41		 inc	 ecx
  00028	6b c9 00	 imul	 ecx, ecx, 0
  0002b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	03 4c 02 04	 add	 ecx, DWORD PTR [edx+eax+4]
  00032	89 4d ec	 mov	 DWORD PTR _pPos$[ebp], ecx

; 294  : 	int xblocks = m_nWidth / 4;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [eax+256]
  0003e	99		 cdq
  0003f	83 e2 03	 and	 edx, 3
  00042	03 c2		 add	 eax, edx
  00044	c1 f8 02	 sar	 eax, 2
  00047	89 45 f4	 mov	 DWORD PTR _xblocks$[ebp], eax

; 295  : 	int yblocks = (m_nHeight / 4) * ((iPitch / m_nWidth) / 2);

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 80 04 01 00
	00		 mov	 eax, DWORD PTR [eax+260]
  00053	99		 cdq
  00054	83 e2 03	 and	 edx, 3
  00057	03 c2		 add	 eax, edx
  00059	8b c8		 mov	 ecx, eax
  0005b	c1 f9 02	 sar	 ecx, 2
  0005e	8b 75 fc	 mov	 esi, DWORD PTR _this$[ebp]
  00061	8b 45 14	 mov	 eax, DWORD PTR _iPitch$[ebp]
  00064	99		 cdq
  00065	f7 be 00 01 00
	00		 idiv	 DWORD PTR [esi+256]
  0006b	99		 cdq
  0006c	2b c2		 sub	 eax, edx
  0006e	d1 f8		 sar	 eax, 1
  00070	0f af c8	 imul	 ecx, eax
  00073	89 4d f0	 mov	 DWORD PTR _yblocks$[ebp], ecx

; 296  : 
; 297  : 	for (int y = 0; y < yblocks; ++y)

  00076	83 65 f8 00	 and	 DWORD PTR _y$1[ebp], 0
  0007a	eb 07		 jmp	 SHORT $LN4@Unextract
$LN2@Unextract:
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _y$1[ebp]
  0007f	40		 inc	 eax
  00080	89 45 f8	 mov	 DWORD PTR _y$1[ebp], eax
$LN4@Unextract:
  00083	8b 45 f8	 mov	 eax, DWORD PTR _y$1[ebp]
  00086	3b 45 f0	 cmp	 eax, DWORD PTR _yblocks$[ebp]
  00089	7d 33		 jge	 SHORT $LN1@Unextract

; 298  : 	{
; 299  : 		pBlock = (DXTColBlock*) (pPos + y * xblocks * 8);

  0008b	8b 45 f8	 mov	 eax, DWORD PTR _y$1[ebp]
  0008e	0f af 45 f4	 imul	 eax, DWORD PTR _xblocks$[ebp]
  00092	8b 4d ec	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00095	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00098	89 45 e8	 mov	 DWORD PTR _pBlock$[ebp], eax

; 300  : 
; 301  : 		memcpy(pbDest, pBlock, xblocks * 8);

  0009b	8b 45 f4	 mov	 eax, DWORD PTR _xblocks$[ebp]
  0009e	c1 e0 03	 shl	 eax, 3
  000a1	50		 push	 eax
  000a2	ff 75 e8	 push	 DWORD PTR _pBlock$[ebp]
  000a5	ff 75 08	 push	 DWORD PTR _pbDest$[ebp]
  000a8	e8 00 00 00 00	 call	 _memcpy
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 302  : 		pbDest += xblocks * 8;

  000b0	8b 45 f4	 mov	 eax, DWORD PTR _xblocks$[ebp]
  000b3	8b 4d 08	 mov	 ecx, DWORD PTR _pbDest$[ebp]
  000b6	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  000b9	89 45 08	 mov	 DWORD PTR _pbDest$[ebp], eax

; 303  : 	}

  000bc	eb be		 jmp	 SHORT $LN2@Unextract
$LN1@Unextract:

; 304  : 
; 305  : 	/*
; 306  : 	for (int y = 0; y < iHeight; ++y)
; 307  : 	{
; 308  : 		memcpy(pbDest, &m_pbCompBufferByLevels[0][0] + y*iWidth, iWidth);
; 309  : 		pbDest += iWidth;
; 310  : 	}
; 311  : 	*/
; 312  : }

  000be	5e		 pop	 esi
  000bf	c9		 leave
  000c0	c2 10 00	 ret	 16			; 00000010H
?Unextract@CDXTCImage@@QAEXPAEHHH@Z ENDP		; CDXTCImage::Unextract
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z
_TEXT	SEGMENT
tv82 = -28						; size = 4
tv65 = -24						; size = 4
_this$ = -20						; size = 4
_a$1 = -16						; size = 2
_r$2 = -12						; size = 2
_g$3 = -8						; size = 2
_b$4 = -4						; size = 2
_strPixelFormat$ = 8					; size = 4
_pxddpf$ = 12						; size = 4
?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z PROC ; CDXTCImage::DecodePixelFormat, COMDAT
; _this$ = ecx

; 914  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 915  : 	switch (pxddpf->dwFourCC)

  00009	8b 45 0c	 mov	 eax, DWORD PTR _pxddpf$[ebp]
  0000c	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000f	89 45 e8	 mov	 DWORD PTR tv65[ebp], eax
  00012	83 7d e8 00	 cmp	 DWORD PTR tv65[ebp], 0
  00016	74 46		 je	 SHORT $LN4@DecodePixe
  00018	81 7d e8 44 58
	54 31		 cmp	 DWORD PTR tv65[ebp], 827611204 ; 31545844H
  0001f	0f 84 ce 00 00
	00		 je	 $LN5@DecodePixe
  00025	81 7d e8 44 58
	54 32		 cmp	 DWORD PTR tv65[ebp], 844388420 ; 32545844H
  0002c	0f 84 e5 00 00
	00		 je	 $LN6@DecodePixe
  00032	81 7d e8 44 58
	54 33		 cmp	 DWORD PTR tv65[ebp], 861165636 ; 33545844H
  00039	0f 84 f9 00 00
	00		 je	 $LN7@DecodePixe
  0003f	81 7d e8 44 58
	54 34		 cmp	 DWORD PTR tv65[ebp], 877942852 ; 34545844H
  00046	0f 84 0d 01 00
	00		 je	 $LN8@DecodePixe
  0004c	81 7d e8 44 58
	54 35		 cmp	 DWORD PTR tv65[ebp], 894720068 ; 35545844H
  00053	0f 84 21 01 00
	00		 je	 $LN9@DecodePixe
  00059	e9 3d 01 00 00	 jmp	 $LN10@DecodePixe
$LN4@DecodePixe:

; 916  : 	{
; 917  : 		case 0:
; 918  : 			{
; 919  : 				// This dds texture isn't compressed so write out ARGB format
; 920  : 				WORD a = GetNumberOfBits(pxddpf->dwRGBAlphaBitMask);

  0005e	8b 45 0c	 mov	 eax, DWORD PTR _pxddpf$[ebp]
  00061	ff 70 1c	 push	 DWORD PTR [eax+28]
  00064	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  00069	59		 pop	 ecx
  0006a	66 89 45 f0	 mov	 WORD PTR _a$1[ebp], ax

; 921  : 				WORD r = GetNumberOfBits(pxddpf->dwRBitMask);

  0006e	8b 45 0c	 mov	 eax, DWORD PTR _pxddpf$[ebp]
  00071	ff 70 10	 push	 DWORD PTR [eax+16]
  00074	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  00079	59		 pop	 ecx
  0007a	66 89 45 f4	 mov	 WORD PTR _r$2[ebp], ax

; 922  : 				WORD g = GetNumberOfBits(pxddpf->dwGBitMask);

  0007e	8b 45 0c	 mov	 eax, DWORD PTR _pxddpf$[ebp]
  00081	ff 70 14	 push	 DWORD PTR [eax+20]
  00084	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  00089	59		 pop	 ecx
  0008a	66 89 45 f8	 mov	 WORD PTR _g$3[ebp], ax

; 923  : 				WORD b = GetNumberOfBits(pxddpf->dwBBitMask);

  0008e	8b 45 0c	 mov	 eax, DWORD PTR _pxddpf$[ebp]
  00091	ff 70 18	 push	 DWORD PTR [eax+24]
  00094	e8 00 00 00 00	 call	 ?GetNumberOfBits@@YAGK@Z ; GetNumberOfBits
  00099	59		 pop	 ecx
  0009a	66 89 45 fc	 mov	 WORD PTR _b$4[ebp], ax

; 924  : 
; 925  : 				_snprintf(strPixelFormat, 31, "ARGB-%d%d%d%d%s", a, r, g, b,

  0009e	8b 45 0c	 mov	 eax, DWORD PTR _pxddpf$[ebp]
  000a1	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000a4	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  000a9	74 09		 je	 SHORT $LN12@DecodePixe
  000ab	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], OFFSET ??_C@_07FBMAHCAD@?9premul@
  000b2	eb 07		 jmp	 SHORT $LN13@DecodePixe
$LN12@DecodePixe:
  000b4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN13@DecodePixe:
  000bb	ff 75 e4	 push	 DWORD PTR tv82[ebp]
  000be	0f b7 45 fc	 movzx	 eax, WORD PTR _b$4[ebp]
  000c2	50		 push	 eax
  000c3	0f b7 45 f8	 movzx	 eax, WORD PTR _g$3[ebp]
  000c7	50		 push	 eax
  000c8	0f b7 45 f4	 movzx	 eax, WORD PTR _r$2[ebp]
  000cc	50		 push	 eax
  000cd	0f b7 45 f0	 movzx	 eax, WORD PTR _a$1[ebp]
  000d1	50		 push	 eax
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@PAGHPOPO@ARGB?9?$CFd?$CFd?$CFd?$CFd?$CFs@
  000d7	6a 1f		 push	 31			; 0000001fH
  000d9	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  000dc	e8 00 00 00 00	 call	 __snprintf
  000e1	83 c4 20	 add	 esp, 32			; 00000020H

; 926  : 					pxddpf->dwBBitMask & DDPF_ALPHAPREMULT ? "-premul" : "");
; 927  : 				m_CompFormat = PF_ARGB;

  000e4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 a0 ec 00 00
	00 00		 and	 DWORD PTR [eax+236], 0

; 928  : 			}
; 929  : 			break;

  000ee	e9 c4 00 00 00	 jmp	 $LN1@DecodePixe
$LN5@DecodePixe:

; 930  : 			
; 931  : 		case MAKEFOURCC('D','X','T','1'):
; 932  : 			strncpy(strPixelFormat, "DXT1", 31);

  000f3	6a 1f		 push	 31			; 0000001fH
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_04DHPPFAPI@DXT1@
  000fa	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  000fd	e8 00 00 00 00	 call	 _strncpy
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 933  : 			m_CompFormat = PF_DXT1;

  00105	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00108	c7 80 ec 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+236], 1

; 934  : 			break;

  00112	e9 a0 00 00 00	 jmp	 $LN1@DecodePixe
$LN6@DecodePixe:

; 935  : 			
; 936  : 		case MAKEFOURCC('D','X','T','2'):
; 937  : 			strncpy(strPixelFormat, "DXT2", 31);

  00117	6a 1f		 push	 31			; 0000001fH
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_04BMNCADDL@DXT2@
  0011e	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00121	e8 00 00 00 00	 call	 _strncpy
  00126	83 c4 0c	 add	 esp, 12			; 0000000cH

; 938  : 			m_CompFormat = PF_DXT2;

  00129	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0012c	c7 80 ec 00 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+236], 2

; 939  : 			break;

  00136	eb 7f		 jmp	 SHORT $LN1@DecodePixe
$LN7@DecodePixe:

; 940  : 			
; 941  : 		case MAKEFOURCC('D','X','T','3'):
; 942  : 			strncpy(strPixelFormat, "DXT3", 31);

  00138	6a 1f		 push	 31			; 0000001fH
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_04FMJDCHK@DXT3@
  0013f	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00142	e8 00 00 00 00	 call	 _strncpy
  00147	83 c4 0c	 add	 esp, 12			; 0000000cH

; 943  : 			m_CompFormat = PF_DXT3;

  0014a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	c7 80 ec 00 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+236], 3

; 944  : 			break;

  00157	eb 5e		 jmp	 SHORT $LN1@DecodePixe
$LN8@DecodePixe:

; 945  : 			
; 946  : 		case MAKEFOURCC('D','X','T','4'):
; 947  : 			strncpy(strPixelFormat, "DXT4", 31);

  00159	6a 1f		 push	 31			; 0000001fH
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_04EKIIKELN@DXT4@
  00160	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00163	e8 00 00 00 00	 call	 _strncpy
  00168	83 c4 0c	 add	 esp, 12			; 0000000cH

; 948  : 			m_CompFormat = PF_DXT4;

  0016b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0016e	c7 80 ec 00 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+236], 4

; 949  : 			break;

  00178	eb 3d		 jmp	 SHORT $LN1@DecodePixe
$LN9@DecodePixe:

; 950  : 			
; 951  : 		case MAKEFOURCC('D','X','T','5'):
; 952  : 			strncpy(strPixelFormat, "DXT5", 31);

  0017a	6a 1f		 push	 31			; 0000001fH
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_04FDJDJFPM@DXT5@
  00181	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  00184	e8 00 00 00 00	 call	 _strncpy
  00189	83 c4 0c	 add	 esp, 12			; 0000000cH

; 953  : 			m_CompFormat = PF_DXT5;

  0018c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0018f	c7 80 ec 00 00
	00 05 00 00 00	 mov	 DWORD PTR [eax+236], 5

; 954  : 			break;

  00199	eb 1c		 jmp	 SHORT $LN1@DecodePixe
$LN10@DecodePixe:

; 955  : 
; 956  : 		default:
; 957  : 			strcpy(strPixelFormat, "Format Unknown");

  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0P@NBMDABNO@Format?5Unknown@
  001a0	ff 75 08	 push	 DWORD PTR _strPixelFormat$[ebp]
  001a3	e8 00 00 00 00	 call	 _strcpy
  001a8	59		 pop	 ecx
  001a9	59		 pop	 ecx

; 958  : 			m_CompFormat = PF_UNKNOWN;

  001aa	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001ad	c7 80 ec 00 00
	00 06 00 00 00	 mov	 DWORD PTR [eax+236], 6
$LN1@DecodePixe:

; 959  : 			break;
; 960  : 	}
; 961  : }

  001b7	c9		 leave
  001b8	c2 08 00	 ret	 8
?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ENDP ; CDXTCImage::DecodePixelFormat
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressARGB@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
_lPitch$ = -12						; size = 4
__My_data$2 = -8					; size = 4
_this$ = -4						; size = 4
_level$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressARGB@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressARGB, COMDAT
; _this$ = ecx

; 855  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 856  : 	UINT lPitch = m_lPitch >> (level * 2);

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  0000c	d1 e1		 shl	 ecx, 1
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	8b 80 f0 00 00
	00		 mov	 eax, DWORD PTR [eax+240]
  00017	d3 f8		 sar	 eax, cl
  00019	89 45 f4	 mov	 DWORD PTR _lPitch$[ebp], eax

; 857  : 	memcpy(pdwDest, &m_bCompVector[level][0], lPitch);

  0001c	6b 45 08 0c	 imul	 eax, DWORD PTR _level$[ebp], 12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8d 44 01 34	 lea	 eax, DWORD PTR [ecx+eax+52]
  00027	89 45 f8	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0002a	33 c0		 xor	 eax, eax
  0002c	c1 e0 00	 shl	 eax, 0
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  00032	03 01		 add	 eax, DWORD PTR [ecx]
  00034	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 857  : 	memcpy(pdwDest, &m_bCompVector[level][0], lPitch);

  00037	ff 75 f4	 push	 DWORD PTR _lPitch$[ebp]
  0003a	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 0c	 push	 DWORD PTR _pdwDest$[ebp]
  00040	e8 00 00 00 00	 call	 _memcpy
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 858  : }

  00048	c9		 leave
  00049	c2 08 00	 ret	 8
?DecompressARGB@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressARGB
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_pAlphaBlock$ = -76					; size = 4
_alphazero$ = -72					; size = 4
_col_1$ = -68						; size = 4
_col_2$ = -64						; size = 4
_col_3$ = -60						; size = 4
_pBase$ = -56						; size = 4
_yblocks$ = -52						; size = 4
__My_data$1 = -48					; size = 4
_nHeight$ = -44						; size = 4
_pImPos$ = -40						; size = 4
_xblocks$ = -36						; size = 4
_pPos$ = -32						; size = 4
_this$ = -28						; size = 4
_nWidth$ = -24						; size = 4
_x$ = -20						; size = 4
_y$ = -16						; size = 4
_pBlock$ = -12						; size = 4
_col_0$ = -8						; size = 4
_wrd$ = -4						; size = 2
_level$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT5, COMDAT
; _this$ = ecx

; 780  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 781  : 	int xblocks, yblocks;
; 782  : #ifdef DEBUG
; 783  : 	if ((ddsd.dwWidth % 4) != 0)
; 784  : 	{
; 785  : 		Tracef("****** warning width not div by 4! %d\n", ddsd.dwWidth);
; 786  : 	}
; 787  : 	
; 788  : 	if ((ddsd.dwHeight % 4) != 0)
; 789  : 	{
; 790  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 791  : 	}
; 792  : 	
; 793  : 	Tracef("end check\n");
; 794  : #endif
; 795  : 	UINT nWidth = m_nWidth >> level;

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [eax+256]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  00015	d3 f8		 sar	 eax, cl
  00017	89 45 e8	 mov	 DWORD PTR _nWidth$[ebp], eax

; 796  : 	UINT nHeight = m_nHeight >> level;

  0001a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 80 04 01 00
	00		 mov	 eax, DWORD PTR [eax+260]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  00026	d3 f8		 sar	 eax, cl
  00028	89 45 d4	 mov	 DWORD PTR _nHeight$[ebp], eax

; 797  : 
; 798  : 	xblocks = nWidth / 4;

  0002b	8b 45 e8	 mov	 eax, DWORD PTR _nWidth$[ebp]
  0002e	c1 e8 02	 shr	 eax, 2
  00031	89 45 dc	 mov	 DWORD PTR _xblocks$[ebp], eax

; 799  : 	yblocks = nHeight / 4;

  00034	8b 45 d4	 mov	 eax, DWORD PTR _nHeight$[ebp]
  00037	c1 e8 02	 shr	 eax, 2
  0003a	89 45 cc	 mov	 DWORD PTR _yblocks$[ebp], eax

; 800  : 
; 801  : 	int x, y;
; 802  : 	
; 803  : 	DWORD * pBase = (DWORD *) pdwDest;

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _pdwDest$[ebp]
  00040	89 45 c8	 mov	 DWORD PTR _pBase$[ebp], eax

; 804  : 	WORD  * pPos = pPos = (WORD *) &m_bCompVector[level][0]; // pos in compressed data

  00043	6b 45 08 0c	 imul	 eax, DWORD PTR _level$[ebp], 12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00047	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8d 44 01 34	 lea	 eax, DWORD PTR [ecx+eax+52]
  0004e	89 45 d0	 mov	 DWORD PTR __My_data$1[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00051	33 c0		 xor	 eax, eax
  00053	c1 e0 00	 shl	 eax, 0
  00056	8b 4d d0	 mov	 ecx, DWORD PTR __My_data$1[ebp]
  00059	03 01		 add	 eax, DWORD PTR [ecx]
  0005b	89 45 e0	 mov	 DWORD PTR _pPos$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 804  : 	WORD  * pPos = pPos = (WORD *) &m_bCompVector[level][0]; // pos in compressed data

  0005e	8b 45 e0	 mov	 eax, DWORD PTR _pPos$[ebp]
  00061	89 45 e0	 mov	 DWORD PTR _pPos$[ebp], eax

; 805  : 	DWORD * pImPos;	// pos in decompressed data
; 806  : 
; 807  : 	DXTColBlock	* pBlock;
; 808  : 	DXTAlphaBlock3BitLinear * pAlphaBlock;
; 809  : 	
; 810  : 	Color8888 col_0, col_1, col_2, col_3;
; 811  : 	WORD wrd;
; 812  : 	
; 813  : 	// fill alphazero with appropriate value to zero out alpha when
; 814  : 	// alphazero is ANDed with the image color 32 bit DWORD:
; 815  : 	col_0.a = 0;

  00064	c6 45 fb 00	 mov	 BYTE PTR _col_0$[ebp+3], 0

; 816  : 	col_0.r = col_0.g = col_0.b = 0xff;

  00068	c6 45 f8 ff	 mov	 BYTE PTR _col_0$[ebp], 255 ; 000000ffH
  0006c	8a 45 f8	 mov	 al, BYTE PTR _col_0$[ebp]
  0006f	88 45 f9	 mov	 BYTE PTR _col_0$[ebp+1], al
  00072	8a 45 f9	 mov	 al, BYTE PTR _col_0$[ebp+1]
  00075	88 45 fa	 mov	 BYTE PTR _col_0$[ebp+2], al

; 817  : 	DWORD alphazero = *((DWORD *) &col_0);

  00078	8b 45 f8	 mov	 eax, DWORD PTR _col_0$[ebp]
  0007b	89 45 b8	 mov	 DWORD PTR _alphazero$[ebp], eax

; 818  : 	
; 819  : 	////////////////////////////////
; 820  : 	// Tracef("blocks: x: %d y: %d\n", xblocks, yblocks);
; 821  : 	for (y = 0; y < yblocks; ++y)

  0007e	83 65 f0 00	 and	 DWORD PTR _y$[ebp], 0
  00082	eb 07		 jmp	 SHORT $LN4@Decompress
$LN2@Decompress:
  00084	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00087	40		 inc	 eax
  00088	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@Decompress:
  0008b	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0008e	3b 45 cc	 cmp	 eax, DWORD PTR _yblocks$[ebp]
  00091	0f 8d c1 00 00
	00		 jge	 $LN1@Decompress

; 822  : 	{
; 823  : 		// 8 bytes per block
; 824  : 		// 1 block for alpha, 1 block for color
; 825  : 		pBlock = (DXTColBlock*) ((DWORD) (pPos + y * xblocks * 16));

  00097	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  0009a	0f af 45 dc	 imul	 eax, DWORD PTR _xblocks$[ebp]
  0009e	c1 e0 04	 shl	 eax, 4
  000a1	8b 4d e0	 mov	 ecx, DWORD PTR _pPos$[ebp]
  000a4	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000a7	89 45 f4	 mov	 DWORD PTR _pBlock$[ebp], eax

; 826  : 
; 827  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  000aa	83 65 ec 00	 and	 DWORD PTR _x$[ebp], 0
  000ae	eb 10		 jmp	 SHORT $LN7@Decompress
$LN5@Decompress:
  000b0	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  000b3	40		 inc	 eax
  000b4	89 45 ec	 mov	 DWORD PTR _x$[ebp], eax
  000b7	8b 45 f4	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000ba	83 c0 08	 add	 eax, 8
  000bd	89 45 f4	 mov	 DWORD PTR _pBlock$[ebp], eax
$LN7@Decompress:
  000c0	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  000c3	3b 45 dc	 cmp	 eax, DWORD PTR _xblocks$[ebp]
  000c6	0f 8d 87 00 00
	00		 jge	 $LN6@Decompress

; 828  : 		{
; 829  : 			// inline
; 830  : 			// Get alpha block
; 831  : 			pAlphaBlock = (DXTAlphaBlock3BitLinear*) pBlock;

  000cc	8b 45 f4	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000cf	89 45 b4	 mov	 DWORD PTR _pAlphaBlock$[ebp], eax

; 832  : 			
; 833  : 			// inline func:
; 834  : 			// Get color block & colors
; 835  : 			pBlock++;

  000d2	8b 45 f4	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000d5	83 c0 08	 add	 eax, 8
  000d8	89 45 f4	 mov	 DWORD PTR _pBlock$[ebp], eax

; 836  : 			
; 837  : 			// Tracef("pBlock: 0x%.8x\n", pBlock);
; 838  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);

  000db	8d 45 fc	 lea	 eax, DWORD PTR _wrd$[ebp]
  000de	50		 push	 eax
  000df	8d 45 c4	 lea	 eax, DWORD PTR _col_3$[ebp]
  000e2	50		 push	 eax
  000e3	8d 45 c0	 lea	 eax, DWORD PTR _col_2$[ebp]
  000e6	50		 push	 eax
  000e7	8d 45 bc	 lea	 eax, DWORD PTR _col_1$[ebp]
  000ea	50		 push	 eax
  000eb	8d 45 f8	 lea	 eax, DWORD PTR _col_0$[ebp]
  000ee	50		 push	 eax
  000ef	ff 75 f4	 push	 DWORD PTR _pBlock$[ebp]
  000f2	e8 00 00 00 00	 call	 ?GetColorBlockColors@@YAXPAUDXTColBlock@@PAUColor8888@@111AAG@Z ; GetColorBlockColors
  000f7	83 c4 18	 add	 esp, 24			; 00000018H

; 839  : 			
; 840  : 			// Decode the color block into the bitmap bits
; 841  : 			// inline func:
; 842  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));

  000fa	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  000fd	c1 e0 04	 shl	 eax, 4
  00100	8b 4d c8	 mov	 ecx, DWORD PTR _pBase$[ebp]
  00103	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00106	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  00109	c1 e1 02	 shl	 ecx, 2
  0010c	0f af 4d e8	 imul	 ecx, DWORD PTR _nWidth$[ebp]
  00110	c1 e1 02	 shl	 ecx, 2
  00113	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00116	89 45 d8	 mov	 DWORD PTR _pImPos$[ebp], eax

; 843  : 
; 844  : 			//DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);
; 845  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  00119	8d 45 c4	 lea	 eax, DWORD PTR _col_3$[ebp]
  0011c	50		 push	 eax
  0011d	8d 45 c0	 lea	 eax, DWORD PTR _col_2$[ebp]
  00120	50		 push	 eax
  00121	8d 45 bc	 lea	 eax, DWORD PTR _col_1$[ebp]
  00124	50		 push	 eax
  00125	8d 45 f8	 lea	 eax, DWORD PTR _col_0$[ebp]
  00128	50		 push	 eax
  00129	ff 75 e8	 push	 DWORD PTR _nWidth$[ebp]
  0012c	ff 75 f4	 push	 DWORD PTR _pBlock$[ebp]
  0012f	ff 75 d8	 push	 DWORD PTR _pImPos$[ebp]
  00132	e8 00 00 00 00	 call	 ?DecodeColorBlock@@YAXPAKPAUDXTColBlock@@H0000@Z ; DecodeColorBlock
  00137	83 c4 1c	 add	 esp, 28			; 0000001cH

; 846  : 
; 847  : 			// Overwrite the previous alpha bits with the alpha block
; 848  : 			//  info
; 849  : 			DecodeAlpha3BitLinear(pImPos, pAlphaBlock, nWidth, alphazero);

  0013a	ff 75 b8	 push	 DWORD PTR _alphazero$[ebp]
  0013d	ff 75 e8	 push	 DWORD PTR _nWidth$[ebp]
  00140	ff 75 b4	 push	 DWORD PTR _pAlphaBlock$[ebp]
  00143	ff 75 d8	 push	 DWORD PTR _pImPos$[ebp]
  00146	e8 00 00 00 00	 call	 ?DecodeAlpha3BitLinear@@YAXPAKPAUDXTAlphaBlock3BitLinear@@HK@Z ; DecodeAlpha3BitLinear
  0014b	83 c4 10	 add	 esp, 16			; 00000010H

; 850  : 		}

  0014e	e9 5d ff ff ff	 jmp	 $LN5@Decompress
$LN6@Decompress:

; 851  : 	}

  00153	e9 2c ff ff ff	 jmp	 $LN2@Decompress
$LN1@Decompress:

; 852  : }	// dxt5

  00158	c9		 leave
  00159	c2 08 00	 ret	 8
?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT5
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_pAlphaBlock$ = -76					; size = 4
_alphazero$ = -72					; size = 4
_col_1$ = -68						; size = 4
_col_2$ = -64						; size = 4
_col_3$ = -60						; size = 4
_pBase$ = -56						; size = 4
_pPos$ = -52						; size = 4
_yblocks$ = -48						; size = 4
__My_data$1 = -44					; size = 4
_nHeight$ = -40						; size = 4
_pImPos$ = -36						; size = 4
_xblocks$ = -32						; size = 4
_this$ = -28						; size = 4
_nWidth$ = -24						; size = 4
_x$ = -20						; size = 4
_y$ = -16						; size = 4
_pBlock$ = -12						; size = 4
_col_0$ = -8						; size = 4
_wrd$ = -4						; size = 2
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT3, COMDAT
; _this$ = ecx

; 706  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 707  : 	int xblocks, yblocks;
; 708  : #ifdef DEBUG
; 709  : 	if ((ddsd.dwWidth % 4) != 0)
; 710  : 	{
; 711  : 		Tracef("****** warning width not div by 4! %d\n", ddsd.dwWidth);
; 712  : 	}
; 713  : 	
; 714  : 	if ((ddsd.dwHeight % 4) != 0)
; 715  : 	{
; 716  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 717  : 	}
; 718  : 	
; 719  : 	Tracef("end check\n");
; 720  : #endif 
; 721  : 	UINT nWidth = m_nWidth >> miplevel;

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [eax+256]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  00015	d3 f8		 sar	 eax, cl
  00017	89 45 e8	 mov	 DWORD PTR _nWidth$[ebp], eax

; 722  : 	UINT nHeight = m_nHeight >> miplevel;

  0001a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 80 04 01 00
	00		 mov	 eax, DWORD PTR [eax+260]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  00026	d3 f8		 sar	 eax, cl
  00028	89 45 d8	 mov	 DWORD PTR _nHeight$[ebp], eax

; 723  : 
; 724  : 	xblocks = nWidth / 4;

  0002b	8b 45 e8	 mov	 eax, DWORD PTR _nWidth$[ebp]
  0002e	c1 e8 02	 shr	 eax, 2
  00031	89 45 e0	 mov	 DWORD PTR _xblocks$[ebp], eax

; 725  : 	yblocks = nHeight / 4;

  00034	8b 45 d8	 mov	 eax, DWORD PTR _nHeight$[ebp]
  00037	c1 e8 02	 shr	 eax, 2
  0003a	89 45 d0	 mov	 DWORD PTR _yblocks$[ebp], eax

; 726  : 
; 727  : 	int		x, y;
; 728  : 	DWORD * pBase	= (DWORD *) pdwDest;

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _pdwDest$[ebp]
  00040	89 45 c8	 mov	 DWORD PTR _pBase$[ebp], eax

; 729  : 	WORD  * pPos	= (WORD *) &m_bCompVector[miplevel][0]; // pos in compressed data

  00043	6b 45 08 0c	 imul	 eax, DWORD PTR _miplevel$[ebp], 12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00047	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8d 44 01 34	 lea	 eax, DWORD PTR [ecx+eax+52]
  0004e	89 45 d4	 mov	 DWORD PTR __My_data$1[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00051	33 c0		 xor	 eax, eax
  00053	c1 e0 00	 shl	 eax, 0
  00056	8b 4d d4	 mov	 ecx, DWORD PTR __My_data$1[ebp]
  00059	03 01		 add	 eax, DWORD PTR [ecx]
  0005b	89 45 cc	 mov	 DWORD PTR _pPos$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 740  : 	col_0.a = 0;

  0005e	c6 45 fb 00	 mov	 BYTE PTR _col_0$[ebp+3], 0

; 741  : 	col_0.r = col_0.g = col_0.b = 0xff;

  00062	c6 45 f8 ff	 mov	 BYTE PTR _col_0$[ebp], 255 ; 000000ffH
  00066	8a 45 f8	 mov	 al, BYTE PTR _col_0$[ebp]
  00069	88 45 f9	 mov	 BYTE PTR _col_0$[ebp+1], al
  0006c	8a 45 f9	 mov	 al, BYTE PTR _col_0$[ebp+1]
  0006f	88 45 fa	 mov	 BYTE PTR _col_0$[ebp+2], al

; 742  : 
; 743  : 	DWORD alphazero = *((DWORD *) &col_0);

  00072	8b 45 f8	 mov	 eax, DWORD PTR _col_0$[ebp]
  00075	89 45 b8	 mov	 DWORD PTR _alphazero$[ebp], eax

; 744  : 
; 745  : 	for (y = 0; y < yblocks; ++y)

  00078	83 65 f0 00	 and	 DWORD PTR _y$[ebp], 0
  0007c	eb 07		 jmp	 SHORT $LN4@Decompress
$LN2@Decompress:
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00081	40		 inc	 eax
  00082	89 45 f0	 mov	 DWORD PTR _y$[ebp], eax
$LN4@Decompress:
  00085	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00088	3b 45 d0	 cmp	 eax, DWORD PTR _yblocks$[ebp]
  0008b	0f 8d c1 00 00
	00		 jge	 $LN1@Decompress

; 746  : 	{
; 747  : 		// 8 bytes per block
; 748  : 		// 1 block for alpha, 1 block for color
; 749  : 		pBlock = (DXTColBlock *) ((DWORD) (pPos + y * xblocks * 16));

  00091	8b 45 f0	 mov	 eax, DWORD PTR _y$[ebp]
  00094	0f af 45 e0	 imul	 eax, DWORD PTR _xblocks$[ebp]
  00098	c1 e0 04	 shl	 eax, 4
  0009b	8b 4d cc	 mov	 ecx, DWORD PTR _pPos$[ebp]
  0009e	8d 04 41	 lea	 eax, DWORD PTR [ecx+eax*2]
  000a1	89 45 f4	 mov	 DWORD PTR _pBlock$[ebp], eax

; 750  : 
; 751  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  000a4	83 65 ec 00	 and	 DWORD PTR _x$[ebp], 0
  000a8	eb 10		 jmp	 SHORT $LN7@Decompress
$LN5@Decompress:
  000aa	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  000ad	40		 inc	 eax
  000ae	89 45 ec	 mov	 DWORD PTR _x$[ebp], eax
  000b1	8b 45 f4	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000b4	83 c0 08	 add	 eax, 8
  000b7	89 45 f4	 mov	 DWORD PTR _pBlock$[ebp], eax
$LN7@Decompress:
  000ba	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  000bd	3b 45 e0	 cmp	 eax, DWORD PTR _xblocks$[ebp]
  000c0	0f 8d 87 00 00
	00		 jge	 $LN6@Decompress

; 752  : 		{
; 753  : 			// inline
; 754  : 			// Get alpha block
; 755  : 			pAlphaBlock = (DXTAlphaBlockExplicit *) pBlock;

  000c6	8b 45 f4	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000c9	89 45 b4	 mov	 DWORD PTR _pAlphaBlock$[ebp], eax

; 756  : 			
; 757  : 			// inline func:
; 758  : 			// Get color block & colors
; 759  : 			pBlock++;

  000cc	8b 45 f4	 mov	 eax, DWORD PTR _pBlock$[ebp]
  000cf	83 c0 08	 add	 eax, 8
  000d2	89 45 f4	 mov	 DWORD PTR _pBlock$[ebp], eax

; 760  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);

  000d5	8d 45 fc	 lea	 eax, DWORD PTR _wrd$[ebp]
  000d8	50		 push	 eax
  000d9	8d 45 c4	 lea	 eax, DWORD PTR _col_3$[ebp]
  000dc	50		 push	 eax
  000dd	8d 45 c0	 lea	 eax, DWORD PTR _col_2$[ebp]
  000e0	50		 push	 eax
  000e1	8d 45 bc	 lea	 eax, DWORD PTR _col_1$[ebp]
  000e4	50		 push	 eax
  000e5	8d 45 f8	 lea	 eax, DWORD PTR _col_0$[ebp]
  000e8	50		 push	 eax
  000e9	ff 75 f4	 push	 DWORD PTR _pBlock$[ebp]
  000ec	e8 00 00 00 00	 call	 ?GetColorBlockColors@@YAXPAUDXTColBlock@@PAUColor8888@@111AAG@Z ; GetColorBlockColors
  000f1	83 c4 18	 add	 esp, 24			; 00000018H

; 761  : 			
; 762  : 			// Decode the color block into the bitmap bits
; 763  : 			// inline func:
; 764  : 			pImPos = (DWORD *) ((DWORD) (pBase + x * 16 + (y * 4) * nWidth * 4));

  000f4	8b 45 ec	 mov	 eax, DWORD PTR _x$[ebp]
  000f7	c1 e0 04	 shl	 eax, 4
  000fa	8b 4d c8	 mov	 ecx, DWORD PTR _pBase$[ebp]
  000fd	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00100	8b 4d f0	 mov	 ecx, DWORD PTR _y$[ebp]
  00103	c1 e1 02	 shl	 ecx, 2
  00106	0f af 4d e8	 imul	 ecx, DWORD PTR _nWidth$[ebp]
  0010a	c1 e1 02	 shl	 ecx, 2
  0010d	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  00110	89 45 dc	 mov	 DWORD PTR _pImPos$[ebp], eax

; 765  : 			
; 766  : 			DecodeColorBlock(pImPos,

  00113	8d 45 c4	 lea	 eax, DWORD PTR _col_3$[ebp]
  00116	50		 push	 eax
  00117	8d 45 c0	 lea	 eax, DWORD PTR _col_2$[ebp]
  0011a	50		 push	 eax
  0011b	8d 45 bc	 lea	 eax, DWORD PTR _col_1$[ebp]
  0011e	50		 push	 eax
  0011f	8d 45 f8	 lea	 eax, DWORD PTR _col_0$[ebp]
  00122	50		 push	 eax
  00123	ff 75 e8	 push	 DWORD PTR _nWidth$[ebp]
  00126	ff 75 f4	 push	 DWORD PTR _pBlock$[ebp]
  00129	ff 75 dc	 push	 DWORD PTR _pImPos$[ebp]
  0012c	e8 00 00 00 00	 call	 ?DecodeColorBlock@@YAXPAKPAUDXTColBlock@@H0000@Z ; DecodeColorBlock
  00131	83 c4 1c	 add	 esp, 28			; 0000001cH

; 767  : 							 pBlock, 
; 768  : 							 nWidth,
; 769  : 							 (DWORD *) &col_0, (DWORD *) &col_1, (DWORD *) &col_2, (DWORD *) &col_3);
; 770  : 			
; 771  : 			// Overwrite the previous alpha bits with the alpha block
; 772  : 			//  info
; 773  : 			// inline func:
; 774  : 			DecodeAlphaExplicit(pImPos, pAlphaBlock, nWidth, alphazero);

  00134	ff 75 b8	 push	 DWORD PTR _alphazero$[ebp]
  00137	ff 75 e8	 push	 DWORD PTR _nWidth$[ebp]
  0013a	ff 75 b4	 push	 DWORD PTR _pAlphaBlock$[ebp]
  0013d	ff 75 dc	 push	 DWORD PTR _pImPos$[ebp]
  00140	e8 00 00 00 00	 call	 ?DecodeAlphaExplicit@@YAXPAKPAUDXTAlphaBlockExplicit@@HK@Z ; DecodeAlphaExplicit
  00145	83 c4 10	 add	 esp, 16			; 00000010H

; 775  : 		}

  00148	e9 5d ff ff ff	 jmp	 $LN5@Decompress
$LN6@Decompress:

; 776  : 	}

  0014d	e9 2c ff ff ff	 jmp	 $LN2@Decompress
$LN1@Decompress:

; 777  : }

  00152	c9		 leave
  00153	c2 08 00	 ret	 8
?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT3
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
_pImPos$ = -68						; size = 4
_col_0$ = -64						; size = 4
_col_1$ = -60						; size = 4
_col_2$ = -56						; size = 4
_col_3$ = -52						; size = 4
_pBase$ = -48						; size = 4
_pPos$ = -44						; size = 4
_yblocks$ = -40						; size = 4
__My_data$1 = -36					; size = 4
_nHeight$ = -32						; size = 4
_xblocks$ = -28						; size = 4
_nWidth$ = -24						; size = 4
_this$ = -20						; size = 4
_pBlock$ = -16						; size = 4
_x$ = -12						; size = 4
_y$ = -8						; size = 4
_wrd$ = -4						; size = 2
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z PROC		; CDXTCImage::DecompressDXT1, COMDAT
; _this$ = ecx

; 647  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 648  : 	// This was hacked up pretty quick & slopily
; 649  : 	// decompresses to 32 bit format 0xARGB
; 650  : 	int xblocks, yblocks;
; 651  : #ifdef DEBUG
; 652  : 	if ((ddsd.dwWidth % 4) != 0)
; 653  : 	{
; 654  : 		Tracef("****** warning width not div by 4!  %d\n", ddsd.dwWidth);
; 655  : 	}
; 656  : 	
; 657  : 	if ((ddsd.dwHeight % 4) != 0)
; 658  : 	{
; 659  : 		Tracef("****** warning Height not div by 4! %d\n", ddsd.dwHeight);
; 660  : 	}
; 661  : 	
; 662  : 	Tracef("end check\n");
; 663  : #endif
; 664  : 	UINT nWidth = m_nWidth >> miplevel;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [eax+256]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  00015	d3 f8		 sar	 eax, cl
  00017	89 45 e8	 mov	 DWORD PTR _nWidth$[ebp], eax

; 665  : 	UINT nHeight = m_nHeight >> miplevel;

  0001a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 80 04 01 00
	00		 mov	 eax, DWORD PTR [eax+260]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  00026	d3 f8		 sar	 eax, cl
  00028	89 45 e0	 mov	 DWORD PTR _nHeight$[ebp], eax

; 666  : 	
; 667  : 	xblocks = nWidth / 4;

  0002b	8b 45 e8	 mov	 eax, DWORD PTR _nWidth$[ebp]
  0002e	c1 e8 02	 shr	 eax, 2
  00031	89 45 e4	 mov	 DWORD PTR _xblocks$[ebp], eax

; 668  : 	yblocks = nHeight / 4;

  00034	8b 45 e0	 mov	 eax, DWORD PTR _nHeight$[ebp]
  00037	c1 e8 02	 shr	 eax, 2
  0003a	89 45 d8	 mov	 DWORD PTR _yblocks$[ebp], eax

; 669  : 
; 670  : 	int		x, y;
; 671  : 	DWORD * pBase	= (DWORD *) pdwDest;

  0003d	8b 45 0c	 mov	 eax, DWORD PTR _pdwDest$[ebp]
  00040	89 45 d0	 mov	 DWORD PTR _pBase$[ebp], eax

; 672  : 	WORD  * pPos	= (WORD *) &m_bCompVector[miplevel][0];;	// pos in compressed data

  00043	6b 45 08 0c	 imul	 eax, DWORD PTR _miplevel$[ebp], 12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00047	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	8d 44 01 34	 lea	 eax, DWORD PTR [ecx+eax+52]
  0004e	89 45 dc	 mov	 DWORD PTR __My_data$1[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  00051	33 c0		 xor	 eax, eax
  00053	c1 e0 00	 shl	 eax, 0
  00056	8b 4d dc	 mov	 ecx, DWORD PTR __My_data$1[ebp]
  00059	03 01		 add	 eax, DWORD PTR [ecx]
  0005b	89 45 d4	 mov	 DWORD PTR _pPos$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 680  : 	for (y = 0; y < yblocks; ++y)

  0005e	83 65 f8 00	 and	 DWORD PTR _y$[ebp], 0
  00062	eb 07		 jmp	 SHORT $LN4@Decompress
$LN2@Decompress:
  00064	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  00067	40		 inc	 eax
  00068	89 45 f8	 mov	 DWORD PTR _y$[ebp], eax
$LN4@Decompress:
  0006b	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  0006e	3b 45 d8	 cmp	 eax, DWORD PTR _yblocks$[ebp]
  00071	0f 8d 8e 00 00
	00		 jge	 $LN1@Decompress

; 681  : 	{
; 682  : 		// 8 bytes per block
; 683  : 		pBlock = (DXTColBlock *) ((DWORD) pPos + y * xblocks * 8);

  00077	8b 45 f8	 mov	 eax, DWORD PTR _y$[ebp]
  0007a	0f af 45 e4	 imul	 eax, DWORD PTR _xblocks$[ebp]
  0007e	8b 4d d4	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00081	8d 04 c1	 lea	 eax, DWORD PTR [ecx+eax*8]
  00084	89 45 f0	 mov	 DWORD PTR _pBlock$[ebp], eax

; 684  : 		
; 685  : 		for (x = 0; x < xblocks; ++x, ++pBlock)

  00087	83 65 f4 00	 and	 DWORD PTR _x$[ebp], 0
  0008b	eb 10		 jmp	 SHORT $LN7@Decompress
$LN5@Decompress:
  0008d	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  00090	40		 inc	 eax
  00091	89 45 f4	 mov	 DWORD PTR _x$[ebp], eax
  00094	8b 45 f0	 mov	 eax, DWORD PTR _pBlock$[ebp]
  00097	83 c0 08	 add	 eax, 8
  0009a	89 45 f0	 mov	 DWORD PTR _pBlock$[ebp], eax
$LN7@Decompress:
  0009d	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  000a0	3b 45 e4	 cmp	 eax, DWORD PTR _xblocks$[ebp]
  000a3	7d 5b		 jge	 SHORT $LN6@Decompress

; 686  : 		{
; 687  : 			// inline func:
; 688  : 			GetColorBlockColors(pBlock, &col_0, &col_1, &col_2, &col_3, wrd);

  000a5	8d 45 fc	 lea	 eax, DWORD PTR _wrd$[ebp]
  000a8	50		 push	 eax
  000a9	8d 45 cc	 lea	 eax, DWORD PTR _col_3$[ebp]
  000ac	50		 push	 eax
  000ad	8d 45 c8	 lea	 eax, DWORD PTR _col_2$[ebp]
  000b0	50		 push	 eax
  000b1	8d 45 c4	 lea	 eax, DWORD PTR _col_1$[ebp]
  000b4	50		 push	 eax
  000b5	8d 45 c0	 lea	 eax, DWORD PTR _col_0$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f0	 push	 DWORD PTR _pBlock$[ebp]
  000bc	e8 00 00 00 00	 call	 ?GetColorBlockColors@@YAXPAUDXTColBlock@@PAUColor8888@@111AAG@Z ; GetColorBlockColors
  000c1	83 c4 18	 add	 esp, 24			; 00000018H

; 689  : 
; 690  : 			pImPos = (DWORD *) ((DWORD) pBase + x*16 + (y*4) * nWidth * 4);

  000c4	8b 45 f4	 mov	 eax, DWORD PTR _x$[ebp]
  000c7	c1 e0 04	 shl	 eax, 4
  000ca	03 45 d0	 add	 eax, DWORD PTR _pBase$[ebp]
  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _y$[ebp]
  000d0	c1 e1 02	 shl	 ecx, 2
  000d3	0f af 4d e8	 imul	 ecx, DWORD PTR _nWidth$[ebp]
  000d7	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
  000da	89 45 bc	 mov	 DWORD PTR _pImPos$[ebp], eax

; 691  : 			DecodeColorBlock(pImPos, pBlock, nWidth, (DWORD *)&col_0, (DWORD *)&col_1, (DWORD *)&col_2, (DWORD *)&col_3);

  000dd	8d 45 cc	 lea	 eax, DWORD PTR _col_3$[ebp]
  000e0	50		 push	 eax
  000e1	8d 45 c8	 lea	 eax, DWORD PTR _col_2$[ebp]
  000e4	50		 push	 eax
  000e5	8d 45 c4	 lea	 eax, DWORD PTR _col_1$[ebp]
  000e8	50		 push	 eax
  000e9	8d 45 c0	 lea	 eax, DWORD PTR _col_0$[ebp]
  000ec	50		 push	 eax
  000ed	ff 75 e8	 push	 DWORD PTR _nWidth$[ebp]
  000f0	ff 75 f0	 push	 DWORD PTR _pBlock$[ebp]
  000f3	ff 75 bc	 push	 DWORD PTR _pImPos$[ebp]
  000f6	e8 00 00 00 00	 call	 ?DecodeColorBlock@@YAXPAKPAUDXTColBlock@@H0000@Z ; DecodeColorBlock
  000fb	83 c4 1c	 add	 esp, 28			; 0000001cH

; 692  : 			// Set to RGB test pattern
; 693  : 			//	pImPos = (DWORD*) ((DWORD) pBase + i * 4 + j * m_nWidth * 4);
; 694  : 			//	*pImPos = ((i * 4) << 16) | ((j * 4) << 8) | ((63 - i) * 4);
; 695  : 
; 696  : 			// checkerboard of only col_0 and col_1 basis colors:
; 697  : 			//	pImPos = (DWORD *) ((DWORD) pBase + i * 8 + j * m_nWidth * 8);
; 698  : 			//	*pImPos = *((DWORD *) &col_0);
; 699  : 			//	pImPos += 1 + m_nWidth;
; 700  : 			//	*pImPos = *((DWORD *) &col_1);
; 701  : 		}

  000fe	eb 8d		 jmp	 SHORT $LN5@Decompress
$LN6@Decompress:

; 702  : 	}

  00100	e9 5f ff ff ff	 jmp	 $LN2@Decompress
$LN1@Decompress:

; 703  : }

  00105	c9		 leave
  00106	c2 08 00	 ret	 8
?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z ENDP		; CDXTCImage::DecompressDXT1
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Decompress@CDXTCImage@@QAEXHPAK@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
_miplevel$ = 8						; size = 4
_pdwDest$ = 12						; size = 4
?Decompress@CDXTCImage@@QAEXHPAK@Z PROC			; CDXTCImage::Decompress, COMDAT
; _this$ = ecx

; 315  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 316  : 	switch (m_CompFormat)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 ec 00 00
	00		 mov	 eax, DWORD PTR [eax+236]
  00011	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  00014	83 7d f8 00	 cmp	 DWORD PTR tv65[ebp], 0
  00018	74 44		 je	 SHORT $LN7@Decompress
  0001a	83 7d f8 01	 cmp	 DWORD PTR tv65[ebp], 1
  0001e	74 0e		 je	 SHORT $LN4@Decompress
  00020	83 7d f8 03	 cmp	 DWORD PTR tv65[ebp], 3
  00024	74 18		 je	 SHORT $LN5@Decompress
  00026	83 7d f8 05	 cmp	 DWORD PTR tv65[ebp], 5
  0002a	74 22		 je	 SHORT $LN6@Decompress
  0002c	eb 3e		 jmp	 SHORT $LN1@Decompress
$LN4@Decompress:

; 317  : 	{
; 318  : 		case PF_DXT1:
; 319  : 			DecompressDXT1(miplevel, pdwDest);

  0002e	ff 75 0c	 push	 DWORD PTR _pdwDest$[ebp]
  00031	ff 75 08	 push	 DWORD PTR _miplevel$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?DecompressDXT1@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT1

; 320  : 			break;

  0003c	eb 2e		 jmp	 SHORT $LN1@Decompress
$LN5@Decompress:

; 321  : 
; 322  : 		case PF_DXT3:
; 323  : 			DecompressDXT3(miplevel, pdwDest);

  0003e	ff 75 0c	 push	 DWORD PTR _pdwDest$[ebp]
  00041	ff 75 08	 push	 DWORD PTR _miplevel$[ebp]
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?DecompressDXT3@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT3

; 324  : 			break;

  0004c	eb 1e		 jmp	 SHORT $LN1@Decompress
$LN6@Decompress:

; 325  : 			
; 326  : 		case PF_DXT5:
; 327  : 			DecompressDXT5(miplevel, pdwDest);

  0004e	ff 75 0c	 push	 DWORD PTR _pdwDest$[ebp]
  00051	ff 75 08	 push	 DWORD PTR _miplevel$[ebp]
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?DecompressDXT5@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressDXT5

; 328  : 			break;

  0005c	eb 0e		 jmp	 SHORT $LN1@Decompress
$LN7@Decompress:

; 329  : 			
; 330  : 		case PF_ARGB:
; 331  : 			DecompressARGB(miplevel, pdwDest);

  0005e	ff 75 0c	 push	 DWORD PTR _pdwDest$[ebp]
  00061	ff 75 08	 push	 DWORD PTR _miplevel$[ebp]
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?DecompressARGB@CDXTCImage@@QAEXHPAK@Z ; CDXTCImage::DecompressARGB
$LN1@Decompress:

; 332  : 			break;
; 333  : 
; 334  : 		case PF_UNKNOWN:
; 335  : 			break;
; 336  : 	}
; 337  : }

  0006c	c9		 leave
  0006d	c2 08 00	 ret	 8
?Decompress@CDXTCImage@@QAEXHPAK@Z ENDP			; CDXTCImage::Decompress
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Copy@CDXTCImage@@QAE_NHPAEJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_miplevel$ = 8						; size = 4
_pbDest$ = 12						; size = 4
_lDestPitch$ = 16					; size = 4
?Copy@CDXTCImage@@QAE_NHPAEJ@Z PROC			; CDXTCImage::Copy, COMDAT
; _this$ = ecx

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 262  : 	if (!(m_dwFlags & DDSD_MIPMAPCOUNT))

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 fc 00 00
	00		 mov	 eax, DWORD PTR [eax+252]
  00010	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00015	75 0a		 jne	 SHORT $LN2@Copy

; 263  : 		if (miplevel)

  00017	83 7d 08 00	 cmp	 DWORD PTR _miplevel$[ebp], 0
  0001b	74 04		 je	 SHORT $LN2@Copy

; 264  : 			return false;

  0001d	32 c0		 xor	 al, al
  0001f	eb 31		 jmp	 SHORT $LN1@Copy
$LN2@Copy:

; 265  : 
; 266  : 	/*
; 267  : 	DXTColBlock * pBlock;
; 268  : 	WORD * pPos = (WORD *) &m_pbCompBufferByLevels[miplevel][0];
; 269  : 	int xblocks = (m_nWidth >> miplevel) / 4;
; 270  : 	int yblocks = (m_nHeight >> miplevel) / 4;
; 271  : 
; 272  : 	for (int y = 0; y < yblocks; ++y)
; 273  : 	{
; 274  : 		// 8 bytes per block
; 275  : 		pBlock = (DXTColBlock*) ((DWORD) pPos + y * xblocks * 8);
; 276  : 
; 277  : 		memcpy(pbDest, pBlock, xblocks * 8);
; 278  : 		pbDest += lDestPitch;
; 279  : 	}
; 280  : 	*/
; 281  : 
; 282  : 	memcpy(pbDest, m_pbCompBufferByLevels[miplevel], m_lPitch >> (miplevel * 2));

  00021	8b 4d 08	 mov	 ecx, DWORD PTR _miplevel$[ebp]
  00024	d1 e1		 shl	 ecx, 1
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 80 f0 00 00
	00		 mov	 eax, DWORD PTR [eax+240]
  0002f	d3 f8		 sar	 eax, cl
  00031	50		 push	 eax
  00032	8b 45 08	 mov	 eax, DWORD PTR _miplevel$[ebp]
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	ff 74 81 04	 push	 DWORD PTR [ecx+eax*4+4]
  0003c	ff 75 0c	 push	 DWORD PTR _pbDest$[ebp]
  0003f	e8 00 00 00 00	 call	 _memcpy
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH

; 283  : 	pbDest += lDestPitch;

  00047	8b 45 0c	 mov	 eax, DWORD PTR _pbDest$[ebp]
  0004a	03 45 10	 add	 eax, DWORD PTR _lDestPitch$[ebp]
  0004d	89 45 0c	 mov	 DWORD PTR _pbDest$[ebp], eax

; 284  : 	return true;

  00050	b0 01		 mov	 al, 1
$LN1@Copy:

; 285  : }

  00052	c9		 leave
  00053	c2 0c 00	 ret	 12			; 0000000cH
?Copy@CDXTCImage@@QAE_NHPAEJ@Z ENDP			; CDXTCImage::Copy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z
_TEXT	SEGMENT
_dwMagic$ = -36						; size = 4
tv137 = -32						; size = 4
tv71 = -28						; size = 4
_dwLinearSize$1 = -24					; size = 4
_i$2 = -20						; size = 4
_this$ = -16						; size = 4
_ddsd$ = -12						; size = 124
__$ArrayPad$ = 112					; size = 4
_c_pbMap$ = 124						; size = 4
?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z PROC	; CDXTCImage::LoadHeaderFromMemory, COMDAT
; _this$ = ecx

; 131  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 8c	 lea	 ebp, DWORD PTR [esp-116]
  00005	81 ec 98 00 00
	00		 sub	 esp, 152		; 00000098H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 70	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 132  : 	//////////////////////////////////////
; 133  : 	// start reading the file
; 134  : 	// from Microsoft's mssdk D3DIM example "Compress"
; 135  : 	DWORD dwMagic;
; 136  : 	
; 137  : 	// Read magic number
; 138  : 	dwMagic = *(DWORD *) c_pbMap;

  00018	8b 45 7c	 mov	 eax, DWORD PTR _c_pbMap$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	89 45 dc	 mov	 DWORD PTR _dwMagic$[ebp], eax

; 139  : 	c_pbMap += sizeof(DWORD);

  00020	8b 45 7c	 mov	 eax, DWORD PTR _c_pbMap$[ebp]
  00023	83 c0 04	 add	 eax, 4
  00026	89 45 7c	 mov	 DWORD PTR _c_pbMap$[ebp], eax

; 140  : 
; 141  : //!@#
; 142  : //	if (dwMagic != MAKEFOURCC('D','D','S',' '))
; 143  : //		return false;
; 144  : 	
; 145  : 	DDSURFACEDESC2 ddsd; // read from dds file
; 146  : 	
; 147  : 	// Read the surface description
; 148  : 	memcpy(&ddsd, c_pbMap, sizeof(DDSURFACEDESC2));

  00029	6a 7c		 push	 124			; 0000007cH
  0002b	ff 75 7c	 push	 DWORD PTR _c_pbMap$[ebp]
  0002e	8d 45 f4	 lea	 eax, DWORD PTR _ddsd$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _memcpy
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH

; 149  : 	c_pbMap += sizeof(DDSURFACEDESC2);

  0003a	8b 45 7c	 mov	 eax, DWORD PTR _c_pbMap$[ebp]
  0003d	83 c0 7c	 add	 eax, 124		; 0000007cH
  00040	89 45 7c	 mov	 DWORD PTR _c_pbMap$[ebp], eax

; 150  : 	
; 151  : 	// Does texture have mipmaps?
; 152  : 	m_bMipTexture = (ddsd.dwMipMapCount > 0) ? TRUE : FALSE;

  00043	83 7d 0c 00	 cmp	 DWORD PTR _ddsd$[ebp+24], 0
  00047	76 09		 jbe	 SHORT $LN12@LoadHeader
  00049	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00050	eb 04		 jmp	 SHORT $LN13@LoadHeader
$LN12@LoadHeader:
  00052	83 65 e4 00	 and	 DWORD PTR tv71[ebp], 0
$LN13@LoadHeader:
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8a 4d e4	 mov	 cl, BYTE PTR tv71[ebp]
  0005c	88 88 f8 00 00
	00		 mov	 BYTE PTR [eax+248], cl

; 153  : 	
; 154  : 	// Clear unwanted flags
; 155  : 	// Can't do this!!!  surface not re-created here
; 156  : 	//    ddsd.dwFlags &= (~DDSD_PITCH);
; 157  : 	//    ddsd.dwFlags &= (~DDSD_LINEARSIZE);
; 158  : 
; 159  : 	// Is it DXTC ?
; 160  : 	// I sure hope pixelformat is valid!
; 161  : 	m_xddPixelFormat.dwFlags = ddsd.ddpfPixelFormat.dwFlags;

  00062	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b 4d 40	 mov	 ecx, DWORD PTR _ddsd$[ebp+76]
  00068	89 88 0c 01 00
	00		 mov	 DWORD PTR [eax+268], ecx

; 162  : 	m_xddPixelFormat.dwFourCC = ddsd.ddpfPixelFormat.dwFourCC;

  0006e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00071	8b 4d 44	 mov	 ecx, DWORD PTR _ddsd$[ebp+80]
  00074	89 88 10 01 00
	00		 mov	 DWORD PTR [eax+272], ecx

; 163  : 	m_xddPixelFormat.dwSize = ddsd.ddpfPixelFormat.dwSize;

  0007a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	8b 4d 3c	 mov	 ecx, DWORD PTR _ddsd$[ebp+72]
  00080	89 88 08 01 00
	00		 mov	 DWORD PTR [eax+264], ecx

; 164  : 	m_xddPixelFormat.dwRGBBitCount = ddsd.ddpfPixelFormat.dwRGBBitCount;

  00086	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00089	8b 4d 48	 mov	 ecx, DWORD PTR _ddsd$[ebp+84]
  0008c	89 88 14 01 00
	00		 mov	 DWORD PTR [eax+276], ecx

; 165  : 	m_xddPixelFormat.dwRGBAlphaBitMask = ddsd.ddpfPixelFormat.dwRGBAlphaBitMask;

  00092	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00095	8b 4d 58	 mov	 ecx, DWORD PTR _ddsd$[ebp+100]
  00098	89 88 24 01 00
	00		 mov	 DWORD PTR [eax+292], ecx

; 166  : 	m_xddPixelFormat.dwRBitMask = ddsd.ddpfPixelFormat.dwRBitMask;

  0009e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b 4d 4c	 mov	 ecx, DWORD PTR _ddsd$[ebp+88]
  000a4	89 88 18 01 00
	00		 mov	 DWORD PTR [eax+280], ecx

; 167  : 	m_xddPixelFormat.dwGBitMask = ddsd.ddpfPixelFormat.dwGBitMask;

  000aa	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 4d 50	 mov	 ecx, DWORD PTR _ddsd$[ebp+92]
  000b0	89 88 1c 01 00
	00		 mov	 DWORD PTR [eax+284], ecx

; 168  : 	m_xddPixelFormat.dwBBitMask = ddsd.ddpfPixelFormat.dwBBitMask;

  000b6	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b 4d 54	 mov	 ecx, DWORD PTR _ddsd$[ebp+96]
  000bc	89 88 20 01 00
	00		 mov	 DWORD PTR [eax+288], ecx

; 169  : 
; 170  : 	DecodePixelFormat(m_strFormat, &m_xddPixelFormat);

  000c2	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	05 08 01 00 00	 add	 eax, 264		; 00000108H
  000ca	50		 push	 eax
  000cb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	05 cc 00 00 00	 add	 eax, 204		; 000000ccH
  000d3	50		 push	 eax
  000d4	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?DecodePixelFormat@CDXTCImage@@QAEXPADPAU_XDDPIXELFORMAT@@@Z ; CDXTCImage::DecodePixelFormat

; 171  : 	
; 172  : 	if (m_CompFormat != PF_DXT1 &&
; 173  : 		m_CompFormat != PF_DXT3 &&

  000dc	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	83 b8 ec 00 00
	00 01		 cmp	 DWORD PTR [eax+236], 1
  000e6	74 1f		 je	 SHORT $LN5@LoadHeader
  000e8	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000eb	83 b8 ec 00 00
	00 03		 cmp	 DWORD PTR [eax+236], 3
  000f2	74 13		 je	 SHORT $LN5@LoadHeader
  000f4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	83 b8 ec 00 00
	00 05		 cmp	 DWORD PTR [eax+236], 5
  000fe	74 07		 je	 SHORT $LN5@LoadHeader

; 174  : 		m_CompFormat != PF_DXT5)
; 175  : 	{
; 176  : 		return false;

  00100	32 c0		 xor	 al, al
  00102	e9 e4 00 00 00	 jmp	 $LN1@LoadHeader
$LN5@LoadHeader:

; 177  : 	}
; 178  : 
; 179  : 	if (ddsd.dwMipMapCount > MAX_MIPLEVELS)

  00107	83 7d 0c 0c	 cmp	 DWORD PTR _ddsd$[ebp+24], 12 ; 0000000cH
  0010b	76 07		 jbe	 SHORT $LN6@LoadHeader

; 180  : 		ddsd.dwMipMapCount = MAX_MIPLEVELS;

  0010d	c7 45 0c 0c 00
	00 00		 mov	 DWORD PTR _ddsd$[ebp+24], 12 ; 0000000cH
$LN6@LoadHeader:

; 181  : 
; 182  : 	m_nWidth		= ddsd.dwWidth;

  00114	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00117	8b 4d 00	 mov	 ecx, DWORD PTR _ddsd$[ebp+12]
  0011a	89 88 00 01 00
	00		 mov	 DWORD PTR [eax+256], ecx

; 183  : 	m_nHeight		= ddsd.dwHeight;

  00120	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00123	8b 4d fc	 mov	 ecx, DWORD PTR _ddsd$[ebp+8]
  00126	89 88 04 01 00
	00		 mov	 DWORD PTR [eax+260], ecx

; 184  : 	//!@#
; 185  : 	m_dwMipMapCount = max(1, ddsd.dwMipMapCount);

  0012c	83 7d 0c 01	 cmp	 DWORD PTR _ddsd$[ebp+24], 1
  00130	73 09		 jae	 SHORT $LN14@LoadHeader
  00132	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
  00139	eb 06		 jmp	 SHORT $LN15@LoadHeader
$LN14@LoadHeader:
  0013b	8b 45 0c	 mov	 eax, DWORD PTR _ddsd$[ebp+24]
  0013e	89 45 e0	 mov	 DWORD PTR tv137[ebp], eax
$LN15@LoadHeader:
  00141	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00144	8b 4d e0	 mov	 ecx, DWORD PTR tv137[ebp]
  00147	89 88 f4 00 00
	00		 mov	 DWORD PTR [eax+244], ecx

; 186  : 	m_dwFlags		= ddsd.dwFlags;

  0014d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00150	8b 4d f8	 mov	 ecx, DWORD PTR _ddsd$[ebp+4]
  00153	89 88 fc 00 00
	00		 mov	 DWORD PTR [eax+252], ecx

; 187  : 
; 188  : 	if (ddsd.dwFlags & DDSD_PITCH)

  00159	8b 45 f8	 mov	 eax, DWORD PTR _ddsd$[ebp+4]
  0015c	83 e0 08	 and	 eax, 8
  0015f	74 1e		 je	 SHORT $LN7@LoadHeader

; 189  : 	{
; 190  : 		m_lPitch = ddsd.lPitch;

  00161	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00164	8b 4d 04	 mov	 ecx, DWORD PTR _ddsd$[ebp+16]
  00167	89 88 f0 00 00
	00		 mov	 DWORD PTR [eax+240], ecx

; 191  : 		m_pbCompBufferByLevels[0] = c_pbMap;

  0016d	6a 04		 push	 4
  0016f	58		 pop	 eax
  00170	6b c0 00	 imul	 eax, eax, 0
  00173	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	8b 55 7c	 mov	 edx, DWORD PTR _c_pbMap$[ebp]
  00179	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx

; 192  : 	}

  0017d	eb 6a		 jmp	 SHORT $LN8@LoadHeader
$LN7@LoadHeader:

; 193  : 	else
; 194  : 	{
; 195  : 		m_lPitch = ddsd.dwLinearSize;

  0017f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00182	8b 4d 04	 mov	 ecx, DWORD PTR _ddsd$[ebp+16]
  00185	89 88 f0 00 00
	00		 mov	 DWORD PTR [eax+240], ecx

; 196  : 
; 197  : 		if (ddsd.dwFlags & DDSD_MIPMAPCOUNT)

  0018b	8b 45 f8	 mov	 eax, DWORD PTR _ddsd$[ebp+4]
  0018e	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00193	74 44		 je	 SHORT $LN9@LoadHeader

; 198  : 		{
; 199  : 			for (DWORD dwLinearSize = ddsd.dwLinearSize, i = 0; i < m_dwMipMapCount; ++i, dwLinearSize >>= 2)

  00195	8b 45 04	 mov	 eax, DWORD PTR _ddsd$[ebp+16]
  00198	89 45 e8	 mov	 DWORD PTR _dwLinearSize$1[ebp], eax
  0019b	83 65 ec 00	 and	 DWORD PTR _i$2[ebp], 0
  0019f	eb 10		 jmp	 SHORT $LN4@LoadHeader
$LN2@LoadHeader:
  001a1	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  001a4	40		 inc	 eax
  001a5	89 45 ec	 mov	 DWORD PTR _i$2[ebp], eax
  001a8	8b 45 e8	 mov	 eax, DWORD PTR _dwLinearSize$1[ebp]
  001ab	c1 e8 02	 shr	 eax, 2
  001ae	89 45 e8	 mov	 DWORD PTR _dwLinearSize$1[ebp], eax
$LN4@LoadHeader:
  001b1	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  001b4	8b 4d ec	 mov	 ecx, DWORD PTR _i$2[ebp]
  001b7	3b 88 f4 00 00
	00		 cmp	 ecx, DWORD PTR [eax+244]
  001bd	73 18		 jae	 SHORT $LN3@LoadHeader

; 200  : 			{
; 201  : 				m_pbCompBufferByLevels[i] = c_pbMap;

  001bf	8b 45 ec	 mov	 eax, DWORD PTR _i$2[ebp]
  001c2	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c5	8b 55 7c	 mov	 edx, DWORD PTR _c_pbMap$[ebp]
  001c8	89 54 81 04	 mov	 DWORD PTR [ecx+eax*4+4], edx

; 202  : 				c_pbMap += dwLinearSize;

  001cc	8b 45 7c	 mov	 eax, DWORD PTR _c_pbMap$[ebp]
  001cf	03 45 e8	 add	 eax, DWORD PTR _dwLinearSize$1[ebp]
  001d2	89 45 7c	 mov	 DWORD PTR _c_pbMap$[ebp], eax

; 203  : 			}

  001d5	eb ca		 jmp	 SHORT $LN2@LoadHeader
$LN3@LoadHeader:

; 204  : 		}

  001d7	eb 10		 jmp	 SHORT $LN8@LoadHeader
$LN9@LoadHeader:

; 205  : 		else
; 206  : 		{
; 207  : 			m_pbCompBufferByLevels[0] = c_pbMap;

  001d9	6a 04		 push	 4
  001db	58		 pop	 eax
  001dc	6b c0 00	 imul	 eax, eax, 0
  001df	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  001e2	8b 55 7c	 mov	 edx, DWORD PTR _c_pbMap$[ebp]
  001e5	89 54 01 04	 mov	 DWORD PTR [ecx+eax+4], edx
$LN8@LoadHeader:

; 208  : 		}
; 209  : 	}
; 210  : 
; 211  : 	return true;

  001e9	b0 01		 mov	 al, 1
$LN1@LoadHeader:

; 212  : }

  001eb	8b 4d 70	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001ee	33 cd		 xor	 ecx, ebp
  001f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001f5	83 c5 74	 add	 ebp, 116		; 00000074H
  001f8	c9		 leave
  001f9	c2 04 00	 ret	 4
?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z ENDP	; CDXTCImage::LoadHeaderFromMemory
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z
_TEXT	SEGMENT
$T1 = -56						; size = 4
__My_data$2 = -52					; size = 4
__Newsize$ = -48					; size = 4
$T3 = -44						; size = 4
__My_data$4 = -40					; size = 4
__My_data$5 = -36					; size = 4
__Newsize$ = -32					; size = 4
_dwBytesPerRow$6 = -28					; size = 4
_pDest$7 = -24						; size = 4
_yp$8 = -20						; size = 4
_dwLinearSize$9 = -16					; size = 4
_i$10 = -12						; size = 4
_this$ = -8						; size = 4
$T11 = -3						; size = 1
$T12 = -2						; size = 1
$T13 = -1						; size = 1
_c_pbMap$ = 8						; size = 4
?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z PROC		; CDXTCImage::LoadFromMemory, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 	if (!LoadHeaderFromMemory(c_pbMap))

  00009	ff 75 08	 push	 DWORD PTR _c_pbMap$[ebp]
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?LoadHeaderFromMemory@CDXTCImage@@QAE_NPBE@Z ; CDXTCImage::LoadHeaderFromMemory
  00014	0f b6 c0	 movzx	 eax, al
  00017	85 c0		 test	 eax, eax
  00019	75 07		 jne	 SHORT $LN8@LoadFromMe

; 218  : 		return false;

  0001b	32 c0		 xor	 al, al
  0001d	e9 d7 01 00 00	 jmp	 $LN1@LoadFromMe
$LN8@LoadFromMe:

; 219  : 
; 220  : 	if (m_dwFlags & DDSD_PITCH)

  00022	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 80 fc 00 00
	00		 mov	 eax, DWORD PTR [eax+252]
  0002b	83 e0 08	 and	 eax, 8
  0002e	0f 84 e4 00 00
	00		 je	 $LN9@LoadFromMe

; 221  : 	{
; 222  : 		DWORD dwBytesPerRow = m_nWidth * m_xddPixelFormat.dwRGBBitCount / 8;

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [eax+256]
  00040	0f af 81 14 01
	00 00		 imul	 eax, DWORD PTR [ecx+276]
  00047	c1 e8 03	 shr	 eax, 3
  0004a	89 45 e4	 mov	 DWORD PTR _dwBytesPerRow$6[ebp], eax

; 223  : 
; 224  : 		m_nCompSize = m_lPitch * m_nHeight;

  0004d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	8b 80 f0 00 00
	00		 mov	 eax, DWORD PTR [eax+240]
  00059	0f af 81 04 01
	00 00		 imul	 eax, DWORD PTR [ecx+260]
  00060	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	89 81 c4 00 00
	00		 mov	 DWORD PTR [ecx+196], eax

; 225  : 		m_nCompLineSz = dwBytesPerRow;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 4d e4	 mov	 ecx, DWORD PTR _dwBytesPerRow$6[ebp]
  0006f	89 88 c8 00 00
	00		 mov	 DWORD PTR [eax+200], ecx

; 227  : 		m_bCompVector[0].resize(m_nCompSize);

  00075	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	8b 80 c4 00 00
	00		 mov	 eax, DWORD PTR [eax+196]
  0007e	89 45 e0	 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00081	8d 45 ff	 lea	 eax, DWORD PTR $T13[ebp]
  00084	50		 push	 eax
  00085	ff 75 e0	 push	 DWORD PTR __Newsize$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 227  : 		m_bCompVector[0].resize(m_nCompSize);

  00088	6a 0c		 push	 12			; 0000000cH
  0008a	58		 pop	 eax
  0008b	6b c0 00	 imul	 eax, eax, 0
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	8d 4c 01 34	 lea	 ecx, DWORD PTR [ecx+eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00095	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 228  : 		BYTE * pDest = &m_bCompVector[0][0];

  0009a	6a 0c		 push	 12			; 0000000cH
  0009c	58		 pop	 eax
  0009d	6b c0 00	 imul	 eax, eax, 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  000a0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	8d 44 01 34	 lea	 eax, DWORD PTR [ecx+eax+52]
  000a7	89 45 dc	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  000aa	33 c0		 xor	 eax, eax
  000ac	c1 e0 00	 shl	 eax, 0
  000af	8b 4d dc	 mov	 ecx, DWORD PTR __My_data$5[ebp]
  000b2	03 01		 add	 eax, DWORD PTR [ecx]
  000b4	89 45 e8	 mov	 DWORD PTR _pDest$7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 230  : 		c_pbMap = m_pbCompBufferByLevels[0];

  000b7	6a 04		 push	 4
  000b9	58		 pop	 eax
  000ba	6b c0 00	 imul	 eax, eax, 0
  000bd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c0	8b 44 01 04	 mov	 eax, DWORD PTR [ecx+eax+4]
  000c4	89 45 08	 mov	 DWORD PTR _c_pbMap$[ebp], eax

; 231  : 
; 232  : 		for (int yp = 0; yp < m_nHeight; ++yp)

  000c7	83 65 ec 00	 and	 DWORD PTR _yp$8[ebp], 0
  000cb	eb 07		 jmp	 SHORT $LN4@LoadFromMe
$LN2@LoadFromMe:
  000cd	8b 45 ec	 mov	 eax, DWORD PTR _yp$8[ebp]
  000d0	40		 inc	 eax
  000d1	89 45 ec	 mov	 DWORD PTR _yp$8[ebp], eax
$LN4@LoadFromMe:
  000d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	8b 4d ec	 mov	 ecx, DWORD PTR _yp$8[ebp]
  000da	3b 88 04 01 00
	00		 cmp	 ecx, DWORD PTR [eax+260]
  000e0	7d 31		 jge	 SHORT $LN3@LoadFromMe

; 233  : 		{
; 234  : 			memcpy(pDest, c_pbMap, dwBytesPerRow);

  000e2	ff 75 e4	 push	 DWORD PTR _dwBytesPerRow$6[ebp]
  000e5	ff 75 08	 push	 DWORD PTR _c_pbMap$[ebp]
  000e8	ff 75 e8	 push	 DWORD PTR _pDest$7[ebp]
  000eb	e8 00 00 00 00	 call	 _memcpy
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 235  : 			pDest += m_lPitch;

  000f3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	8b 4d e8	 mov	 ecx, DWORD PTR _pDest$7[ebp]
  000f9	03 88 f0 00 00
	00		 add	 ecx, DWORD PTR [eax+240]
  000ff	89 4d e8	 mov	 DWORD PTR _pDest$7[ebp], ecx

; 236  : 			c_pbMap += m_lPitch;

  00102	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00105	8b 4d 08	 mov	 ecx, DWORD PTR _c_pbMap$[ebp]
  00108	03 88 f0 00 00
	00		 add	 ecx, DWORD PTR [eax+240]
  0010e	89 4d 08	 mov	 DWORD PTR _c_pbMap$[ebp], ecx

; 237  : 		}

  00111	eb ba		 jmp	 SHORT $LN2@LoadFromMe
$LN3@LoadFromMe:

; 238  : 	}

  00113	e9 df 00 00 00	 jmp	 $LN10@LoadFromMe
$LN9@LoadFromMe:

; 239  : 	else
; 240  : 	{
; 241  : 		if (m_dwFlags & DDSD_MIPMAPCOUNT)

  00118	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0011b	8b 80 fc 00 00
	00		 mov	 eax, DWORD PTR [eax+252]
  00121	25 00 00 02 00	 and	 eax, 131072		; 00020000H
  00126	74 77		 je	 SHORT $LN11@LoadFromMe

; 242  : 		{
; 243  : 			for (DWORD dwLinearSize = m_lPitch, i = 0; i < m_dwMipMapCount; ++i, dwLinearSize >>= 2)

  00128	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0012b	8b 80 f0 00 00
	00		 mov	 eax, DWORD PTR [eax+240]
  00131	89 45 f0	 mov	 DWORD PTR _dwLinearSize$9[ebp], eax
  00134	83 65 f4 00	 and	 DWORD PTR _i$10[ebp], 0
  00138	eb 10		 jmp	 SHORT $LN7@LoadFromMe
$LN5@LoadFromMe:
  0013a	8b 45 f4	 mov	 eax, DWORD PTR _i$10[ebp]
  0013d	40		 inc	 eax
  0013e	89 45 f4	 mov	 DWORD PTR _i$10[ebp], eax
  00141	8b 45 f0	 mov	 eax, DWORD PTR _dwLinearSize$9[ebp]
  00144	c1 e8 02	 shr	 eax, 2
  00147	89 45 f0	 mov	 DWORD PTR _dwLinearSize$9[ebp], eax
$LN7@LoadFromMe:
  0014a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0014d	8b 4d f4	 mov	 ecx, DWORD PTR _i$10[ebp]
  00150	3b 88 f4 00 00
	00		 cmp	 ecx, DWORD PTR [eax+244]
  00156	73 45		 jae	 SHORT $LN6@LoadFromMe
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  00158	8d 45 fe	 lea	 eax, DWORD PTR $T12[ebp]
  0015b	50		 push	 eax
  0015c	ff 75 f0	 push	 DWORD PTR _dwLinearSize$9[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 245  : 				m_bCompVector[i].resize(dwLinearSize);

  0015f	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$10[ebp], 12
  00163	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	8d 4c 01 34	 lea	 ecx, DWORD PTR [ecx+eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  0016a	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 246  : 				Copy(i, &m_bCompVector[i][0], dwLinearSize);

  0016f	6b 45 f4 0c	 imul	 eax, DWORD PTR _i$10[ebp], 12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  00173	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	8d 44 01 34	 lea	 eax, DWORD PTR [ecx+eax+52]
  0017a	89 45 d8	 mov	 DWORD PTR __My_data$4[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  0017d	33 c0		 xor	 eax, eax
  0017f	c1 e0 00	 shl	 eax, 0
  00182	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  00185	03 01		 add	 eax, DWORD PTR [ecx]
  00187	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 246  : 				Copy(i, &m_bCompVector[i][0], dwLinearSize);

  0018a	ff 75 f0	 push	 DWORD PTR _dwLinearSize$9[ebp]
  0018d	ff 75 d4	 push	 DWORD PTR $T3[ebp]
  00190	ff 75 f4	 push	 DWORD PTR _i$10[ebp]
  00193	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00196	e8 00 00 00 00	 call	 ?Copy@CDXTCImage@@QAE_NHPAEJ@Z ; CDXTCImage::Copy

; 247  : 			}

  0019b	eb 9d		 jmp	 SHORT $LN5@LoadFromMe
$LN6@LoadFromMe:

; 248  : 		}

  0019d	eb 58		 jmp	 SHORT $LN10@LoadFromMe
$LN11@LoadFromMe:

; 251  : 			m_bCompVector[0].resize(m_lPitch);

  0019f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001a2	8b 80 f0 00 00
	00		 mov	 eax, DWORD PTR [eax+240]
  001a8	89 45 d0	 mov	 DWORD PTR __Newsize$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  001ab	8d 45 fd	 lea	 eax, DWORD PTR $T11[ebp]
  001ae	50		 push	 eax
  001af	ff 75 d0	 push	 DWORD PTR __Newsize$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 251  : 			m_bCompVector[0].resize(m_lPitch);

  001b2	6a 0c		 push	 12			; 0000000cH
  001b4	58		 pop	 eax
  001b5	6b c0 00	 imul	 eax, eax, 0
  001b8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	8d 4c 01 34	 lea	 ecx, DWORD PTR [ecx+eax+52]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1242 :         _Resize(_Newsize, _Value_init_tag{});

  001bf	e8 00 00 00 00	 call	 ??$_Resize@U_Value_init_tag@std@@@?$vector@EV?$allocator@E@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<unsigned char,std::allocator<unsigned char> >::_Resize<std::_Value_init_tag>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 252  : 			Copy(0, &m_bCompVector[0][0], m_lPitch);

  001c4	6a 0c		 push	 12			; 0000000cH
  001c6	58		 pop	 eax
  001c7	6b c0 00	 imul	 eax, eax, 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  001ca	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	8d 44 01 34	 lea	 eax, DWORD PTR [ecx+eax+52]
  001d1	89 45 cc	 mov	 DWORD PTR __My_data$2[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  001d4	33 c0		 xor	 eax, eax
  001d6	c1 e0 00	 shl	 eax, 0
  001d9	8b 4d cc	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  001dc	03 01		 add	 eax, DWORD PTR [ecx]
  001de	89 45 c8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 252  : 			Copy(0, &m_bCompVector[0][0], m_lPitch);

  001e1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001e4	ff b0 f0 00 00
	00		 push	 DWORD PTR [eax+240]
  001ea	ff 75 c8	 push	 DWORD PTR $T1[ebp]
  001ed	6a 00		 push	 0
  001ef	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f2	e8 00 00 00 00	 call	 ?Copy@CDXTCImage@@QAE_NHPAEJ@Z ; CDXTCImage::Copy
$LN10@LoadFromMe:

; 253  : 		}
; 254  : 	}
; 255  : 
; 256  : 	// done reading file
; 257  : 	return true;

  001f7	b0 01		 mov	 al, 1
$LN1@LoadFromMe:

; 258  : }

  001f9	c9		 leave
  001fa	c2 04 00	 ret	 4
?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z ENDP		; CDXTCImage::LoadFromMemory
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
_pvMap$ = -40						; size = 4
_found$2 = -36						; size = 4
__SubString$ = -32					; size = 4
_exts$ = -28						; size = 4
_next$ = -24						; size = 4
_i$ = -20						; size = 4
$T3 = -15						; size = 1
$T4 = -14						; size = 1
_knownformat$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_mappedFile$ = 0					; size = 324
__$ArrayPad$ = 324					; size = 4
_filename$ = 336					; size = 4
?LoadFromFile@CDXTCImage@@QAE_NPBD@Z PROC		; CDXTCImage::LoadFromFile, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8d ac 24 b8 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-328]
  00008	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  0000e	6a ff		 push	 -1
  00010	68 00 00 00 00	 push	 __ehhandler$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
  00015	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  0001b	50		 push	 eax
  0001c	83 ec 20	 sub	 esp, 32			; 00000020H
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 85 44 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 88   : 	// only understands .dds files for now
; 89   : 	// return true if success
; 90   : 	char * exts[] = { ".DDS" };

  00039	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _exts$[ebp], OFFSET ??_C@_04LFFPHNGG@?4DDS@

; 91   : 	int next = 1;

  00040	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _next$[ebp], 1

; 92   : 	
; 93   : 	static char fileupper[MAX_PATH+1];
; 94   : 	
; 95   : 	strncpy(fileupper, filename, MAX_PATH); 

  00047	68 04 01 00 00	 push	 260			; 00000104H
  0004c	ff b5 50 01 00
	00		 push	 DWORD PTR _filename$[ebp]
  00052	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  00057	e8 00 00 00 00	 call	 _strncpy
  0005c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 96   : 	strupr(fileupper);

  0005f	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  00064	e8 00 00 00 00	 call	 _strupr
  00069	59		 pop	 ecx

; 97   : 	
; 98   : 	int i;
; 99   : 	bool knownformat = false;

  0006a	c6 45 f3 00	 mov	 BYTE PTR _knownformat$[ebp], 0

; 100  : 	
; 101  : 	for (i = 0; i < next; ++i)

  0006e	83 65 ec 00	 and	 DWORD PTR _i$[ebp], 0
  00072	eb 07		 jmp	 SHORT $LN4@LoadFromFi
$LN2@LoadFromFi:
  00074	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  00077	40		 inc	 eax
  00078	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN4@LoadFromFi:
  0007b	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  0007e	3b 45 e8	 cmp	 eax, DWORD PTR _next$[ebp]
  00081	7d 2d		 jge	 SHORT $LN3@LoadFromFi

; 103  : 		char * found = strstr(fileupper, exts[0]);

  00083	6a 04		 push	 4
  00085	58		 pop	 eax
  00086	6b c0 00	 imul	 eax, eax, 0
  00089	8b 44 05 e4	 mov	 eax, DWORD PTR _exts$[ebp+eax]
  0008d	89 45 e0	 mov	 DWORD PTR __SubString$[ebp], eax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\string.h

; 524  :         return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));

  00090	ff 75 e0	 push	 DWORD PTR __SubString$[ebp]
  00093	68 00 00 00 00	 push	 OFFSET ?fileupper@?1??LoadFromFile@CDXTCImage@@QAE_NPBD@Z@4PADA
  00098	e8 00 00 00 00	 call	 _strstr
  0009d	59		 pop	 ecx
  0009e	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp

; 103  : 		char * found = strstr(fileupper, exts[0]);

  0009f	89 45 dc	 mov	 DWORD PTR _found$2[ebp], eax

; 104  : 		
; 105  : 		if (found != NULL)

  000a2	83 7d dc 00	 cmp	 DWORD PTR _found$2[ebp], 0
  000a6	74 06		 je	 SHORT $LN5@LoadFromFi

; 106  : 		{
; 107  : 			knownformat = true;

  000a8	c6 45 f3 01	 mov	 BYTE PTR _knownformat$[ebp], 1

; 108  : 			break;

  000ac	eb 02		 jmp	 SHORT $LN3@LoadFromFi
$LN5@LoadFromFi:

; 109  : 		}
; 110  : 	}

  000ae	eb c4		 jmp	 SHORT $LN2@LoadFromFi
$LN3@LoadFromFi:

; 111  : 	
; 112  : 	if (knownformat == false)

  000b0	0f b6 45 f3	 movzx	 eax, BYTE PTR _knownformat$[ebp]
  000b4	85 c0		 test	 eax, eax
  000b6	75 16		 jne	 SHORT $LN6@LoadFromFi

; 113  : 	{
; 114  : 		Tracef("Unknown file format encountered! [%s]\n", filename);

  000b8	ff b5 50 01 00
	00		 push	 DWORD PTR _filename$[ebp]
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GCJNOCJN@Unknown?5file?5format?5encountered@
  000c3	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  000c8	59		 pop	 ecx
  000c9	59		 pop	 ecx

; 115  : 		return(false);

  000ca	32 c0		 xor	 al, al
  000cc	eb 6a		 jmp	 SHORT $LN1@LoadFromFi
$LN6@LoadFromFi:

; 116  : 	}
; 117  : 
; 118  : 	CMappedFile mappedFile;

  000ce	8d 4d 00	 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000d1	e8 00 00 00 00	 call	 ??0CMappedFile@@QAE@XZ	; CMappedFile::CMappedFile
  000d6	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 119  : 	LPCVOID pvMap;
; 120  : 
; 121  : 	if (!mappedFile.Create(filename, &pvMap, 0, 0))

  000da	6a 00		 push	 0
  000dc	6a 00		 push	 0
  000de	8d 45 d8	 lea	 eax, DWORD PTR _pvMap$[ebp]
  000e1	50		 push	 eax
  000e2	ff b5 50 01 00
	00		 push	 DWORD PTR _filename$[ebp]
  000e8	8d 4d 00	 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  000eb	e8 00 00 00 00	 call	 ?Create@CMappedFile@@QAEHPBDPAPBXHH@Z ; CMappedFile::Create
  000f0	85 c0		 test	 eax, eax
  000f2	75 27		 jne	 SHORT $LN7@LoadFromFi

; 122  : 	{
; 123  : 		Tracef("Can't open file for reading! [%s]\n", filename);

  000f4	ff b5 50 01 00
	00		 push	 DWORD PTR _filename$[ebp]
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@JGFKJJPC@Can?8t?5open?5file?5for?5reading?$CB?5?$FL?$CF@
  000ff	e8 00 00 00 00	 call	 ?Tracef@@YAXPBDZZ	; Tracef
  00104	59		 pop	 ecx
  00105	59		 pop	 ecx

; 124  : 		return false;

  00106	c6 45 f2 00	 mov	 BYTE PTR $T4[ebp], 0
  0010a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0010e	8d 4d 00	 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00111	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00116	8a 45 f2	 mov	 al, BYTE PTR $T4[ebp]
  00119	eb 1d		 jmp	 SHORT $LN1@LoadFromFi
$LN7@LoadFromFi:

; 125  : 	}
; 126  : 
; 127  : 	return LoadFromMemory((const BYTE*) pvMap);

  0011b	ff 75 d8	 push	 DWORD PTR _pvMap$[ebp]
  0011e	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	e8 00 00 00 00	 call	 ?LoadFromMemory@CDXTCImage@@QAE_NPBE@Z ; CDXTCImage::LoadFromMemory
  00126	88 45 f1	 mov	 BYTE PTR $T3[ebp], al
  00129	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0012d	8d 4d 00	 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00130	e8 00 00 00 00	 call	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00135	8a 45 f1	 mov	 al, BYTE PTR $T3[ebp]
$LN1@LoadFromFi:

; 128  : }

  00138	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0013b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00142	59		 pop	 ecx
  00143	8b 8d 44 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00149	33 cd		 xor	 ecx, ebp
  0014b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00150	81 c5 48 01 00
	00		 add	 ebp, 328		; 00000148H
  00156	c9		 leave
  00157	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z$0:
  00000	8d 4d 00	 lea	 ecx, DWORD PTR _mappedFile$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMappedFile@@UAE@XZ	; CMappedFile::~CMappedFile
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 8a 50 01 00
	00		 mov	 ecx, DWORD PTR [edx+336]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?LoadFromFile@CDXTCImage@@QAE_NPBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?LoadFromFile@CDXTCImage@@QAE_NPBD@Z ENDP		; CDXTCImage::LoadFromFile
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@EV?$allocator@E@std@@@std@@AAEAAV?$allocator@E@2@XZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@EV?$allocator@E@std@@@std@@CAXXZ ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 6d		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00075	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007d	ff 75 d4	 push	 DWORD PTR __Count$[ebp]
  00080	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  00083	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00088	59		 pop	 ecx
  00089	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  0008a	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0008d	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00090	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00093	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  00096	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00099	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  0009c	c9		 leave
  0009d	c3		 ret	 0
?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 5b		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00075	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00078	8b 00		 mov	 eax, DWORD PTR [eax]
  0007a	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0007d	ff 75 d4	 push	 DWORD PTR __Count$[ebp]
  00080	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  00083	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00088	59		 pop	 ecx
  00089	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00090	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00092	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00095	03 45 0c	 add	 eax, DWORD PTR __Newsize$[ebp]
  00098	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0009b	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  0009d	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  000a0	03 45 10	 add	 eax, DWORD PTR __Newcapacity$[ebp]
  000a3	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000a6	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000a8	c9		 leave
  000a9	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@EV?$allocator@E@std@@@std@@AAEXQAEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv81 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0001d	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00020	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00026	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00029	83 4d f0 ff	 or	 DWORD PTR $T7[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0002d	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00034	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00037	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0003a	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  0003d	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00040	73 08		 jae	 SHORT $LN25@Calculate_
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  00045	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
  00048	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  0004a	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0004d	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
$LN26@Calculate_:
  00050	8b 45 e8	 mov	 eax, DWORD PTR tv81[ebp]
  00053	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  00056	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00059	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0005c	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00064	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00067	d1 e8		 shr	 eax, 1
  00069	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  0006c	2b c8		 sub	 ecx, eax
  0006e	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00071	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00073	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  00076	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00078	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0007b	d1 e8		 shr	 eax, 1
  0007d	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00080	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00083	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  00086	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00089	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  0008b	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0008e	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00090	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00093	c9		 leave
  00094	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@EV?$allocator@E@std@@@std@@ABEII@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z PROC ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@EV?$allocator@E@std@@@std@@AAEXPAE0@Z ENDP ; std::vector<unsigned char,std::allocator<unsigned char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@E@std@@@std@@YAXPAEQAEAAV?$allocator@E@0@@Z ; std::_Destroy_range<std::allocator<unsigned char> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@AAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ PROC	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >, COMDAT
; _this$ = ecx

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	83 60 08 00	 and	 DWORD PTR [eax+8], 0

; 446  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 447  :     }

  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	c9		 leave
  0002d	c3		 ret	 0
??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXQAEI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@E@std@@QAEXQAEI@Z PROC		; std::allocator<unsigned char>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00012	59		 pop	 ecx
  00013	59		 pop	 ecx

; 811  :     }

  00014	c9		 leave
  00015	c2 08 00	 ret	 8
?deallocate@?$allocator@E@std@@QAEXQAEI@Z ENDP		; std::allocator<unsigned char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Clear@CDXTCImage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?Clear@CDXTCImage@@QAEXXZ PROC				; CDXTCImage::Clear, COMDAT
; _this$ = ecx

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 80   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)

  00008	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  0000c	eb 07		 jmp	 SHORT $LN4@Clear
$LN2@Clear:
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00011	40		 inc	 eax
  00012	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Clear:
  00015	83 7d fc 0c	 cmp	 DWORD PTR _i$1[ebp], 12	; 0000000cH
  00019	7d 12		 jge	 SHORT $LN3@Clear

; 81   : 		m_bCompVector[i].clear();

  0001b	6b 45 fc 0c	 imul	 eax, DWORD PTR _i$1[ebp], 12
  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8d 4c 01 34	 lea	 ecx, DWORD PTR [ecx+eax+52]
  00026	e8 00 00 00 00	 call	 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<unsigned char,std::allocator<unsigned char> >::clear
  0002b	eb e1		 jmp	 SHORT $LN2@Clear
$LN3@Clear:

; 82   : 
; 83   : 	Initialize();

  0002d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?Initialize@CDXTCImage@@QAEXXZ ; CDXTCImage::Initialize

; 84   : }

  00035	c9		 leave
  00036	c3		 ret	 0
?Clear@CDXTCImage@@QAEXXZ ENDP				; CDXTCImage::Clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ?Initialize@CDXTCImage@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_i$1 = -4						; size = 4
?Initialize@CDXTCImage@@QAEXXZ PROC			; CDXTCImage::Initialize, COMDAT
; _this$ = ecx

; 70   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 71   : 	m_nWidth = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 a0 00 01 00
	00 00		 and	 DWORD PTR [eax+256], 0

; 72   : 	m_nHeight = 0;

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 a0 04 01 00
	00 00		 and	 DWORD PTR [eax+260], 0

; 73   : 
; 74   : 	for (int i = 0; i < MAX_MIPLEVELS; ++i)

  0001c	83 65 fc 00	 and	 DWORD PTR _i$1[ebp], 0
  00020	eb 07		 jmp	 SHORT $LN4@Initialize
$LN2@Initialize:
  00022	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00025	40		 inc	 eax
  00026	89 45 fc	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@Initialize:
  00029	83 7d fc 0c	 cmp	 DWORD PTR _i$1[ebp], 12	; 0000000cH
  0002d	7d 0d		 jge	 SHORT $LN1@Initialize

; 75   : 		m_pbCompBufferByLevels[i] = NULL;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _i$1[ebp]
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 64 81 04 00	 and	 DWORD PTR [ecx+eax*4+4], 0
  0003a	eb e6		 jmp	 SHORT $LN2@Initialize
$LN1@Initialize:

; 76   : }

  0003c	c9		 leave
  0003d	c3		 ret	 0
?Initialize@CDXTCImage@@QAEXXZ ENDP			; CDXTCImage::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ??1CDXTCImage@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CDXTCImage@@UAE@XZ PROC				; CDXTCImage::~CDXTCImage, COMDAT
; _this$ = ecx

; 66   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CDXTCImage@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDXTCImage@@6B@

; 67   : }

  0002f	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00034	6a 0c		 push	 12			; 0000000cH
  00036	6a 0c		 push	 12			; 0000000cH
  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	83 c0 34	 add	 eax, 52			; 00000034H
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00044	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00047	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004e	59		 pop	 ecx
  0004f	c9		 leave
  00050	c3		 ret	 0
  00051	cc		 int	 3
  00052	cc		 int	 3
  00053	cc		 int	 3
  00054	cc		 int	 3
  00055	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CDXTCImage@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CDXTCImage@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CDXTCImage@@UAE@XZ ENDP				; CDXTCImage::~CDXTCImage
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterImageLib\DXTCImage.cpp
;	COMDAT ??0CDXTCImage@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CDXTCImage@@QAE@XZ PROC				; CDXTCImage::CDXTCImage, COMDAT
; _this$ = ecx

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CDXTCImage@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CDXTCImage@@6B@
  0002f	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00034	68 00 00 00 00	 push	 OFFSET ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::vector<unsigned char,std::allocator<unsigned char> >
  00039	6a 0c		 push	 12			; 0000000cH
  0003b	6a 0c		 push	 12			; 0000000cH
  0003d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00040	83 c0 34	 add	 eax, 52			; 00000034H
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 ??_L@YGXPAXIIP6EX0@Z1@Z
  00049	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 62   : 	Initialize();

  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?Initialize@CDXTCImage@@QAEXXZ ; CDXTCImage::Initialize

; 63   : }

  00055	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00059	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00066	59		 pop	 ecx
  00067	c9		 leave
  00068	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CDXTCImage@@QAE@XZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<unsigned char,std::allocator<unsigned char> >::~vector<unsigned char,std::allocator<unsigned char> >
  00005	6a 0c		 push	 12			; 0000000cH
  00007	6a 0c		 push	 12			; 0000000cH
  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 34	 add	 eax, 52			; 00000034H
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00015	c3		 ret	 0
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$??0CDXTCImage@@QAE@XZ:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CDXTCImage@@QAE@XZ
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CDXTCImage@@QAE@XZ ENDP				; CDXTCImage::CDXTCImage
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT __snprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__snprintf PROC						; COMDAT

; 1969 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1970 :         int _Result;
; 1971 :         va_list _ArgList;
; 1972 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0000c	8b 45 10	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	ff 75 0c	 push	 DWORD PTR __BufferCount$[ebp]
  0001d	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c9 01	 or	 ecx, 1
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	50		 push	 eax
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00034	83 c4 1c	 add	 esp, 28			; 0000001cH
  00037	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003e	7d 06		 jge	 SHORT $LN7@snprintf
  00040	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00044	eb 06		 jmp	 SHORT $LN3@snprintf
$LN7@snprintf:
  00046	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00049	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@snprintf:

; 1973 :     #pragma warning(suppress:28719)    // 28719
; 1974 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004f	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1975 :         __crt_va_end(_ArgList);

  00052	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1976 :         return _Result;

  00056	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1977 :     }

  00059	c9		 leave
  0005a	c3		 ret	 0
__snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
