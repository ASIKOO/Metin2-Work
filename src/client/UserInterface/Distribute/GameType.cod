; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@		; `string'
PUBLIC	??_C@_0BB@HALCDGDI@d?3?1ymir?5work?1ui?1@	; `string'
PUBLIC	??_C@_08IMCOOJPA@mark?110?1@			; `string'
PUBLIC	??_C@_0O@NEJHPHDP@?$LB?$LM?$LI?$LC?C?$LM?312?4fnt@ ; `string'
PUBLIC	??_C@_0P@FDDKCBCN@?$LB?$LM?$LI?$LC?C?$LM?312i?4fnt@ ; `string'
PUBLIC	?c_aSlotTypeToInvenType@@3PAEA			; c_aSlotTypeToInvenType
_DATA	SEGMENT
?c_aSlotTypeToInvenType@@3PAEA DB 00H			; c_aSlotTypeToInvenType
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	05H
_DATA	ENDS
;	COMDAT ??_C@_0P@FDDKCBCN@?$LB?$LM?$LI?$LC?C?$LM?312i?4fnt@
CONST	SEGMENT
??_C@_0P@FDDKCBCN@?$LB?$LM?$LI?$LC?C?$LM?312i?4fnt@ DB 0b1H, 0bcH, 0b8H, 0b2H
	DB	0c3H, 0bcH, ':12i.fnt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NEJHPHDP@?$LB?$LM?$LI?$LC?C?$LM?312?4fnt@
CONST	SEGMENT
??_C@_0O@NEJHPHDP@?$LB?$LM?$LI?$LC?C?$LM?312?4fnt@ DB 0b1H, 0bcH, 0b8H, 0b2H
	DB	0c3H, 0bcH, ':12.fnt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08IMCOOJPA@mark?110?1@
CONST	SEGMENT
??_C@_08IMCOOJPA@mark?110?1@ DB 'mark/10/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HALCDGDI@d?3?1ymir?5work?1ui?1@
CONST	SEGMENT
??_C@_0BB@HALCDGDI@d?3?1ymir?5work?1ui?1@ DB 'd:/ymir work/ui/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@
CONST	SEGMENT
??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@ DB 'd:/ymir work/', 00H ; `string'
CONST	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?DefaultFont_Startup@@YAXXZ			; DefaultFont_Startup
PUBLIC	?DefaultFont_Cleanup@@YAXXZ			; DefaultFont_Cleanup
PUBLIC	?DefaultFont_SetName@@YAXPBD@Z			; DefaultFont_SetName
PUBLIC	?DefaultFont_GetResource@@YAPAVCResource@@XZ	; DefaultFont_GetResource
PUBLIC	?DefaultItalicFont_GetResource@@YAPAVCResource@@XZ ; DefaultItalicFont_GetResource
PUBLIC	?SetGuildSymbolPath@@YAXPBD@Z			; SetGuildSymbolPath
PUBLIC	?GetGuildSymbolFileName@@YAPBDK@Z		; GetGuildSymbolFileName
PUBLIC	?SlotTypeToInvenType@@YAEE@Z			; SlotTypeToInvenType
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?ReloadDefaultFonts@@YA_NXZ			; ReloadDefaultFonts
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton
PUBLIC	?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strResourcePath
PUBLIC	?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strImagePath
PUBLIC	?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_04FAHLGLIA@?4fnt@				; `string'
PUBLIC	??_C@_01KBJDNOO@i@				; `string'
PUBLIC	??_C@_05MJKNGIJO@mark?1@			; `string'
PUBLIC	??_C@_01KMDKNFGN@?1@				; `string'
PUBLIC	??_C@_0L@GNKPCGDN@?$CFs?$CF03d?4jpg@		; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_strchr:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_getf@@YAPBDPBDZZ:PROC				; _getf
EXTRN	?AddReference@CReferenceObject@@QAEXXZ:PROC	; CReferenceObject::AddReference
EXTRN	?Release@CReferenceObject@@QAEXXZ:PROC		; CReferenceObject::Release
EXTRN	?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z:PROC ; CResourceManager::GetResourcePointer
EXTRN	__CxxThrowException@8:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A DD 01H DUP (?) ; CSingleton<CResourceManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?gs_pkDefaultFont@@3PAVCResource@@A DD 01H DUP (?)	; gs_pkDefaultFont
?gs_pkDefaultItalicFont@@3PAVCResource@@A DD 01H DUP (?) ; gs_pkDefaultItalicFont
?gs_isReloadDefaultFont@@3_NA DB 01H DUP (?)		; gs_isReloadDefaultFont
_BSS	ENDS
CRT$XCU	SEGMENT
?g_strResourcePath$initializer$@@3P6AXXZA DD FLAT:??__Eg_strResourcePath@@YAXXZ ; g_strResourcePath$initializer$
CRT$XCU	ENDS
;	COMDAT ??_C@_0L@GNKPCGDN@?$CFs?$CF03d?4jpg@
CONST	SEGMENT
??_C@_0L@GNKPCGDN@?$CFs?$CF03d?4jpg@ DB '%s%03d.jpg', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05MJKNGIJO@mark?1@
CONST	SEGMENT
??_C@_05MJKNGIJO@mark?1@ DB 'mark/', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01KBJDNOO@i@
CONST	SEGMENT
??_C@_01KBJDNOO@i@ DB 'i', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04FAHLGLIA@?4fnt@
CONST	SEGMENT
??_C@_04FAHLGLIA@?4fnt@ DB '.fnt', 00H			; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
_DATA	SEGMENT
?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; g_strResourcePath
	DB	19 DUP(00H)
	DD	0fH
?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; g_strImagePath
	DB	19 DUP(00H)
	DD	0fH
?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; g_strGuildSymbolPathName
	DB	19 DUP(00H)
	DD	0fH
?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; gs_strDefaultFontName
	DB	19 DUP(00H)
	DD	0fH
?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; gs_strDefaultItalicFontName
	DB	19 DUP(00H)
	DD	0fH
_DATA	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
CRT$XCU	SEGMENT
?g_strImagePath$initializer$@@3P6AXXZA DD FLAT:??__Eg_strImagePath@@YAXXZ ; g_strImagePath$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?g_strGuildSymbolPathName$initializer$@@3P6AXXZA DD FLAT:??__Eg_strGuildSymbolPathName@@YAXXZ ; g_strGuildSymbolPathName$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_strDefaultFontName$initializer$@@3P6AXXZA DD FLAT:??__Egs_strDefaultFontName@@YAXXZ ; gs_strDefaultFontName$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?gs_strDefaultItalicFontName$initializer$@@3P6AXXZA DD FLAT:??__Egs_strDefaultItalicFontName@@YAXXZ ; gs_strDefaultItalicFontName$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?ReloadDefaultFonts@@YA_NXZ
_TEXT	SEGMENT
?ReloadDefaultFonts@@YA_NXZ PROC			; ReloadDefaultFonts, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2227 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2218 :         const value_type* _Result = _Bx._Buf;

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 42   : {

  0000c	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2219 :         if (_Large_string_engaged()) {

  0000d	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 43   : 	CResourceManager& rkResMgr = CResourceManager::Instance();

  00014	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?ms_singleton@?$CSingleton@VCResourceManager@@@@0PAVCResourceManager@@A ; CSingleton<CResourceManager>::ms_singleton

; 44   : 
; 45   : 	gs_isReloadDefaultFont = false;
; 46   : 
; 47   : 	CResource* pkNewFont = rkResMgr.GetResourcePointer(gs_strDefaultFontName.c_str());

  0001a	8b ce		 mov	 ecx, esi
  0001c	57		 push	 edi
  0001d	50		 push	 eax
  0001e	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 0
  00025	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  0002a	8b f8		 mov	 edi, eax

; 48   : 	pkNewFont->AddReference();

  0002c	8b cf		 mov	 ecx, edi
  0002e	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference

; 49   : 	if (gs_pkDefaultFont)

  00033	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A
  00039	85 c9		 test	 ecx, ecx
  0003b	74 05		 je	 SHORT $LN2@ReloadDefa

; 50   : 		gs_pkDefaultFont->Release();

  0003d	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN2@ReloadDefa:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2227 :         return _BUF_SIZE <= _Myres;

  00042	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2218 :         const value_type* _Result = _Bx._Buf;

  00049	b8 00 00 00 00	 mov	 eax, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 53   : 	CResource* pkNewItalicFont = rkResMgr.GetResourcePointer(gs_strDefaultItalicFontName.c_str());

  0004e	8b ce		 mov	 ecx, esi
  00050	89 3d 00 00 00
	00		 mov	 DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2219 :         if (_Large_string_engaged()) {

  00056	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 53   : 	CResource* pkNewItalicFont = rkResMgr.GetResourcePointer(gs_strDefaultItalicFontName.c_str());

  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 ?GetResourcePointer@CResourceManager@@QAEPAVCResource@@PBD@Z ; CResourceManager::GetResourcePointer
  00063	8b f0		 mov	 esi, eax

; 54   : 	pkNewItalicFont->AddReference();

  00065	8b ce		 mov	 ecx, esi
  00067	e8 00 00 00 00	 call	 ?AddReference@CReferenceObject@@QAEXXZ ; CReferenceObject::AddReference

; 55   : 	if (gs_pkDefaultItalicFont)

  0006c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pkDefaultItalicFont@@3PAVCResource@@A
  00072	85 c9		 test	 ecx, ecx
  00074	74 05		 je	 SHORT $LN19@ReloadDefa

; 56   : 		gs_pkDefaultItalicFont->Release();

  00076	e8 00 00 00 00	 call	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release
$LN19@ReloadDefa:
  0007b	5f		 pop	 edi

; 57   : 	gs_pkDefaultItalicFont = pkNewItalicFont;
; 58   : 
; 59   : 	return true;
; 60   : }

  0007c	89 35 00 00 00
	00		 mov	 DWORD PTR ?gs_pkDefaultItalicFont@@3PAVCResource@@A, esi
  00082	b0 01		 mov	 al, 1
  00084	5e		 pop	 esi
  00085	c3		 ret	 0
?ReloadDefaultFonts@@YA_NXZ ENDP			; ReloadDefaultFonts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??__Fgs_strDefaultItalicFontName@@YAXXZ
text$yd	SEGMENT
??__Fgs_strDefaultItalicFontName@@YAXXZ PROC		; `dynamic atexit destructor for 'gs_strDefaultItalicFontName'', COMDAT

; 2227 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00007	72 22		 jb	 SHORT $LN7@dynamic

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00009	56		 push	 esi
  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00010	68 00 00 00 00	 push	 OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00015	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  0001f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	50		 push	 eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	5e		 pop	 esi
$LN7@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  0002b	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00035	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0003f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00046	c3		 ret	 0
??__Fgs_strDefaultItalicFontName@@YAXXZ ENDP		; `dynamic atexit destructor for 'gs_strDefaultItalicFontName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ??__Egs_strDefaultItalicFontName@@YAXXZ
text$di	SEGMENT
??__Egs_strDefaultItalicFontName@@YAXXZ PROC		; `dynamic initializer for 'gs_strDefaultItalicFontName'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2417 :         assign(_Ptr);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0P@FDDKCBCN@?$LB?$LM?$LI?$LC?C?$LM?312i?4fnt@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 11   : static std::string gs_strDefaultItalicFontName = "±¼¸²Ã¼:12i.fnt";

  0000f	68 00 00 00 00	 push	 OFFSET ??__Fgs_strDefaultItalicFontName@@YAXXZ ; `dynamic atexit destructor for 'gs_strDefaultItalicFontName''
  00014	e8 00 00 00 00	 call	 _atexit
  00019	59		 pop	 ecx
  0001a	c3		 ret	 0
??__Egs_strDefaultItalicFontName@@YAXXZ ENDP		; `dynamic initializer for 'gs_strDefaultItalicFontName''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??__Fgs_strDefaultFontName@@YAXXZ
text$yd	SEGMENT
??__Fgs_strDefaultFontName@@YAXXZ PROC			; `dynamic atexit destructor for 'gs_strDefaultFontName'', COMDAT

; 2227 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00007	72 22		 jb	 SHORT $LN7@dynamic

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00009	56		 push	 esi
  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00010	68 00 00 00 00	 push	 OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00015	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  0001f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	50		 push	 eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	5e		 pop	 esi
$LN7@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  0002b	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00035	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0003f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00046	c3		 ret	 0
??__Fgs_strDefaultFontName@@YAXXZ ENDP			; `dynamic atexit destructor for 'gs_strDefaultFontName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ??__Egs_strDefaultFontName@@YAXXZ
text$di	SEGMENT
??__Egs_strDefaultFontName@@YAXXZ PROC			; `dynamic initializer for 'gs_strDefaultFontName'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2417 :         assign(_Ptr);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NEJHPHDP@?$LB?$LM?$LI?$LC?C?$LM?312?4fnt@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 10   : static std::string gs_strDefaultFontName = "±¼¸²Ã¼:12.fnt";

  0000f	68 00 00 00 00	 push	 OFFSET ??__Fgs_strDefaultFontName@@YAXXZ ; `dynamic atexit destructor for 'gs_strDefaultFontName''
  00014	e8 00 00 00 00	 call	 _atexit
  00019	59		 pop	 ecx
  0001a	c3		 ret	 0
??__Egs_strDefaultFontName@@YAXXZ ENDP			; `dynamic initializer for 'gs_strDefaultFontName''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??__Fg_strGuildSymbolPathName@@YAXXZ
text$yd	SEGMENT
??__Fg_strGuildSymbolPathName@@YAXXZ PROC		; `dynamic atexit destructor for 'g_strGuildSymbolPathName'', COMDAT

; 2227 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00007	72 22		 jb	 SHORT $LN7@dynamic

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00009	56		 push	 esi
  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00010	68 00 00 00 00	 push	 OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
  00015	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  0001f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	50		 push	 eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	5e		 pop	 esi
$LN7@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  0002b	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00035	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0003f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00046	c3		 ret	 0
??__Fg_strGuildSymbolPathName@@YAXXZ ENDP		; `dynamic atexit destructor for 'g_strGuildSymbolPathName''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ??__Eg_strGuildSymbolPathName@@YAXXZ
text$di	SEGMENT
??__Eg_strGuildSymbolPathName@@YAXXZ PROC		; `dynamic initializer for 'g_strGuildSymbolPathName'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2417 :         assign(_Ptr);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_08IMCOOJPA@mark?110?1@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 7    : std::string g_strGuildSymbolPathName = "mark/10/";

  0000f	68 00 00 00 00	 push	 OFFSET ??__Fg_strGuildSymbolPathName@@YAXXZ ; `dynamic atexit destructor for 'g_strGuildSymbolPathName''
  00014	e8 00 00 00 00	 call	 _atexit
  00019	59		 pop	 ecx
  0001a	c3		 ret	 0
??__Eg_strGuildSymbolPathName@@YAXXZ ENDP		; `dynamic initializer for 'g_strGuildSymbolPathName''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??__Fg_strImagePath@@YAXXZ
text$yd	SEGMENT
??__Fg_strImagePath@@YAXXZ PROC				; `dynamic atexit destructor for 'g_strImagePath'', COMDAT

; 2227 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00007	72 22		 jb	 SHORT $LN7@dynamic

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00009	56		 push	 esi
  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00010	68 00 00 00 00	 push	 OFFSET ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strImagePath
  00015	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  0001f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	50		 push	 eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	5e		 pop	 esi
$LN7@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  0002b	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00035	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0003f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00046	c3		 ret	 0
??__Fg_strImagePath@@YAXXZ ENDP				; `dynamic atexit destructor for 'g_strImagePath''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ??__Eg_strImagePath@@YAXXZ
text$di	SEGMENT
??__Eg_strImagePath@@YAXXZ PROC				; `dynamic initializer for 'g_strImagePath'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2417 :         assign(_Ptr);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HALCDGDI@d?3?1ymir?5work?1ui?1@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strImagePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strImagePath
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 5    : std::string g_strImagePath = "d:/ymir work/ui/";

  0000f	68 00 00 00 00	 push	 OFFSET ??__Fg_strImagePath@@YAXXZ ; `dynamic atexit destructor for 'g_strImagePath''
  00014	e8 00 00 00 00	 call	 _atexit
  00019	59		 pop	 ecx
  0001a	c3		 ret	 0
??__Eg_strImagePath@@YAXXZ ENDP				; `dynamic initializer for 'g_strImagePath''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??__Fg_strResourcePath@@YAXXZ
text$yd	SEGMENT
??__Fg_strResourcePath@@YAXXZ PROC			; `dynamic atexit destructor for 'g_strResourcePath'', COMDAT

; 2227 :         return _BUF_SIZE <= _Myres;

  00000	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00007	72 22		 jb	 SHORT $LN7@dynamic

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  00009	56		 push	 esi
  0000a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00010	68 00 00 00 00	 push	 OFFSET ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strResourcePath
  00015	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0001a	a1 14 00 00 00	 mov	 eax, DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
  0001f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00020	50		 push	 eax
  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	5e		 pop	 esi
$LN7@dynamic:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  0002b	c7 05 10 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00035	c7 05 14 00 00
	00 0f 00 00 00	 mov	 DWORD PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  0003f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00046	c3		 ret	 0
??__Fg_strResourcePath@@YAXXZ ENDP			; `dynamic atexit destructor for 'g_strResourcePath''
text$yd	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ??__Eg_strResourcePath@@YAXXZ
text$di	SEGMENT
??__Eg_strResourcePath@@YAXXZ PROC			; `dynamic initializer for 'g_strResourcePath'', COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2417 :         assign(_Ptr);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0O@GCFJLOM@d?3?1ymir?5work?1@
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strResourcePath@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strResourcePath
  0000a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 4    : std::string g_strResourcePath = "d:/ymir work/";

  0000f	68 00 00 00 00	 push	 OFFSET ??__Fg_strResourcePath@@YAXXZ ; `dynamic atexit destructor for 'g_strResourcePath''
  00014	e8 00 00 00 00	 call	 _atexit
  00019	59		 pop	 ecx
  0001a	c3		 ret	 0
??__Eg_strResourcePath@@YAXXZ ENDP			; `dynamic initializer for 'g_strResourcePath''
text$di	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?SlotTypeToInvenType@@YAEE@Z
_TEXT	SEGMENT
_bSlotType$ = 8						; size = 1
?SlotTypeToInvenType@@YAEE@Z PROC			; SlotTypeToInvenType, COMDAT

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 	if (bSlotType >= SLOT_TYPE_MAX)

  00003	8a 45 08	 mov	 al, BYTE PTR _bSlotType$[ebp]
  00006	3c 0c		 cmp	 al, 12			; 0000000cH
  00008	72 04		 jb	 SHORT $LN2@SlotTypeTo

; 109  : 		return RESERVED_WINDOW;

  0000a	32 c0		 xor	 al, al

; 112  : }

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
$LN2@SlotTypeTo:

; 110  : 	else
; 111  : 		return c_aSlotTypeToInvenType[bSlotType];

  0000e	0f b6 c0	 movzx	 eax, al
  00011	8a 80 00 00 00
	00		 mov	 al, BYTE PTR ?c_aSlotTypeToInvenType@@3PAEA[eax]

; 112  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?SlotTypeToInvenType@@YAEE@Z ENDP			; SlotTypeToInvenType
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?GetGuildSymbolFileName@@YAPBDK@Z
_TEXT	SEGMENT
_dwGuildID$ = 8						; size = 4
?GetGuildSymbolFileName@@YAPBDK@Z PROC			; GetGuildSymbolFileName, COMDAT

; 86   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2227 :         return _BUF_SIZE <= _Myres;

  00003	83 3d 14 00 00
	00 10		 cmp	 DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000a	b8 00 00 00 00	 mov	 eax, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 87   : 	return _getf("%s%03d.jpg", g_strGuildSymbolPathName.c_str(), dwGuildID);

  0000f	ff 75 08	 push	 DWORD PTR _dwGuildID$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2219 :         if (_Large_string_engaged()) {

  00012	0f 43 05 00 00
	00 00		 cmovae	 eax, DWORD PTR ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 87   : 	return _getf("%s%03d.jpg", g_strGuildSymbolPathName.c_str(), dwGuildID);

  00019	50		 push	 eax
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_0L@GNKPCGDN@?$CFs?$CF03d?4jpg@
  0001f	e8 00 00 00 00	 call	 ?_getf@@YAPBDPBDZZ	; _getf
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 88   : }

  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?GetGuildSymbolFileName@@YAPBDK@Z ENDP			; GetGuildSymbolFileName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?SetGuildSymbolPath@@YAXPBD@Z
_TEXT	SEGMENT
_c_szPathName$ = 8					; size = 4
?SetGuildSymbolPath@@YAXPBD@Z PROC			; SetGuildSymbolPath, COMDAT

; 79   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2878 :         return assign(_Ptr);

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_05MJKNGIJO@mark?1@
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
  0000d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 81   : 	g_strGuildSymbolPathName += c_szPathName;

  00012	ff 75 08	 push	 DWORD PTR _c_szPathName$[ebp]
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
  0001a	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 82   : 	g_strGuildSymbolPathName += "/";

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_01KMDKNFGN@?1@
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ?g_strGuildSymbolPathName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; g_strGuildSymbolPathName
  00029	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 83   : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?SetGuildSymbolPath@@YAXPBD@Z ENDP			; SetGuildSymbolPath
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?DefaultItalicFont_GetResource@@YAPAVCResource@@XZ
_TEXT	SEGMENT
?DefaultItalicFont_GetResource@@YAPAVCResource@@XZ PROC	; DefaultItalicFont_GetResource, COMDAT

; 71   : 	if (!gs_pkDefaultItalicFont || gs_isReloadDefaultFont)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_pkDefaultItalicFont@@3PAVCResource@@A
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN3@DefaultIta
  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 0
  00010	74 0a		 je	 SHORT $LN2@DefaultIta
$LN3@DefaultIta:

; 72   : 		ReloadDefaultFonts();

  00012	e8 00 00 00 00	 call	 ?ReloadDefaultFonts@@YA_NXZ ; ReloadDefaultFonts

; 73   : 	return gs_pkDefaultItalicFont;

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_pkDefaultItalicFont@@3PAVCResource@@A
$LN2@DefaultIta:

; 74   : }

  0001c	c3		 ret	 0
?DefaultItalicFont_GetResource@@YAPAVCResource@@XZ ENDP	; DefaultItalicFont_GetResource
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?DefaultFont_GetResource@@YAPAVCResource@@XZ
_TEXT	SEGMENT
?DefaultFont_GetResource@@YAPAVCResource@@XZ PROC	; DefaultFont_GetResource, COMDAT

; 64   : 	if (!gs_pkDefaultFont || gs_isReloadDefaultFont)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A
  00005	85 c0		 test	 eax, eax
  00007	74 09		 je	 SHORT $LN3@DefaultFon
  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 0
  00010	74 0a		 je	 SHORT $LN2@DefaultFon
$LN3@DefaultFon:

; 65   : 		ReloadDefaultFonts();

  00012	e8 00 00 00 00	 call	 ?ReloadDefaultFonts@@YA_NXZ ; ReloadDefaultFonts

; 66   : 	return gs_pkDefaultFont;

  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A
$LN2@DefaultFon:

; 67   : }

  0001c	c3		 ret	 0
?DefaultFont_GetResource@@YAPAVCResource@@XZ ENDP	; DefaultFont_GetResource
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?DefaultFont_SetName@@YAXPBD@Z
_TEXT	SEGMENT
_c_szFontName$ = 8					; size = 4
?DefaultFont_SetName@@YAXPBD@Z PROC			; DefaultFont_SetName, COMDAT

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2878 :         return assign(_Ptr);

  00004	8b 75 08	 mov	 esi, DWORD PTR _c_szFontName$[ebp]
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  0000c	56		 push	 esi
  0000d	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 31   : 	gs_strDefaultFontName += ".fnt";

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_04FAHLGLIA@?4fnt@
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  0001c	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2878 :         return assign(_Ptr);

  00021	56		 push	 esi
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00027	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp

; 34   : 	if(strchr(c_szFontName, ':'))

  0002c	6a 3a		 push	 58			; 0000003aH
  0002e	56		 push	 esi
  0002f	e8 00 00 00 00	 call	 _strchr
  00034	83 c4 08	 add	 esp, 8
  00037	5e		 pop	 esi
  00038	85 c0		 test	 eax, eax
  0003a	74 0f		 je	 SHORT $LN2@DefaultFon

; 35   : 		gs_strDefaultItalicFontName += "i";

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_01KBJDNOO@i@
  00041	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00046	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN2@DefaultFon:

; 36   : 	gs_strDefaultItalicFontName += ".fnt";

  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_04FAHLGLIA@?4fnt@
  00050	b9 00 00 00 00	 mov	 ecx, OFFSET ?gs_strDefaultItalicFontName@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
  00055	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 37   : 
; 38   : 	gs_isReloadDefaultFont = true;

  0005a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?gs_isReloadDefaultFont@@3_NA, 1

; 39   : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?DefaultFont_SetName@@YAXPBD@Z ENDP			; DefaultFont_SetName
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?DefaultFont_Cleanup@@YAXXZ
_TEXT	SEGMENT
?DefaultFont_Cleanup@@YAXXZ PROC			; DefaultFont_Cleanup, COMDAT

; 24   : 	if (gs_pkDefaultFont)

  00000	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A
  00006	85 c9		 test	 ecx, ecx
  00008	0f 85 00 00 00
	00		 jne	 ?Release@CReferenceObject@@QAEXXZ ; CReferenceObject::Release

; 25   : 		gs_pkDefaultFont->Release();
; 26   : }

  0000e	c3		 ret	 0
?DefaultFont_Cleanup@@YAXXZ ENDP			; DefaultFont_Cleanup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\GameType.cpp
;	COMDAT ?DefaultFont_Startup@@YAXXZ
_TEXT	SEGMENT
?DefaultFont_Startup@@YAXXZ PROC			; DefaultFont_Startup, COMDAT

; 19   : 	gs_pkDefaultFont = NULL;

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_pkDefaultFont@@3PAVCResource@@A, 0

; 20   : }

  0000a	c3		 ret	 0
?DefaultFont_Startup@@YAXXZ ENDP			; DefaultFont_Startup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
__Old$1$ = -8						; size = 4
__New_ptr$1 = -4					; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3061 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00003	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]

; 3061 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00006	83 ec 08	 sub	 esp, 8
  00009	53		 push	 ebx
  0000a	56		 push	 esi

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000b	8b f2		 mov	 esi, edx

; 3061 :     basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  0000d	57		 push	 edi
  0000e	8b f9		 mov	 edi, ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00010	8d 4e 01	 lea	 ecx, DWORD PTR [esi+1]
$LL38@assign:
  00013	8a 06		 mov	 al, BYTE PTR [esi]
  00015	46		 inc	 esi
  00016	84 c0		 test	 al, al
  00018	75 f9		 jne	 SHORT $LL38@assign
  0001a	2b f1		 sub	 esi, ecx

; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  0001c	8b 4f 14	 mov	 ecx, DWORD PTR [edi+20]
  0001f	89 4d f8	 mov	 DWORD PTR __Old$1$[ebp], ecx
  00022	3b f1		 cmp	 esi, ecx
  00024	77 26		 ja	 SHORT $LN6@assign

; 2209 :         value_type* _Result = _Bx._Buf;

  00026	8b df		 mov	 ebx, edi

; 2227 :         return _BUF_SIZE <= _Myres;

  00028	83 f9 10	 cmp	 ecx, 16			; 00000010H

; 2210 :         if (_Large_string_engaged()) {

  0002b	72 02		 jb	 SHORT $LN9@assign

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0002d	8b 1f		 mov	 ebx, DWORD PTR [edi]
$LN9@assign:

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0002f	56		 push	 esi
  00030	52		 push	 edx
  00031	53		 push	 ebx

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  00032	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00035	e8 00 00 00 00	 call	 _memmove
  0003a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003d	c6 04 33 00	 mov	 BYTE PTR [ebx+esi], 0

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00041	8b c7		 mov	 eax, edi
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx

; 3063 :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
$LN6@assign:

; 4305 :         if (_New_size > max_size()) {

  0004c	81 fe ff ff ff
	7f		 cmp	 esi, 2147483647		; 7fffffffH
  00052	0f 87 91 00 00
	00		 ja	 $LN42@assign

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00058	8b de		 mov	 ebx, esi
  0005a	83 cb 0f	 or	 ebx, 15			; 0000000fH
  0005d	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00063	76 07		 jbe	 SHORT $LN23@assign

; 4287 :             return _Max;

  00065	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  0006a	eb 1e		 jmp	 SHORT $LN22@assign
$LN23@assign:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0006c	8b d1		 mov	 edx, ecx
  0006e	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00073	d1 ea		 shr	 edx, 1
  00075	2b c2		 sub	 eax, edx
  00077	3b c8		 cmp	 ecx, eax
  00079	76 07		 jbe	 SHORT $LN24@assign

; 4291 :             return _Max;

  0007b	bb ff ff ff 7f	 mov	 ebx, 2147483647		; 7fffffffH
  00080	eb 08		 jmp	 SHORT $LN22@assign
$LN24@assign:

; 4292 :         }
; 4293 : 
; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00082	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00085	3b d8		 cmp	 ebx, eax
  00087	0f 42 d8	 cmovb	 ebx, eax
$LN22@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0008a	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00093	56		 push	 esi
  00094	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00097	89 45 fc	 mov	 DWORD PTR __New_ptr$1[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0009a	50		 push	 eax

; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  0009b	89 77 10	 mov	 DWORD PTR [edi+16], esi

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  0009e	89 5f 14	 mov	 DWORD PTR [edi+20], ebx

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a1	e8 00 00 00 00	 call	 _memcpy

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000a6	8b 5d fc	 mov	 ebx, DWORD PTR __New_ptr$1[ebp]

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000a9	83 c4 10	 add	 esp, 16			; 00000010H

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  000ac	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  000af	c6 04 33 00	 mov	 BYTE PTR [ebx+esi], 0

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  000b3	83 f8 10	 cmp	 eax, 16			; 00000010H
  000b6	72 19		 jb	 SHORT $LN17@assign

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000b8	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000b9	50		 push	 eax
  000ba	ff 37		 push	 DWORD PTR [edi]
  000bc	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000c1	83 c4 08	 add	 esp, 8

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000c4	89 1f		 mov	 DWORD PTR [edi], ebx

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000c6	8b c7		 mov	 eax, edi
  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx

; 3063 :     }

  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c2 04 00	 ret	 4
$LN17@assign:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000d1	8d 45 fc	 lea	 eax, DWORD PTR __New_ptr$1[ebp]
  000d4	50		 push	 eax
  000d5	57		 push	 edi
  000d6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000db	83 c4 08	 add	 esp, 8
  000de	8b c7		 mov	 eax, edi
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx

; 3063 :     }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 04 00	 ret	 4
$LN42@assign:

; 4306 :             _Xlen_string(); // result too long

  000e9	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN39@assign:
  000ee	cc		 int	 3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z
_TEXT	SEGMENT
__Old_size$1$ = -16					; size = 4
__New_ptr$1 = -12					; size = 4
__Old$1$ = -8						; size = 4
tv441 = -4						; size = 4
tv438 = -4						; size = 4
$T2 = -4						; size = 4
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 2900 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b d9		 mov	 ebx, ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]

; 2900 :     basic_string& operator+=(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  0000d	57		 push	 edi

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0000e	8b f9		 mov	 edi, ecx
  00010	8d 57 01	 lea	 edx, DWORD PTR [edi+1]
$LL49@operator:
  00013	8a 07		 mov	 al, BYTE PTR [edi]
  00015	47		 inc	 edi
  00016	84 c0		 test	 al, al
  00018	75 f9		 jne	 SHORT $LL49@operator

; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  0001a	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0001d	2b fa		 sub	 edi, edx

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0001f	8b 53 14	 mov	 edx, DWORD PTR [ebx+20]
  00022	8b c2		 mov	 eax, edx
  00024	2b c6		 sub	 eax, esi
  00026	89 75 f0	 mov	 DWORD PTR __Old_size$1$[ebp], esi
  00029	89 55 f8	 mov	 DWORD PTR __Old$1$[ebp], edx
  0002c	3b f8		 cmp	 edi, eax
  0002e	77 2b		 ja	 SHORT $LN8@operator

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00030	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00033	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 2209 :         value_type* _Result = _Bx._Buf;

  00036	8b c3		 mov	 eax, ebx

; 2227 :         return _BUF_SIZE <= _Myres;

  00038	83 fa 10	 cmp	 edx, 16			; 00000010H

; 2210 :         if (_Large_string_engaged()) {

  0003b	72 02		 jb	 SHORT $LN11@operator

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  0003d	8b 03		 mov	 eax, DWORD PTR [ebx]
$LN11@operator:

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  0003f	57		 push	 edi

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00040	03 f0		 add	 esi, eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00042	51		 push	 ecx
  00043	56		 push	 esi
  00044	e8 00 00 00 00	 call	 _memmove
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0004c	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 2901 :         return append(_Ptr);

  00050	8b c3		 mov	 eax, ebx
  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx

; 2902 :     }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 04 00	 ret	 4
$LN8@operator:

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  0005b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00060	2b c6		 sub	 eax, esi
  00062	3b c7		 cmp	 eax, edi
  00064	0f 82 d5 00 00
	00		 jb	 $LN54@operator

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0006a	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0006d	83 c9 0f	 or	 ecx, 15			; 0000000fH
  00070	81 f9 ff ff ff
	7f		 cmp	 ecx, 2147483647		; 7fffffffH

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00076	76 07		 jbe	 SHORT $LN25@operator

; 4287 :             return _Max;

  00078	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  0007d	eb 24		 jmp	 SHORT $LN51@operator
$LN25@operator:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0007f	8b c2		 mov	 eax, edx
  00081	d1 e8		 shr	 eax, 1
  00083	89 45 fc	 mov	 DWORD PTR tv441[ebp], eax
  00086	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0008b	2b 45 fc	 sub	 eax, DWORD PTR tv441[ebp]
  0008e	3b d0		 cmp	 edx, eax
  00090	76 07		 jbe	 SHORT $LN26@operator

; 4291 :             return _Max;

  00092	b9 ff ff ff 7f	 mov	 ecx, 2147483647		; 7fffffffH
  00097	eb 0a		 jmp	 SHORT $LN51@operator
$LN26@operator:

; 4292 :         }
; 4293 : 
; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00099	8b 45 fc	 mov	 eax, DWORD PTR tv441[ebp]
  0009c	03 c2		 add	 eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0009e	3b c8		 cmp	 ecx, eax
  000a0	0f 42 c8	 cmovb	 ecx, eax
$LN51@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000a3	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  000a6	89 4d fc	 mov	 DWORD PTR $T2[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000a9	50		 push	 eax
  000aa	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4344 :         _My_data._Myres       = _New_capacity;

  000af	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  000b2	8b d0		 mov	 edx, eax
  000b4	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  000b7	89 55 f4	 mov	 DWORD PTR __New_ptr$1[ebp], edx
  000ba	89 43 10	 mov	 DWORD PTR [ebx+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  000bd	83 c4 04	 add	 esp, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  000c0	83 7d f8 10	 cmp	 DWORD PTR __Old$1$[ebp], 16 ; 00000010H
  000c4	8d 04 32	 lea	 eax, DWORD PTR [edx+esi]
  000c7	89 4b 14	 mov	 DWORD PTR [ebx+20], ecx
  000ca	89 45 fc	 mov	 DWORD PTR tv438[ebp], eax
  000cd	72 3e		 jb	 SHORT $LN19@operator

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000cf	ff 75 f0	 push	 DWORD PTR __Old_size$1$[ebp]

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  000d2	8b 33		 mov	 esi, DWORD PTR [ebx]

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000d4	56		 push	 esi
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 _memcpy
  000db	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000de	57		 push	 edi
  000df	50		 push	 eax
  000e0	ff 75 fc	 push	 DWORD PTR tv438[ebp]
  000e3	e8 00 00 00 00	 call	 _memcpy

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000e8	8b 45 fc	 mov	 eax, DWORD PTR tv438[ebp]
  000eb	c6 04 38 00	 mov	 BYTE PTR [eax+edi], 0

; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ef	8b 45 f8	 mov	 eax, DWORD PTR __Old$1$[ebp]
  000f2	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000f3	50		 push	 eax
  000f4	56		 push	 esi
  000f5	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000fa	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$1[ebp]

; 2901 :         return append(_Ptr);

  000fd	83 c4 20	 add	 esp, 32			; 00000020H

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  00100	89 03		 mov	 DWORD PTR [ebx], eax

; 2901 :         return append(_Ptr);

  00102	8b c3		 mov	 eax, ebx
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5b		 pop	 ebx

; 2902 :     }

  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c2 04 00	 ret	 4
$LN19@operator:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0010d	56		 push	 esi
  0010e	53		 push	 ebx
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 _memcpy
  00115	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00118	8b 75 fc	 mov	 esi, DWORD PTR tv438[ebp]
  0011b	57		 push	 edi
  0011c	50		 push	 eax
  0011d	56		 push	 esi
  0011e	e8 00 00 00 00	 call	 _memcpy

; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00123	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$1[ebp]

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00126	c6 04 3e 00	 mov	 BYTE PTR [esi+edi], 0

; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0012a	50		 push	 eax
  0012b	53		 push	 ebx
  0012c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>

; 2901 :         return append(_Ptr);

  00131	83 c4 20	 add	 esp, 32			; 00000020H
  00134	8b c3		 mov	 eax, ebx
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx

; 2902 :     }

  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 04 00	 ret	 4
$LN54@operator:

; 4334 :             _Xlen_string(); // result too long

  0013f	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN50@operator:
  00144	cc		 int	 3
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2275 :     _Xlength_error("string too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlen_strin:
  0000a	cc		 int	 3
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
