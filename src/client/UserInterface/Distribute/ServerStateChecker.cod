; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ	; CSingleton<CServerStateChecker>::~CSingleton<CServerStateChecker>
PUBLIC	??_G?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z ; CSingleton<CServerStateChecker>::`scalar deleting destructor'
PUBLIC	??0CServerStateChecker@@QAE@XZ			; CServerStateChecker::CServerStateChecker
PUBLIC	??1CServerStateChecker@@UAE@XZ			; CServerStateChecker::~CServerStateChecker
PUBLIC	?Create@CServerStateChecker@@QAEXPAU_object@@@Z	; CServerStateChecker::Create
PUBLIC	?AddChannel@CServerStateChecker@@QAEXIPBDI@Z	; CServerStateChecker::AddChannel
PUBLIC	?Request@CServerStateChecker@@QAEXXZ		; CServerStateChecker::Request
PUBLIC	?Update@CServerStateChecker@@QAEXXZ		; CServerStateChecker::Update
PUBLIC	?Initialize@CServerStateChecker@@QAEXXZ		; CServerStateChecker::Initialize
PUBLIC	??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::~list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
PUBLIC	??_GCServerStateChecker@@UAEPAXI@Z		; CServerStateChecker::`scalar deleting destructor'
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A ; CSingleton<CServerStateChecker>::ms_singleton
PUBLIC	??_7?$CSingleton@VCServerStateChecker@@@@6B@	; CSingleton<CServerStateChecker>::`vftable'
PUBLIC	??_7CServerStateChecker@@6B@			; CServerStateChecker::`vftable'
PUBLIC	??_C@_04INACLLOK@?$CIii?$CJ@			; `string'
PUBLIC	??_C@_0BD@EEDMKMGJ@NotifyChannelState@		; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_R4CServerStateChecker@@6B@			; CServerStateChecker::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCServerStateChecker@@@8			; CServerStateChecker `RTTI Type Descriptor'
PUBLIC	??_R3CServerStateChecker@@8			; CServerStateChecker::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CServerStateChecker@@8			; CServerStateChecker::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CServerStateChecker@@8		; CServerStateChecker::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8 ; CSingleton<CServerStateChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8	; CSingleton<CServerStateChecker> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCServerStateChecker@@@@8	; CSingleton<CServerStateChecker>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VCServerStateChecker@@@@8	; CSingleton<CServerStateChecker>::`RTTI Base Class Array'
PUBLIC	??_R4?$CSingleton@VCServerStateChecker@@@@6B@	; CSingleton<CServerStateChecker>::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp__Py_BuildValue:PROC
EXTRN	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z:PROC ; PyCallClassMemberFunc
EXTRN	??0CNetworkStream@@QAE@XZ:PROC			; CNetworkStream::CNetworkStream
EXTRN	??1CNetworkStream@@UAE@XZ:PROC			; CNetworkStream::~CNetworkStream
EXTRN	?SetRecvBufferSize@CNetworkStream@@QAEXH@Z:PROC	; CNetworkStream::SetRecvBufferSize
EXTRN	?SetSendBufferSize@CNetworkStream@@QAEXH@Z:PROC	; CNetworkStream::SetSendBufferSize
EXTRN	?ClearRecvBuffer@CNetworkStream@@QAEXXZ:PROC	; CNetworkStream::ClearRecvBuffer
EXTRN	?Process@CNetworkStream@@QAEXXZ:PROC		; CNetworkStream::Process
EXTRN	?Connect@CNetworkStream@@QAE_NPBDHH@Z:PROC	; CNetworkStream::Connect
EXTRN	?Disconnect@CNetworkStream@@QAEXXZ:PROC		; CNetworkStream::Disconnect
EXTRN	?Recv@CNetworkStream@@QAE_NHPAX@Z:PROC		; CNetworkStream::Recv
EXTRN	?Send@CNetworkStream@@QAE_NHPBX@Z:PROC		; CNetworkStream::Send
EXTRN	??_E?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z:PROC ; CSingleton<CServerStateChecker>::`vector deleting destructor'
EXTRN	??_ECServerStateChecker@@UAEPAXI@Z:PROC		; CServerStateChecker::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A DD 01H DUP (?) ; CSingleton<CServerStateChecker>::ms_singleton
_BSS	ENDS
;	COMDAT ??_R4?$CSingleton@VCServerStateChecker@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCServerStateChecker@@@@6B@ DD 00H	; CSingleton<CServerStateChecker>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCServerStateChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCServerStateChecker@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCServerStateChecker@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8 ; CSingleton<CServerStateChecker>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCServerStateChecker@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCServerStateChecker@@@@8 DD 00H	; CSingleton<CServerStateChecker>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCServerStateChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CServerStateChecker> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCServerStateChecker@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8 ; CSingleton<CServerStateChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCServerStateChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CServerStateChecker@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CServerStateChecker@@8 DD FLAT:??_R0?AVCServerStateChecker@@@8 ; CServerStateChecker::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CServerStateChecker@@8
rdata$r	ENDS
;	COMDAT ??_R2CServerStateChecker@@8
rdata$r	SEGMENT
??_R2CServerStateChecker@@8 DD FLAT:??_R1A@?0A@EA@CServerStateChecker@@8 ; CServerStateChecker::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CServerStateChecker@@8
rdata$r	SEGMENT
??_R3CServerStateChecker@@8 DD 00H			; CServerStateChecker::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CServerStateChecker@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCServerStateChecker@@@8
data$rs	SEGMENT
??_R0?AVCServerStateChecker@@@8 DD FLAT:??_7type_info@@6B@ ; CServerStateChecker `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCServerStateChecker@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CServerStateChecker@@6B@
rdata$r	SEGMENT
??_R4CServerStateChecker@@6B@ DD 00H			; CServerStateChecker::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCServerStateChecker@@@8
	DD	FLAT:??_R3CServerStateChecker@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EEDMKMGJ@NotifyChannelState@
CONST	SEGMENT
??_C@_0BD@EEDMKMGJ@NotifyChannelState@ DB 'NotifyChannelState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04INACLLOK@?$CIii?$CJ@
CONST	SEGMENT
??_C@_04INACLLOK@?$CIii?$CJ@ DB '(ii)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CServerStateChecker@@6B@
CONST	SEGMENT
??_7CServerStateChecker@@6B@ DD FLAT:??_R4CServerStateChecker@@6B@ ; CServerStateChecker::`vftable'
	DD	FLAT:??_ECServerStateChecker@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCServerStateChecker@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCServerStateChecker@@@@6B@ DD FLAT:??_R4?$CSingleton@VCServerStateChecker@@@@6B@ ; CSingleton<CServerStateChecker>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z$0
__ehfuncinfo$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z$1
__ehfuncinfo$??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?push_back@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXABUSChannel@CServerStateChecker@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXABUSChannel@CServerStateChecker@@@Z$1
__ehfuncinfo$?push_back@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXABUSChannel@CServerStateChecker@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXABUSChannel@CServerStateChecker@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?AddChannel@CServerStateChecker@@QAEXIPBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?AddChannel@CServerStateChecker@@QAEXIPBDI@Z$1
__ehfuncinfo$?AddChannel@CServerStateChecker@@QAEXIPBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?AddChannel@CServerStateChecker@@QAEXIPBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CServerStateChecker@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CServerStateChecker@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CServerStateChecker@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CServerStateChecker@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CServerStateChecker@@QAE@XZ$2
__ehfuncinfo$??0CServerStateChecker@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CServerStateChecker@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *>, COMDAT

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00000	c2 00 00	 ret	 0
??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >, COMDAT
; _this$ = ecx

; 1057 :         if (_Ptr) {

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	85 c0		 test	 eax, eax
  00005	74 0b		 je	 SHORT $LN2@Alloc_cons

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6a 14		 push	 20			; 00000014H
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0000f	83 c4 08	 add	 esp, 8
$LN2@Alloc_cons:

; 1058 :             _Al.deallocate(_Ptr, 1);
; 1059 :         }
; 1060 :     }

  00012	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00003	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GCServerStateChecker@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCServerStateChecker@@UAEPAXI@Z PROC			; CServerStateChecker::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	e8 00 00 00 00	 call	 ??1CServerStateChecker@@UAE@XZ ; CServerStateChecker::~CServerStateChecker
  0000b	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0000f	74 0e		 je	 SHORT $LN4@scalar
  00011	68 8c 00 00 00	 push	 140			; 0000008cH
  00016	56		 push	 esi
  00017	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0001c	83 c4 08	 add	 esp, 8
$LN4@scalar:
  0001f	8b c6		 mov	 eax, esi
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??_GCServerStateChecker@@UAEPAXI@Z ENDP			; CServerStateChecker::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ PROC ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::~list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx

; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00003	8b 17		 mov	 edx, DWORD PTR [edi]

; 324  :         _Head->_Prev->_Next = nullptr;

  00005	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00008	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000e	8b 02		 mov	 eax, DWORD PTR [edx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00010	85 c0		 test	 eax, eax
  00012	74 15		 je	 SHORT $LN7@list
  00014	56		 push	 esi
$LL8@list:

; 328  :             _Pnext = _Pnode->_Next;

  00015	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00017	6a 14		 push	 20			; 00000014H
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001f	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00022	8b c6		 mov	 eax, esi
  00024	85 f6		 test	 esi, esi
  00026	75 ed		 jne	 SHORT $LL8@list
  00028	5e		 pop	 esi
$LN7@list:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00029	6a 14		 push	 20			; 00000014H
  0002b	ff 37		 push	 DWORD PTR [edi]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	83 c4 08	 add	 esp, 8
  00035	5f		 pop	 edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1051 :     }

  00036	c3		 ret	 0
??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ENDP ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::~list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?Initialize@CServerStateChecker@@QAEXXZ
_TEXT	SEGMENT
?Initialize@CServerStateChecker@@QAEXXZ PROC		; CServerStateChecker::Initialize, COMDAT
; _this$ = ecx

; 102  : {

  00000	57		 push	 edi
  00001	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  00003	8b 57 08	 mov	 edx, DWORD PTR [edi+8]

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00009	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 02		 mov	 eax, DWORD PTR [edx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00011	85 c0		 test	 eax, eax
  00013	74 15		 je	 SHORT $LN7@Initialize
  00015	56		 push	 esi
$LL8@Initialize:

; 328  :             _Pnext = _Pnode->_Next;

  00016	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00018	6a 14		 push	 20			; 00000014H
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00020	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00023	8b c6		 mov	 eax, esi
  00025	85 f6		 test	 esi, esi
  00027	75 ed		 jne	 SHORT $LL8@Initialize
  00029	5e		 pop	 esi
$LN7@Initialize:

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 104  : 	m_kStream.Disconnect();

  0002d	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  00030	89 00		 mov	 DWORD PTR [eax], eax

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00032	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00035	89 40 04	 mov	 DWORD PTR [eax+4], eax

; 1432 :         _My_data._Mysize        = 0;

  00038	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 104  : 	m_kStream.Disconnect();

  0003f	5f		 pop	 edi
  00040	e9 00 00 00 00	 jmp	 ?Disconnect@CNetworkStream@@QAEXXZ ; CNetworkStream::Disconnect
?Initialize@CServerStateChecker@@QAEXXZ ENDP		; CServerStateChecker::Initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?Update@CServerStateChecker@@QAEXXZ
_TEXT	SEGMENT
_nSize$ = -12						; size = 4
_channelStatus$1 = -8					; size = 3
_bHeader$ = -1						; size = 1
?Update@CServerStateChecker@@QAEXXZ PROC		; CServerStateChecker::Update, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 73   : 	m_kStream.Process();

  0000a	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0000d	e8 00 00 00 00	 call	 ?Process@CNetworkStream@@QAEXXZ ; CNetworkStream::Process

; 74   : 
; 75   : 	BYTE bHeader;
; 76   : 	if (!m_kStream.Recv(sizeof(bHeader), &bHeader)) {

  00012	8d 45 ff	 lea	 eax, DWORD PTR _bHeader$[ebp]
  00015	50		 push	 eax
  00016	6a 01		 push	 1
  00018	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0001b	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00020	84 c0		 test	 al, al
  00022	74 7e		 je	 SHORT $LN1@Update

; 77   : 		return;
; 78   : 	}
; 79   : 	if (HEADER_GC_RESPOND_CHANNELSTATUS != bHeader) {

  00024	80 7d ff d2	 cmp	 BYTE PTR _bHeader$[ebp], 210 ; 000000d2H
  00028	75 78		 jne	 SHORT $LN1@Update

; 80   : 		return;
; 81   : 	}
; 82   : 	int nSize;
; 83   : 	if (!m_kStream.Recv(sizeof(nSize), &nSize)) {

  0002a	8d 45 f4	 lea	 eax, DWORD PTR _nSize$[ebp]
  0002d	50		 push	 eax
  0002e	6a 04		 push	 4
  00030	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00033	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00038	84 c0		 test	 al, al
  0003a	74 66		 je	 SHORT $LN1@Update

; 84   : 		return;
; 85   : 	}
; 86   : 	for (int i = 0; i < nSize; i++) {

  0003c	56		 push	 esi
  0003d	33 f6		 xor	 esi, esi
  0003f	39 75 f4	 cmp	 DWORD PTR _nSize$[ebp], esi
  00042	7e 56		 jle	 SHORT $LN3@Update
$LL4@Update:

; 87   : 		TChannelStatus channelStatus;
; 88   : 		if (!m_kStream.Recv(sizeof(channelStatus), &channelStatus)) {

  00044	8d 45 f8	 lea	 eax, DWORD PTR _channelStatus$1[ebp]
  00047	50		 push	 eax
  00048	6a 03		 push	 3
  0004a	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0004d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00052	84 c0		 test	 al, al
  00054	74 4b		 je	 SHORT $LN54@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00056	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00059	8b 01		 mov	 eax, DWORD PTR [ecx]
  0005b	3b c1		 cmp	 eax, ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 91   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  0005d	74 35		 je	 SHORT $LN2@Update
  0005f	0f bf 55 f8	 movsx	 edx, WORD PTR _channelStatus$1[ebp]
$LL23@Update:

; 92   : 			if (channelStatus.nPort == it->uPort) {

  00063	3b 50 10	 cmp	 edx, DWORD PTR [eax+16]
  00066	74 08		 je	 SHORT $LN46@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  00068	8b 00		 mov	 eax, DWORD PTR [eax]

; 199  :         return this->_Ptr == _Right._Ptr;

  0006a	3b c1		 cmp	 eax, ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 91   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  0006c	75 f5		 jne	 SHORT $LL23@Update

; 87   : 		TChannelStatus channelStatus;
; 88   : 		if (!m_kStream.Recv(sizeof(channelStatus), &channelStatus)) {

  0006e	eb 24		 jmp	 SHORT $LN2@Update
$LN46@Update:

; 93   : 				PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, channelStatus.bStatus));

  00070	0f b6 4d fa	 movzx	 ecx, BYTE PTR _channelStatus$1[ebp+2]
  00074	51		 push	 ecx
  00075	ff 70 08	 push	 DWORD PTR [eax+8]
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ@
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00083	50		 push	 eax
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEDMKMGJ@NotifyChannelState@
  00089	ff 77 04	 push	 DWORD PTR [edi+4]
  0008c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00091	83 c4 18	 add	 esp, 24			; 00000018H
$LN2@Update:

; 84   : 		return;
; 85   : 	}
; 86   : 	for (int i = 0; i < nSize; i++) {

  00094	46		 inc	 esi
  00095	3b 75 f4	 cmp	 esi, DWORD PTR _nSize$[ebp]
  00098	7c aa		 jl	 SHORT $LL4@Update
$LN3@Update:

; 94   : 				break;
; 95   : 			}
; 96   : 		}
; 97   : 	}
; 98   : 	Initialize();

  0009a	8b cf		 mov	 ecx, edi
  0009c	e8 00 00 00 00	 call	 ?Initialize@CServerStateChecker@@QAEXXZ ; CServerStateChecker::Initialize
$LN54@Update:
  000a1	5e		 pop	 esi
$LN1@Update:
  000a2	5f		 pop	 edi

; 99   : }

  000a3	5b		 pop	 ebx
  000a4	8b e5		 mov	 esp, ebp
  000a6	5d		 pop	 ebp
  000a7	c3		 ret	 0
?Update@CServerStateChecker@@QAEXXZ ENDP		; CServerStateChecker::Update
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?Request@CServerStateChecker@@QAEXXZ
_TEXT	SEGMENT
_bHeader$ = -1						; size = 1
?Request@CServerStateChecker@@QAEXXZ PROC		; CServerStateChecker::Request, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1200 :         return _Mypair._Myval2._Mysize == 0;

  00007	83 7f 0c 00	 cmp	 DWORD PTR [edi+12], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 45   : 	if (m_lstChannel.empty()) { 

  0000b	0f 84 ce 00 00
	00		 je	 $LN10@Request
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00011	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 49   : 	if (!m_kStream.Connect(m_lstChannel.begin()->c_szAddr, m_lstChannel.begin()->uPort))

  00014	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00017	53		 push	 ebx
  00018	56		 push	 esi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 49   : 	if (!m_kStream.Connect(m_lstChannel.begin()->c_szAddr, m_lstChannel.begin()->uPort))

  00019	6a 03		 push	 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 49   : 	if (!m_kStream.Connect(m_lstChannel.begin()->c_szAddr, m_lstChannel.begin()->uPort))

  0001d	ff 70 10	 push	 DWORD PTR [eax+16]
  00020	ff 70 0c	 push	 DWORD PTR [eax+12]
  00023	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NPBDHH@Z ; CNetworkStream::Connect
  00028	84 c0		 test	 al, al
  0002a	75 3f		 jne	 SHORT $LN9@Request
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0002c	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0002f	8b 30		 mov	 esi, DWORD PTR [eax]
  00031	3b f0		 cmp	 esi, eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 51   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  00033	0f 84 a4 00 00
	00		 je	 $LN102@Request
  00039	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__Py_BuildValue
  0003f	90		 npad	 1
$LL51@Request:

; 52   : 			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));

  00040	6a 00		 push	 0
  00042	ff 76 08	 push	 DWORD PTR [esi+8]
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ@
  0004a	ff d3		 call	 ebx
  0004c	50		 push	 eax
  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEDMKMGJ@NotifyChannelState@
  00052	ff 77 04	 push	 DWORD PTR [edi+4]
  00055	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0005a	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 52   : 			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));

  0005c	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 199  :         return this->_Ptr == _Right._Ptr;

  0005f	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 51   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  00062	75 dc		 jne	 SHORT $LL51@Request
  00064	5e		 pop	 esi
  00065	5b		 pop	 ebx
  00066	5f		 pop	 edi

; 67   : 		return;
; 68   : 	}
; 69   : }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
$LN9@Request:

; 53   : 		}
; 54   : 		return;
; 55   : 	}
; 56   : 	m_kStream.ClearRecvBuffer();

  0006b	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0006e	e8 00 00 00 00	 call	 ?ClearRecvBuffer@CNetworkStream@@QAEXXZ ; CNetworkStream::ClearRecvBuffer

; 57   : 	m_kStream.SetSendBufferSize(1024);

  00073	68 00 04 00 00	 push	 1024			; 00000400H
  00078	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0007b	e8 00 00 00 00	 call	 ?SetSendBufferSize@CNetworkStream@@QAEXH@Z ; CNetworkStream::SetSendBufferSize

; 58   : 	m_kStream.SetRecvBufferSize(1024);

  00080	68 00 04 00 00	 push	 1024			; 00000400H
  00085	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00088	e8 00 00 00 00	 call	 ?SetRecvBufferSize@CNetworkStream@@QAEXH@Z ; CNetworkStream::SetRecvBufferSize

; 59   : 
; 60   : 	BYTE bHeader = HEADER_CG_STATE_CHECKER;
; 61   : 	if (!m_kStream.Send(sizeof(bHeader), &bHeader))

  0008d	8d 45 ff	 lea	 eax, DWORD PTR _bHeader$[ebp]
  00090	c6 45 ff ce	 mov	 BYTE PTR _bHeader$[ebp], 206 ; 000000ceH
  00094	50		 push	 eax
  00095	6a 01		 push	 1
  00097	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0009a	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0009f	84 c0		 test	 al, al
  000a1	75 3a		 jne	 SHORT $LN102@Request
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000a3	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000a6	8b 30		 mov	 esi, DWORD PTR [eax]
  000a8	3b f0		 cmp	 esi, eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 63   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  000aa	74 2a		 je	 SHORT $LN6@Request
  000ac	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__Py_BuildValue
$LL77@Request:

; 64   : 			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));

  000b2	6a 00		 push	 0
  000b4	ff 76 08	 push	 DWORD PTR [esi+8]
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ@
  000bc	ff d3		 call	 ebx
  000be	50		 push	 eax
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEDMKMGJ@NotifyChannelState@
  000c4	ff 77 04	 push	 DWORD PTR [edi+4]
  000c7	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  000cc	8b 36		 mov	 esi, DWORD PTR [esi]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 64   : 			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));

  000ce	83 c4 18	 add	 esp, 24			; 00000018H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 199  :         return this->_Ptr == _Right._Ptr;

  000d1	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 63   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  000d4	75 dc		 jne	 SHORT $LL77@Request
$LN6@Request:

; 65   : 		}
; 66   : 		Initialize();

  000d6	8b cf		 mov	 ecx, edi
  000d8	e8 00 00 00 00	 call	 ?Initialize@CServerStateChecker@@QAEXXZ ; CServerStateChecker::Initialize
$LN102@Request:
  000dd	5e		 pop	 esi
  000de	5b		 pop	 ebx
$LN10@Request:
  000df	5f		 pop	 edi

; 67   : 		return;
; 68   : 	}
; 69   : }

  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
?Request@CServerStateChecker@@QAEXXZ ENDP		; CServerStateChecker::Request
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?AddChannel@CServerStateChecker@@QAEXIPBDI@Z
_TEXT	SEGMENT
_c$ = -32						; size = 12
__Op$2 = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Insert_before$3 = 8					; size = 4
_uServerIndex$ = 8					; size = 4
__Insert_after$4 = 12					; size = 4
_c_szAddr$ = 12						; size = 4
_uPort$ = 16						; size = 4
?AddChannel@CServerStateChecker@@QAEXIPBDI@Z PROC	; CServerStateChecker::AddChannel, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?AddChannel@CServerStateChecker@@QAEXIPBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	53		 push	 ebx
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1014 :         if (_Mysize == max_size()) {

  00028	81 79 0c cc cc
	cc 0c		 cmp	 DWORD PTR [ecx+12], 214748364 ; 0cccccccH
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 40   : 	m_lstChannel.push_back(c);

  0002f	8d 71 08	 lea	 esi, DWORD PTR [ecx+8]
  00032	8b 45 08	 mov	 eax, DWORD PTR _uServerIndex$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  00035	8b 1e		 mov	 ebx, DWORD PTR [esi]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 36   : 	c.uServerIndex = uServerIndex;

  00037	89 45 e0	 mov	 DWORD PTR _c$[ebp], eax

; 37   : 	c.c_szAddr = c_szAddr;

  0003a	8b 45 0c	 mov	 eax, DWORD PTR _c_szAddr$[ebp]
  0003d	89 45 e4	 mov	 DWORD PTR _c$[ebp+4], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1014 :         if (_Mysize == max_size()) {

  00040	74 69		 je	 SHORT $LN43@AddChannel
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  00042	89 75 ec	 mov	 DWORD PTR __Op$2[ebp], esi

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00045	6a 14		 push	 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00047	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  0004e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Op$2[ebp+4], 0

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00055	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  0005a	f3 0f 7e 45 e0	 movq	 xmm0, QWORD PTR _c$[ebp]

; 1053 :         _Ptr = _Al.allocate(1);

  0005f	8b f8		 mov	 edi, eax

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00061	8b 45 10	 mov	 eax, DWORD PTR _uPort$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1020 :         return _Op._Transfer_before(_Where);

  00064	89 5d 08	 mov	 DWORD PTR __Insert_before$3[ebp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00067	66 0f d6 47 08	 movq	 QWORD PTR [edi+8], xmm0
  0006c	89 47 10	 mov	 DWORD PTR [edi+16], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  0006f	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$3[ebp]

; 1019 :         ++_Mysize;

  00072	ff 46 04	 inc	 DWORD PTR [esi+4]

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00075	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00078	50		 push	 eax
  00079	57		 push	 edi
  0007a	89 75 0c	 mov	 DWORD PTR __Insert_after$4[ebp], esi
  0007d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00082	8d 45 0c	 lea	 eax, DWORD PTR __Insert_after$4[ebp]
  00085	50		 push	 eax
  00086	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>

; 603  :         const auto _Result    = this->_Ptr;
; 604  :         this->_Ptr            = pointer{};
; 605  :         _Insert_before->_Prev = _Result;

  0008f	89 7b 04	 mov	 DWORD PTR [ebx+4], edi
  00092	83 c4 14	 add	 esp, 20			; 00000014H

; 606  :         _Insert_after->_Next  = _Result;

  00095	89 3e		 mov	 DWORD PTR [esi], edi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 41   : }

  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	5f		 pop	 edi
  000a3	5e		 pop	 esi
  000a4	5b		 pop	 ebx
  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c2 0c 00	 ret	 12			; 0000000cH
$LN43@AddChannel:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1015 :             _Xlength_error("list too long");

  000ab	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  000b0	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN41@AddChannel:
  000b5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?AddChannel@CServerStateChecker@@QAEXIPBDI@Z$1:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR __Op$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?AddChannel@CServerStateChecker@@QAEXIPBDI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?AddChannel@CServerStateChecker@@QAEXIPBDI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?AddChannel@CServerStateChecker@@QAEXIPBDI@Z ENDP	; CServerStateChecker::AddChannel
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?Create@CServerStateChecker@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_poWnd$ = 8						; size = 4
?Create@CServerStateChecker@@QAEXPAU_object@@@Z PROC	; CServerStateChecker::Create, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 30   : 	m_poWnd = poWnd;

  00003	8b 45 08	 mov	 eax, DWORD PTR _poWnd$[ebp]
  00006	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 31   : }

  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?Create@CServerStateChecker@@QAEXPAU_object@@@Z ENDP	; CServerStateChecker::Create
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ??1CServerStateChecker@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1CServerStateChecker@@UAE@XZ PROC			; CServerStateChecker::~CServerStateChecker, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CServerStateChecker@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	8b f9		 mov	 edi, ecx
  00026	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CServerStateChecker@@6B@

; 24   : 	Initialize();

  0002c	e8 00 00 00 00	 call	 ?Initialize@CServerStateChecker@@QAEXXZ ; CServerStateChecker::Initialize

; 26   : }

  00031	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00034	c7 47 04 00 00
	00 00		 mov	 DWORD PTR [edi+4], 0
  0003b	e8 00 00 00 00	 call	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  00040	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]

; 324  :         _Head->_Prev->_Next = nullptr;

  00043	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00046	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0004c	8b 01		 mov	 eax, DWORD PTR [ecx]

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0004e	85 c0		 test	 eax, eax
  00050	74 13		 je	 SHORT $LN9@CServerSta
$LL10@CServerSta:

; 328  :             _Pnext = _Pnode->_Next;

  00052	8b 30		 mov	 esi, DWORD PTR [eax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00054	6a 14		 push	 20			; 00000014H
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005c	83 c4 08	 add	 esp, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  0005f	8b c6		 mov	 eax, esi
  00061	85 f6		 test	 esi, esi
  00063	75 ed		 jne	 SHORT $LL10@CServerSta
$LN9@CServerSta:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00065	6a 14		 push	 20			; 00000014H
  00067	ff 77 08	 push	 DWORD PTR [edi+8]
  0006a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 19   : 	{ 

  0006f	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7?$CSingleton@VCServerStateChecker@@@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00075	83 c4 08	 add	 esp, 8
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 21   : 		ms_singleton = 0; 

  00078	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A, 0 ; CSingleton<CServerStateChecker>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 26   : }

  00082	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00085	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008c	59		 pop	 ecx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
  00093	cc		 int	 3
  00094	cc		 int	 3
  00095	cc		 int	 3
  00096	cc		 int	 3
  00097	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CServerStateChecker@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CServerStateChecker@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CServerStateChecker@@UAE@XZ ENDP			; CServerStateChecker::~CServerStateChecker
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ??0CServerStateChecker@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Newhead$2 = -16					; size = 4
__$EHRec$ = -12						; size = 12
??0CServerStateChecker@@QAE@XZ PROC			; CServerStateChecker::CServerStateChecker, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CServerStateChecker@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	8b f9		 mov	 edi, ecx
  00029	89 7d ec	 mov	 DWORD PTR _this$[ebp], edi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  0002c	89 3d 00 00 00
	00		 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A, edi ; CSingleton<CServerStateChecker>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 18   : {

  00032	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], OFFSET ??_7CServerStateChecker@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00038	6a 14		 push	 20			; 00000014H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 18   : {

  0003a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00041	c7 47 08 00 00
	00 00		 mov	 DWORD PTR [edi+8], 0
  00048	c7 47 0c 00 00
	00 00		 mov	 DWORD PTR [edi+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0004f	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  00054	8b f0		 mov	 esi, eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00056	8d 45 f0	 lea	 eax, DWORD PTR __Newhead$2[ebp]
  00059	50		 push	 eax
  0005a	56		 push	 esi
  0005b	89 75 f0	 mov	 DWORD PTR __Newhead$2[ebp], esi
  0005e	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  00063	8d 45 f0	 lea	 eax, DWORD PTR __Newhead$2[ebp]
  00066	50		 push	 eax
  00067	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>
  00070	83 c4 14	 add	 esp, 20			; 00000014H

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00073	89 77 08	 mov	 DWORD PTR [edi+8], esi
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 18   : {

  00076	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  00079	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0007d	e8 00 00 00 00	 call	 ??0CNetworkStream@@QAE@XZ ; CNetworkStream::CNetworkStream

; 19   : 	Initialize();

  00082	8b cf		 mov	 ecx, edi
  00084	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00088	e8 00 00 00 00	 call	 ?Initialize@CServerStateChecker@@QAEXXZ ; CServerStateChecker::Initialize

; 20   : }

  0008d	8b c7		 mov	 eax, edi
  0008f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00092	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00099	59		 pop	 ecx
  0009a	5f		 pop	 edi
  0009b	5e		 pop	 esi
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CServerStateChecker@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ ; CSingleton<CServerStateChecker>::~CSingleton<CServerStateChecker>
__unwindfunclet$??0CServerStateChecker@@QAE@XZ$1:
  00008	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::~list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
__unwindfunclet$??0CServerStateChecker@@QAE@XZ$2:
  00013	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 10	 add	 ecx, 16			; 00000010H
  00019	e9 00 00 00 00	 jmp	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
__ehhandler$??0CServerStateChecker@@QAE@XZ:
  00023	90		 npad	 1
  00024	90		 npad	 1
  00025	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00029	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002c	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CServerStateChecker@@QAE@XZ
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CServerStateChecker@@QAE@XZ ENDP			; CServerStateChecker::CServerStateChecker
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z PROC	; CSingleton<CServerStateChecker>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1

; 19   : 	{ 

  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7?$CSingleton@VCServerStateChecker@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A, 0 ; CSingleton<CServerStateChecker>::ms_singleton
  0001a	74 0b		 je	 SHORT $LN6@scalar
  0001c	6a 04		 push	 4
  0001e	56		 push	 esi
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00027	8b c6		 mov	 eax, esi
  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z ENDP	; CSingleton<CServerStateChecker>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ
_TEXT	SEGMENT
??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ PROC	; CSingleton<CServerStateChecker>::~CSingleton<CServerStateChecker>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$CSingleton@VCServerStateChecker@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00006	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A, 0 ; CSingleton<CServerStateChecker>::ms_singleton

; 22   : 	}

  00010	c3		 ret	 0
??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ ENDP	; CSingleton<CServerStateChecker>::~CSingleton<CServerStateChecker>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]

; 116  :     if (_Block_size <= _Bytes) {

  00009	3b c8		 cmp	 ecx, eax
  0000b	0f 86 00 00 00
	00		 jbe	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length

; 77   :         return ::operator new(_Bytes);

  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 117  :         _Throw_bad_array_new_length(); // add overflow
; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00017	8b c8		 mov	 ecx, eax

; 77   :         return ::operator new(_Bytes);

  00019	83 c4 04	 add	 esp, 4

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0001c	85 c9		 test	 ecx, ecx
  0001e	74 0b		 je	 SHORT $LN7@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00020	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00023	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00026	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;
; 129  : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  0000b	72 09		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000d	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  00010	5d		 pop	 ebp

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00011	e9 00 00 00 00	 jmp	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00016	85 c0		 test	 eax, eax
  00018	74 09		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001a	89 45 08	 mov	 DWORD PTR __Bytes$[ebp], eax

; 210  : }

  0001d	5d		 pop	 ebp

; 77   :         return ::operator new(_Bytes);

  0001e	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 206  :         return _Traits::_Allocate(_Bytes);
; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00023	33 c0		 xor	 eax, eax

; 210  : }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00006	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000c	72 18		 jb	 SHORT $LN15@Deallocate

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0000e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00011	83 c1 23	 add	 ecx, 35			; 00000023H
  00014	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00017	2b c2		 sub	 eax, edx

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00019	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001c	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001f	76 08		 jbe	 SHORT $LN13@Deallocate
  00021	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00026	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
$LN13@Deallocate:

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00029	89 4d 0c	 mov	 DWORD PTR __Bytes$[ebp], ecx
  0002c	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx

; 222  : }

  0002f	5d		 pop	 ebp

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  00030	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@Throw_bad_:
  0001c	cc		 int	 3
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN12@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN12@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_array_new_length@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx
  00010	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	0f 57 c0	 xorps	 xmm0, xmm0

; 142  :     }

  00003	8b c1		 mov	 eax, ecx

; 65   :         : _Data()

  00005	66 0f d6 41 04	 movq	 QWORD PTR [ecx+4], xmm0

; 66   :     {
; 67   :         _Data._What = _Message;

  0000a	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 141  :     {

  00011	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00017	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN9@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN9@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 72   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0

; 71   :         : _Data()

  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8
  00026	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7bad_alloc@std@@6B@
  0002c	8b c6		 mov	 eax, esi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 89   :     {

  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 90   :         __std_exception_destroy(&_Data);

  00006	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ___std_exception_destroy
  00015	83 c4 04	 add	 esp, 4
  00018	f6 45 08 01	 test	 BYTE PTR ___flags$[ebp], 1
  0001c	74 0b		 je	 SHORT $LN6@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	56		 push	 esi
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN6@scalar:
  00029	8b c6		 mov	 eax, esi
  0002b	5e		 pop	 esi
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00003	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
  00008	85 c9		 test	 ecx, ecx
  0000a	0f 45 c1	 cmovne	 eax, ecx

; 96   :     }

  0000d	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :         __std_exception_destroy(&_Data);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]
  00003	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ___std_exception_destroy
  0000f	59		 pop	 ecx

; 91   :     }

  00010	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx
  00006	0f 57 c0	 xorps	 xmm0, xmm0
  00009	8d 46 04	 lea	 eax, DWORD PTR [esi+4]

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0000c	50		 push	 eax
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
  00013	66 0f d6 00	 movq	 QWORD PTR [eax], xmm0
  00017	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0001a	83 c0 04	 add	 eax, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ___std_exception_copy
  00023	83 c4 08	 add	 esp, 8

; 74   :     }

  00026	8b c6		 mov	 eax, esi
  00028	5e		 pop	 esi
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b 75 10	 mov	 esi, DWORD PTR ___n$[ebp]
  00007	85 f6		 test	 esi, esi
  00009	74 16		 je	 SHORT $LN6@vector
  0000b	53		 push	 ebx
  0000c	8b 5d 14	 mov	 ebx, DWORD PTR ___f$[ebp]
  0000f	57		 push	 edi
  00010	8b 7d 08	 mov	 edi, DWORD PTR ___t$[ebp]
$LL2@vector:
  00013	8b cf		 mov	 ecx, edi
  00015	ff d3		 call	 ebx
  00017	03 7d 0c	 add	 edi, DWORD PTR ___s$[ebp]
  0001a	83 ee 01	 sub	 esi, 1
  0001d	75 f4		 jne	 SHORT $LL2@vector
  0001f	5f		 pop	 edi
  00020	5b		 pop	 ebx
$LN6@vector:
  00021	5e		 pop	 esi
  00022	5d		 pop	 ebp
  00023	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
