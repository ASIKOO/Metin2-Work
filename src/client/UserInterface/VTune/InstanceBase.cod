; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?HAIR_COLOR_ENABLE@@3HA				; HAIR_COLOR_ENABLE
PUBLIC	?USE_ARMOR_SPECULAR@@3HA			; USE_ARMOR_SPECULAR
PUBLIC	?RIDE_HORSE_ENABLE@@3HA				; RIDE_HORSE_ENABLE
PUBLIC	?ms_dwUpdateCounter@CInstanceBase@@1KA		; CInstanceBase::ms_dwUpdateCounter
PUBLIC	?ms_dwRenderCounter@CInstanceBase@@1KA		; CInstanceBase::ms_dwRenderCounter
PUBLIC	?ms_dwDeformCounter@CInstanceBase@@1KA		; CInstanceBase::ms_dwDeformCounter
PUBLIC	?g_iAccumulationTime@@3HA			; g_iAccumulationTime
_BSS	SEGMENT
?HAIR_COLOR_ENABLE@@3HA DD 01H DUP (?)			; HAIR_COLOR_ENABLE
?USE_ARMOR_SPECULAR@@3HA DD 01H DUP (?)			; USE_ARMOR_SPECULAR
?ms_dwUpdateCounter@CInstanceBase@@1KA DD 01H DUP (?)	; CInstanceBase::ms_dwUpdateCounter
?ms_dwRenderCounter@CInstanceBase@@1KA DD 01H DUP (?)	; CInstanceBase::ms_dwRenderCounter
?ms_dwDeformCounter@CInstanceBase@@1KA DD 01H DUP (?)	; CInstanceBase::ms_dwDeformCounter
?g_iAccumulationTime@@3HA DD 01H DUP (?)		; g_iAccumulationTime
_BSS	ENDS
_DATA	SEGMENT
?RIDE_HORSE_ENABLE@@3HA DD 01H				; RIDE_HORSE_ENABLE
_DATA	ENDS
PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	_sprintf
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_of
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$CSingleton@VIBackground@@@@UAEPAXI@Z	; CSingleton<IBackground>::`scalar deleting destructor'
PUBLIC	??_GIBackground@@UAEPAXI@Z			; IBackground::`scalar deleting destructor'
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??0?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >
PUBLIC	?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Alloc_sentinel_and_proxy
PUBLIC	?DestroySystem@CInstanceBase@@SAXXZ		; CInstanceBase::DestroySystem
PUBLIC	?CreateSystem@CInstanceBase@@SAXI@Z		; CInstanceBase::CreateSystem
PUBLIC	?SetMainInstance@CInstanceBase@@QAEXXZ		; CInstanceBase::SetMainInstance
PUBLIC	?OnSelected@CInstanceBase@@QAEXXZ		; CInstanceBase::OnSelected
PUBLIC	?OnUnselected@CInstanceBase@@QAEXXZ		; CInstanceBase::OnUnselected
PUBLIC	?OnTargeted@CInstanceBase@@QAEXXZ		; CInstanceBase::OnTargeted
PUBLIC	?OnUntargeted@CInstanceBase@@QAEXXZ		; CInstanceBase::OnUntargeted
PUBLIC	?__IsExistMainInstance@CInstanceBase@@IAE_NXZ	; CInstanceBase::__IsExistMainInstance
PUBLIC	?__IsMainInstance@CInstanceBase@@IAE_NXZ	; CInstanceBase::__IsMainInstance
PUBLIC	?__MainCanSeeHiddenThing@CInstanceBase@@IAE_NXZ	; CInstanceBase::__MainCanSeeHiddenThing
PUBLIC	?__GetBowRange@CInstanceBase@@IAEMXZ		; CInstanceBase::__GetBowRange
PUBLIC	??0CInstanceBase@@QAE@XZ			; CInstanceBase::CInstanceBase
PUBLIC	??1CInstanceBase@@UAE@XZ			; CInstanceBase::~CInstanceBase
PUBLIC	?LessRenderOrder@CInstanceBase@@QAE_NPAV1@@Z	; CInstanceBase::LessRenderOrder
PUBLIC	?MountHorse@CInstanceBase@@QAEXI@Z		; CInstanceBase::MountHorse
PUBLIC	?DismountHorse@CInstanceBase@@QAEXXZ		; CInstanceBase::DismountHorse
PUBLIC	?CalculateDistanceSq3d@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z ; CInstanceBase::CalculateDistanceSq3d
PUBLIC	?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z	; CInstanceBase::Create
PUBLIC	?CreateDeviceObjects@CInstanceBase@@QAE_NXZ	; CInstanceBase::CreateDeviceObjects
PUBLIC	?DestroyDeviceObjects@CInstanceBase@@QAEXXZ	; CInstanceBase::DestroyDeviceObjects
PUBLIC	?Destroy@CInstanceBase@@QAEXXZ			; CInstanceBase::Destroy
PUBLIC	?Update@CInstanceBase@@QAEXXZ			; CInstanceBase::Update
PUBLIC	?Transform@CInstanceBase@@QAEXXZ		; CInstanceBase::Transform
PUBLIC	?Deform@CInstanceBase@@QAEXXZ			; CInstanceBase::Deform
PUBLIC	?Render@CInstanceBase@@QAEXXZ			; CInstanceBase::Render
PUBLIC	?RenderTrace@CInstanceBase@@QAEXXZ		; CInstanceBase::RenderTrace
PUBLIC	?RenderToShadowMap@CInstanceBase@@QAEXXZ	; CInstanceBase::RenderToShadowMap
PUBLIC	?RenderCollision@CInstanceBase@@QAEXXZ		; CInstanceBase::RenderCollision
PUBLIC	?RegisterBoundingSphere@CInstanceBase@@QAEXXZ	; CInstanceBase::RegisterBoundingSphere
PUBLIC	?GetBoundBox@CInstanceBase@@QAEXPAUD3DXVECTOR3@@0@Z ; CInstanceBase::GetBoundBox
PUBLIC	?SetNameString@CInstanceBase@@QAEXPBDH@Z	; CInstanceBase::SetNameString
PUBLIC	?SetRace@CInstanceBase@@QAE_NK@Z		; CInstanceBase::SetRace
PUBLIC	?SetVirtualID@CInstanceBase@@QAEXK@Z		; CInstanceBase::SetVirtualID
PUBLIC	?SetVirtualNumber@CInstanceBase@@QAEXK@Z	; CInstanceBase::SetVirtualNumber
PUBLIC	?SetInstanceType@CInstanceBase@@QAEXH@Z		; CInstanceBase::SetInstanceType
PUBLIC	?SetAlignment@CInstanceBase@@QAEXF@Z		; CInstanceBase::SetAlignment
PUBLIC	?SetPKMode@CInstanceBase@@QAEXE@Z		; CInstanceBase::SetPKMode
PUBLIC	?SetKiller@CInstanceBase@@QAEX_N@Z		; CInstanceBase::SetKiller
PUBLIC	?SetPartyMemberFlag@CInstanceBase@@QAEX_N@Z	; CInstanceBase::SetPartyMemberFlag
PUBLIC	?SetStateFlags@CInstanceBase@@QAEXK@Z		; CInstanceBase::SetStateFlags
PUBLIC	?SetArmor@CInstanceBase@@QAEXK@Z		; CInstanceBase::SetArmor
PUBLIC	?SetShape@CInstanceBase@@QAEXKM@Z		; CInstanceBase::SetShape
PUBLIC	?SetHair@CInstanceBase@@QAEXK@Z			; CInstanceBase::SetHair
PUBLIC	?SetWeapon@CInstanceBase@@QAE_NK@Z		; CInstanceBase::SetWeapon
PUBLIC	?ChangeArmor@CInstanceBase@@QAE_NK@Z		; CInstanceBase::ChangeArmor
PUBLIC	?ChangeWeapon@CInstanceBase@@QAEXK@Z		; CInstanceBase::ChangeWeapon
PUBLIC	?ChangeHair@CInstanceBase@@QAEXK@Z		; CInstanceBase::ChangeHair
PUBLIC	?ChangeGuild@CInstanceBase@@QAEXK@Z		; CInstanceBase::ChangeGuild
PUBLIC	?GetWeaponType@CInstanceBase@@QAEKXZ		; CInstanceBase::GetWeaponType
PUBLIC	?SetComboType@CInstanceBase@@QAEXI@Z		; CInstanceBase::SetComboType
PUBLIC	?GetNameString@CInstanceBase@@QAEPBDXZ		; CInstanceBase::GetNameString
PUBLIC	?GetInstanceType@CInstanceBase@@QAEHXZ		; CInstanceBase::GetInstanceType
PUBLIC	?GetPart@CInstanceBase@@QAEKW4EParts@CRaceData@@@Z ; CInstanceBase::GetPart
PUBLIC	?GetShape@CInstanceBase@@QAEKXZ			; CInstanceBase::GetShape
PUBLIC	?GetRace@CInstanceBase@@QAEKXZ			; CInstanceBase::GetRace
PUBLIC	?GetVirtualID@CInstanceBase@@QAEKXZ		; CInstanceBase::GetVirtualID
PUBLIC	?GetVirtualNumber@CInstanceBase@@QAEKXZ		; CInstanceBase::GetVirtualNumber
PUBLIC	?GetEmpireID@CInstanceBase@@QAEKXZ		; CInstanceBase::GetEmpireID
PUBLIC	?GetGuildID@CInstanceBase@@QAEKXZ		; CInstanceBase::GetGuildID
PUBLIC	?GetAlignment@CInstanceBase@@QAEHXZ		; CInstanceBase::GetAlignment
PUBLIC	?GetAlignmentGrade@CInstanceBase@@QAEIXZ	; CInstanceBase::GetAlignmentGrade
PUBLIC	?GetAlignmentType@CInstanceBase@@QAEHXZ		; CInstanceBase::GetAlignmentType
PUBLIC	?GetPKMode@CInstanceBase@@QAEEXZ		; CInstanceBase::GetPKMode
PUBLIC	?IsKiller@CInstanceBase@@QAE_NXZ		; CInstanceBase::IsKiller
PUBLIC	?IsPartyMember@CInstanceBase@@QAE_NXZ		; CInstanceBase::IsPartyMember
PUBLIC	?CanAct@CInstanceBase@@QAE_NXZ			; CInstanceBase::CanAct
PUBLIC	?CanMove@CInstanceBase@@QAE_NXZ			; CInstanceBase::CanMove
PUBLIC	?CanAttack@CInstanceBase@@QAE_NXZ		; CInstanceBase::CanAttack
PUBLIC	?CanUseSkill@CInstanceBase@@QAE_NXZ		; CInstanceBase::CanUseSkill
PUBLIC	?CanFishing@CInstanceBase@@QAE_NXZ		; CInstanceBase::CanFishing
PUBLIC	?IsConflictAlignmentInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsConflictAlignmentInstance
PUBLIC	?IsAttackableInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsAttackableInstance
PUBLIC	?IsTargetableInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsTargetableInstance
PUBLIC	?CanChangeTarget@CInstanceBase@@QAE_NXZ		; CInstanceBase::CanChangeTarget
PUBLIC	?CanPickInstance@CInstanceBase@@QAE_NXZ		; CInstanceBase::CanPickInstance
PUBLIC	?CanViewTargetHP@CInstanceBase@@QAE_NAAV1@@Z	; CInstanceBase::CanViewTargetHP
PUBLIC	?IsInvisibility@CInstanceBase@@QAEHXZ		; CInstanceBase::IsInvisibility
PUBLIC	?IsParalysis@CInstanceBase@@QAEHXZ		; CInstanceBase::IsParalysis
PUBLIC	?IsGameMaster@CInstanceBase@@QAEHXZ		; CInstanceBase::IsGameMaster
PUBLIC	?IsSameEmpire@CInstanceBase@@QAEHAAV1@@Z	; CInstanceBase::IsSameEmpire
PUBLIC	?IsBowMode@CInstanceBase@@QAEHXZ		; CInstanceBase::IsBowMode
PUBLIC	?IsHandMode@CInstanceBase@@QAEHXZ		; CInstanceBase::IsHandMode
PUBLIC	?IsFishingMode@CInstanceBase@@QAEHXZ		; CInstanceBase::IsFishingMode
PUBLIC	?IsFishing@CInstanceBase@@QAEHXZ		; CInstanceBase::IsFishing
PUBLIC	?IsWearingDress@CInstanceBase@@QAEHXZ		; CInstanceBase::IsWearingDress
PUBLIC	?IsHoldingPickAxe@CInstanceBase@@QAEHXZ		; CInstanceBase::IsHoldingPickAxe
PUBLIC	?IsMountingHorse@CInstanceBase@@QAEHXZ		; CInstanceBase::IsMountingHorse
PUBLIC	?IsNewMount@CInstanceBase@@QAEHXZ		; CInstanceBase::IsNewMount
PUBLIC	?IsForceVisible@CInstanceBase@@QAEHXZ		; CInstanceBase::IsForceVisible
PUBLIC	?IsInSafe@CInstanceBase@@QAEHXZ			; CInstanceBase::IsInSafe
PUBLIC	?IsEnemy@CInstanceBase@@QAEHXZ			; CInstanceBase::IsEnemy
PUBLIC	?IsStone@CInstanceBase@@QAEHXZ			; CInstanceBase::IsStone
PUBLIC	?IsResource@CInstanceBase@@QAEHXZ		; CInstanceBase::IsResource
PUBLIC	?IsNPC@CInstanceBase@@QAEHXZ			; CInstanceBase::IsNPC
PUBLIC	?IsPC@CInstanceBase@@QAEHXZ			; CInstanceBase::IsPC
PUBLIC	?IsPoly@CInstanceBase@@QAEHXZ			; CInstanceBase::IsPoly
PUBLIC	?IsWarp@CInstanceBase@@QAEHXZ			; CInstanceBase::IsWarp
PUBLIC	?IsGoto@CInstanceBase@@QAEHXZ			; CInstanceBase::IsGoto
PUBLIC	?IsObject@CInstanceBase@@QAEHXZ			; CInstanceBase::IsObject
PUBLIC	?IsDoor@CInstanceBase@@QAEHXZ			; CInstanceBase::IsDoor
PUBLIC	?IsBuilding@CInstanceBase@@QAEHXZ		; CInstanceBase::IsBuilding
PUBLIC	?IsWoodenDoor@CInstanceBase@@QAEHXZ		; CInstanceBase::IsWoodenDoor
PUBLIC	?IsStoneDoor@CInstanceBase@@QAEHXZ		; CInstanceBase::IsStoneDoor
PUBLIC	?IsFlag@CInstanceBase@@QAEHXZ			; CInstanceBase::IsFlag
PUBLIC	?IsGuildWall@CInstanceBase@@QAEHXZ		; CInstanceBase::IsGuildWall
PUBLIC	?IsDead@CInstanceBase@@QAEHXZ			; CInstanceBase::IsDead
PUBLIC	?IsStun@CInstanceBase@@QAEHXZ			; CInstanceBase::IsStun
PUBLIC	?IsSleep@CInstanceBase@@QAEHXZ			; CInstanceBase::IsSleep
PUBLIC	?__IsSyncing@CInstanceBase@@QAEHXZ		; CInstanceBase::__IsSyncing
PUBLIC	?PushUDPState@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MII@Z ; CInstanceBase::PushUDPState
PUBLIC	?PushTCPState@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MII@Z ; CInstanceBase::PushTCPState
PUBLIC	?PushTCPStateExpanded@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MIII@Z ; CInstanceBase::PushTCPStateExpanded
PUBLIC	?NEW_SetOwner@CInstanceBase@@QAEXK@Z		; CInstanceBase::NEW_SetOwner
PUBLIC	?NEW_IsLastPixelPosition@CInstanceBase@@QAE_NXZ	; CInstanceBase::NEW_IsLastPixelPosition
PUBLIC	?NEW_GetLastPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetLastPixelPositionRef
PUBLIC	?AvoidObject@CInstanceBase@@QAE_NABVCGraphicObjectInstance@@@Z ; CInstanceBase::AvoidObject
PUBLIC	?IsBlockObject@CInstanceBase@@QAE_NABVCGraphicObjectInstance@@@Z ; CInstanceBase::IsBlockObject
PUBLIC	?BlockMovement@CInstanceBase@@QAEXXZ		; CInstanceBase::BlockMovement
PUBLIC	?RestoreRenderMode@CInstanceBase@@QAEXXZ	; CInstanceBase::RestoreRenderMode
PUBLIC	?SetAddRenderMode@CInstanceBase@@QAEXXZ		; CInstanceBase::SetAddRenderMode
PUBLIC	?SetModulateRenderMode@CInstanceBase@@QAEXXZ	; CInstanceBase::SetModulateRenderMode
PUBLIC	?SetRenderMode@CInstanceBase@@QAEXH@Z		; CInstanceBase::SetRenderMode
PUBLIC	?SetAddColor@CInstanceBase@@QAEXABUD3DXCOLOR@@@Z ; CInstanceBase::SetAddColor
PUBLIC	?IntersectDefendingSphere@CInstanceBase@@QAE_NXZ ; CInstanceBase::IntersectDefendingSphere
PUBLIC	?IntersectBoundingBox@CInstanceBase@@QAE_NXZ	; CInstanceBase::IntersectBoundingBox
PUBLIC	?Refresh@CInstanceBase@@QAEXK_N@Z		; CInstanceBase::Refresh
PUBLIC	?GetDistance@CInstanceBase@@QAEMPAV1@@Z		; CInstanceBase::GetDistance
PUBLIC	?GetDistance@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z ; CInstanceBase::GetDistance
PUBLIC	?GetGraphicThingInstanceRef@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstanceRef
PUBLIC	?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::GetGraphicThingInstancePtr
PUBLIC	?__Background_IsWaterPixelPosition@CInstanceBase@@QAE_NABUD3DXVECTOR3@@@Z ; CInstanceBase::__Background_IsWaterPixelPosition
PUBLIC	?__Background_GetWaterHeight@CInstanceBase@@QAE_NABUD3DXVECTOR3@@PAM@Z ; CInstanceBase::__Background_GetWaterHeight
PUBLIC	?__LessRenderOrder_GetLODLevel@CInstanceBase@@IAEIXZ ; CInstanceBase::__LessRenderOrder_GetLODLevel
PUBLIC	?__Initialize@CInstanceBase@@IAEXXZ		; CInstanceBase::__Initialize
PUBLIC	?__InitializeRotationSpeed@CInstanceBase@@IAEXXZ ; CInstanceBase::__InitializeRotationSpeed
PUBLIC	?__Create_SetName@CInstanceBase@@IAEXABUSCreateData@1@@Z ; CInstanceBase::__Create_SetName
PUBLIC	?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z ; CInstanceBase::__Create_SetWarpName
PUBLIC	?__GetMainInstancePtr@CInstanceBase@@IAEPAV1@XZ	; CInstanceBase::__GetMainInstancePtr
PUBLIC	?__FindInstancePtr@CInstanceBase@@IAEPAV1@K@Z	; CInstanceBase::__FindInstancePtr
PUBLIC	?__FindRaceType@CInstanceBase@@IAE_NKPAE@Z	; CInstanceBase::__FindRaceType
PUBLIC	?__GetRaceType@CInstanceBase@@IAEKXZ		; CInstanceBase::__GetRaceType
PUBLIC	?__IsShapeAnimalWear@CInstanceBase@@IAE_NXZ	; CInstanceBase::__IsShapeAnimalWear
PUBLIC	?__IsChangableWeapon@CInstanceBase@@IAEHH@Z	; CInstanceBase::__IsChangableWeapon
PUBLIC	?__EnableSkipCollision@CInstanceBase@@IAEXXZ	; CInstanceBase::__EnableSkipCollision
PUBLIC	?__DisableSkipCollision@CInstanceBase@@IAEXXZ	; CInstanceBase::__DisableSkipCollision
PUBLIC	?__ClearMainInstance@CInstanceBase@@IAEXXZ	; CInstanceBase::__ClearMainInstance
PUBLIC	?__CanProcessNetworkStatePacket@CInstanceBase@@IAEHXZ ; CInstanceBase::__CanProcessNetworkStatePacket
PUBLIC	?__IsInDustRange@CInstanceBase@@IAE_NXZ		; CInstanceBase::__IsInDustRange
PUBLIC	?__ProcessFunctionEmotion@CInstanceBase@@IAEXKKABUD3DXVECTOR3@@@Z ; CInstanceBase::__ProcessFunctionEmotion
PUBLIC	?__IsEnableTCPProcess@CInstanceBase@@IAEHI@Z	; CInstanceBase::__IsEnableTCPProcess
PUBLIC	?__CanRender@CInstanceBase@@IAE_NXZ		; CInstanceBase::__CanRender
PUBLIC	?__IsInViewFrustum@CInstanceBase@@IAE_NXZ	; CInstanceBase::__IsInViewFrustum
PUBLIC	?__AttachHorseSaddle@CInstanceBase@@IAEXXZ	; CInstanceBase::__AttachHorseSaddle
PUBLIC	?__DetachHorseSaddle@CInstanceBase@@IAEXXZ	; CInstanceBase::__DetachHorseSaddle
PUBLIC	??0SHORSE@CInstanceBase@@QAE@XZ			; CInstanceBase::SHORSE::SHORSE
PUBLIC	??1SHORSE@CInstanceBase@@QAE@XZ			; CInstanceBase::SHORSE::~SHORSE
PUBLIC	?Destroy@SHORSE@CInstanceBase@@QAEXXZ		; CInstanceBase::SHORSE::Destroy
PUBLIC	?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z ; CInstanceBase::SHORSE::Create
PUBLIC	?SetAttackSpeed@SHORSE@CInstanceBase@@QAEXI@Z	; CInstanceBase::SHORSE::SetAttackSpeed
PUBLIC	?SetMoveSpeed@SHORSE@CInstanceBase@@QAEXI@Z	; CInstanceBase::SHORSE::SetMoveSpeed
PUBLIC	?Deform@SHORSE@CInstanceBase@@QAEXXZ		; CInstanceBase::SHORSE::Deform
PUBLIC	?Render@SHORSE@CInstanceBase@@QAEXXZ		; CInstanceBase::SHORSE::Render
PUBLIC	?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::SHORSE::GetActorRef
PUBLIC	?GetActorPtr@SHORSE@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::SHORSE::GetActorPtr
PUBLIC	?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ	; CInstanceBase::SHORSE::IsMounting
PUBLIC	?CanAttack@SHORSE@CInstanceBase@@QAE_NXZ	; CInstanceBase::SHORSE::CanAttack
PUBLIC	?CanUseSkill@SHORSE@CInstanceBase@@QAE_NXZ	; CInstanceBase::SHORSE::CanUseSkill
PUBLIC	?GetLevel@SHORSE@CInstanceBase@@QAEIXZ		; CInstanceBase::SHORSE::GetLevel
PUBLIC	?IsNewMount@SHORSE@CInstanceBase@@QAE_NXZ	; CInstanceBase::SHORSE::IsNewMount
PUBLIC	?__Initialize@SHORSE@CInstanceBase@@QAEXXZ	; CInstanceBase::SHORSE::__Initialize
PUBLIC	?__SetBlendRenderingMode@CInstanceBase@@IAEXXZ	; CInstanceBase::__SetBlendRenderingMode
PUBLIC	?__SetAlphaValue@CInstanceBase@@IAEXM@Z		; CInstanceBase::__SetAlphaValue
PUBLIC	?__GetAlphaValue@CInstanceBase@@IAEMXZ		; CInstanceBase::__GetAlphaValue
PUBLIC	?MovementProcess@CInstanceBase@@IAEXXZ		; CInstanceBase::MovementProcess
PUBLIC	?StateProcess@CInstanceBase@@IAEXXZ		; CInstanceBase::StateProcess
PUBLIC	?GetLocalTime@CInstanceBase@@IAEMXZ		; CInstanceBase::GetLocalTime
PUBLIC	?RefreshState@CInstanceBase@@IAEXK_N@Z		; CInstanceBase::RefreshState
PUBLIC	?RefreshActorInstance@CInstanceBase@@IAEXXZ	; CInstanceBase::RefreshActorInstance
PUBLIC	?OnSyncing@CInstanceBase@@IAEXXZ		; CInstanceBase::OnSyncing
PUBLIC	?OnWaiting@CInstanceBase@@IAEXXZ		; CInstanceBase::OnWaiting
PUBLIC	?OnMoving@CInstanceBase@@IAEXXZ			; CInstanceBase::OnMoving
PUBLIC	?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition
PUBLIC	?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition
PUBLIC	?NEW_SetDstPixelPositionZ@CInstanceBase@@IAEXM@Z ; CInstanceBase::NEW_SetDstPixelPositionZ
PUBLIC	?NEW_GetCurPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetCurPixelPositionRef
PUBLIC	?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetSrcPixelPositionRef
PUBLIC	?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
PUBLIC	?__GetRefinedEffect@CInstanceBase@@IAEIPAVCItemData@@@Z ; CInstanceBase::__GetRefinedEffect
PUBLIC	?__ClearWeaponRefineEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__ClearWeaponRefineEffect
PUBLIC	?__ClearArmorRefineEffect@CInstanceBase@@IAEXXZ	; CInstanceBase::__ClearArmorRefineEffect
PUBLIC	??1SEffectContainer@CInstanceBase@@QAE@XZ	; CInstanceBase::SEffectContainer::~SEffectContainer
PUBLIC	??0?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >
PUBLIC	??1?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::~list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >
PUBLIC	?_Unchecked_erase@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Unchecked_erase
PUBLIC	?clear@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEXXZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::clear
PUBLIC	?_Tidy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Alloc_sentinel_and_proxy
PUBLIC	??0?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >
PUBLIC	??1?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::~list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >
PUBLIC	?_Tidy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Alloc_sentinel_and_proxy
PUBLIC	?__Warrior_Initialize@CInstanceBase@@IAEXXZ	; CInstanceBase::__Warrior_Initialize
PUBLIC	?__GetBackgroundHeight@CInstanceBase@@KAMMM@Z	; CInstanceBase::__GetBackgroundHeight
PUBLIC	?__GetShadowMapColor@CInstanceBase@@KAKMM@Z	; CInstanceBase::__GetShadowMapColor
PUBLIC	?ResetPerformanceCounter@CInstanceBase@@SAXXZ	; CInstanceBase::ResetPerformanceCounter
PUBLIC	?GetInfo@CInstanceBase@@SAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; CInstanceBase::GetInfo
PUBLIC	?New@CInstanceBase@@SAPAV1@XZ			; CInstanceBase::New
PUBLIC	?Delete@CInstanceBase@@SAXPAV1@@Z		; CInstanceBase::Delete
PUBLIC	?GetDuelMode@CInstanceBase@@QAEKXZ		; CInstanceBase::GetDuelMode
PUBLIC	?SetDuelMode@CInstanceBase@@QAEXK@Z		; CInstanceBase::SetDuelMode
PUBLIC	??_GCInstanceBase@@UAEPAXI@Z			; CInstanceBase::`scalar deleting destructor'
PUBLIC	?deallocate@?$allocator@PAVCInstanceBase@@@std@@QAEXQAPAVCInstanceBase@@I@Z ; std::allocator<CInstanceBase *>::deallocate
PUBLIC	?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Reallocate_exactly
PUBLIC	?reserve@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXI@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::reserve
PUBLIC	?clear@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::clear
PUBLIC	?_Destroy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXPAPAVCInstanceBase@@0@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@ABEII@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXQAPAVCInstanceBase@@II@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@CAXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Xlength
PUBLIC	?_Getal@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEAAV?$allocator@PAVCInstanceBase@@@2@XZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Getal
PUBLIC	?IsWall@@YA_NI@Z				; IsWall
PUBLIC	?__ArmorVnumToShape@@YA_NHPAK@Z			; __ArmorVnumToShape
PUBLIC	?IsBlock@CActorInstanceBackground@@UAE_NHH@Z	; CActorInstanceBackground::IsBlock
PUBLIC	??_GCActorInstanceBackground@@UAEPAXI@Z		; CActorInstanceBackground::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPool@VCInstanceBase@@@@QAE@XZ	; CDynamicPool<CInstanceBase>::CDynamicPool<CInstanceBase>
PUBLIC	??1?$CDynamicPool@VCInstanceBase@@@@UAE@XZ	; CDynamicPool<CInstanceBase>::~CDynamicPool<CInstanceBase>
PUBLIC	?Destroy@?$CDynamicPool@VCInstanceBase@@@@QAEXXZ ; CDynamicPool<CInstanceBase>::Destroy
PUBLIC	?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ ; CDynamicPool<CInstanceBase>::Alloc
PUBLIC	?Delete@?$CDynamicPool@VCInstanceBase@@@@KAXPAVCInstanceBase@@@Z ; CDynamicPool<CInstanceBase>::Delete
PUBLIC	??_G?$CDynamicPool@VCInstanceBase@@@@UAEPAXI@Z	; CDynamicPool<CInstanceBase>::`scalar deleting destructor'
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SCommand,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
PUBLIC	??$_Emplace@ABUSCommand@CInstanceBase@@@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@1@QAU21@ABUSCommand@CInstanceBase@@@Z ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Emplace<CInstanceBase::SCommand const &>
PUBLIC	??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
PUBLIC	??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
PUBLIC	?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
PUBLIC	?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
PUBLIC	?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
PUBLIC	?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
PUBLIC	??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
PUBLIC	??$_Traits_find_first_of@U?$char_traits@D@std@@@std@@YAIQBDII0IU?$integral_constant@_N$00@0@@Z ; std::_Traits_find_first_of<std::char_traits<char> >
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@std@@P6AXPAVCInstanceBase@@@Z@std@@YAP6AXPAVCInstanceBase@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInstanceBase *> > >,void (__cdecl*)(CInstanceBase *)>
PUBLIC	??$emplace_back@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXABQAVCInstanceBase@@@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::emplace_back<CInstanceBase * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXABQAVCInstanceBase@@@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Emplace_back_with_unused_capacity<CInstanceBase * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Emplace_reallocate<CInstanceBase * const &>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *,std::_List_node<CInstanceBase::SEffectDamage,void *> * &>
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SCommand,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
PUBLIC	??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
PUBLIC	??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAXPAPAVCInstanceBase@@QAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Destroy_range<std::allocator<CInstanceBase *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
PUBLIC	??$_Uninitialized_move@PAPAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAPAPAVCInstanceBase@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Uninitialized_move<CInstanceBase * *,std::allocator<CInstanceBase *> >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_Transfer_before
PUBLIC	??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > ><CInstanceBase::SCommand const &>
PUBLIC	??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
PUBLIC	??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SCommand,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> * const &>
PUBLIC	??$_Copy_memmove@PAPAVCInstanceBase@@PAPAV1@@std@@YAPAPAVCInstanceBase@@PAPAV1@00@Z ; std::_Copy_memmove<CInstanceBase * *,CInstanceBase * *>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * const &>
PUBLIC	??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	?ms_singleton@?$CSingleton@VIBackground@@@@0PAVIBackground@@A ; CSingleton<IBackground>::ms_singleton
PUBLIC	??_7?$CSingleton@VIBackground@@@@6B@		; CSingleton<IBackground>::`vftable'
PUBLIC	??_7IBackground@@6B@				; IBackground::`vftable'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4IBackground@@6B@				; IBackground::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVIBackground@@@8				; IBackground `RTTI Type Descriptor'
PUBLIC	??_R3IBackground@@8				; IBackground::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2IBackground@@8				; IBackground::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@IBackground@@8			; IBackground::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VIBackground@@@@8	; CSingleton<IBackground>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VIBackground@@@@@8		; CSingleton<IBackground> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VIBackground@@@@8		; CSingleton<IBackground>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VIBackground@@@@8		; CSingleton<IBackground>::`RTTI Base Class Array'
PUBLIC	??_R4?$CSingleton@VIBackground@@@@6B@		; CSingleton<IBackground>::`RTTI Complete Object Locator'
PUBLIC	?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
PUBLIC	?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
PUBLIC	?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
PUBLIC	?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A ; CInstanceBase::ms_kPool
PUBLIC	??_7CInstanceBase@@6B@				; CInstanceBase::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonNonPlayer@@@@0PAVCPythonNonPlayer@@A ; CSingleton<CPythonNonPlayer>::ms_singleton
PUBLIC	?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
PUBLIC	?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A ; TAbstractSingleton<IAbstractApplication>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
PUBLIC	??_C@_06PNAKCKLH@saddle@			; `string'
PUBLIC	??_7CActorInstanceBackground@@6B@		; CActorInstanceBackground::`vftable'
PUBLIC	??_7?$CDynamicPool@VCInstanceBase@@@@6B@	; CDynamicPool<CInstanceBase>::`vftable'
PUBLIC	??_C@_0EL@PHAIMNFF@CInstanceBase?3?3__EnableSkipColl@ ; `string'
PUBLIC	??_C@_01CLKCMJKC@?5@				; `string'
PUBLIC	??_C@_0BP@PGINAIMI@Inst?5?9?5UC?5?$CFd?0?5RC?5?$CFd?5Pool?5?9?5?$CFd?5@ ; `string'
PUBLIC	??_C@_0EG@IFLKAGDE@CInstanceBase?3?3PushTCPState?5?G?C?$LH@ ; `string'
PUBLIC	??_C@_0DM@EIDAANLK@vid?$DN?$CFd?5?$LP?r?A?w?$MA?O?5?$LM?v?5?$LO?x?$LE?B?5?$LL?s?E?B?$LG?s?5?$LN?$LK@ ; `string'
PUBLIC	??_C@_0EG@MNIPPABI@CPythonCharacterManager?3?3Change@ ; `string'
PUBLIC	??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
PUBLIC	??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CInstanceBase@@6B@				; CInstanceBase::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCInstanceBase@@@8			; CInstanceBase `RTTI Type Descriptor'
PUBLIC	??_R3CInstanceBase@@8				; CInstanceBase::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CInstanceBase@@8				; CInstanceBase::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CInstanceBase@@8			; CInstanceBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$CDynamicPool@VCInstanceBase@@@@6B@	; CDynamicPool<CInstanceBase>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$CDynamicPool@VCInstanceBase@@@@@8	; CDynamicPool<CInstanceBase> `RTTI Type Descriptor'
PUBLIC	??_R3?$CDynamicPool@VCInstanceBase@@@@8		; CDynamicPool<CInstanceBase>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CDynamicPool@VCInstanceBase@@@@8		; CDynamicPool<CInstanceBase>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CDynamicPool@VCInstanceBase@@@@8 ; CDynamicPool<CInstanceBase>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CActorInstanceBackground@@6B@		; CActorInstanceBackground::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCActorInstanceBackground@@@8		; CActorInstanceBackground `RTTI Type Descriptor'
PUBLIC	??_R3CActorInstanceBackground@@8		; CActorInstanceBackground::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CActorInstanceBackground@@8		; CActorInstanceBackground::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CActorInstanceBackground@@8	; CActorInstanceBackground::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3b808081
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e19999a
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__real@437a0000
PUBLIC	__real@43960000
PUBLIC	__real@43b40000
PUBLIC	__real@43fa0000
PUBLIC	__real@447a0000
PUBLIC	__real@44960000
PUBLIC	__real@44fa0000
PUBLIC	__real@45160000
PUBLIC	__real@451c4000
PUBLIC	__real@c2c80000
PUBLIC	__xmm@41f00000000000000000000000000000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__Init_thread_header:PROC
EXTRN	__Init_thread_abort:PROC
EXTRN	__Init_thread_footer:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memchr:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strlen:PROC
EXTRN	_fmod:PROC
EXTRN	_sqrt:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Lognf@@YAXIPBDZZ:PROC				; Lognf
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	?IsFile@@YA_NPBD@Z:PROC				; IsFile
EXTRN	?ELTimer_GetFrameMSec@@YAKXZ:PROC		; ELTimer_GetFrameMSec
EXTRN	??0CScreen@@QAE@XZ:PROC				; CScreen::CScreen
EXTRN	??1CScreen@@UAE@XZ:PROC				; CScreen::~CScreen
EXTRN	?RenderLine3d@CScreen@@QAEXMMMMMM@Z:PROC	; CScreen::RenderLine3d
EXTRN	?SetDiffuseColor@CScreen@@QAEXMMMM@Z:PROC	; CScreen::SetDiffuseColor
EXTRN	?Render@CGraphicObjectInstance@@QAE_NXZ:PROC	; CGraphicObjectInstance::Render
EXTRN	?isShow@CGraphicObjectInstance@@QAE_NXZ:PROC	; CGraphicObjectInstance::isShow
EXTRN	?Initialize@CGraphicObjectInstance@@QAEXXZ:PROC	; CGraphicObjectInstance::Initialize
EXTRN	?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ:PROC ; CGraphicObjectInstance::RegisterBoundingSphere
EXTRN	?DeformNoSkin@CGraphicThingInstance@@QAEXXZ:PROC ; CGraphicThingInstance::DeformNoSkin
EXTRN	?CreateDeviceObjects@CGraphicThingInstance@@QAE_NXZ:PROC ; CGraphicThingInstance::CreateDeviceObjects
EXTRN	?DestroyDeviceObjects@CGraphicThingInstance@@QAEXXZ:PROC ; CGraphicThingInstance::DestroyDeviceObjects
EXTRN	?AttachModelInstance@CGraphicThingInstance@@QAEXHPBDAAV1@H@Z:PROC ; CGraphicThingInstance::AttachModelInstance
EXTRN	?DetachModelInstance@CGraphicThingInstance@@QAEXHAAV1@H@Z:PROC ; CGraphicThingInstance::DetachModelInstance
EXTRN	?GetLocalTime@CGraphicThingInstance@@QAEMXZ:PROC ; CGraphicThingInstance::GetLocalTime
EXTRN	?GetSecondElapsed@CGraphicThingInstance@@QAEMXZ:PROC ; CGraphicThingInstance::GetSecondElapsed
EXTRN	?GetLODControllerPointer@CGraphicThingInstance@@QAEPAVCGrannyLODController@@K@Z:PROC ; CGraphicThingInstance::GetLODControllerPointer
EXTRN	?Intersect@CGraphicThingInstance@@QAE_NPAM00@Z:PROC ; CGraphicThingInstance::Intersect
EXTRN	?GetBoundBox@CGraphicThingInstance@@QAEXPAUD3DXVECTOR3@@0@Z:PROC ; CGraphicThingInstance::GetBoundBox
EXTRN	?GetRotatingDirection@@YAHMM@Z:PROC		; GetRotatingDirection
EXTRN	?SPixelPosition_CalculateDistanceSq3d@@YAMABUD3DXVECTOR3@@0@Z:PROC ; SPixelPosition_CalculateDistanceSq3d
EXTRN	??_E?$CSingleton@VIBackground@@@@UAEPAXI@Z:PROC	; CSingleton<IBackground>::`vector deleting destructor'
EXTRN	??_EIBackground@@UAEPAXI@Z:PROC			; IBackground::`vector deleting destructor'
EXTRN	?GetIndex@CItemData@@QBEKXZ:PROC		; CItemData::GetIndex
EXTRN	?GetType@CItemData@@QBEEXZ:PROC			; CItemData::GetType
EXTRN	?GetSubType@CItemData@@QBEEXZ:PROC		; CItemData::GetSubType
EXTRN	?GetRefine@CItemData@@QBEIXZ:PROC		; CItemData::GetRefine
EXTRN	?GetWeaponType@CItemData@@QBEKXZ:PROC		; CItemData::GetWeaponType
EXTRN	?GetValue@CItemData@@QBEJE@Z:PROC		; CItemData::GetValue
EXTRN	?GetSocketCount@CItemData@@QBEHXZ:PROC		; CItemData::GetSocketCount
EXTRN	?GetSpecularPowerf@CItemData@@QBEMXZ:PROC	; CItemData::GetSpecularPowerf
EXTRN	?GetGuildSymbolFileName@@YAPBDK@Z:PROC		; GetGuildSymbolFileName
EXTRN	?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SaveRenderState
EXTRN	?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z:PROC ; CStateManager::RestoreRenderState
EXTRN	?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z:PROC ; CStateManager::SetRenderState
EXTRN	?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z:PROC ; CStateManager::SetTextureStageState
EXTRN	?GetEmptyPtr@IEventHandler@CActorInstance@@SAPAV12@XZ:PROC ; CActorInstance::IEventHandler::GetEmptyPtr
EXTRN	?IsDirLine@CActorInstance@@SA_NXZ:PROC		; CActorInstance::IsDirLine
EXTRN	??0CActorInstance@@QAE@XZ:PROC			; CActorInstance::CActorInstance
EXTRN	??1CActorInstance@@UAE@XZ:PROC			; CActorInstance::~CActorInstance
EXTRN	?INSTANCEBASE_Transform@CActorInstance@@QAEXXZ:PROC ; CActorInstance::INSTANCEBASE_Transform
EXTRN	?INSTANCEBASE_Deform@CActorInstance@@QAEXXZ:PROC ; CActorInstance::INSTANCEBASE_Deform
EXTRN	?Destroy@CActorInstance@@QAEXXZ:PROC		; CActorInstance::Destroy
EXTRN	?Stop@CActorInstance@@QAEXM@Z:PROC		; CActorInstance::Stop
EXTRN	?SetMainInstance@CActorInstance@@QAEXXZ:PROC	; CActorInstance::SetMainInstance
EXTRN	?SetAttackSpeed@CActorInstance@@QAEXM@Z:PROC	; CActorInstance::SetAttackSpeed
EXTRN	?SetMoveSpeed@CActorInstance@@QAEXM@Z:PROC	; CActorInstance::SetMoveSpeed
EXTRN	?SetMaterialColor@CActorInstance@@QAEXK@Z:PROC	; CActorInstance::SetMaterialColor
EXTRN	?SetEventHandler@CActorInstance@@QAEXPAVIEventHandler@1@@Z:PROC ; CActorInstance::SetEventHandler
EXTRN	?SetRace@CActorInstance@@QAE_NK@Z:PROC		; CActorInstance::SetRace
EXTRN	?SetHair@CActorInstance@@QAEXK@Z:PROC		; CActorInstance::SetHair
EXTRN	?SetVirtualID@CActorInstance@@QAEXK@Z:PROC	; CActorInstance::SetVirtualID
EXTRN	?SetShape@CActorInstance@@QAEXKM@Z:PROC		; CActorInstance::SetShape
EXTRN	?ChangeMaterial@CActorInstance@@QAEXPBD@Z:PROC	; CActorInstance::ChangeMaterial
EXTRN	?SetComboType@CActorInstance@@QAEXG@Z:PROC	; CActorInstance::SetComboType
EXTRN	?GetRace@CActorInstance@@QAEKXZ:PROC		; CActorInstance::GetRace
EXTRN	?GetActorType@CActorInstance@@QBEIXZ:PROC	; CActorInstance::GetActorType
EXTRN	?SetActorType@CActorInstance@@QAEXI@Z:PROC	; CActorInstance::SetActorType
EXTRN	?CanAct@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::CanAct
EXTRN	?CanMove@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::CanMove
EXTRN	?CanAttack@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::CanAttack
EXTRN	?CanUseSkill@CActorInstance@@QAE_NXZ:PROC	; CActorInstance::CanUseSkill
EXTRN	?IsPC@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsPC
EXTRN	?IsNPC@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsNPC
EXTRN	?IsEnemy@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsEnemy
EXTRN	?IsStone@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsStone
EXTRN	?IsWarp@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsWarp
EXTRN	?IsGoto@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsGoto
EXTRN	?IsObject@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsObject
EXTRN	?IsDoor@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsDoor
EXTRN	?IsPoly@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsPoly
EXTRN	?IsBuilding@CActorInstance@@QAE_NXZ:PROC	; CActorInstance::IsBuilding
EXTRN	?IsHandMode@CActorInstance@@QAE_NXZ:PROC	; CActorInstance::IsHandMode
EXTRN	?IsBowMode@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsBowMode
EXTRN	?AttachWeapon@CActorInstance@@QAEXKKK@Z:PROC	; CActorInstance::AttachWeapon
EXTRN	?RefreshActorInstance@CActorInstance@@QAEXXZ:PROC ; CActorInstance::RefreshActorInstance
EXTRN	?GetPartItemID@CActorInstance@@QAEKK@Z:PROC	; CActorInstance::GetPartItemID
EXTRN	?SetMotionMode@CActorInstance@@QAEXH@Z:PROC	; CActorInstance::SetMotionMode
EXTRN	?GetMotionMode@CActorInstance@@QAEHXZ:PROC	; CActorInstance::GetMotionMode
EXTRN	?InterceptOnceMotion@CActorInstance@@QAE_NKMIM@Z:PROC ; CActorInstance::InterceptOnceMotion
EXTRN	?InterceptLoopMotion@CActorInstance@@QAE_NKM@Z:PROC ; CActorInstance::InterceptLoopMotion
EXTRN	?IsPushing@CActorInstance@@QAE_NXZ:PROC		; CActorInstance::IsPushing
EXTRN	?IsUsingSkill@CActorInstance@@QAEHXZ:PROC	; CActorInstance::IsUsingSkill
EXTRN	?CanCancelSkill@CActorInstance@@QAEHXZ:PROC	; CActorInstance::CanCancelSkill
EXTRN	?UpdateAdvancingPointInstance@CActorInstance@@QAEXXZ:PROC ; CActorInstance::UpdateAdvancingPointInstance
EXTRN	?AvoidObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z:PROC ; CActorInstance::AvoidObject
EXTRN	?IsBlockObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z:PROC ; CActorInstance::IsBlockObject
EXTRN	?BlockMovement@CActorInstance@@QAEXXZ:PROC	; CActorInstance::BlockMovement
EXTRN	?IsUsingMovingSkill@CActorInstance@@QAEHXZ:PROC	; CActorInstance::IsUsingMovingSkill
EXTRN	?IsActEmotion@CActorInstance@@QAEHXZ:PROC	; CActorInstance::IsActEmotion
EXTRN	?IsSleep@CActorInstance@@QAEHXZ:PROC		; CActorInstance::IsSleep
EXTRN	?IsParalysis@CActorInstance@@QAEHXZ:PROC	; CActorInstance::IsParalysis
EXTRN	?IsDead@CActorInstance@@QAEHXZ:PROC		; CActorInstance::IsDead
EXTRN	?IsStun@CActorInstance@@QAEHXZ:PROC		; CActorInstance::IsStun
EXTRN	?IsKnockDown@CActorInstance@@QAEHXZ:PROC	; CActorInstance::IsKnockDown
EXTRN	?DieEnd@CActorInstance@@QAEXXZ:PROC		; CActorInstance::DieEnd
EXTRN	?SetBattleHitEffect@CActorInstance@@QAEXK@Z:PROC ; CActorInstance::SetBattleHitEffect
EXTRN	?GetMovementVectorRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ:PROC ; CActorInstance::GetMovementVectorRef
EXTRN	?SetCurPixelPosition@CActorInstance@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CActorInstance::SetCurPixelPosition
EXTRN	?NEW_SetSrcPixelPosition@CActorInstance@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CActorInstance::NEW_SetSrcPixelPosition
EXTRN	?NEW_SetDstPixelPosition@CActorInstance@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CActorInstance::NEW_SetDstPixelPosition
EXTRN	?NEW_SetDstPixelPositionZ@CActorInstance@@QAEXM@Z:PROC ; CActorInstance::NEW_SetDstPixelPositionZ
EXTRN	?NEW_GetCurPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ:PROC ; CActorInstance::NEW_GetCurPixelPositionRef
EXTRN	?NEW_GetSrcPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ:PROC ; CActorInstance::NEW_GetSrcPixelPositionRef
EXTRN	?NEW_GetDstPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ:PROC ; CActorInstance::NEW_GetDstPixelPositionRef
EXTRN	?NEW_GetLastPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ:PROC ; CActorInstance::NEW_GetLastPixelPositionRef
EXTRN	?GetPixelPosition@CActorInstance@@QAEXPAUD3DXVECTOR3@@@Z:PROC ; CActorInstance::GetPixelPosition
EXTRN	?SetOwner@CActorInstance@@QAEXK@Z:PROC		; CActorInstance::SetOwner
EXTRN	?GetRotation@CActorInstance@@QAEMXZ:PROC	; CActorInstance::GetRotation
EXTRN	?GetTargetRotation@CActorInstance@@QAEMXZ:PROC	; CActorInstance::GetTargetRotation
EXTRN	?GetAdvancingRotation@CActorInstance@@QAEMXZ:PROC ; CActorInstance::GetAdvancingRotation
EXTRN	?SetRotation@CActorInstance@@QAEXM@Z:PROC	; CActorInstance::SetRotation
EXTRN	?SetAdvancingRotation@CActorInstance@@QAEXM@Z:PROC ; CActorInstance::SetAdvancingRotation
EXTRN	?IsMovement@CActorInstance@@QAEHXZ:PROC		; CActorInstance::IsMovement
EXTRN	?RestoreRenderMode@CActorInstance@@QAEXXZ:PROC	; CActorInstance::RestoreRenderMode
EXTRN	?SetBlendRenderMode@CActorInstance@@QAEXXZ:PROC	; CActorInstance::SetBlendRenderMode
EXTRN	?SetAlphaValue@CActorInstance@@QAEXM@Z:PROC	; CActorInstance::SetAlphaValue
EXTRN	?GetAlphaValue@CActorInstance@@QAEMXZ:PROC	; CActorInstance::GetAlphaValue
EXTRN	?BlendAlphaValue@CActorInstance@@QAEXMM@Z:PROC	; CActorInstance::BlendAlphaValue
EXTRN	?SetAddRenderMode@CActorInstance@@QAEXXZ:PROC	; CActorInstance::SetAddRenderMode
EXTRN	?SetAddColor@CActorInstance@@QAEXABUD3DXCOLOR@@@Z:PROC ; CActorInstance::SetAddColor
EXTRN	?SetModulateRenderMode@CActorInstance@@QAEXXZ:PROC ; CActorInstance::SetModulateRenderMode
EXTRN	?SetRenderMode@CActorInstance@@QAEXH@Z:PROC	; CActorInstance::SetRenderMode
EXTRN	?RenderTrace@CActorInstance@@QAEXXZ:PROC	; CActorInstance::RenderTrace
EXTRN	?RenderCollisionData@CActorInstance@@QAEXXZ:PROC ; CActorInstance::RenderCollisionData
EXTRN	?RenderToShadowMap@CActorInstance@@QAEXXZ:PROC	; CActorInstance::RenderToShadowMap
EXTRN	?IntersectDefendingSphere@CActorInstance@@QAE_NXZ:PROC ; CActorInstance::IntersectDefendingSphere
EXTRN	?CanFishing@CActorInstance@@QAE_NXZ:PROC	; CActorInstance::CanFishing
EXTRN	?IsFishing@CActorInstance@@QAEHXZ:PROC		; CActorInstance::IsFishing
EXTRN	?CanChangeTarget@CActorInstance@@QAE_NXZ:PROC	; CActorInstance::CanChangeTarget
EXTRN	?MountHorse@CActorInstance@@QAEXPAV1@@Z:PROC	; CActorInstance::MountHorse
EXTRN	?HORSE_MotionProcess@CActorInstance@@QAEXH@Z:PROC ; CActorInstance::HORSE_MotionProcess
EXTRN	?MotionProcess@CActorInstance@@QAEXH@Z:PROC	; CActorInstance::MotionProcess
EXTRN	?RotationProcess@CActorInstance@@QAEXXZ:PROC	; CActorInstance::RotationProcess
EXTRN	?PhysicsProcess@CActorInstance@@QAEXXZ:PROC	; CActorInstance::PhysicsProcess
EXTRN	?ComboProcess@CActorInstance@@QAEXXZ:PROC	; CActorInstance::ComboProcess
EXTRN	?AccumulationMovement@CActorInstance@@QAEXXZ:PROC ; CActorInstance::AccumulationMovement
EXTRN	?__OnSyncing@CActorInstance@@QAEXXZ:PROC	; CActorInstance::__OnSyncing
EXTRN	?__OnWaiting@CActorInstance@@QAEXXZ:PROC	; CActorInstance::__OnWaiting
EXTRN	?__OnMoving@CActorInstance@@QAEXXZ:PROC		; CActorInstance::__OnMoving
EXTRN	?EnableSkipCollision@CActorInstance@@QAEXXZ:PROC ; CActorInstance::EnableSkipCollision
EXTRN	?DisableSkipCollision@CActorInstance@@QAEXXZ:PROC ; CActorInstance::DisableSkipCollision
EXTRN	?__IsSyncing@CActorInstance@@QAE_NXZ:PROC	; CActorInstance::__IsSyncing
EXTRN	??0CAffectFlagContainer@@QAE@XZ:PROC		; CAffectFlagContainer::CAffectFlagContainer
EXTRN	??1CAffectFlagContainer@@QAE@XZ:PROC		; CAffectFlagContainer::~CAffectFlagContainer
EXTRN	?Clear@CAffectFlagContainer@@QAEXXZ:PROC	; CAffectFlagContainer::Clear
EXTRN	?CopyInstance@CAffectFlagContainer@@QAEXABV1@@Z:PROC ; CAffectFlagContainer::CopyInstance
EXTRN	?IsSet@CAffectFlagContainer@@QBE_NI@Z:PROC	; CAffectFlagContainer::IsSet
EXTRN	?ConvertToPosition@CAffectFlagContainer@@QBEXPAI0@Z:PROC ; CAffectFlagContainer::ConvertToPosition
EXTRN	?__AttachEffect@CInstanceBase@@IAEKI@Z:PROC	; CInstanceBase::__AttachEffect
EXTRN	?__DetachEffect@CInstanceBase@@IAEXK@Z:PROC	; CInstanceBase::__DetachEffect
EXTRN	?AttachTextTail@CInstanceBase@@QAEXXZ:PROC	; CInstanceBase::AttachTextTail
EXTRN	?DetachTextTail@CInstanceBase@@QAEXXZ:PROC	; CInstanceBase::DetachTextTail
EXTRN	?RefreshTextTail@CInstanceBase@@QAEXXZ:PROC	; CInstanceBase::RefreshTextTail
EXTRN	?RefreshTextTailTitle@CInstanceBase@@QAEXXZ:PROC ; CInstanceBase::RefreshTextTailTitle
EXTRN	?SetAttackSpeed@CInstanceBase@@QAEXI@Z:PROC	; CInstanceBase::SetAttackSpeed
EXTRN	?SetMoveSpeed@CInstanceBase@@QAEXI@Z:PROC	; CInstanceBase::SetMoveSpeed
EXTRN	?SetRotationSpeed@CInstanceBase@@QAEXM@Z:PROC	; CInstanceBase::SetRotationSpeed
EXTRN	?IsPVPInstance@CInstanceBase@@QAE_NAAV1@@Z:PROC	; CInstanceBase::IsPVPInstance
EXTRN	?IsAffect@CInstanceBase@@QAE_NI@Z:PROC		; CInstanceBase::IsAffect
EXTRN	?IsWaiting@CInstanceBase@@QAEHXZ:PROC		; CInstanceBase::IsWaiting
EXTRN	?IsWalking@CInstanceBase@@QAEHXZ:PROC		; CInstanceBase::IsWalking
EXTRN	?SetAdvancingRotation@CInstanceBase@@QAEXM@Z:PROC ; CInstanceBase::SetAdvancingRotation
EXTRN	?EndWalking@CInstanceBase@@QAEXM@Z:PROC		; CInstanceBase::EndWalking
EXTRN	?EndWalkingWithoutBlending@CInstanceBase@@QAEXXZ:PROC ; CInstanceBase::EndWalkingWithoutBlending
EXTRN	?SetEventHandler@CInstanceBase@@QAEXPAVIEventHandler@CActorInstance@@@Z:PROC ; CInstanceBase::SetEventHandler
EXTRN	?NEW_UseSkill@CInstanceBase@@QAE_NIII_N@Z:PROC	; CInstanceBase::NEW_UseSkill
EXTRN	?NEW_GetDistanceFromDestPixelPosition@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z:PROC ; CInstanceBase::NEW_GetDistanceFromDestPixelPosition
EXTRN	?NEW_GetDistanceFromDestInstance@CInstanceBase@@QAEMAAV1@@Z:PROC ; CInstanceBase::NEW_GetDistanceFromDestInstance
EXTRN	?NEW_GetAdvancingRotationFromPixelPosition@CInstanceBase@@QAEMABUD3DXVECTOR3@@0@Z:PROC ; CInstanceBase::NEW_GetAdvancingRotationFromPixelPosition
EXTRN	?NEW_SetPixelPosition@CInstanceBase@@QAEXABUD3DXVECTOR3@@@Z:PROC ; CInstanceBase::NEW_SetPixelPosition
EXTRN	?RunNormalAttack@CInstanceBase@@QAEXM@Z:PROC	; CInstanceBase::RunNormalAttack
EXTRN	?RunComboAttack@CInstanceBase@@QAEXMK@Z:PROC	; CInstanceBase::RunComboAttack
EXTRN	?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z:PROC ; CInstanceBase::SCRIPT_SetPixelPosition
EXTRN	?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z:PROC ; CInstanceBase::NEW_GetPixelPosition
EXTRN	?NEW_LookAtDestInstance@CInstanceBase@@QAEXAAV1@@Z:PROC ; CInstanceBase::NEW_LookAtDestInstance
EXTRN	?GetRotation@CInstanceBase@@QAEMXZ:PROC		; CInstanceBase::GetRotation
EXTRN	?GetAdvancingRotation@CInstanceBase@@QAEMXZ:PROC ; CInstanceBase::GetAdvancingRotation
EXTRN	?SetRotation@CInstanceBase@@QAEXM@Z:PROC	; CInstanceBase::SetRotation
EXTRN	?BlendRotation@CInstanceBase@@QAEXMM@Z:PROC	; CInstanceBase::BlendRotation
EXTRN	?SetMotionMode@CInstanceBase@@QAEXH@Z:PROC	; CInstanceBase::SetMotionMode
EXTRN	?__ClearAffects@CInstanceBase@@QAEXXZ:PROC	; CInstanceBase::__ClearAffects
EXTRN	?SetAffectFlagContainer@CInstanceBase@@QAEXABVCAffectFlagContainer@@@Z:PROC ; CInstanceBase::SetAffectFlagContainer
EXTRN	?__EnableChangingTCPState@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__EnableChangingTCPState
EXTRN	?__ComboProcess@CInstanceBase@@IAEXXZ:PROC	; CInstanceBase::__ComboProcess
EXTRN	?AttackProcess@CInstanceBase@@IAEXXZ:PROC	; CInstanceBase::AttackProcess
EXTRN	?StartWalking@CInstanceBase@@IAEXXZ:PROC	; CInstanceBase::StartWalking
EXTRN	?__AttachSelectEffect@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__AttachSelectEffect
EXTRN	?__DetachSelectEffect@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__DetachSelectEffect
EXTRN	?__AttachTargetEffect@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__AttachTargetEffect
EXTRN	?__DetachTargetEffect@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__DetachTargetEffect
EXTRN	?__AttachEmpireEffect@CInstanceBase@@IAEXK@Z:PROC ; CInstanceBase::__AttachEmpireEffect
EXTRN	?__EffectContainer_Initialize@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__EffectContainer_Initialize
EXTRN	?__EffectContainer_Destroy@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__EffectContainer_Destroy
EXTRN	?__StoneSmoke_Inialize@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__StoneSmoke_Inialize
EXTRN	?__StoneSmoke_Destroy@CInstanceBase@@IAEXXZ:PROC ; CInstanceBase::__StoneSmoke_Destroy
EXTRN	?ProcessDamage@CInstanceBase@@IAEXXZ:PROC	; CInstanceBase::ProcessDamage
EXTRN	?__FindDUELKey@CInstanceBase@@KA_NKK@Z:PROC	; CInstanceBase::__FindDUELKey
EXTRN	?GetEventHandlerRef@CInstanceBase@@IAEAAVIEventHandler@CActorInstance@@XZ:PROC ; CInstanceBase::GetEventHandlerRef
EXTRN	??_ECInstanceBase@@UAEPAXI@Z:PROC		; CInstanceBase::`vector deleting destructor'
EXTRN	?GetHeight@CMapManager@@QAEMMM@Z:PROC		; CMapManager::GetHeight
EXTRN	?GetWaterHeight@CMapManager@@QAE_NHHPAJ@Z:PROC	; CMapManager::GetWaterHeight
EXTRN	?GetShadowMapColor@CMapManager@@QAEKMM@Z:PROC	; CMapManager::GetShadowMapColor
EXTRN	?isAttrOn@CMapManager@@QAE_NMME@Z:PROC		; CMapManager::isAttrOn
EXTRN	?isAttrOn@CMapManager@@QAE_NHHE@Z:PROC		; CMapManager::isAttrOn
EXTRN	?GetName@CPythonNonPlayer@@QAE_NKPAPBD@Z:PROC	; CPythonNonPlayer::GetName
EXTRN	?GetInstanceType@CPythonNonPlayer@@QAE_NKPAE@Z:PROC ; CPythonNonPlayer::GetInstanceType
EXTRN	?GetMonsterColor@CPythonNonPlayer@@QAEKK@Z:PROC	; CPythonNonPlayer::GetMonsterColor
EXTRN	?IsObserverMode@CPythonPlayer@@QAE_NXZ:PROC	; CPythonPlayer::IsObserverMode
EXTRN	?ClearMainInstance@CPythonCharacterManager@@QAEXXZ:PROC ; CPythonCharacterManager::ClearMainInstance
EXTRN	?SetMainInstance@CPythonCharacterManager@@QAE_NK@Z:PROC ; CPythonCharacterManager::SetMainInstance
EXTRN	?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ:PROC ; CPythonCharacterManager::GetMainInstancePtr
EXTRN	?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z:PROC ; CItemManager::GetItemDataPointer
EXTRN	??_ECActorInstanceBackground@@UAEPAXI@Z:PROC	; CActorInstanceBackground::`vector deleting destructor'
EXTRN	??_E?$CDynamicPool@VCInstanceBase@@@@UAEPAXI@Z:PROC ; CDynamicPool<CInstanceBase>::`vector deleting destructor'
EXTRN	?ELTimer_GetServerFrameMSec@@YAKXZ:PROC		; ELTimer_GetServerFrameMSec
EXTRN	??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vector deleting destructor'
EXTRN	??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z:PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	__Init_thread_epoch:DWORD
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?ms_adwCRCAffectEffect@CInstanceBase@@1PAKA:BYTE ; CInstanceBase::ms_adwCRCAffectEffect
EXTRN	?ms_fDustGap@CInstanceBase@@1MA:DWORD		; CInstanceBase::ms_fDustGap
EXTRN	?ms_fHorseDustGap@CInstanceBase@@1MA:DWORD	; CInstanceBase::ms_fHorseDustGap
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VIBackground@@@@0PAVIBackground@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VIBackground@@@@0PAVIBackground@@A DD 01H DUP (?) ; CSingleton<IBackground>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A
_BSS	SEGMENT
?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A DB 024H DUP (?) ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A DD 01H DUP (?) ; CSingleton<CStateManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A DB 024H DUP (?) ; CInstanceBase::ms_kPool
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A DD 01H DUP (?) ; CSingleton<CPythonBackground>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonNonPlayer@@@@0PAVCPythonNonPlayer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonNonPlayer@@@@0PAVCPythonNonPlayer@@A DD 01H DUP (?) ; CSingleton<CPythonNonPlayer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A
_BSS	SEGMENT
?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A DD 01H DUP (?) ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A DD 01H DUP (?) ; CSingleton<CPythonPlayer>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A DD 01H DUP (?) ; CSingleton<CPythonCharacterManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A
_BSS	SEGMENT
?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A DD 01H DUP (?) ; TAbstractSingleton<IAbstractApplication>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A DD 01H DUP (?) ; CSingleton<CItemManager>::ms_singleton
_BSS	ENDS
_BSS	SEGMENT
?gs_kActorInstBG@@3VCActorInstanceBackground@@A DD 01H DUP (?) ; gs_kActorInstBG
_BSS	ENDS
;	COMDAT ?s_kScreen@?9??Render@CInstanceBase@@QAEXXZ@4VCScreen@@A
_BSS	SEGMENT
?s_kScreen@?9??Render@CInstanceBase@@QAEXXZ@4VCScreen@@A DD 01H DUP (?) ; `CInstanceBase::Render'::`10'::s_kScreen
_BSS	ENDS
;	COMDAT ?$TSS0@?9??Render@CInstanceBase@@QAEXXZ@4HA
_BSS	SEGMENT
?$TSS0@?9??Render@CInstanceBase@@QAEXXZ@4HA DD 01H DUP (?) ; `CInstanceBase::Render'::`10'::$TSS0
_BSS	ENDS
CRT$XCU	SEGMENT
?gs_kActorInstBG$initializer$@@3P6AXXZA DD FLAT:??__Egs_kActorInstBG@@YAXXZ ; gs_kActorInstBG$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c2c80000
CONST	SEGMENT
__real@c2c80000 DD 0c2c80000r			; -100
CONST	ENDS
;	COMDAT __real@451c4000
CONST	SEGMENT
__real@451c4000 DD 0451c4000r			; 2500
CONST	ENDS
;	COMDAT __real@45160000
CONST	SEGMENT
__real@45160000 DD 045160000r			; 2400
CONST	ENDS
;	COMDAT __real@44fa0000
CONST	SEGMENT
__real@44fa0000 DD 044fa0000r			; 2000
CONST	ENDS
;	COMDAT __real@44960000
CONST	SEGMENT
__real@44960000 DD 044960000r			; 1200
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@43fa0000
CONST	SEGMENT
__real@43fa0000 DD 043fa0000r			; 500
CONST	ENDS
;	COMDAT __real@43b40000
CONST	SEGMENT
__real@43b40000 DD 043b40000r			; 360
CONST	ENDS
;	COMDAT __real@43960000
CONST	SEGMENT
__real@43960000 DD 043960000r			; 300
CONST	ENDS
;	COMDAT __real@437a0000
CONST	SEGMENT
__real@437a0000 DD 0437a0000r			; 250
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@3e19999a
CONST	SEGMENT
__real@3e19999a DD 03e19999ar			; 0.15
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@3b808081
CONST	SEGMENT
__real@3b808081 DD 03b808081r			; 0.00392157
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@CActorInstanceBackground@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CActorInstanceBackground@@8 DD FLAT:??_R0?AVCActorInstanceBackground@@@8 ; CActorInstanceBackground::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CActorInstanceBackground@@8
rdata$r	ENDS
;	COMDAT ??_R2CActorInstanceBackground@@8
rdata$r	SEGMENT
??_R2CActorInstanceBackground@@8 DD FLAT:??_R1A@?0A@EA@CActorInstanceBackground@@8 ; CActorInstanceBackground::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@IBackground@@8
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VIBackground@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CActorInstanceBackground@@8
rdata$r	SEGMENT
??_R3CActorInstanceBackground@@8 DD 00H			; CActorInstanceBackground::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2CActorInstanceBackground@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCActorInstanceBackground@@@8
data$rs	SEGMENT
??_R0?AVCActorInstanceBackground@@@8 DD FLAT:??_7type_info@@6B@ ; CActorInstanceBackground `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCActorInstanceBackground@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CActorInstanceBackground@@6B@
rdata$r	SEGMENT
??_R4CActorInstanceBackground@@6B@ DD 00H		; CActorInstanceBackground::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCActorInstanceBackground@@@8
	DD	FLAT:??_R3CActorInstanceBackground@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPool@VCInstanceBase@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPool@VCInstanceBase@@@@8 DD FLAT:??_R0?AV?$CDynamicPool@VCInstanceBase@@@@@8 ; CDynamicPool<CInstanceBase>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPool@VCInstanceBase@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPool@VCInstanceBase@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPool@VCInstanceBase@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPool@VCInstanceBase@@@@8 ; CDynamicPool<CInstanceBase>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPool@VCInstanceBase@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPool@VCInstanceBase@@@@8 DD 00H		; CDynamicPool<CInstanceBase>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPool@VCInstanceBase@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPool@VCInstanceBase@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPool@VCInstanceBase@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPool<CInstanceBase> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPool@VCInstanceBase@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPool@VCInstanceBase@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPool@VCInstanceBase@@@@6B@ DD 00H	; CDynamicPool<CInstanceBase>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPool@VCInstanceBase@@@@@8
	DD	FLAT:??_R3?$CDynamicPool@VCInstanceBase@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CInstanceBase@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CInstanceBase@@8 DD FLAT:??_R0?AVCInstanceBase@@@8 ; CInstanceBase::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CInstanceBase@@8
rdata$r	ENDS
;	COMDAT ??_R2CInstanceBase@@8
rdata$r	SEGMENT
??_R2CInstanceBase@@8 DD FLAT:??_R1A@?0A@EA@CInstanceBase@@8 ; CInstanceBase::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CInstanceBase@@8
rdata$r	SEGMENT
??_R3CInstanceBase@@8 DD 00H				; CInstanceBase::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CInstanceBase@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCInstanceBase@@@8
data$rs	SEGMENT
??_R0?AVCInstanceBase@@@8 DD FLAT:??_7type_info@@6B@	; CInstanceBase `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCInstanceBase@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CInstanceBase@@6B@
rdata$r	SEGMENT
??_R4CInstanceBase@@6B@ DD 00H				; CInstanceBase::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCInstanceBase@@@8
	DD	FLAT:??_R3CInstanceBase@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDe'
	DB	'corator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDec'
	DB	'orator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpd'
	DB	'ateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@N'
	DB	'EffectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEff'
	DB	'ectUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffe'
	DB	'ctUpdateDecorator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecora'
	DB	'tor@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD FLAT:??_R1A@?0A@EA@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	SEGMENT
??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8 DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
data$rs	SEGMENT
??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8 DD FLAT:??_7type_info@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDeco'
	DB	'rator@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
rdata$r	SEGMENT
??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD 00H ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@@8
	DD	FLAT:??_R3?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ DD FLAT:??_R4?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`vftable'
	DD	FLAT:??_E?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_0EG@MNIPPABI@CPythonCharacterManager?3?3Change@
CONST	SEGMENT
??_C@_0EG@MNIPPABI@CPythonCharacterManager?3?3Change@ DB 'CPythonCharacte'
	DB	'rManager::ChangeArmor - SetRace VID[%d] Race[%d] ERROR', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@EIDAANLK@vid?$DN?$CFd?5?$LP?r?A?w?$MA?O?5?$LM?v?5?$LO?x?$LE?B?5?$LL?s?E?B?$LG?s?5?$LN?$LK@
CONST	SEGMENT
??_C@_0DM@EIDAANLK@vid?$DN?$CFd?5?$LP?r?A?w?$MA?O?5?$LM?v?5?$LO?x?$LE?B?5?$LL?s?E?B?$LG?s?5?$LN?$LK@ DB 'v'
	DB	'id=%d ', 0bfH, 0f2H, 0c1H, 0f7H, 0c0H, 0cfH, ' ', 0bcH, 0f6H, ' '
	DB	0beH, 0f8H, 0b4H, 0c2H, ' ', 0bbH, 0f3H, 0c5H, 0c2H, 0b6H, 0f3H
	DB	' ', 0bdH, 0baH, 0c5H, 0b5H, ' IsDead=%d, IsKnockDown=%d', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@IFLKAGDE@CInstanceBase?3?3PushTCPState?5?G?C?$LH@
CONST	SEGMENT
??_C@_0EG@IFLKAGDE@CInstanceBase?3?3PushTCPState?5?G?C?$LH@ DB 'CInstance'
	DB	'Base::PushTCPState ', 0c7H, 0c3H, 0b7H, 0b9H, 0c0H, 0ccH, 0beH
	DB	0eeH, ' ', 0c0H, 0daH, 0bdH, 0c5H, 0bfH, 0a1H, 0b0H, 0d4H, ' ', 0c0H
	DB	0ccH, 0b5H, 0bfH, 0c6H, 0d0H, 0c5H, 0b6H, 0c0H, 0baH, ' ', 0bfH
	DB	0c0H, 0b8H, 0e9H, ' ', 0beH, 0c8H, 0b5H, 0c8H, 0b4H, 0d9H, '!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PGINAIMI@Inst?5?9?5UC?5?$CFd?0?5RC?5?$CFd?5Pool?5?9?5?$CFd?5@
CONST	SEGMENT
??_C@_0BP@PGINAIMI@Inst?5?9?5UC?5?$CFd?0?5RC?5?$CFd?5Pool?5?9?5?$CFd?5@ DB 'I'
	DB	'nst - UC %d, RC %d Pool - %d ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EL@PHAIMNFF@CInstanceBase?3?3__EnableSkipColl@
CONST	SEGMENT
??_C@_0EL@PHAIMNFF@CInstanceBase?3?3__EnableSkipColl@ DB 'CInstanceBase::'
	DB	'__EnableSkipCollision - ', 0c0H, 0daH, 0bdH, 0c5H, 0c0H, 0baH
	DB	' ', 0c3H, 0e6H, 0b5H, 0b9H, 0b0H, 0cbH, 0bbH, 0e7H, 0bdH, 0baH
	DB	0c5H, 0b5H, 0c0H, 0ccH, ' ', 0b5H, 0c7H, 0b8H, 0e9H, ' ', 0beH
	DB	0c8H, 0b5H, 0c8H, 0b4H, 0d9H, '!!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7?$CDynamicPool@VCInstanceBase@@@@6B@
CONST	SEGMENT
??_7?$CDynamicPool@VCInstanceBase@@@@6B@ DD FLAT:??_R4?$CDynamicPool@VCInstanceBase@@@@6B@ ; CDynamicPool<CInstanceBase>::`vftable'
	DD	FLAT:??_E?$CDynamicPool@VCInstanceBase@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CActorInstanceBackground@@6B@
CONST	SEGMENT
??_7CActorInstanceBackground@@6B@ DD FLAT:??_R4CActorInstanceBackground@@6B@ ; CActorInstanceBackground::`vftable'
	DD	FLAT:??_ECActorInstanceBackground@@UAEPAXI@Z
	DD	FLAT:?IsBlock@CActorInstanceBackground@@UAE_NHH@Z
CONST	ENDS
;	COMDAT ??_C@_06PNAKCKLH@saddle@
CONST	SEGMENT
??_C@_06PNAKCKLH@saddle@ DB 'saddle', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CInstanceBase@@6B@
CONST	SEGMENT
??_7CInstanceBase@@6B@ DD FLAT:??_R4CInstanceBase@@6B@	; CInstanceBase::`vftable'
	DD	FLAT:??_ECInstanceBase@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$CSingleton@VIBackground@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VIBackground@@@@6B@ DD 00H		; CSingleton<IBackground>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VIBackground@@@@@8
	DD	FLAT:??_R3?$CSingleton@VIBackground@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VIBackground@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VIBackground@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VIBackground@@@@8 ; CSingleton<IBackground>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VIBackground@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VIBackground@@@@8 DD 00H		; CSingleton<IBackground>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VIBackground@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VIBackground@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VIBackground@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<IBackground> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VIBackground@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VIBackground@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VIBackground@@@@8 DD FLAT:??_R0?AV?$CSingleton@VIBackground@@@@@8 ; CSingleton<IBackground>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VIBackground@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@IBackground@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@IBackground@@8 DD FLAT:??_R0?AVIBackground@@@8 ; IBackground::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3IBackground@@8
rdata$r	ENDS
;	COMDAT ??_R2IBackground@@8
rdata$r	SEGMENT
??_R2IBackground@@8 DD FLAT:??_R1A@?0A@EA@IBackground@@8 ; IBackground::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VIBackground@@@@8
rdata$r	ENDS
;	COMDAT ??_R3IBackground@@8
rdata$r	SEGMENT
??_R3IBackground@@8 DD 00H				; IBackground::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2IBackground@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVIBackground@@@8
data$rs	SEGMENT
??_R0?AVIBackground@@@8 DD FLAT:??_7type_info@@6B@	; IBackground `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVIBackground@@', 00H
data$rs	ENDS
;	COMDAT ??_R4IBackground@@6B@
rdata$r	SEGMENT
??_R4IBackground@@6B@ DD 00H				; IBackground::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVIBackground@@@8
	DD	FLAT:??_R3IBackground@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7IBackground@@6B@
CONST	SEGMENT
??_7IBackground@@6B@ DD FLAT:??_R4IBackground@@6B@	; IBackground::`vftable'
	DD	FLAT:??_EIBackground@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VIBackground@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VIBackground@@@@6B@ DD FLAT:??_R4?$CSingleton@VIBackground@@@@6B@ ; CSingleton<IBackground>::`vftable'
	DD	FLAT:??_E?$CSingleton@VIBackground@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z$0
__ehfuncinfo$??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ$0
__ehfuncinfo$?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z$11 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z$0
__unwindtable$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z$11
__ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z$0
__ehfuncinfo$?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z$0
__ehfuncinfo$?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?ChangeArmor@CInstanceBase@@QAE_NK@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ChangeArmor@CInstanceBase@@QAE_NK@Z$0
__ehfuncinfo$?ChangeArmor@CInstanceBase@@QAE_NK@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?ChangeArmor@CInstanceBase@@QAE_NK@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Render@CInstanceBase@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Render@CInstanceBase@@QAEXXZ$0
__ehfuncinfo$?Render@CInstanceBase@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Render@CInstanceBase@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z$0
__ehfuncinfo$?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CInstanceBase@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CInstanceBase@@QAE@XZ DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0CInstanceBase@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CInstanceBase@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CInstanceBase@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CInstanceBase@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CInstanceBase@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CInstanceBase@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CInstanceBase@@QAE@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0CInstanceBase@@QAE@XZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0CInstanceBase@@QAE@XZ$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
??ms_kPool$initializer$@CInstanceBase@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A@@YAXXZ ; ??ms_kPool$initializer$@CInstanceBase@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA DD FLAT:??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; ??ms_kPool$initializer$@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVCInstanceBase@@PAPAV1@@std@@YAPAPAVCInstanceBase@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVCInstanceBase@@PAPAV1@@std@@YAPAPAVCInstanceBase@@PAPAV1@00@Z PROC ; std::_Copy_memmove<CInstanceBase * *,CInstanceBase * *>, COMDAT

; 4360 : _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 4361 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4362 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 4363 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f8	 mov	 DWORD PTR __Dest_ch$[ebp], eax

; 4364 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00018	8b 45 f0	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0001b	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4365 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	ff 75 f4	 push	 DWORD PTR __Count$[ebp]
  00024	ff 75 fc	 push	 DWORD PTR __First_ch$[ebp]
  00027	ff 75 f8	 push	 DWORD PTR __Dest_ch$[ebp]
  0002a	e8 00 00 00 00	 call	 _memmove
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4366 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

  00032	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00035	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4367 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Copy_memmove@PAPAVCInstanceBase@@PAPAV1@@std@@YAPAPAVCInstanceBase@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<CInstanceBase * *,CInstanceBase * *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SCommand,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SCommand,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU01@@Z PROC ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >, COMDAT

; 368  :     static void _Freenode0(_Alloc& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 369  :         static_assert(is_same_v<typename _Alloc::value_type, _Tree_node>, "Bad _Freenode0 call");
; 370  :         _Destroy_in_place(_Ptr->_Left);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  0000b	59		 pop	 ecx

; 371  :         _Destroy_in_place(_Ptr->_Parent);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  00018	59		 pop	 ecx

; 372  :         _Destroy_in_place(_Ptr->_Right);

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001c	83 c0 08	 add	 eax, 8
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@@Z ; std::_Destroy_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *>
  00025	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	6b c0 18	 imul	 eax, eax, 24
  0002c	50		 push	 eax
  0002d	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00035	59		 pop	 ecx
  00036	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 374  :     }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU01@@Z ENDP ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Old_val$2 = -16					; size = 4
__New_val$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -4						; size = 4
__Al$ = 8						; size = 4
__Rootnode$ = 12					; size = 4
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >, COMDAT
; _this$ = ecx

; 742  :     void _Erase_tree(_Alnode& _Al, _Nodeptr _Rootnode) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@Erase_tree:

; 743  :         while (!_Rootnode->_Isnil) { // free subtrees, then node

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0000c	0f be 40 0d	 movsx	 eax, BYTE PTR [eax+13]
  00010	85 c0		 test	 eax, eax
  00012	75 43		 jne	 SHORT $LN4@Erase_tree

; 744  :             _Erase_tree(_Al, _Rootnode->_Right);

  00014	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00017	ff 70 08	 push	 DWORD PTR [eax+8]
  0001a	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >

; 745  :             _Alnode::value_type::_Freenode(_Al, _STD exchange(_Rootnode, _Rootnode->_Left));

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  00028	89 45 f4	 mov	 DWORD PTR __New_val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 598  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  0002b	8b 45 0c	 mov	 eax, DWORD PTR __Rootnode$[ebp]
  0002e	89 45 f0	 mov	 DWORD PTR __Old_val$2[ebp], eax

; 599  :     _Val         = static_cast<_Other&&>(_New_val);

  00031	8b 45 f4	 mov	 eax, DWORD PTR __New_val$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	89 45 0c	 mov	 DWORD PTR __Rootnode$[ebp], eax

; 600  :     return _Old_val;

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Old_val$2[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 379  :         allocator_traits<_Alloc>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0003f	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  00042	83 c0 10	 add	 eax, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00045	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 380  :         _Freenode0(_Al, _Ptr);

  00048	ff 75 fc	 push	 DWORD PTR $T3[ebp]
  0004b	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
  00053	59		 pop	 ecx
  00054	59		 pop	 ecx

; 746  :         }

  00055	eb b2		 jmp	 SHORT $LN2@Erase_tree
$LN4@Erase_tree:

; 747  :     }

  00057	c9		 leave
  00058	c2 08 00	 ret	 8
??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > ><CInstanceBase::SCommand const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00039	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00051	83 c0 08	 add	 eax, 8
  00054	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00057	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005a	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00065	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00068	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00071	6a 09		 push	 9
  00073	59		 pop	 ecx
  00074	8b 75 e0	 mov	 esi, DWORD PTR $T3[ebp]
  00077	8b 7d dc	 mov	 edi, DWORD PTR $T2[ebp]
  0007a	f3 a5		 rep movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  0007c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00080	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00086	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008d	59		 pop	 ecx
  0008e	5f		 pop	 edi
  0008f	5e		 pop	 esi
  00090	c9		 leave
  00091	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > ><CInstanceBase::SCommand const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 12		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 2c	 imul	 eax, eax, 44
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 5d 74
	d1 05		 mov	 DWORD PTR __Max_possible$1[ebp], 97612893 ; 05d1745dH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d 5d 74 d1 05	 cmp	 eax, 97612893		; 05d1745dH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 2c	 imul	 eax, eax, 44
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCRotationDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CRotationDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCGravityDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CGravityDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CAirResistanceDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCNullDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CNullDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool'', COMDAT

; 272  : template <class T> CDynamicPoolEx<T> CPooledObject<T>::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A ; CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@?$CPooledObject@VCHeaderDecorator@NEffectUpdateDecorator@@@@1V?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CPooledObject<NEffectUpdateDecorator::CHeaderDecorator>::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAPAPAVCInstanceBase@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__UFirst$ = -8						; size = 4
__ULast$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAPAPAVCInstanceBase@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z PROC ; std::_Uninitialized_move<CInstanceBase * *,std::allocator<CInstanceBase *> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR __ULast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00012	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00018	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001b	ff 75 fc	 push	 DWORD PTR __ULast$[ebp]
  0001e	ff 75 f8	 push	 DWORD PTR __UFirst$[ebp]
  00021	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVCInstanceBase@@PAPAV1@@std@@YAPAPAVCInstanceBase@@PAPAV1@00@Z ; std::_Copy_memmove<CInstanceBase * *,CInstanceBase * *>
  00026	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1694 :         return _Dest + (_ULast - _UFirst);

  00029	8b 45 fc	 mov	 eax, DWORD PTR __ULast$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0002f	c1 f8 02	 sar	 eax, 2
  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00035	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }
; 1700 : 
; 1701 :         return _Backout._Release();
; 1702 :     }
; 1703 : }

  00038	c9		 leave
  00039	c3		 ret	 0
??$_Uninitialized_move@PAPAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAPAPAVCInstanceBase@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ENDP ; std::_Uninitialized_move<CInstanceBase * *,std::allocator<CInstanceBase *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z PROC ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAXPAPAVCInstanceBase@@QAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAXPAPAVCInstanceBase@@QAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z PROC ; std::_Destroy_range<std::allocator<CInstanceBase *> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAXPAPAVCInstanceBase@@QAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<CInstanceBase *> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@@Z
_TEXT	SEGMENT
__Max_possible$1 = -20					; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Pnode$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
__Al$ = 8						; size = 4
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@@Z PROC ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >, COMDAT

; 341  :     static _Nodeptr _Buyheadnode(_Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 ec aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00011	33 c0		 xor	 eax, eax
  00013	40		 inc	 eax
  00014	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  00019	76 05		 jbe	 SHORT $LN6@Buyheadnod

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0001b	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Buyheadnod:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	6b c0 18	 imul	 eax, eax, 24
  00026	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00031	59		 pop	 ecx
  00032	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 343  :         const auto _Pnode = _Al.allocate(1);

  00035	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00038	89 45 f8	 mov	 DWORD PTR __Pnode$[ebp], eax

; 344  :         _Construct_in_place(_Pnode->_Left, _Pnode);

  0003b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0003e	50		 push	 eax
  0003f	ff 75 f8	 push	 DWORD PTR __Pnode$[ebp]
  00042	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> * const &>
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx

; 345  :         _Construct_in_place(_Pnode->_Parent, _Pnode);

  00049	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0004c	50		 push	 eax
  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00050	83 c0 04	 add	 eax, 4
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> * const &>
  00059	59		 pop	 ecx
  0005a	59		 pop	 ecx

; 346  :         _Construct_in_place(_Pnode->_Right, _Pnode);

  0005b	8d 45 f8	 lea	 eax, DWORD PTR __Pnode$[ebp]
  0005e	50		 push	 eax
  0005f	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00062	83 c0 08	 add	 eax, 8
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> *,std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> * const &>
  0006b	59		 pop	 ecx
  0006c	59		 pop	 ecx

; 347  :         _Pnode->_Color = _Black;

  0006d	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00070	c6 40 0c 01	 mov	 BYTE PTR [eax+12], 1

; 348  :         _Pnode->_Isnil = true;

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00077	c6 40 0d 01	 mov	 BYTE PTR [eax+13], 1

; 349  :         return _Pnode;

  0007b	8b 45 f8	 mov	 eax, DWORD PTR __Pnode$[ebp]
$LN9@Buyheadnod:

; 350  :     }

  0007e	c9		 leave
  0007f	c3		 ret	 0
??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@@Z ENDP ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<CInstanceBase::SCommand,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SCommand,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SCommand,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 2c	 imul	 eax, eax, 44
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<CInstanceBase::SCommand,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 18	 imul	 eax, eax, 24
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *,std::_List_node<CInstanceBase::SEffectDamage,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *,std::_List_node<CInstanceBase::SEffectDamage,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Emplace_reallocate<CInstanceBase * const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	c1 f9 02	 sar	 ecx, 2
  00060	89 4d 60	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00063	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00066	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00069	8b 00		 mov	 eax, DWORD PTR [eax]
  0006b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0006d	c1 f8 02	 sar	 eax, 2
  00070	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00073	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00076	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00079	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  0007c	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0007f	c7 45 40 ff ff
	ff 3f		 mov	 DWORD PTR $T22[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00086	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0008d	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00090	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00093	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  00096	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  00099	73 08		 jae	 SHORT $LN34@Emplace_re
  0009b	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  0009e	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a1	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000a3	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000a9	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000ac	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000af	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000b2	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000b5	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000b8	8b 00		 mov	 eax, DWORD PTR [eax]
  000ba	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000bd	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c0	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000c3	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000c5	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@CAXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000ca	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000cd	40		 inc	 eax
  000ce	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d1	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000d4	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@ABEII@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Calculate_growth
  000dc	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000df	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000e3	c7 45 bc ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  000ea	81 7d 54 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  000f1	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000f3	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  000f8	8b 45 54	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000fb	c1 e0 02	 shl	 eax, 2
  000fe	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00101	ff 75 10	 push	 DWORD PTR $T14[ebp]
  00104	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00109	59		 pop	 ecx
  0010a	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  0010d	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00110	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00113	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]
  00117	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  0011a	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  0011d	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00120	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00124	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00127	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0012a	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0012d	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00130	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00133	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00136	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  00139	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0013c	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  0013f	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00142	8b 45 04	 mov	 eax, DWORD PTR $T11[ebp]
  00145	8b 4d 00	 mov	 ecx, DWORD PTR $T10[ebp]
  00148	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0014a	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  0014c	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014f	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00152	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00155	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  00158	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015b	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0015e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00160	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00162	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00165	8b 00		 mov	 eax, DWORD PTR [eax]
  00167	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016a	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016d	8b 00		 mov	 eax, DWORD PTR [eax]
  0016f	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00172	33 c0		 xor	 eax, eax
  00174	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00177	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017a	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017d	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00180	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00183	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00186	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00189	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018c	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0018f	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00192	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00195	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAPAPAVCInstanceBase@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Uninitialized_move<CInstanceBase * *,std::allocator<CInstanceBase *> >
  0019a	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019d	eb 5e		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0019f	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a2	8b 00		 mov	 eax, DWORD PTR [eax]
  001a4	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001aa	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001ad	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b0	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b3	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b6	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001b9	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001bc	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001bf	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAPAPAVCInstanceBase@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Uninitialized_move<CInstanceBase * *,std::allocator<CInstanceBase *> >
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c7	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001ca	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cd	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d0	8b 00		 mov	 eax, DWORD PTR [eax]
  001d2	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d5	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001d8	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001db	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001de	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e1	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e4	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  001e7	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ea	8d 44 81 04	 lea	 eax, DWORD PTR [ecx+eax*4+4]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001ee	50		 push	 eax
  001ef	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f2	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAPAPAVCInstanceBase@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Uninitialized_move<CInstanceBase * *,std::allocator<CInstanceBase *> >
  001fa	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001fd	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  001ff	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00202	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00205	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00208	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXPAPAVCInstanceBase@@0@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  0020d	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00210	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00213	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00216	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCInstanceBase@@@std@@QAEXQAPAVCInstanceBase@@I@Z ; std::allocator<CInstanceBase *>::deallocate

; 762  :         _RERAISE;

  0021b	6a 00		 push	 0
  0021d	6a 00		 push	 0
  0021f	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00224	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00229	c3		 ret	 0
$LN7@Emplace_re:
  0022a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  0022e	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00230	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00234	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00237	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023a	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  0023d	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXQAPAVCInstanceBase@@II@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00245	8b 45 60	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  00248	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0024b	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
$LN70@Emplace_re:

; 767  :     }

  0024e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00251	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00258	59		 pop	 ecx
  00259	5f		 pop	 edi
  0025a	5e		 pop	 esi
  0025b	5b		 pop	 ebx
  0025c	83 c5 70	 add	 ebp, 112		; 00000070H
  0025f	c9		 leave
  00260	c2 08 00	 ret	 8
  00263	cc		 int	 3
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Emplace_reallocate<CInstanceBase * const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXABQAVCInstanceBase@@@Z
_TEXT	SEGMENT
__Result$ = -44						; size = 4
$T1 = -40						; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXABQAVCInstanceBase@@@Z PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Emplace_back_with_unused_capacity<CInstanceBase * const &>, COMDAT
; _this$ = ecx

; 682  :     decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 683  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 684  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 fc	 mov	 DWORD PTR __Mylast$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00018	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0001b	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00026	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0002f	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00032	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  00035	89 45 d8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00038	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  0003b	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003e	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  00041	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00044	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00047	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  0004a	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0004c	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  0004e	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	89 45 d4	 mov	 DWORD PTR __Result$[ebp], eax

; 690  :         ++_Mylast;

  00056	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	83 c0 04	 add	 eax, 4
  0005e	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00061	89 01		 mov	 DWORD PTR [ecx], eax

; 691  : #if _HAS_CXX17
; 692  :         return _Result;
; 693  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 694  :         (void) _Result;
; 695  : #endif // _HAS_CXX17
; 696  :     }

  00063	c9		 leave
  00064	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXABQAVCInstanceBase@@@Z ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Emplace_back_with_unused_capacity<CInstanceBase * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXABQAVCInstanceBase@@@Z
_TEXT	SEGMENT
__Result$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXABQAVCInstanceBase@@@Z PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::emplace_back<CInstanceBase * const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	83 c0 04	 add	 eax, 4
  00015	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  00018	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00023	74 13		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00025	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  0002b	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXABQAVCInstanceBase@@@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Emplace_back_with_unused_capacity<CInstanceBase * const &>
  00036	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00038	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003b	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003e	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00044	ff 30		 push	 DWORD PTR [eax]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEPAPAVCInstanceBase@@QAPAV2@ABQAV2@@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Emplace_reallocate<CInstanceBase * const &>
  0004e	89 45 e8	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  00051	c9		 leave
  00052	c2 04 00	 ret	 4
??$emplace_back@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXABQAVCInstanceBase@@@Z ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::emplace_back<CInstanceBase * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm
;	COMDAT ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@std@@P6AXPAVCInstanceBase@@@Z@std@@YAP6AXPAVCInstanceBase@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@0@1P6AX0@Z@Z
_TEXT	SEGMENT
__ULast$ = -32						; size = 4
$T1 = -28						; size = 4
$T2 = -24						; size = 4
__Ptr$3 = -20						; size = 4
$T4 = -16						; size = 4
$T5 = -12						; size = 4
__Ptr$6 = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Func$ = 16						; size = 4
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@std@@P6AXPAVCInstanceBase@@@Z@std@@YAP6AXPAVCInstanceBase@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@0@1P6AX0@Z@Z PROC ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInstanceBase *> > >,void (__cdecl*)(CInstanceBase *)>, COMDAT

; 303  : _CONSTEXPR20 _Fn for_each(_InIt _First, _InIt _Last, _Fn _Func) { // perform function for each element [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$6[ebp]
  0000f	89 45 f4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  00012	8b 45 f4	 mov	 eax, DWORD PTR $T5[ebp]
  00015	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 305  :     auto _UFirst      = _Get_unwrapped(_First);

  00018	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  0001b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00021	89 45 ec	 mov	 DWORD PTR __Ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00024	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$3[ebp]
  00027	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 310  :         return _Unfancy(this->_Ptr);

  0002a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0002d	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\algorithm

; 306  :     const auto _ULast = _Get_unwrapped(_Last);

  00030	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  00033	89 45 e0	 mov	 DWORD PTR __ULast$[ebp], eax

; 307  :     for (; _UFirst != _ULast; ++_UFirst) {

  00036	eb 09		 jmp	 SHORT $LN4@for_each
$LN2@for_each:
  00038	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003b	83 c0 04	 add	 eax, 4
  0003e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@for_each:
  00041	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00044	3b 45 e0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00047	74 0b		 je	 SHORT $LN3@for_each

; 308  :         _Func(*_UFirst);

  00049	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004c	ff 30		 push	 DWORD PTR [eax]
  0004e	ff 55 10	 call	 DWORD PTR __Func$[ebp]
  00051	59		 pop	 ecx

; 309  :     }

  00052	eb e4		 jmp	 SHORT $LN2@for_each
$LN3@for_each:

; 310  : 
; 311  :     return _Func;

  00054	8b 45 10	 mov	 eax, DWORD PTR __Func$[ebp]

; 312  : }

  00057	c9		 leave
  00058	c3		 ret	 0
??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@std@@P6AXPAVCInstanceBase@@@Z@std@@YAP6AXPAVCInstanceBase@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@0@1P6AX0@Z@Z ENDP ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInstanceBase *> > >,void (__cdecl*)(CInstanceBase *)>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Traits_find_first_of@U?$char_traits@D@std@@@std@@YAIQBDII0IU?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__End$1 = -124						; size = 4
$T2 = -120						; size = 4
__End$3 = -116						; size = 4
$T4 = -112						; size = 4
___formal$ = -108					; size = 1
__First$ = -104						; size = 4
__Match_try$5 = -100					; size = 4
__Match_try$6 = -96					; size = 4
$T7 = -90						; size = 1
$T8 = -89						; size = 1
__Matches$9 = -88					; size = 256
__$ArrayPad$ = 168					; size = 4
__Haystack$ = 180					; size = 4
__Hay_size$ = 184					; size = 4
__Start_at$ = 188					; size = 4
__Needle$ = 192						; size = 4
__Needle_size$ = 196					; size = 4
___formal$ = 200					; size = 1
??$_Traits_find_first_of@U?$char_traits@D@std@@@std@@YAIQBDII0IU?$integral_constant@_N$00@0@@Z PROC ; std::_Traits_find_first_of<std::char_traits<char> >, COMDAT

; 748  :     const size_t _Needle_size, true_type) noexcept {

  00000	55		 push	 ebp
  00001	8d ac 24 54 ff
	ff ff		 lea	 ebp, DWORD PTR [esp-172]
  00008	81 ec 28 01 00
	00		 sub	 esp, 296		; 00000128H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 a8 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 749  :     // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size), at/after _Start_at
; 750  :     // special case for std::char_traits
; 751  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it

  0001b	83 bd c4 00 00
	00 00		 cmp	 DWORD PTR __Needle_size$[ebp], 0
  00022	0f 84 3d 01 00
	00		 je	 $LN5@Traits_fin
  00028	8b 85 bc 00 00
	00		 mov	 eax, DWORD PTR __Start_at$[ebp]
  0002e	3b 85 b8 00 00
	00		 cmp	 eax, DWORD PTR __Hay_size$[ebp]
  00034	0f 83 2b 01 00
	00		 jae	 $LN5@Traits_fin
  0003a	68 00 01 00 00	 push	 256			; 00000100H
  0003f	6a 00		 push	 0
  00041	8d 45 a8	 lea	 eax, DWORD PTR __Matches$9[ebp]
  00044	50		 push	 eax
  00045	e8 00 00 00 00	 call	 _memset
  0004a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 752  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 753  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  0004d	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR __Needle$[ebp]
  00053	89 45 98	 mov	 DWORD PTR __First$[ebp], eax
  00056	eb 07		 jmp	 SHORT $LN15@Traits_fin
$LN13@Traits_fin:

; 682  :         for (; _First != _Last; ++_First) {

  00058	8b 45 98	 mov	 eax, DWORD PTR __First$[ebp]
  0005b	40		 inc	 eax
  0005c	89 45 98	 mov	 DWORD PTR __First$[ebp], eax
$LN15@Traits_fin:

; 752  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 753  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  0005f	8b 85 c0 00 00
	00		 mov	 eax, DWORD PTR __Needle$[ebp]
  00065	03 85 c4 00 00
	00		 add	 eax, DWORD PTR __Needle_size$[ebp]

; 682  :         for (; _First != _Last; ++_First) {

  0006b	39 45 98	 cmp	 DWORD PTR __First$[ebp], eax
  0006e	74 0d		 je	 SHORT $LN12@Traits_fin

; 683  :             _Matches[static_cast<unsigned char>(*_First)] = true;

  00070	8b 45 98	 mov	 eax, DWORD PTR __First$[ebp]
  00073	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00076	c6 44 05 a8 01	 mov	 BYTE PTR __Matches$9[ebp+eax], 1

; 684  :         }

  0007b	eb db		 jmp	 SHORT $LN13@Traits_fin
$LN12@Traits_fin:

; 752  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 753  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,

  0007d	33 c0		 xor	 eax, eax
  0007f	40		 inc	 eax
  00080	0f 85 8e 00 00
	00		 jne	 $LN6@Traits_fin

; 754  :                                                                 // fall back to the serial algorithm
; 755  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});

  00086	33 c0		 xor	 eax, eax
  00088	88 45 a7	 mov	 BYTE PTR $T8[ebp], al
  0008b	8a 45 a7	 mov	 al, BYTE PTR $T8[ebp]
  0008e	88 45 94	 mov	 BYTE PTR ___formal$[ebp], al

; 733  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it

  00091	83 bd c4 00 00
	00 00		 cmp	 DWORD PTR __Needle_size$[ebp], 0
  00098	74 71		 je	 SHORT $LN21@Traits_fin
  0009a	8b 85 bc 00 00
	00		 mov	 eax, DWORD PTR __Start_at$[ebp]
  000a0	3b 85 b8 00 00
	00		 cmp	 eax, DWORD PTR __Hay_size$[ebp]
  000a6	73 63		 jae	 SHORT $LN21@Traits_fin

; 734  :         const auto _End = _Haystack + _Hay_size;

  000a8	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR __Haystack$[ebp]
  000ae	03 85 b8 00 00
	00		 add	 eax, DWORD PTR __Hay_size$[ebp]
  000b4	89 45 8c	 mov	 DWORD PTR __End$3[ebp], eax

; 735  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  000b7	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR __Haystack$[ebp]
  000bd	03 85 bc 00 00
	00		 add	 eax, DWORD PTR __Start_at$[ebp]
  000c3	89 45 a0	 mov	 DWORD PTR __Match_try$6[ebp], eax
  000c6	eb 07		 jmp	 SHORT $LN20@Traits_fin
$LN18@Traits_fin:
  000c8	8b 45 a0	 mov	 eax, DWORD PTR __Match_try$6[ebp]
  000cb	40		 inc	 eax
  000cc	89 45 a0	 mov	 DWORD PTR __Match_try$6[ebp], eax
$LN20@Traits_fin:
  000cf	8b 45 a0	 mov	 eax, DWORD PTR __Match_try$6[ebp]
  000d2	3b 45 8c	 cmp	 eax, DWORD PTR __End$3[ebp]
  000d5	73 34		 jae	 SHORT $LN21@Traits_fin

; 410  :         return static_cast<const _Elem*>(_CSTD memchr(_First, _Ch, _Count));

  000d7	ff b5 c4 00 00
	00		 push	 DWORD PTR __Needle_size$[ebp]
  000dd	8b 45 a0	 mov	 eax, DWORD PTR __Match_try$6[ebp]
  000e0	0f be 00	 movsx	 eax, BYTE PTR [eax]
  000e3	50		 push	 eax
  000e4	ff b5 c0 00 00
	00		 push	 DWORD PTR __Needle$[ebp]
  000ea	e8 00 00 00 00	 call	 _memchr
  000ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f2	89 45 88	 mov	 DWORD PTR $T2[ebp], eax

; 736  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {

  000f5	83 7d 88 00	 cmp	 DWORD PTR $T2[ebp], 0
  000f9	74 0e		 je	 SHORT $LN22@Traits_fin

; 737  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  000fb	8b 45 a0	 mov	 eax, DWORD PTR __Match_try$6[ebp]
  000fe	2b 85 b4 00 00
	00		 sub	 eax, DWORD PTR __Haystack$[ebp]
  00104	89 45 90	 mov	 DWORD PTR $T4[ebp], eax
  00107	eb 06		 jmp	 SHORT $LN23@Traits_fin
$LN22@Traits_fin:

; 738  :             }
; 739  :         }

  00109	eb bd		 jmp	 SHORT $LN18@Traits_fin
$LN21@Traits_fin:

; 740  :     }
; 741  : 
; 742  :     return static_cast<size_t>(-1); // no match

  0010b	83 4d 90 ff	 or	 DWORD PTR $T4[ebp], -1
$LN23@Traits_fin:

; 754  :                                                                 // fall back to the serial algorithm
; 755  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});

  0010f	8b 45 90	 mov	 eax, DWORD PTR $T4[ebp]
  00112	eb 54		 jmp	 SHORT $LN8@Traits_fin
$LN6@Traits_fin:

; 756  :         }
; 757  : 
; 758  :         const auto _End = _Haystack + _Hay_size;

  00114	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR __Haystack$[ebp]
  0011a	03 85 b8 00 00
	00		 add	 eax, DWORD PTR __Hay_size$[ebp]
  00120	89 45 84	 mov	 DWORD PTR __End$1[ebp], eax

; 759  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {

  00123	8b 85 b4 00 00
	00		 mov	 eax, DWORD PTR __Haystack$[ebp]
  00129	03 85 bc 00 00
	00		 add	 eax, DWORD PTR __Start_at$[ebp]
  0012f	89 45 9c	 mov	 DWORD PTR __Match_try$5[ebp], eax
  00132	eb 07		 jmp	 SHORT $LN4@Traits_fin
$LN2@Traits_fin:
  00134	8b 45 9c	 mov	 eax, DWORD PTR __Match_try$5[ebp]
  00137	40		 inc	 eax
  00138	89 45 9c	 mov	 DWORD PTR __Match_try$5[ebp], eax
$LN4@Traits_fin:
  0013b	8b 45 9c	 mov	 eax, DWORD PTR __Match_try$5[ebp]
  0013e	3b 45 84	 cmp	 eax, DWORD PTR __End$1[ebp]
  00141	73 22		 jae	 SHORT $LN5@Traits_fin

; 690  :         return _Matches[static_cast<unsigned char>(_Ch)];

  00143	8b 45 9c	 mov	 eax, DWORD PTR __Match_try$5[ebp]
  00146	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00149	8a 44 05 a8	 mov	 al, BYTE PTR __Matches$9[ebp+eax]
  0014d	88 45 a6	 mov	 BYTE PTR $T7[ebp], al

; 760  :             if (_Matches._Match(*_Match_try)) {

  00150	0f b6 45 a6	 movzx	 eax, BYTE PTR $T7[ebp]
  00154	85 c0		 test	 eax, eax
  00156	74 0b		 je	 SHORT $LN7@Traits_fin

; 761  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match

  00158	8b 45 9c	 mov	 eax, DWORD PTR __Match_try$5[ebp]
  0015b	2b 85 b4 00 00
	00		 sub	 eax, DWORD PTR __Haystack$[ebp]
  00161	eb 05		 jmp	 SHORT $LN8@Traits_fin
$LN7@Traits_fin:

; 762  :             }
; 763  :         }

  00163	eb cf		 jmp	 SHORT $LN2@Traits_fin
$LN5@Traits_fin:

; 764  :     }
; 765  : 
; 766  :     return static_cast<size_t>(-1); // no match

  00165	83 c8 ff	 or	 eax, -1
$LN8@Traits_fin:

; 767  : }

  00168	8b 8d a8 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0016e	33 cd		 xor	 ecx, ebp
  00170	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00175	81 c5 ac 00 00
	00		 add	 ebp, 172		; 000000acH
  0017b	c9		 leave
  0017c	c3		 ret	 0
??$_Traits_find_first_of@U?$char_traits@D@std@@@std@@YAIQBDII0IU?$integral_constant@_N$00@0@@Z ENDP ; std::_Traits_find_first_of<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCHeaderDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@KAXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCHeaderDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CHeaderDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CHeaderDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCHeaderDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCHeaderDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CHeaderDecorator *,std::allocator<NEffectUpdateDecorator::CHeaderDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCHeaderDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CHeaderDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCNullDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CNullDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@KAXPAVCNullDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCNullDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCNullDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CNullDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CNullDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCNullDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCNullDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CNullDecorator *,std::allocator<NEffectUpdateDecorator::CNullDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCNullDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CNullDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCWDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCWDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationCCWDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationCCWDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationCCWDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationCCWDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@KAXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CTextureAnimationRandomDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *,std::allocator<NEffectUpdateDecorator::CTextureAnimationRandomDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCTextureAnimationRandomDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CTextureAnimationRandomDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCAirResistanceDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@KAXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCAirResistanceDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CAirResistanceDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CAirResistanceDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCAirResistanceDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CAirResistanceDecorator *,std::allocator<NEffectUpdateDecorator::CAirResistanceDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCAirResistanceDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CAirResistanceDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCGravityDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@KAXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCGravityDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CGravityDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CGravityDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCGravityDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCGravityDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CGravityDecorator *,std::allocator<NEffectUpdateDecorator::CGravityDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCGravityDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CGravityDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAEPAXI@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ PROC ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@YAXPAPAVCRotationDecorator@NEffectUpdateDecorator@@QAPAV12@AAV?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@0@@Z ; std::_Destroy_range<std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ENDP ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z
_TEXT	SEGMENT
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete, COMDAT

; 223  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 224  : 			::operator delete(pkData);

  00003	ff 75 08	 push	 DWORD PTR _pkData$[ebp]
  00006	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  0000b	59		 pop	 ecx

; 225  : 		}

  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy, COMDAT
; _this$ = ecx

; 150  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 160  : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@KAXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@std@@P6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@Z@std@@YAP6AXPAVCRotationDecorator@NEffectUpdateDecorator@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<NEffectUpdateDecorator::CRotationDecorator *> > >,void (__cdecl*)(NEffectUpdateDecorator::CRotationDecorator *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 161  : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear

; 162  : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@QAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::clear

; 163  : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 132  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@

; 133  : 			assert(m_kVct_pkFree.size()==m_kVct_pkData.size());
; 134  : 			Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAEXXZ ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::Destroy

; 142  : 		}

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0003d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00048	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCRotationDecorator@NEffectUpdateDecorator@@V?$allocator@PAVCRotationDecorator@NEffectUpdateDecorator@@@std@@@std@@AAEXXZ ; std::vector<NEffectUpdateDecorator::CRotationDecorator *,std::allocator<NEffectUpdateDecorator::CRotationDecorator *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 142  : 		}

  0004d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00050	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00057	59		 pop	 ecx
  00058	c9		 leave
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@UAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::~CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ PROC ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>, COMDAT
; _this$ = ecx

; 126  : 		CDynamicPoolEx()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 127  : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 128  : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 129  : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 130  : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPoolEx@VCRotationDecorator@NEffectUpdateDecorator@@@@QAE@XZ ENDP ; CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>::CDynamicPoolEx<NEffectUpdateDecorator::CRotationDecorator>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABUSCommand@CInstanceBase@@@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@1@QAU21@ABUSCommand@CInstanceBase@@@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABUSCommand@CInstanceBase@@@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@1@QAU21@ABUSCommand@CInstanceBase@@@Z PROC ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Emplace<CInstanceBase::SCommand const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 5d 74
	d1 05		 mov	 DWORD PTR $T12[ebp], 97612893 ; 05d1745dH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABUSCommand@CInstanceBase@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@ABUSCommand@CInstanceBase@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > ><CInstanceBase::SCommand const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABUSCommand@CInstanceBase@@@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@1@QAU21@ABUSCommand@CInstanceBase@@@Z ENDP ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Emplace<CInstanceBase::SCommand const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<CInstanceBase::SCommand,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SCommand,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<CInstanceBase::SCommand,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__Fs_kScreen@?9??Render@CInstanceBase@@QAEXXZ@YAXXZ
text$yd	SEGMENT
??__Fs_kScreen@?9??Render@CInstanceBase@@QAEXXZ@YAXXZ PROC ; `CInstanceBase::Render'::`10'::`dynamic atexit destructor for 's_kScreen'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kScreen@?9??Render@CInstanceBase@@QAEXXZ@4VCScreen@@A
  00008	e8 00 00 00 00	 call	 ??1CScreen@@UAE@XZ	; CScreen::~CScreen
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Fs_kScreen@?9??Render@CInstanceBase@@QAEXXZ@YAXXZ ENDP ; `CInstanceBase::Render'::`10'::`dynamic atexit destructor for 's_kScreen''
text$yd	ENDS
; Function compile flags: /Odspy
;	COMDAT ??__F?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A@@YAXXZ
text$yd	SEGMENT
??__F?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A@@YAXXZ PROC ; `dynamic atexit destructor for 'CInstanceBase::ms_kPool'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A ; CInstanceBase::ms_kPool
  00008	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCInstanceBase@@@@UAE@XZ ; CDynamicPool<CInstanceBase>::~CDynamicPool<CInstanceBase>
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__F?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A@@YAXXZ ENDP ; `dynamic atexit destructor for 'CInstanceBase::ms_kPool''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ??__E?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A@@YAXXZ
text$di	SEGMENT
??__E?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A@@YAXXZ PROC ; `dynamic initializer for 'CInstanceBase::ms_kPool'', COMDAT

; 386  : CDynamicPool<CInstanceBase> CInstanceBase::ms_kPool;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A ; CInstanceBase::ms_kPool
  00008	e8 00 00 00 00	 call	 ??0?$CDynamicPool@VCInstanceBase@@@@QAE@XZ ; CDynamicPool<CInstanceBase>::CDynamicPool<CInstanceBase>
  0000d	68 00 00 00 00	 push	 OFFSET ??__F?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A@@YAXXZ ; `dynamic atexit destructor for 'CInstanceBase::ms_kPool''
  00012	e8 00 00 00 00	 call	 _atexit
  00017	59		 pop	 ecx
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
??__E?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A@@YAXXZ ENDP ; `dynamic initializer for 'CInstanceBase::ms_kPool''
text$di	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_G?$CDynamicPool@VCInstanceBase@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CDynamicPool@VCInstanceBase@@@@UAEPAXI@Z PROC	; CDynamicPool<CInstanceBase>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$CDynamicPool@VCInstanceBase@@@@UAE@XZ ; CDynamicPool<CInstanceBase>::~CDynamicPool<CInstanceBase>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0c		 je	 SHORT $LN2@scalar
  00017	6a 24		 push	 36			; 00000024H
  00019	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx
$LN2@scalar:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c9		 leave
  00027	c2 04 00	 ret	 4
??_G?$CDynamicPool@VCInstanceBase@@@@UAEPAXI@Z ENDP	; CDynamicPool<CInstanceBase>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Delete@?$CDynamicPool@VCInstanceBase@@@@KAXPAVCInstanceBase@@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
$T1 = -4						; size = 4
_pkData$ = 8						; size = 4
?Delete@?$CDynamicPool@VCInstanceBase@@@@KAXPAVCInstanceBase@@@Z PROC ; CDynamicPool<CInstanceBase>::Delete, COMDAT

; 109  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 110  : 			delete pkData;

  00005	8b 45 08	 mov	 eax, DWORD PTR _pkData$[ebp]
  00008	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000b	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  0000f	74 11		 je	 SHORT $LN3@Delete
  00011	6a 01		 push	 1
  00013	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001b	ff 10		 call	 DWORD PTR [eax]
  0001d	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00020	eb 04		 jmp	 SHORT $LN1@Delete
$LN3@Delete:
  00022	83 65 f8 00	 and	 DWORD PTR tv70[ebp], 0
$LN1@Delete:

; 111  : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
?Delete@?$CDynamicPool@VCInstanceBase@@@@KAXPAVCInstanceBase@@@Z ENDP ; CDynamicPool<CInstanceBase>::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ
_TEXT	SEGMENT
$T2 = -84						; size = 4
$T3 = -80						; size = 4
_pkFreeData$ = -76					; size = 4
$T4 = -72						; size = 4
__Ptr$ = -68						; size = 4
__My_data$5 = -64					; size = 4
$T6 = -60						; size = 4
__My_data$7 = -56					; size = 4
$T8 = -52						; size = 4
_this$ = -48						; size = 4
_pkNewData$9 = -44					; size = 4
tv80 = -40						; size = 4
$T10 = -36						; size = 4
tv130 = -32						; size = 4
__My_data$11 = -28					; size = 4
__Mylast$12 = -24					; size = 4
_this$ = -20						; size = 4
$T13 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ PROC ; CDynamicPool<CInstanceBase>::Alloc, COMDAT
; _this$ = ecx

; 62   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 48	 sub	 esp, 72			; 00000048H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1478 :         auto& _My_data = _Mypair._Myval2;

  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c0 10	 add	 eax, 16			; 00000010H
  0002e	89 45 e4	 mov	 DWORD PTR __My_data$11[ebp], eax

; 1479 :         return _My_data._Myfirst == _My_data._Mylast;

  00031	8b 45 e4	 mov	 eax, DWORD PTR __My_data$11[ebp]
  00034	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$11[ebp]
  00037	8b 00		 mov	 eax, DWORD PTR [eax]
  00039	3b 41 04	 cmp	 eax, DWORD PTR [ecx+4]
  0003c	75 09		 jne	 SHORT $LN9@Alloc
  0003e	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv130[ebp], 1
  00045	eb 04		 jmp	 SHORT $LN10@Alloc
$LN9@Alloc:
  00047	83 65 e0 00	 and	 DWORD PTR tv130[ebp], 0
$LN10@Alloc:
  0004b	8a 45 e0	 mov	 al, BYTE PTR tv130[ebp]
  0004e	88 45 f3	 mov	 BYTE PTR $T13[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 63   : 			if (m_kVct_pkFree.empty())

  00051	0f b6 45 f3	 movzx	 eax, BYTE PTR $T13[ebp]
  00055	85 c0		 test	 eax, eax
  00057	74 5a		 je	 SHORT $LN2@Alloc

; 64   : 			{
; 65   : 				T* pkNewData=new T;

  00059	68 b0 06 00 00	 push	 1712			; 000006b0H
  0005e	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00063	59		 pop	 ecx
  00064	89 45 dc	 mov	 DWORD PTR $T10[ebp], eax
  00067	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0006b	83 7d dc 00	 cmp	 DWORD PTR $T10[ebp], 0
  0006f	74 0d		 je	 SHORT $LN4@Alloc
  00071	8b 4d dc	 mov	 ecx, DWORD PTR $T10[ebp]
  00074	e8 00 00 00 00	 call	 ??0CInstanceBase@@QAE@XZ ; CInstanceBase::CInstanceBase
  00079	89 45 d8	 mov	 DWORD PTR tv80[ebp], eax
  0007c	eb 04		 jmp	 SHORT $LN5@Alloc
$LN4@Alloc:
  0007e	83 65 d8 00	 and	 DWORD PTR tv80[ebp], 0
$LN5@Alloc:
  00082	8b 45 d8	 mov	 eax, DWORD PTR tv80[ebp]
  00085	89 45 cc	 mov	 DWORD PTR $T8[ebp], eax
  00088	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0008c	8b 45 cc	 mov	 eax, DWORD PTR $T8[ebp]
  0008f	89 45 d4	 mov	 DWORD PTR _pkNewData$9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00092	8d 45 d4	 lea	 eax, DWORD PTR _pkNewData$9[ebp]
  00095	50		 push	 eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 66   : 				m_kVct_pkData.push_back(pkNewData);

  00096	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  0009c	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXABQAVCInstanceBase@@@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::emplace_back<CInstanceBase * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 67   : 				++m_uUsedCapacity;

  000a1	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000a7	40		 inc	 eax
  000a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	89 41 20	 mov	 DWORD PTR [ecx+32], eax

; 68   : 				return pkNewData;

  000ae	8b 45 d4	 mov	 eax, DWORD PTR _pkNewData$9[ebp]
  000b1	eb 65		 jmp	 SHORT $LN1@Alloc
$LN2@Alloc:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1554 :         auto& _My_data = _Mypair._Myval2;

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 c0 10	 add	 eax, 16			; 00000010H
  000b9	89 45 c8	 mov	 DWORD PTR __My_data$7[ebp], eax

; 1555 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1556 :         _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
; 1557 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1558 : 
; 1559 :         return _My_data._Mylast[-1];

  000bc	6a 04		 push	 4
  000be	58		 pop	 eax
  000bf	6b c0 ff	 imul	 eax, eax, -1
  000c2	8b 4d c8	 mov	 ecx, DWORD PTR __My_data$7[ebp]
  000c5	03 41 04	 add	 eax, DWORD PTR [ecx+4]
  000c8	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 71   : 			T* pkFreeData=m_kVct_pkFree.back();

  000cb	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  000ce	8b 00		 mov	 eax, DWORD PTR [eax]
  000d0	89 45 b4	 mov	 DWORD PTR _pkFreeData$[ebp], eax

; 72   : 			m_kVct_pkFree.pop_back();

  000d3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	83 c0 10	 add	 eax, 16			; 00000010H
  000d9	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1329 :         auto& _My_data   = _Mypair._Myval2;

  000dc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000df	89 45 c0	 mov	 DWORD PTR __My_data$5[ebp], eax

; 1330 :         pointer& _Mylast = _My_data._Mylast;

  000e2	8b 45 c0	 mov	 eax, DWORD PTR __My_data$5[ebp]
  000e5	83 c0 04	 add	 eax, 4
  000e8	89 45 e8	 mov	 DWORD PTR __Mylast$12[ebp], eax

; 1331 : 
; 1332 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1333 :         _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
; 1334 :         _Orphan_range(_Mylast - 1, _Mylast);
; 1335 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1336 : 
; 1337 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  000eb	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  000ee	8b 00		 mov	 eax, DWORD PTR [eax]
  000f0	83 e8 04	 sub	 eax, 4
  000f3	89 45 bc	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000f6	8b 45 bc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000f9	89 45 b0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000fc	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000ff	89 45 b8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00102	8b 45 b8	 mov	 eax, DWORD PTR $T4[ebp]
  00105	89 45 ac	 mov	 DWORD PTR $T2[ebp], eax

; 1338 :         --_Mylast;

  00108	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$12[ebp]
  0010b	8b 00		 mov	 eax, DWORD PTR [eax]
  0010d	83 e8 04	 sub	 eax, 4
  00110	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$12[ebp]
  00113	89 01		 mov	 DWORD PTR [ecx], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 73   : 			return pkFreeData;

  00115	8b 45 b4	 mov	 eax, DWORD PTR _pkFreeData$[ebp]
$LN1@Alloc:

; 74   : 		}

  00118	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0011b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00122	59		 pop	 ecx
  00123	c9		 leave
  00124	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ$0:
  00000	68 b0 06 00 00	 push	 1712			; 000006b0H
  00005	ff 75 dc	 push	 DWORD PTR $T10[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a b4	 mov	 ecx, DWORD PTR [edx-76]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ ENDP ; CDynamicPool<CInstanceBase>::Alloc
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ?Destroy@?$CDynamicPool@VCInstanceBase@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
$T4 = -32						; size = 4
$T5 = -28						; size = 4
___param0$ = -24					; size = 4
$T6 = -20						; size = 4
___param0$ = -16					; size = 4
__My_data$7 = -12					; size = 4
__My_data$8 = -8					; size = 4
_this$ = -4						; size = 4
?Destroy@?$CDynamicPool@VCInstanceBase@@@@QAEXXZ PROC	; CDynamicPool<CInstanceBase>::Destroy, COMDAT
; _this$ = ecx

; 38   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1420 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00012	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00015	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00018	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	89 45 f0	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00021	8b 45 f0	 mov	 eax, DWORD PTR ___param0$[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax

; 1421 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00027	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  0002a	89 45 e0	 mov	 DWORD PTR $T4[ebp], eax

; 1410 :         auto& _My_data = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 04	 add	 eax, 4
  00033	89 45 f4	 mov	 DWORD PTR __My_data$7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  00039	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0003c	8b 45 f4	 mov	 eax, DWORD PTR __My_data$7[ebp]
  0003f	8b 00		 mov	 eax, DWORD PTR [eax]
  00041	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 42   :     _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR $T5[ebp], eax

; 1411 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0004a	8d 45 e4	 lea	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 50   : 			std::for_each(m_kVct_pkData.begin(), m_kVct_pkData.end(), Delete);

  00050	68 00 00 00 00	 push	 OFFSET ?Delete@?$CDynamicPool@VCInstanceBase@@@@KAXPAVCInstanceBase@@@Z ; CDynamicPool<CInstanceBase>::Delete
  00055	8b 45 e0	 mov	 eax, DWORD PTR $T4[ebp]
  00058	ff 30		 push	 DWORD PTR [eax]
  0005a	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  0005d	ff 30		 push	 DWORD PTR [eax]
  0005f	e8 00 00 00 00	 call	 ??$for_each@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@std@@P6AXPAVCInstanceBase@@@Z@std@@YAP6AXPAVCInstanceBase@@@ZV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVCInstanceBase@@@std@@@std@@@0@1P6AX0@Z@Z ; std::for_each<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<CInstanceBase *> > >,void (__cdecl*)(CInstanceBase *)>
  00064	83 c4 0c	 add	 esp, 12			; 0000000cH

; 51   : 			m_kVct_pkData.clear();

  00067	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	83 c1 04	 add	 ecx, 4
  0006d	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::clear

; 52   : 			m_kVct_pkFree.clear();

  00072	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00075	83 c1 10	 add	 ecx, 16			; 00000010H
  00078	e8 00 00 00 00	 call	 ?clear@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::clear

; 53   : 		}

  0007d	c9		 leave
  0007e	c3		 ret	 0
?Destroy@?$CDynamicPool@VCInstanceBase@@@@QAEXXZ ENDP	; CDynamicPool<CInstanceBase>::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??1?$CDynamicPool@VCInstanceBase@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CDynamicPool@VCInstanceBase@@@@UAE@XZ PROC		; CDynamicPool<CInstanceBase>::~CDynamicPool<CInstanceBase>, COMDAT
; _this$ = ecx

; 18   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCInstanceBase@@@@6B@

; 26   : 		}

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00016	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00021	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 26   : 		}

  00026	c9		 leave
  00027	c3		 ret	 0
??1?$CDynamicPool@VCInstanceBase@@@@UAE@XZ ENDP		; CDynamicPool<CInstanceBase>::~CDynamicPool<CInstanceBase>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
;	COMDAT ??0?$CDynamicPool@VCInstanceBase@@@@QAE@XZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_this$ = -16						; size = 4
_this$1 = -12						; size = 4
_this$2 = -8						; size = 4
_this$ = -4						; size = 4
??0?$CDynamicPool@VCInstanceBase@@@@QAE@XZ PROC		; CDynamicPool<CInstanceBase>::CDynamicPool<CInstanceBase>, COMDAT
; _this$ = ecx

; 11   : 		CDynamicPool()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 12   : 		{

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CDynamicPool@VCInstanceBase@@@@6B@
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	83 c0 04	 add	 eax, 4
  00018	89 45 f0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  0001b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00021	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00027	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  0002a	83 20 00	 and	 DWORD PTR [eax], 0
  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00030	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$2[ebp]
  00037	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 12   : 		{

  0003b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 c0 10	 add	 eax, 16			; 00000010H
  00041	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00044	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	89 45 f4	 mov	 DWORD PTR _this$1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00050	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00053	83 20 00	 and	 DWORD PTR [eax], 0
  00056	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00059	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  0005d	8b 45 f4	 mov	 eax, DWORD PTR _this$1[ebp]
  00060	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 14   : 			m_uInitCapacity=0;

  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	83 60 1c 00	 and	 DWORD PTR [eax+28], 0

; 15   : 			m_uUsedCapacity=0;

  0006b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	83 60 20 00	 and	 DWORD PTR [eax+32], 0

; 16   : 		}

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	c9		 leave
  00076	c3		 ret	 0
??0?$CDynamicPool@VCInstanceBase@@@@QAE@XZ ENDP		; CDynamicPool<CInstanceBase>::CDynamicPool<CInstanceBase>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gameLib\Interface.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??__Fgs_kActorInstBG@@YAXXZ
text$yd	SEGMENT
??__Fgs_kActorInstBG@@YAXXZ PROC			; `dynamic atexit destructor for 'gs_kActorInstBG'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 311  : 		virtual ~CActorInstanceBackground() {}

  00003	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_kActorInstBG@@3VCActorInstanceBackground@@A, OFFSET ??_7CActorInstanceBackground@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gameLib\Interface.h

; 8    : 		virtual ~IBackground() {}

  0000d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_kActorInstBG@@3VCActorInstanceBackground@@A, OFFSET ??_7IBackground@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 19   : 	{ 

  00017	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_kActorInstBG@@3VCActorInstanceBackground@@A, OFFSET ??_7?$CSingleton@VIBackground@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00021	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VIBackground@@@@0PAVIBackground@@A, 0 ; CSingleton<IBackground>::ms_singleton
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??__Fgs_kActorInstBG@@YAXXZ ENDP			; `dynamic atexit destructor for 'gs_kActorInstBG''
text$yd	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gameLib\Interface.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ??__Egs_kActorInstBG@@YAXXZ
text$di	SEGMENT
_offset$1 = -4						; size = 4
??__Egs_kActorInstBG@@YAXXZ PROC			; `dynamic initializer for 'gs_kActorInstBG'', COMDAT

; 319  : static CActorInstanceBackground gs_kActorInstBG;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 12   : 	{ 

  00004	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_kActorInstBG@@3VCActorInstanceBackground@@A, OFFSET ??_7?$CSingleton@VIBackground@@@@6B@

; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 

  0000e	33 c0		 xor	 eax, eax
  00010	89 45 fc	 mov	 DWORD PTR _offset$1[ebp], eax

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00013	8b 45 fc	 mov	 eax, DWORD PTR _offset$1[ebp]
  00016	05 00 00 00 00	 add	 eax, OFFSET ?gs_kActorInstBG@@3VCActorInstanceBackground@@A
  0001b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VIBackground@@@@0PAVIBackground@@A, eax ; CSingleton<IBackground>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gameLib\Interface.h

; 7    : 		IBackground() {}

  00020	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_kActorInstBG@@3VCActorInstanceBackground@@A, OFFSET ??_7IBackground@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 310  : 		CActorInstanceBackground() {}

  0002a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?gs_kActorInstBG@@3VCActorInstanceBackground@@A, OFFSET ??_7CActorInstanceBackground@@6B@

; 319  : static CActorInstanceBackground gs_kActorInstBG;

  00034	68 00 00 00 00	 push	 OFFSET ??__Fgs_kActorInstBG@@YAXXZ ; `dynamic atexit destructor for 'gs_kActorInstBG''
  00039	e8 00 00 00 00	 call	 _atexit
  0003e	59		 pop	 ecx
  0003f	c9		 leave
  00040	c3		 ret	 0
??__Egs_kActorInstBG@@YAXXZ ENDP			; `dynamic initializer for 'gs_kActorInstBG''
text$di	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gameLib\Interface.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??_GCActorInstanceBackground@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCActorInstanceBackground@@UAEPAXI@Z PROC		; CActorInstanceBackground::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 311  : 		virtual ~CActorInstanceBackground() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CActorInstanceBackground@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gameLib\Interface.h

; 8    : 		virtual ~IBackground() {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IBackground@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 19   : 	{ 

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VIBackground@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00022	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VIBackground@@@@0PAVIBackground@@A, 0 ; CSingleton<IBackground>::ms_singleton
  00029	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	74 0c		 je	 SHORT $LN2@scalar
  00031	6a 04		 push	 4
  00033	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
$LN2@scalar:
  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c9		 leave
  00041	c2 04 00	 ret	 4
??_GCActorInstanceBackground@@UAEPAXI@Z ENDP		; CActorInstanceBackground::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsBlock@CActorInstanceBackground@@UAE_NHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rkBG$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?IsBlock@CActorInstanceBackground@@UAE_NHH@Z PROC	; CActorInstanceBackground::IsBlock, COMDAT
; _this$ = ecx

; 313  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 314  : 			CPythonBackground& rkBG=CPythonBackground::Instance();

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0000d	89 45 fc	 mov	 DWORD PTR _rkBG$[ebp], eax

; 315  : 			return rkBG.isAttrOn(x, y, CTerrainImpl::ATTRIBUTE_BLOCK);

  00010	6a 01		 push	 1
  00012	ff 75 0c	 push	 DWORD PTR _y$[ebp]
  00015	ff 75 08	 push	 DWORD PTR _x$[ebp]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _rkBG$[ebp]
  0001b	e8 00 00 00 00	 call	 ?isAttrOn@CMapManager@@QAE_NHHE@Z ; CMapManager::isAttrOn

; 316  : 		}

  00020	c9		 leave
  00021	c2 08 00	 ret	 8
?IsBlock@CActorInstanceBackground@@UAE_NHH@Z ENDP	; CActorInstanceBackground::IsBlock
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__ArmorVnumToShape@@YA_NHPAK@Z
_TEXT	SEGMENT
_pItemData$ = -8					; size = 4
$T1 = -4						; size = 4
_iVnum$ = 8						; size = 4
_pdwShape$ = 12						; size = 4
?__ArmorVnumToShape@@YA_NHPAK@Z PROC			; __ArmorVnumToShape, COMDAT

; 281  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 282  : 	*pdwShape = iVnum;

  00005	8b 45 0c	 mov	 eax, DWORD PTR _pdwShape$[ebp]
  00008	8b 4d 08	 mov	 ecx, DWORD PTR _iVnum$[ebp]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 283  : 
; 284  : 	/////////////////////////////////////////
; 285  : 
; 286  : 	if (0 == iVnum || 1 == iVnum)

  0000d	83 7d 08 00	 cmp	 DWORD PTR _iVnum$[ebp], 0
  00011	74 06		 je	 SHORT $LN3@ArmorVnumT
  00013	83 7d 08 01	 cmp	 DWORD PTR _iVnum$[ebp], 1
  00017	75 04		 jne	 SHORT $LN2@ArmorVnumT
$LN3@ArmorVnumT:

; 287  : 		return false;

  00019	32 c0		 xor	 al, al
  0001b	eb 3d		 jmp	 SHORT $LN1@ArmorVnumT
$LN2@ArmorVnumT:

; 288  : 
; 289  : 	if (!USE_ARMOR_SPECULAR)

  0001d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?USE_ARMOR_SPECULAR@@3HA, 0 ; USE_ARMOR_SPECULAR
  00024	75 04		 jne	 SHORT $LN4@ArmorVnumT

; 290  : 		return false;

  00026	32 c0		 xor	 al, al
  00028	eb 30		 jmp	 SHORT $LN1@ArmorVnumT
$LN4@ArmorVnumT:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0002f	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 293  : 	if (!CItemManager::Instance().GetItemDataPointer(iVnum, &pItemData))

  00032	8d 45 f8	 lea	 eax, DWORD PTR _pItemData$[ebp]
  00035	50		 push	 eax
  00036	ff 75 08	 push	 DWORD PTR _iVnum$[ebp]
  00039	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  00041	85 c0		 test	 eax, eax
  00043	75 04		 jne	 SHORT $LN5@ArmorVnumT

; 294  : 		return false;

  00045	32 c0		 xor	 al, al
  00047	eb 11		 jmp	 SHORT $LN1@ArmorVnumT
$LN5@ArmorVnumT:

; 295  : 
; 296  : 	enum
; 297  : 	{
; 298  : 		SHAPE_VALUE_SLOT_INDEX = 3,
; 299  : 	};
; 300  : 
; 301  : 	*pdwShape = pItemData->GetValue(SHAPE_VALUE_SLOT_INDEX);

  00049	6a 03		 push	 3
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _pItemData$[ebp]
  0004e	e8 00 00 00 00	 call	 ?GetValue@CItemData@@QBEJE@Z ; CItemData::GetValue
  00053	8b 4d 0c	 mov	 ecx, DWORD PTR _pdwShape$[ebp]
  00056	89 01		 mov	 DWORD PTR [ecx], eax

; 302  : 
; 303  : 	return true;

  00058	b0 01		 mov	 al, 1
$LN1@ArmorVnumT:

; 304  : }

  0005a	c9		 leave
  0005b	c3		 ret	 0
?__ArmorVnumToShape@@YA_NHPAK@Z ENDP			; __ArmorVnumToShape
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsWall@@YA_NI@Z
_TEXT	SEGMENT
tv64 = -4						; size = 4
_race$ = 8						; size = 4
?IsWall@@YA_NI@Z PROC					; IsWall, COMDAT

; 22   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 23   : 	switch (race)

  00004	8b 45 08	 mov	 eax, DWORD PTR _race$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000a	81 7d fc 79 37
	00 00		 cmp	 DWORD PTR tv64[ebp], 14201 ; 00003779H
  00011	72 0f		 jb	 SHORT $LN2@IsWall
  00013	81 7d fc 7c 37
	00 00		 cmp	 DWORD PTR tv64[ebp], 14204 ; 0000377cH
  0001a	76 02		 jbe	 SHORT $LN4@IsWall
  0001c	eb 04		 jmp	 SHORT $LN2@IsWall
$LN4@IsWall:

; 24   : 	{
; 25   : 		case 14201:
; 26   : 		case 14202:
; 27   : 		case 14203:
; 28   : 		case 14204:
; 29   : 			return true;

  0001e	b0 01		 mov	 al, 1
  00020	eb 02		 jmp	 SHORT $LN1@IsWall
$LN2@IsWall:

; 30   : 			break;
; 31   : 	}
; 32   : 	return false;

  00022	32 c0		 xor	 al, al
$LN1@IsWall:

; 33   : }

  00024	c9		 leave
  00025	c3		 ret	 0
?IsWall@@YA_NI@Z ENDP					; IsWall
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Getal@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEAAV?$allocator@PAVCInstanceBase@@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Getal@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEAAV?$allocator@PAVCInstanceBase@@@2@XZ PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Getal, COMDAT
; _this$ = ecx

; 1732 :     _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000b	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 1734 :     }

  00011	c9		 leave
  00012	c3		 ret	 0
?_Getal@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEAAV?$allocator@PAVCInstanceBase@@@2@XZ ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@CAXXZ PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@CAXXZ ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXXZ PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 74		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAXPAPAVCInstanceBase@@QAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Destroy_range<std::allocator<CInstanceBase *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00097	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009a	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009d	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a0	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a3	c9		 leave
  000a4	c3		 ret	 0
?_Tidy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXXZ ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXQAPAVCInstanceBase@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXQAPAVCInstanceBase@@II@Z PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 62		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAXPAPAVCInstanceBase@@QAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Destroy_range<std::allocator<CInstanceBase *> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	c1 f8 02	 sar	 eax, 2
  00075	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 00		 mov	 eax, DWORD PTR [eax]
  0007d	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00080	8b 45 d4	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	c1 e0 02	 shl	 eax, 2
  00086	50		 push	 eax
  00087	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0008f	59		 pop	 ecx
  00090	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00091	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00094	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00097	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  00099	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0009f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a7	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000ad	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  000b0	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b3	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b5	c9		 leave
  000b6	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXQAPAVCInstanceBase@@II@Z ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@ABEII@Z PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00020	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00023	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00026	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  00029	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002c	c7 45 f0 ff ff
	ff 3f		 mov	 DWORD PTR $T7[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00033	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003a	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00040	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00043	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00046	73 08		 jae	 SHORT $LN25@Calculate_
  00048	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  0004e	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00050	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00053	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00056	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  00059	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005c	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00062	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0006d	d1 e8		 shr	 eax, 1
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00072	2b c8		 sub	 ecx, eax
  00074	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00077	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  00079	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007c	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0007e	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00081	d1 e8		 shr	 eax, 1
  00083	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00086	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  00089	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008c	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0008f	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00091	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00094	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00096	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  00099	c9		 leave
  0009a	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@ABEII@Z ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXPAPAVCInstanceBase@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXPAPAVCInstanceBase@@0@Z PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAXPAPAVCInstanceBase@@QAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Destroy_range<std::allocator<CInstanceBase *> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXPAPAVCInstanceBase@@0@Z ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?clear@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Myfirst$ = -16					; size = 4
__Mylast$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXXZ PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::clear, COMDAT
; _this$ = ecx

; 1383 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1384 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1385 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1386 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f4	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1387 : 
; 1388 :         _My_data._Orphan_all();
; 1389 :         _Destroy(_Myfirst, _Mylast);

  0001e	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  00026	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00029	8b 00		 mov	 eax, DWORD PTR [eax]
  0002b	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00031	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00037	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0003a	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  0003d	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00040	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00043	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAXPAPAVCInstanceBase@@QAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Destroy_range<std::allocator<CInstanceBase *> >
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1390 :         _Mylast = _Myfirst;

  0004b	8b 45 f4	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00051	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00053	89 08		 mov	 DWORD PTR [eax], ecx

; 1391 :     }

  00055	c9		 leave
  00056	c3		 ret	 0
?clear@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXXZ ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?reserve@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
$T6 = -28						; size = 4
$T7 = -24						; size = 4
tv81 = -20						; size = 4
$T8 = -16						; size = 4
$T9 = -12						; size = 4
__My_data$10 = -8					; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?reserve@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXI@Z PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::reserve, COMDAT
; _this$ = ecx

; 1304 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$10[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$10[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	c1 f8 02	 sar	 eax, 2
  0001d	89 45 e8	 mov	 DWORD PTR $T7[ebp], eax

; 1305 :         // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1306 :         if (_Newcapacity > capacity()) { // something to do (reserve() never shrinks)

  00020	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00023	3b 45 e8	 cmp	 eax, DWORD PTR $T7[ebp]
  00026	76 62		 jbe	 SHORT $LN4@reserve

; 1737 :         return _Mypair._Get_first();

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0002b	89 45 e4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  0002e	8b 45 e4	 mov	 eax, DWORD PTR $T6[ebp]
  00031	89 45 d0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00034	c7 45 f4 ff ff
	ff 3f		 mov	 DWORD PTR $T9[ebp], 1073741823 ; 3fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0003b	c7 45 e0 ff ff
	ff 7f		 mov	 DWORD PTR $T5[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00042	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  00045	89 45 f0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00048	8b 45 f4	 mov	 eax, DWORD PTR $T9[ebp]
  0004b	3b 45 f0	 cmp	 eax, DWORD PTR $T8[ebp]
  0004e	73 08		 jae	 SHORT $LN25@reserve
  00050	8d 45 f4	 lea	 eax, DWORD PTR $T9[ebp]
  00053	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  00056	eb 06		 jmp	 SHORT $LN26@reserve
$LN25@reserve:
  00058	8d 45 f0	 lea	 eax, DWORD PTR $T8[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
$LN26@reserve:
  0005e	8b 45 ec	 mov	 eax, DWORD PTR tv81[ebp]
  00061	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  00064	8b 45 dc	 mov	 eax, DWORD PTR $T4[ebp]
  00067	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0006a	8b 45 d8	 mov	 eax, DWORD PTR $T3[ebp]
  0006d	8b 00		 mov	 eax, DWORD PTR [eax]
  0006f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax

; 1307 :             if (_Newcapacity > max_size()) {

  00072	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00075	3b 45 d4	 cmp	 eax, DWORD PTR $T2[ebp]
  00078	76 05		 jbe	 SHORT $LN3@reserve

; 1308 :                 _Xlength();

  0007a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@CAXXZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Xlength
$LN3@reserve:

; 1309 :             }
; 1310 : 
; 1311 :             _Reallocate_exactly(_Newcapacity);

  0007f	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Reallocate_exactly
$LN4@reserve:

; 1312 :         }
; 1313 :     }

  0008a	c9		 leave
  0008b	c2 04 00	 ret	 4
?reserve@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXI@Z ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::reserve
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Max_possible$2 = -80					; size = 4
$T3 = -76						; size = 4
__Size$ = -72						; size = 4
__First$ = -68						; size = 4
__Last$ = -64						; size = 4
$T4 = -60						; size = 4
$T5 = -56						; size = 4
$T6 = -52						; size = 4
$T7 = -48						; size = 4
__Myfirst$ = -44					; size = 4
__Mylast$ = -40						; size = 4
__My_data$ = -36					; size = 4
__Newvec$ = -32						; size = 4
_this$ = -28						; size = 4
___formal$ = -24					; size = 1
__Overflow_is_possible$8 = -18				; size = 1
$T9 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Newcapacity$ = 8					; size = 4
?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z PROC ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Reallocate_exactly, COMDAT
; _this$ = ecx

; 1251 :     void _Reallocate_exactly(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 40	 sub	 esp, 64			; 00000040H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 1252 :         // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
; 1253 :         auto& _My_data    = _Mypair._Myval2;

  0002f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00032	89 45 dc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1254 :         pointer& _Myfirst = _My_data._Myfirst;

  00035	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00038	89 45 d4	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1255 :         pointer& _Mylast  = _My_data._Mylast;

  0003b	8b 45 dc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0003e	83 c0 04	 add	 eax, 4
  00041	89 45 d8	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1256 : 
; 1257 :         const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

  00044	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00047	8b 4d d4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0004a	8b 00		 mov	 eax, DWORD PTR [eax]
  0004c	2b 01		 sub	 eax, DWORD PTR [ecx]
  0004e	c1 f8 02	 sar	 eax, 2
  00051	89 45 b8	 mov	 DWORD PTR __Size$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  00054	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00057	89 45 d0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0005a	8b 45 d0	 mov	 eax, DWORD PTR $T7[ebp]
  0005d	89 45 b4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00060	c6 45 ee 01	 mov	 BYTE PTR __Overflow_is_possible$8[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00064	c7 45 b0 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$2[ebp], 1073741823 ; 3fffffffH

; 60   :         if (_Count > _Max_possible) {

  0006b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Newcapacity$[ebp], 1073741823 ; 3fffffffH
  00072	76 05		 jbe	 SHORT $LN17@Reallocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00074	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN17@Reallocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00079	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0007c	c1 e0 02	 shl	 eax, 2
  0007f	89 45 cc	 mov	 DWORD PTR $T6[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00082	ff 75 cc	 push	 DWORD PTR $T6[ebp]
  00085	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0008a	59		 pop	 ecx
  0008b	89 45 e0	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1261 :         _TRY_BEGIN

  0008e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00092	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00095	8b 00		 mov	 eax, DWORD PTR [eax]
  00097	89 45 c0	 mov	 DWORD PTR __Last$[ebp], eax
  0009a	8b 45 d4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009d	8b 00		 mov	 eax, DWORD PTR [eax]
  0009f	89 45 bc	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  000a2	33 c0		 xor	 eax, eax
  000a4	88 45 ef	 mov	 BYTE PTR $T9[ebp], al
  000a7	8a 45 ef	 mov	 al, BYTE PTR $T9[ebp]
  000aa	88 45 e8	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  000ad	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  000b0	89 45 c8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  000b3	8b 45 c8	 mov	 eax, DWORD PTR $T5[ebp]
  000b6	89 45 c4	 mov	 DWORD PTR $T4[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  000b9	ff 75 c4	 push	 DWORD PTR $T4[ebp]
  000bc	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000bf	ff 75 c0	 push	 DWORD PTR __Last$[ebp]
  000c2	ff 75 bc	 push	 DWORD PTR __First$[ebp]
  000c5	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@YAPAPAVCInstanceBase@@QAPAV1@0PAPAV1@AAV?$allocator@PAVCInstanceBase@@@0@@Z ; std::_Uninitialized_move<CInstanceBase * *,std::allocator<CInstanceBase *> >
  000ca	83 c4 10	 add	 esp, 16			; 00000010H

; 1262 :         _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  000cd	eb 24		 jmp	 SHORT $LN4@Reallocate
__catch$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z$0:

; 1263 :         _CATCH_ALL
; 1264 :         _Getal().deallocate(_Newvec, _Newcapacity);

  000cf	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  000d2	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  000d5	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEAAV?$allocator@PAVCInstanceBase@@@2@XZ ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Getal
  000dd	8b c8		 mov	 ecx, eax
  000df	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVCInstanceBase@@@std@@QAEXQAPAVCInstanceBase@@I@Z ; std::allocator<CInstanceBase *>::deallocate

; 1265 :         _RERAISE;

  000e4	6a 00		 push	 0
  000e6	6a 00		 push	 0
  000e8	e8 00 00 00 00	 call	 __CxxThrowException@8

; 1266 :         _CATCH_END

  000ed	b8 00 00 00 00	 mov	 eax, $LN7@Reallocate
  000f2	c3		 ret	 0
$LN4@Reallocate:
  000f3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  000f7	eb 04		 jmp	 SHORT __tryend$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z$1
$LN7@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  000f9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1267 : 
; 1268 :         _Change_array(_Newvec, _Size, _Newcapacity);

  000fd	ff 75 08	 push	 DWORD PTR __Newcapacity$[ebp]
  00100	ff 75 b8	 push	 DWORD PTR __Size$[ebp]
  00103	ff 75 e0	 push	 DWORD PTR __Newvec$[ebp]
  00106	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00109	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXQAPAVCInstanceBase@@II@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Change_array
$LN20@Reallocate:

; 1269 :     }

  0010e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00111	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00118	59		 pop	 ecx
  00119	5f		 pop	 edi
  0011a	5e		 pop	 esi
  0011b	5b		 pop	 ebx
  0011c	c9		 leave
  0011d	c2 04 00	 ret	 4
  00120	cc		 int	 3
  00121	cc		 int	 3
  00122	cc		 int	 3
  00123	cc		 int	 3
  00124	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Reallocate_exactly@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@AAEXI@Z ENDP ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::_Reallocate_exactly
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVCInstanceBase@@@std@@QAEXQAPAVCInstanceBase@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVCInstanceBase@@@std@@QAEXQAPAVCInstanceBase@@I@Z PROC ; std::allocator<CInstanceBase *>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	59		 pop	 ecx
  00017	59		 pop	 ecx

; 811  :     }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVCInstanceBase@@@std@@QAEXQAPAVCInstanceBase@@I@Z ENDP ; std::allocator<CInstanceBase *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCInstanceBase@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCInstanceBase@@UAEPAXI@Z PROC			; CInstanceBase::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CInstanceBase@@UAE@XZ ; CInstanceBase::~CInstanceBase
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 b0 06 00 00	 push	 1712			; 000006b0H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCInstanceBase@@UAEPAXI@Z ENDP			; CInstanceBase::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetDuelMode@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_type$ = 8						; size = 4
?SetDuelMode@CInstanceBase@@QAEXK@Z PROC		; CInstanceBase::SetDuelMode, COMDAT
; _this$ = ecx

; 2137 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2138 : 	m_dwDuelMode = type;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _type$[ebp]
  0000d	89 88 a8 06 00
	00		 mov	 DWORD PTR [eax+1704], ecx

; 2139 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetDuelMode@CInstanceBase@@QAEXK@Z ENDP		; CInstanceBase::SetDuelMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetDuelMode@CInstanceBase@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetDuelMode@CInstanceBase@@QAEKXZ PROC			; CInstanceBase::GetDuelMode, COMDAT
; _this$ = ecx

; 2142 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2143 : 	return m_dwDuelMode;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 a8 06 00
	00		 mov	 eax, DWORD PTR [eax+1704]

; 2144 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetDuelMode@CInstanceBase@@QAEKXZ ENDP			; CInstanceBase::GetDuelMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Delete@CInstanceBase@@SAXPAV1@@Z
_TEXT	SEGMENT
_pkData$ = -4						; size = 4
_pkInst$ = 8						; size = 4
?Delete@CInstanceBase@@SAXPAV1@@Z PROC			; CInstanceBase::Delete, COMDAT

; 642  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 643  : 	pkInst->Destroy();

  00004	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  00007	e8 00 00 00 00	 call	 ?Destroy@CInstanceBase@@QAEXXZ ; CInstanceBase::Destroy

; 644  : 	ms_kPool.Free(pkInst);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _pkInst$[ebp]
  0000f	89 45 fc	 mov	 DWORD PTR _pkData$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00012	8d 45 fc	 lea	 eax, DWORD PTR _pkData$[ebp]
  00015	50		 push	 eax
  00016	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A+16
  0001b	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVCInstanceBase@@@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXABQAVCInstanceBase@@@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::emplace_back<CInstanceBase * const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 645  : }

  00020	c9		 leave
  00021	c3		 ret	 0
?Delete@CInstanceBase@@SAXPAV1@@Z ENDP			; CInstanceBase::Delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?New@CInstanceBase@@SAPAV1@XZ
_TEXT	SEGMENT
?New@CInstanceBase@@SAPAV1@XZ PROC			; CInstanceBase::New, COMDAT

; 637  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 638  : 	return ms_kPool.Alloc();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A ; CInstanceBase::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Alloc@?$CDynamicPool@VCInstanceBase@@@@QAEPAVCInstanceBase@@XZ ; CDynamicPool<CInstanceBase>::Alloc

; 639  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?New@CInstanceBase@@SAPAV1@XZ ENDP			; CInstanceBase::New
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetInfo@CInstanceBase@@SAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
$T3 = -120						; size = 4
__My_data$4 = -116					; size = 4
_szInfo$ = -112						; size = 256
__$ArrayPad$ = 144					; size = 4
_pstInfo$ = 156						; size = 4
?GetInfo@CInstanceBase@@SAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; CInstanceBase::GetInfo, COMDAT

; 966  : {

  00000	55		 push	 ebp
  00001	8d ac 24 6c ff
	ff ff		 lea	 ebp, DWORD PTR [esp-148]
  00008	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 90 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  0001b	c7 45 8c 04 00
	00 00		 mov	 DWORD PTR __My_data$4[ebp], OFFSET ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A+4

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00022	8b 45 8c	 mov	 eax, DWORD PTR __My_data$4[ebp]
  00025	8b 4d 8c	 mov	 ecx, DWORD PTR __My_data$4[ebp]
  00028	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0002d	c1 f8 02	 sar	 eax, 2
  00030	89 45 88	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 968  : 	sprintf(szInfo, "Inst - UC %d, RC %d Pool - %d ", 

  00033	ff 75 88	 push	 DWORD PTR $T3[ebp]
  00036	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_dwRenderCounter@CInstanceBase@@1KA ; CInstanceBase::ms_dwRenderCounter
  0003c	ff 35 00 00 00
	00		 push	 DWORD PTR ?ms_dwUpdateCounter@CInstanceBase@@1KA ; CInstanceBase::ms_dwUpdateCounter
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PGINAIMI@Inst?5?9?5UC?5?$CFd?0?5RC?5?$CFd?5Pool?5?9?5?$CFd?5@
  00047	8d 45 90	 lea	 eax, DWORD PTR _szInfo$[ebp]
  0004a	50		 push	 eax
  0004b	e8 00 00 00 00	 call	 _sprintf
  00050	83 c4 14	 add	 esp, 20			; 00000014H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00053	8d 45 90	 lea	 eax, DWORD PTR _szInfo$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 84	 mov	 eax, DWORD PTR $T2[ebp]
  00063	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2958 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 80	 push	 DWORD PTR $T1[ebp]
  00069	8d 45 90	 lea	 eax, DWORD PTR _szInfo$[ebp]
  0006c	50		 push	 eax
  0006d	8b 8d 9c 00 00
	00		 mov	 ecx, DWORD PTR _pstInfo$[ebp]
  00073	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 975  : }

  00078	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	33 cd		 xor	 ecx, ebp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	81 c5 94 00 00
	00		 add	 ebp, 148		; 00000094H
  0008b	c9		 leave
  0008c	c3		 ret	 0
?GetInfo@CInstanceBase@@SAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; CInstanceBase::GetInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?ResetPerformanceCounter@CInstanceBase@@SAXXZ
_TEXT	SEGMENT
?ResetPerformanceCounter@CInstanceBase@@SAXXZ PROC	; CInstanceBase::ResetPerformanceCounter, COMDAT

; 978  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 979  : 	ms_dwUpdateCounter=0;

  00003	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_dwUpdateCounter@CInstanceBase@@1KA, 0 ; CInstanceBase::ms_dwUpdateCounter

; 980  : 	ms_dwRenderCounter=0;

  0000a	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_dwRenderCounter@CInstanceBase@@1KA, 0 ; CInstanceBase::ms_dwRenderCounter

; 981  : 	ms_dwDeformCounter=0;

  00011	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_dwDeformCounter@CInstanceBase@@1KA, 0 ; CInstanceBase::ms_dwDeformCounter

; 982  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?ResetPerformanceCounter@CInstanceBase@@SAXXZ ENDP	; CInstanceBase::ResetPerformanceCounter
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__GetShadowMapColor@CInstanceBase@@KAKMM@Z
_TEXT	SEGMENT
_rkBG$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?__GetShadowMapColor@CInstanceBase@@KAKMM@Z PROC	; CInstanceBase::__GetShadowMapColor, COMDAT

; 425  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 426  : 	CPythonBackground& rkBG=CPythonBackground::Instance();

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00009	89 45 fc	 mov	 DWORD PTR _rkBG$[ebp], eax

; 427  : 	return rkBG.GetShadowMapColor(x, y);

  0000c	51		 push	 ecx
  0000d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  00012	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00017	51		 push	 ecx
  00018	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0001d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _rkBG$[ebp]
  00025	e8 00 00 00 00	 call	 ?GetShadowMapColor@CMapManager@@QAEKMM@Z ; CMapManager::GetShadowMapColor

; 428  : }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?__GetShadowMapColor@CInstanceBase@@KAKMM@Z ENDP	; CInstanceBase::__GetShadowMapColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__GetBackgroundHeight@CInstanceBase@@KAMMM@Z
_TEXT	SEGMENT
_rkBG$ = -4						; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?__GetBackgroundHeight@CInstanceBase@@KAMMM@Z PROC	; CInstanceBase::__GetBackgroundHeight, COMDAT

; 431  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 432  : 	CPythonBackground& rkBG=CPythonBackground::Instance();

  00004	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  00009	89 45 fc	 mov	 DWORD PTR _rkBG$[ebp], eax

; 433  : 	return rkBG.GetHeight(x, y);

  0000c	51		 push	 ecx
  0000d	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _y$[ebp]
  00012	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00017	51		 push	 ecx
  00018	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _x$[ebp]
  0001d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _rkBG$[ebp]
  00025	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight

; 434  : }

  0002a	c9		 leave
  0002b	c3		 ret	 0
?__GetBackgroundHeight@CInstanceBase@@KAMMM@Z ENDP	; CInstanceBase::__GetBackgroundHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__Warrior_Initialize@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__Warrior_Initialize@CInstanceBase@@IAEXXZ PROC	; CInstanceBase::__Warrior_Initialize, COMDAT
; _this$ = ecx

; 3023 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3024 : 	m_kWarrior.m_dwGeomgyeongEffect=0;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 a0 a4 06 00
	00 00		 and	 DWORD PTR [eax+1700], 0

; 3025 : }

  00011	c9		 leave
  00012	c3		 ret	 0
?__Warrior_Initialize@CInstanceBase@@IAEXXZ ENDP	; CInstanceBase::__Warrior_Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S12$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ PROC ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S12$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc aa aa
	aa 0a		 mov	 DWORD PTR __Max_possible$1[ebp], 178956970 ; 0aaaaaaaH

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d aa aa aa 0a	 cmp	 eax, 178956970		; 0aaaaaaaH
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 18	 imul	 eax, eax, 24
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *,std::_List_node<CInstanceBase::SEffectDamage,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USEffectDamage@CInstanceBase@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SEffectDamage,void *> *,std::_List_node<CInstanceBase::SEffectDamage,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ ENDP ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ PROC ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USEffectDamage@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SEffectDamage,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SEffectDamage,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ ENDP ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ PROC ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::~list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ ENDP ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::~list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ PROC ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ ENDP ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S13$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ PROC ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S13$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc 5d 74
	d1 05		 mov	 DWORD PTR __Max_possible$1[ebp], 97612893 ; 05d1745dH

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d 5d 74 d1 05	 cmp	 eax, 97612893		; 05d1745dH
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 2c	 imul	 eax, eax, 44
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USCommand@CInstanceBase@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USCommand@CInstanceBase@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CInstanceBase::SCommand,void *> *,std::_List_node<CInstanceBase::SCommand,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ ENDP ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ PROC ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SCommand,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SCommand,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ ENDP ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEXXZ PROC ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SCommand,void *>::_Free_non_head<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEXXZ ENDP ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Unchecked_erase@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Pnode$ = 8						; size = 4
?_Unchecked_erase@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z PROC ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Unchecked_erase, COMDAT
; _this$ = ecx

; 1359 :     _Nodeptr _Unchecked_erase(const _Nodeptr _Pnode) noexcept { // erase element at _Pnode

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1360 :         const auto _Result = _Pnode->_Next;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1361 :         _Mypair._Myval2._Orphan_ptr2(_Pnode);
; 1362 :         --_Mypair._Myval2._Mysize;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	48		 dec	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1363 :         _Pnode->_Prev->_Next = _Result;

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00021	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00024	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00027	89 08		 mov	 DWORD PTR [eax], ecx

; 1364 :         _Result->_Prev       = _Pnode->_Prev;

  00029	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR __Pnode$[ebp]
  0002f	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00032	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1787 :         return _Mypair._Get_first();

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0003b	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  00041	8b 45 08	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00044	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00047	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  0004a	ff 75 08	 push	 DWORD PTR __Pnode$[ebp]
  0004d	ff 75 f0	 push	 DWORD PTR $T2[ebp]
  00050	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@std@@@?$_List_node@USCommand@CInstanceBase@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USCommand@CInstanceBase@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CInstanceBase::SCommand,void *>::_Freenode0<std::allocator<std::_List_node<CInstanceBase::SCommand,void *> > >
  00055	59		 pop	 ecx
  00056	59		 pop	 ecx

; 1365 :         _Node::_Freenode(_Getal(), _Pnode);
; 1366 :         return _Result;

  00057	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1367 :     }

  0005a	c9		 leave
  0005b	c2 04 00	 ret	 4
?_Unchecked_erase@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z ENDP ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Unchecked_erase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ PROC ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::~list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ ENDP ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::~list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ PROC ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ ENDP ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1SEffectContainer@CInstanceBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SEffectContainer@CInstanceBase@@QAE@XZ PROC		; CInstanceBase::SEffectContainer::~SEffectContainer, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >
  0000f	c9		 leave
  00010	c3		 ret	 0
??1SEffectContainer@CInstanceBase@@QAE@XZ ENDP		; CInstanceBase::SEffectContainer::~SEffectContainer
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__ClearArmorRefineEffect@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__ClearArmorRefineEffect@CInstanceBase@@IAEXXZ PROC	; CInstanceBase::__ClearArmorRefineEffect, COMDAT
; _this$ = ecx

; 2677 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2678 : 	if (m_armorRefineEffect)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 a4 01 00
	00 00		 cmp	 DWORD PTR [eax+420], 0
  00011	74 1b		 je	 SHORT $LN1@ClearArmor

; 2679 : 	{
; 2680 : 		__DetachEffect(m_armorRefineEffect);

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff b0 a4 01 00
	00		 push	 DWORD PTR [eax+420]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?__DetachEffect@CInstanceBase@@IAEXK@Z ; CInstanceBase::__DetachEffect

; 2681 : 		m_armorRefineEffect = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 a0 a4 01 00
	00 00		 and	 DWORD PTR [eax+420], 0
$LN1@ClearArmor:

; 2682 : 	}
; 2683 : }

  0002e	c9		 leave
  0002f	c3		 ret	 0
?__ClearArmorRefineEffect@CInstanceBase@@IAEXXZ ENDP	; CInstanceBase::__ClearArmorRefineEffect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__ClearWeaponRefineEffect@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__ClearWeaponRefineEffect@CInstanceBase@@IAEXXZ PROC	; CInstanceBase::__ClearWeaponRefineEffect, COMDAT
; _this$ = ecx

; 2663 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2664 : 	if (m_swordRefineEffectRight)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 9c 01 00
	00 00		 cmp	 DWORD PTR [eax+412], 0
  00011	74 1b		 je	 SHORT $LN2@ClearWeapo

; 2665 : 	{
; 2666 : 		__DetachEffect(m_swordRefineEffectRight);

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	ff b0 9c 01 00
	00		 push	 DWORD PTR [eax+412]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?__DetachEffect@CInstanceBase@@IAEXK@Z ; CInstanceBase::__DetachEffect

; 2667 : 		m_swordRefineEffectRight = 0;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 a0 9c 01 00
	00 00		 and	 DWORD PTR [eax+412], 0
$LN2@ClearWeapo:

; 2668 : 	}
; 2669 : 	if (m_swordRefineEffectLeft)

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 b8 a0 01 00
	00 00		 cmp	 DWORD PTR [eax+416], 0
  00038	74 1b		 je	 SHORT $LN1@ClearWeapo

; 2670 : 	{
; 2671 : 		__DetachEffect(m_swordRefineEffectLeft);

  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	ff b0 a0 01 00
	00		 push	 DWORD PTR [eax+416]
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?__DetachEffect@CInstanceBase@@IAEXK@Z ; CInstanceBase::__DetachEffect

; 2672 : 		m_swordRefineEffectLeft = 0;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 a0 a0 01 00
	00 00		 and	 DWORD PTR [eax+416], 0
$LN1@ClearWeapo:

; 2673 : 	}
; 2674 : }

  00055	c9		 leave
  00056	c3		 ret	 0
?__ClearWeaponRefineEffect@CInstanceBase@@IAEXXZ ENDP	; CInstanceBase::__ClearWeaponRefineEffect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__GetRefinedEffect@CInstanceBase@@IAEIPAVCItemData@@@Z
_TEXT	SEGMENT
_vnum$1 = -24						; size = 4
tv80 = -20						; size = 4
tv75 = -16						; size = 4
tv86 = -12						; size = 4
_refine$ = -8						; size = 4
_this$ = -4						; size = 4
_pItem$ = 8						; size = 4
?__GetRefinedEffect@CInstanceBase@@IAEIPAVCItemData@@@Z PROC ; CInstanceBase::__GetRefinedEffect, COMDAT
; _this$ = ecx

; 2686 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2687 : 	DWORD refine = max(pItem->GetRefine() + pItem->GetSocketCount(),CItemData::ITEM_SOCKET_MAX_NUM) - CItemData::ITEM_SOCKET_MAX_NUM;

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0000d	e8 00 00 00 00	 call	 ?GetRefine@CItemData@@QBEIXZ ; CItemData::GetRefine
  00012	8b f0		 mov	 esi, eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00017	e8 00 00 00 00	 call	 ?GetSocketCount@CItemData@@QBEHXZ ; CItemData::GetSocketCount
  0001c	03 f0		 add	 esi, eax
  0001e	83 fe 03	 cmp	 esi, 3
  00021	76 19		 jbe	 SHORT $LN21@GetRefined
  00023	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00026	e8 00 00 00 00	 call	 ?GetRefine@CItemData@@QBEIXZ ; CItemData::GetRefine
  0002b	8b f0		 mov	 esi, eax
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00030	e8 00 00 00 00	 call	 ?GetSocketCount@CItemData@@QBEHXZ ; CItemData::GetSocketCount
  00035	03 f0		 add	 esi, eax
  00037	89 75 f0	 mov	 DWORD PTR tv75[ebp], esi
  0003a	eb 07		 jmp	 SHORT $LN22@GetRefined
$LN21@GetRefined:
  0003c	c7 45 f0 03 00
	00 00		 mov	 DWORD PTR tv75[ebp], 3
$LN22@GetRefined:
  00043	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  00046	83 e8 03	 sub	 eax, 3
  00049	89 45 f8	 mov	 DWORD PTR _refine$[ebp], eax

; 2688 : 	switch (pItem->GetType())

  0004c	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  0004f	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType
  00054	88 45 ec	 mov	 BYTE PTR tv80[ebp], al
  00057	80 7d ec 01	 cmp	 BYTE PTR tv80[ebp], 1
  0005b	74 0f		 je	 SHORT $LN6@GetRefined
  0005d	80 7d ec 02	 cmp	 BYTE PTR tv80[ebp], 2
  00061	0f 84 04 01 00
	00		 je	 $LN15@GetRefined
  00067	e9 88 01 00 00	 jmp	 $LN2@GetRefined
$LN6@GetRefined:

; 2689 : 	{
; 2690 : 	case CItemData::ITEM_TYPE_WEAPON:
; 2691 : 		__ClearWeaponRefineEffect();		

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?__ClearWeaponRefineEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__ClearWeaponRefineEffect

; 2692 : 		if (refine < 7)	//  7   .

  00074	83 7d f8 07	 cmp	 DWORD PTR _refine$[ebp], 7
  00078	73 07		 jae	 SHORT $LN7@GetRefined

; 2693 : 			return 0;

  0007a	33 c0		 xor	 eax, eax
  0007c	e9 75 01 00 00	 jmp	 $LN1@GetRefined
$LN7@GetRefined:

; 2694 : 		switch(pItem->GetSubType())

  00081	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00084	e8 00 00 00 00	 call	 ?GetSubType@CItemData@@QBEEXZ ; CItemData::GetSubType
  00089	88 45 f4	 mov	 BYTE PTR tv86[ebp], al
  0008c	80 7d f4 01	 cmp	 BYTE PTR tv86[ebp], 1
  00090	74 1a		 je	 SHORT $LN8@GetRefined
  00092	80 7d f4 02	 cmp	 BYTE PTR tv86[ebp], 2
  00096	74 5e		 je	 SHORT $LN11@GetRefined
  00098	80 7d f4 04	 cmp	 BYTE PTR tv86[ebp], 4
  0009c	74 45		 je	 SHORT $LN10@GetRefined
  0009e	80 7d f4 05	 cmp	 BYTE PTR tv86[ebp], 5
  000a2	74 2c		 je	 SHORT $LN9@GetRefined
  000a4	80 7d f4 06	 cmp	 BYTE PTR tv86[ebp], 6
  000a8	74 39		 je	 SHORT $LN10@GetRefined
  000aa	eb 5d		 jmp	 SHORT $LN12@GetRefined
$LN8@GetRefined:

; 2695 : 		{
; 2696 : 		case CItemData::WEAPON_DAGGER:
; 2697 : 			m_swordRefineEffectRight = EFFECT_REFINED+EFFECT_SMALLSWORD_REFINED7+refine-7;

  000ac	8b 45 f8	 mov	 eax, DWORD PTR _refine$[ebp]
  000af	05 e8 00 00 00	 add	 eax, 232		; 000000e8H
  000b4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax

; 2698 : 			m_swordRefineEffectLeft = EFFECT_REFINED+EFFECT_SMALLSWORD_REFINED7_LEFT+refine-7;

  000bd	8b 45 f8	 mov	 eax, DWORD PTR _refine$[ebp]
  000c0	05 eb 00 00 00	 add	 eax, 235		; 000000ebH
  000c5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	89 81 a0 01 00
	00		 mov	 DWORD PTR [ecx+416], eax

; 2699 : 			break;

  000ce	eb 4a		 jmp	 SHORT $LN4@GetRefined
$LN9@GetRefined:

; 2700 : 		case CItemData::WEAPON_FAN:
; 2701 : 			m_swordRefineEffectRight = EFFECT_REFINED+EFFECT_FANBELL_REFINED7+refine-7;

  000d0	8b 45 f8	 mov	 eax, DWORD PTR _refine$[ebp]
  000d3	05 e5 00 00 00	 add	 eax, 229		; 000000e5H
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax

; 2702 : 			break;

  000e1	eb 37		 jmp	 SHORT $LN4@GetRefined
$LN10@GetRefined:

; 2703 : 		case CItemData::WEAPON_ARROW:
; 2704 : 		case CItemData::WEAPON_BELL:
; 2705 : 			m_swordRefineEffectRight = EFFECT_REFINED+EFFECT_SMALLSWORD_REFINED7+refine-7;

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _refine$[ebp]
  000e6	05 e8 00 00 00	 add	 eax, 232		; 000000e8H
  000eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ee	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax

; 2706 : 			break;

  000f4	eb 24		 jmp	 SHORT $LN4@GetRefined
$LN11@GetRefined:

; 2707 : 		case CItemData::WEAPON_BOW:
; 2708 : 			m_swordRefineEffectRight = EFFECT_REFINED+EFFECT_BOW_REFINED7+refine-7;

  000f6	8b 45 f8	 mov	 eax, DWORD PTR _refine$[ebp]
  000f9	05 e2 00 00 00	 add	 eax, 226		; 000000e2H
  000fe	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00101	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax

; 2709 : 			break;

  00107	eb 11		 jmp	 SHORT $LN4@GetRefined
$LN12@GetRefined:

; 2710 : 		default:
; 2711 : 			m_swordRefineEffectRight = EFFECT_REFINED+EFFECT_SWORD_REFINED7+refine-7;

  00109	8b 45 f8	 mov	 eax, DWORD PTR _refine$[ebp]
  0010c	05 df 00 00 00	 add	 eax, 223		; 000000dfH
  00111	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00114	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax
$LN4@GetRefined:

; 2712 : 		}
; 2713 : 		if (m_swordRefineEffectRight)

  0011a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0011d	83 b8 9c 01 00
	00 00		 cmp	 DWORD PTR [eax+412], 0
  00124	74 1a		 je	 SHORT $LN13@GetRefined

; 2714 : 			m_swordRefineEffectRight = __AttachEffect(m_swordRefineEffectRight);

  00126	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00129	ff b0 9c 01 00
	00		 push	 DWORD PTR [eax+412]
  0012f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00132	e8 00 00 00 00	 call	 ?__AttachEffect@CInstanceBase@@IAEKI@Z ; CInstanceBase::__AttachEffect
  00137	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	89 81 9c 01 00
	00		 mov	 DWORD PTR [ecx+412], eax
$LN13@GetRefined:

; 2715 : 		if (m_swordRefineEffectLeft)

  00140	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00143	83 b8 a0 01 00
	00 00		 cmp	 DWORD PTR [eax+416], 0
  0014a	74 1a		 je	 SHORT $LN14@GetRefined

; 2716 : 			m_swordRefineEffectLeft = __AttachEffect(m_swordRefineEffectLeft);

  0014c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0014f	ff b0 a0 01 00
	00		 push	 DWORD PTR [eax+416]
  00155	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00158	e8 00 00 00 00	 call	 ?__AttachEffect@CInstanceBase@@IAEKI@Z ; CInstanceBase::__AttachEffect
  0015d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	89 81 a0 01 00
	00		 mov	 DWORD PTR [ecx+416], eax
$LN14@GetRefined:

; 2717 : 		break;

  00166	e9 89 00 00 00	 jmp	 $LN2@GetRefined
$LN15@GetRefined:

; 2718 : 	case CItemData::ITEM_TYPE_ARMOR:
; 2719 : 		__ClearArmorRefineEffect();

  0016b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0016e	e8 00 00 00 00	 call	 ?__ClearArmorRefineEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__ClearArmorRefineEffect

; 2720 : 
; 2721 : 		//   
; 2722 : 		if (pItem->GetSubType() == CItemData::ARMOR_BODY)

  00173	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00176	e8 00 00 00 00	 call	 ?GetSubType@CItemData@@QBEEXZ ; CItemData::GetSubType
  0017b	0f b6 c0	 movzx	 eax, al
  0017e	85 c0		 test	 eax, eax
  00180	75 37		 jne	 SHORT $LN16@GetRefined

; 2723 : 		{
; 2724 : 			DWORD vnum = pItem->GetIndex();

  00182	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  00185	e8 00 00 00 00	 call	 ?GetIndex@CItemData@@QBEKXZ ; CItemData::GetIndex
  0018a	89 45 e8	 mov	 DWORD PTR _vnum$1[ebp], eax

; 2725 : 
; 2726 : 			if (12010 <= vnum && vnum <= 12049)

  0018d	81 7d e8 ea 2e
	00 00		 cmp	 DWORD PTR _vnum$1[ebp], 12010 ; 00002eeaH
  00194	72 23		 jb	 SHORT $LN16@GetRefined
  00196	81 7d e8 11 2f
	00 00		 cmp	 DWORD PTR _vnum$1[ebp], 12049 ; 00002f11H
  0019d	77 1a		 ja	 SHORT $LN16@GetRefined

; 2727 : 			{
; 2728 : 				__AttachEffect(EFFECT_REFINED+EFFECT_BODYARMOR_SPECIAL);

  0019f	68 f8 00 00 00	 push	 248			; 000000f8H
  001a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a7	e8 00 00 00 00	 call	 ?__AttachEffect@CInstanceBase@@IAEKI@Z ; CInstanceBase::__AttachEffect

; 2729 : 				__AttachEffect(EFFECT_REFINED+EFFECT_BODYARMOR_SPECIAL2);

  001ac	68 f9 00 00 00	 push	 249			; 000000f9H
  001b1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	e8 00 00 00 00	 call	 ?__AttachEffect@CInstanceBase@@IAEKI@Z ; CInstanceBase::__AttachEffect
$LN16@GetRefined:

; 2730 : 			}
; 2731 : 		}
; 2732 : 
; 2733 : 		if (refine < 7)	//  7   .

  001b9	83 7d f8 07	 cmp	 DWORD PTR _refine$[ebp], 7
  001bd	73 04		 jae	 SHORT $LN18@GetRefined

; 2734 : 			return 0;

  001bf	33 c0		 xor	 eax, eax
  001c1	eb 33		 jmp	 SHORT $LN1@GetRefined
$LN18@GetRefined:

; 2735 : 
; 2736 : 		if (pItem->GetSubType() == CItemData::ARMOR_BODY)

  001c3	8b 4d 08	 mov	 ecx, DWORD PTR _pItem$[ebp]
  001c6	e8 00 00 00 00	 call	 ?GetSubType@CItemData@@QBEEXZ ; CItemData::GetSubType
  001cb	0f b6 c0	 movzx	 eax, al
  001ce	85 c0		 test	 eax, eax
  001d0	75 22		 jne	 SHORT $LN2@GetRefined

; 2737 : 		{
; 2738 : 			m_armorRefineEffect = EFFECT_REFINED+EFFECT_BODYARMOR_REFINED7+refine-7;

  001d2	8b 45 f8	 mov	 eax, DWORD PTR _refine$[ebp]
  001d5	05 ee 00 00 00	 add	 eax, 238		; 000000eeH
  001da	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001dd	89 81 a4 01 00
	00		 mov	 DWORD PTR [ecx+420], eax

; 2739 : 			__AttachEffect(m_armorRefineEffect);

  001e3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001e6	ff b0 a4 01 00
	00		 push	 DWORD PTR [eax+420]
  001ec	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ef	e8 00 00 00 00	 call	 ?__AttachEffect@CInstanceBase@@IAEKI@Z ; CInstanceBase::__AttachEffect
$LN2@GetRefined:

; 2740 : 		}
; 2741 : 		break;
; 2742 : 	}
; 2743 : 	return 0;

  001f4	33 c0		 xor	 eax, eax
$LN1@GetRefined:

; 2744 : }

  001f6	5e		 pop	 esi
  001f7	c9		 leave
  001f8	c2 04 00	 ret	 4
?__GetRefinedEffect@CInstanceBase@@IAEIPAVCItemData@@@Z ENDP ; CInstanceBase::__GetRefinedEffect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ PROC ; CInstanceBase::NEW_GetDstPixelPositionRef, COMDAT
; _this$ = ecx

; 1015 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1016 : 	return m_GraphicThingInstance.NEW_GetDstPixelPositionRef();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetDstPixelPositionRef

; 1017 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ENDP ; CInstanceBase::NEW_GetDstPixelPositionRef
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ PROC ; CInstanceBase::NEW_GetSrcPixelPositionRef, COMDAT
; _this$ = ecx

; 1020 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1021 : 	return m_GraphicThingInstance.NEW_GetSrcPixelPositionRef();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?NEW_GetSrcPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetSrcPixelPositionRef

; 1022 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ENDP ; CInstanceBase::NEW_GetSrcPixelPositionRef
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_GetCurPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NEW_GetCurPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ PROC ; CInstanceBase::NEW_GetCurPixelPositionRef, COMDAT
; _this$ = ecx

; 1010 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1011 : 	return m_GraphicThingInstance.NEW_GetCurPixelPositionRef();	

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?NEW_GetCurPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetCurPixelPositionRef

; 1012 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?NEW_GetCurPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ENDP ; CInstanceBase::NEW_GetCurPixelPositionRef
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_SetDstPixelPositionZ@CInstanceBase@@IAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_z$ = 8							; size = 4
?NEW_SetDstPixelPositionZ@CInstanceBase@@IAEXM@Z PROC	; CInstanceBase::NEW_SetDstPixelPositionZ, COMDAT
; _this$ = ecx

; 995  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 996  : 	m_GraphicThingInstance.NEW_SetDstPixelPositionZ(z);

  00007	51		 push	 ecx
  00008	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _z$[ebp]
  0000d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0001b	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPositionZ@CActorInstance@@QAEXM@Z ; CActorInstance::NEW_SetDstPixelPositionZ

; 997  : }

  00020	c9		 leave
  00021	c2 04 00	 ret	 4
?NEW_SetDstPixelPositionZ@CInstanceBase@@IAEXM@Z ENDP	; CInstanceBase::NEW_SetDstPixelPositionZ
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rkPPosDst$ = 8					; size = 4
?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z PROC ; CInstanceBase::NEW_SetDstPixelPosition, COMDAT
; _this$ = ecx

; 1000 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1001 : 	m_GraphicThingInstance.NEW_SetDstPixelPosition(c_rkPPosDst);

  00007	ff 75 08	 push	 DWORD PTR _c_rkPPosDst$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CActorInstance@@QAEXABUD3DXVECTOR3@@@Z ; CActorInstance::NEW_SetDstPixelPosition

; 1002 : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ENDP ; CInstanceBase::NEW_SetDstPixelPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rkPPosSrc$ = 8					; size = 4
?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z PROC ; CInstanceBase::NEW_SetSrcPixelPosition, COMDAT
; _this$ = ecx

; 1005 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1006 : 	m_GraphicThingInstance.NEW_SetSrcPixelPosition(c_rkPPosSrc);

  00007	ff 75 08	 push	 DWORD PTR _c_rkPPosSrc$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CActorInstance@@QAEXABUD3DXVECTOR3@@@Z ; CActorInstance::NEW_SetSrcPixelPosition

; 1007 : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ENDP ; CInstanceBase::NEW_SetSrcPixelPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?OnMoving@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnMoving@CInstanceBase@@IAEXXZ PROC			; CInstanceBase::OnMoving, COMDAT
; _this$ = ecx

; 1036 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1037 : 	m_GraphicThingInstance.__OnMoving();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?__OnMoving@CActorInstance@@QAEXXZ ; CActorInstance::__OnMoving

; 1038 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?OnMoving@CInstanceBase@@IAEXXZ ENDP			; CInstanceBase::OnMoving
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?OnWaiting@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnWaiting@CInstanceBase@@IAEXXZ PROC			; CInstanceBase::OnWaiting, COMDAT
; _this$ = ecx

; 1031 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1032 : 	m_GraphicThingInstance.__OnWaiting();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?__OnWaiting@CActorInstance@@QAEXXZ ; CActorInstance::__OnWaiting

; 1033 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?OnWaiting@CInstanceBase@@IAEXXZ ENDP			; CInstanceBase::OnWaiting
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?OnSyncing@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnSyncing@CInstanceBase@@IAEXXZ PROC			; CInstanceBase::OnSyncing, COMDAT
; _this$ = ecx

; 1026 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1027 : 	m_GraphicThingInstance.__OnSyncing();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?__OnSyncing@CActorInstance@@QAEXXZ ; CActorInstance::__OnSyncing

; 1028 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?OnSyncing@CInstanceBase@@IAEXXZ ENDP			; CInstanceBase::OnSyncing
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?RefreshActorInstance@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RefreshActorInstance@CInstanceBase@@IAEXXZ PROC	; CInstanceBase::RefreshActorInstance, COMDAT
; _this$ = ecx

; 2510 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2511 : 	m_GraphicThingInstance.RefreshActorInstance();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?RefreshActorInstance@CActorInstance@@QAEXXZ ; CActorInstance::RefreshActorInstance

; 2512 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?RefreshActorInstance@CInstanceBase@@IAEXXZ ENDP	; CInstanceBase::RefreshActorInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?RefreshState@CInstanceBase@@IAEXK_N@Z
_TEXT	SEGMENT
_rkItemMgr$ = -28					; size = 4
_dwPartItemID$ = -24					; size = 4
_pItemData$ = -20					; size = 4
tv174 = -16						; size = 4
tv150 = -12						; size = 4
_this$ = -8						; size = 4
_byItemType$ = -2					; size = 1
_bySubType$ = -1					; size = 1
_dwMotIndex$ = 8					; size = 4
_isLoop$ = 12						; size = 1
?RefreshState@CInstanceBase@@IAEXK_N@Z PROC		; CInstanceBase::RefreshState, COMDAT
; _this$ = ecx

; 2851 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2852 : 	DWORD dwPartItemID = m_GraphicThingInstance.GetPartItemID(CRaceData::PART_WEAPON);

  00009	6a 01		 push	 1
  0000b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00014	e8 00 00 00 00	 call	 ?GetPartItemID@CActorInstance@@QAEKK@Z ; CActorInstance::GetPartItemID
  00019	89 45 e8	 mov	 DWORD PTR _dwPartItemID$[ebp], eax

; 2853 : 
; 2854 : 	BYTE byItemType = 0xff;

  0001c	c6 45 fe ff	 mov	 BYTE PTR _byItemType$[ebp], 255 ; 000000ffH

; 2855 : 	BYTE bySubType = 0xff;

  00020	c6 45 ff ff	 mov	 BYTE PTR _bySubType$[ebp], 255 ; 000000ffH

; 2856 : 
; 2857 : 	CItemManager & rkItemMgr = CItemManager::Instance();

  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00029	89 45 e4	 mov	 DWORD PTR _rkItemMgr$[ebp], eax

; 2858 : 	CItemData * pItemData;
; 2859 : 	
; 2860 : 	if (rkItemMgr.GetItemDataPointer(dwPartItemID, &pItemData))

  0002c	8d 45 ec	 lea	 eax, DWORD PTR _pItemData$[ebp]
  0002f	50		 push	 eax
  00030	ff 75 e8	 push	 DWORD PTR _dwPartItemID$[ebp]
  00033	8b 4d e4	 mov	 ecx, DWORD PTR _rkItemMgr$[ebp]
  00036	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  0003b	85 c0		 test	 eax, eax
  0003d	74 16		 je	 SHORT $LN6@RefreshSta

; 2861 : 	{
; 2862 : 		byItemType = pItemData->GetType();

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _pItemData$[ebp]
  00042	e8 00 00 00 00	 call	 ?GetType@CItemData@@QBEEXZ ; CItemData::GetType
  00047	88 45 fe	 mov	 BYTE PTR _byItemType$[ebp], al

; 2863 : 		bySubType = pItemData->GetWeaponType();

  0004a	8b 4d ec	 mov	 ecx, DWORD PTR _pItemData$[ebp]
  0004d	e8 00 00 00 00	 call	 ?GetWeaponType@CItemData@@QBEKXZ ; CItemData::GetWeaponType
  00052	88 45 ff	 mov	 BYTE PTR _bySubType$[ebp], al
$LN6@RefreshSta:

; 2864 : 	}
; 2865 : 
; 2866 : 	if (IsPoly())

  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?IsPoly@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPoly
  0005d	85 c0		 test	 eax, eax
  0005f	74 0f		 je	 SHORT $LN7@RefreshSta

; 2867 : 	{
; 2868 : 		SetMotionMode(CRaceMotionData::MODE_GENERAL);

  00061	6a 01		 push	 1
  00063	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2869 : 	}

  0006b	e9 9e 01 00 00	 jmp	 $LN4@RefreshSta
$LN7@RefreshSta:

; 2870 : 	else if (IsWearingDress())

  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?IsWearingDress@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWearingDress
  00078	85 c0		 test	 eax, eax
  0007a	74 0f		 je	 SHORT $LN9@RefreshSta

; 2871 : 	{
; 2872 : 		SetMotionMode(CRaceMotionData::MODE_WEDDING_DRESS);

  0007c	6a 10		 push	 16			; 00000010H
  0007e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00081	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2873 : 	}

  00086	e9 83 01 00 00	 jmp	 $LN4@RefreshSta
$LN9@RefreshSta:

; 2874 : 	else if (IsHoldingPickAxe())

  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?IsHoldingPickAxe@CInstanceBase@@QAEHXZ ; CInstanceBase::IsHoldingPickAxe
  00093	85 c0		 test	 eax, eax
  00095	74 2d		 je	 SHORT $LN11@RefreshSta

; 2875 : 	{
; 2876 : 		if (m_kHorse.IsMounting())

  00097	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	83 c1 04	 add	 ecx, 4
  0009d	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  000a2	0f b6 c0	 movzx	 eax, al
  000a5	85 c0		 test	 eax, eax
  000a7	74 0c		 je	 SHORT $LN13@RefreshSta

; 2877 : 		{
; 2878 : 			SetMotionMode(CRaceMotionData::MODE_HORSE);

  000a9	6a 09		 push	 9
  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2879 : 		}

  000b3	eb 0a		 jmp	 SHORT $LN14@RefreshSta
$LN13@RefreshSta:

; 2880 : 		else
; 2881 : 		{
; 2882 : 			SetMotionMode(CRaceMotionData::MODE_GENERAL);

  000b5	6a 01		 push	 1
  000b7	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode
$LN14@RefreshSta:

; 2883 : 		}
; 2884 : 	}

  000bf	e9 4a 01 00 00	 jmp	 $LN4@RefreshSta
$LN11@RefreshSta:

; 2885 : 	else if (CItemData::ITEM_TYPE_ROD == byItemType)

  000c4	0f b6 45 fe	 movzx	 eax, BYTE PTR _byItemType$[ebp]
  000c8	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  000cb	75 2d		 jne	 SHORT $LN15@RefreshSta

; 2886 : 	{
; 2887 : 		if (m_kHorse.IsMounting())

  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	83 c1 04	 add	 ecx, 4
  000d3	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  000d8	0f b6 c0	 movzx	 eax, al
  000db	85 c0		 test	 eax, eax
  000dd	74 0c		 je	 SHORT $LN17@RefreshSta

; 2888 : 		{
; 2889 : 			SetMotionMode(CRaceMotionData::MODE_HORSE);

  000df	6a 09		 push	 9
  000e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2890 : 		}

  000e9	eb 0a		 jmp	 SHORT $LN18@RefreshSta
$LN17@RefreshSta:

; 2891 : 		else
; 2892 : 		{
; 2893 : 			SetMotionMode(CRaceMotionData::MODE_FISHING);

  000eb	6a 08		 push	 8
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode
$LN18@RefreshSta:

; 2894 : 		}
; 2895 : 	}

  000f5	e9 14 01 00 00	 jmp	 $LN4@RefreshSta
$LN15@RefreshSta:

; 2896 : 	else if (m_kHorse.IsMounting())

  000fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	83 c1 04	 add	 ecx, 4
  00100	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  00105	0f b6 c0	 movzx	 eax, al
  00108	85 c0		 test	 eax, eax
  0010a	0f 84 80 00 00
	00		 je	 $LN19@RefreshSta

; 2897 : 	{
; 2898 : 		switch (bySubType)

  00110	8a 45 ff	 mov	 al, BYTE PTR _bySubType$[ebp]
  00113	88 45 f4	 mov	 BYTE PTR tv150[ebp], al
  00116	80 7d f4 00	 cmp	 BYTE PTR tv150[ebp], 0
  0011a	74 20		 je	 SHORT $LN21@RefreshSta
  0011c	80 7d f4 01	 cmp	 BYTE PTR tv150[ebp], 1
  00120	74 32		 je	 SHORT $LN23@RefreshSta
  00122	80 7d f4 02	 cmp	 BYTE PTR tv150[ebp], 2
  00126	74 50		 je	 SHORT $LN26@RefreshSta
  00128	80 7d f4 03	 cmp	 BYTE PTR tv150[ebp], 3
  0012c	74 1a		 je	 SHORT $LN22@RefreshSta
  0012e	80 7d f4 04	 cmp	 BYTE PTR tv150[ebp], 4
  00132	74 38		 je	 SHORT $LN25@RefreshSta
  00134	80 7d f4 05	 cmp	 BYTE PTR tv150[ebp], 5
  00138	74 26		 je	 SHORT $LN24@RefreshSta
  0013a	eb 48		 jmp	 SHORT $LN27@RefreshSta
$LN21@RefreshSta:

; 2899 : 		{
; 2900 : 			case CItemData::WEAPON_SWORD:
; 2901 : 				SetMotionMode(CRaceMotionData::MODE_HORSE_ONEHAND_SWORD);

  0013c	6a 0a		 push	 10			; 0000000aH
  0013e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2902 : 				break;

  00146	eb 46		 jmp	 SHORT $LN2@RefreshSta
$LN22@RefreshSta:

; 2903 : 
; 2904 : 			case CItemData::WEAPON_TWO_HANDED:
; 2905 : 				SetMotionMode(CRaceMotionData::MODE_HORSE_TWOHAND_SWORD); // Only Warrior

  00148	6a 0b		 push	 11			; 0000000bH
  0014a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2906 : 				break;

  00152	eb 3a		 jmp	 SHORT $LN2@RefreshSta
$LN23@RefreshSta:

; 2907 : 
; 2908 : 			case CItemData::WEAPON_DAGGER:
; 2909 : 				SetMotionMode(CRaceMotionData::MODE_HORSE_DUALHAND_SWORD); // Only Assassin

  00154	6a 0c		 push	 12			; 0000000cH
  00156	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00159	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2910 : 				break;

  0015e	eb 2e		 jmp	 SHORT $LN2@RefreshSta
$LN24@RefreshSta:

; 2911 : 
; 2912 : 			case CItemData::WEAPON_FAN:
; 2913 : 				SetMotionMode(CRaceMotionData::MODE_HORSE_FAN); // Only Shaman

  00160	6a 0e		 push	 14			; 0000000eH
  00162	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00165	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2914 : 				break;

  0016a	eb 22		 jmp	 SHORT $LN2@RefreshSta
$LN25@RefreshSta:

; 2915 : 
; 2916 : 			case CItemData::WEAPON_BELL:
; 2917 : 				SetMotionMode(CRaceMotionData::MODE_HORSE_BELL); // Only Shaman

  0016c	6a 0f		 push	 15			; 0000000fH
  0016e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00171	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2918 : 				break;

  00176	eb 16		 jmp	 SHORT $LN2@RefreshSta
$LN26@RefreshSta:

; 2919 : 
; 2920 : 			case CItemData::WEAPON_BOW:
; 2921 : 				SetMotionMode(CRaceMotionData::MODE_HORSE_BOW); // Only Shaman

  00178	6a 0d		 push	 13			; 0000000dH
  0017a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017d	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2922 : 				break;

  00182	eb 0a		 jmp	 SHORT $LN2@RefreshSta
$LN27@RefreshSta:

; 2923 : 
; 2924 : 			default:
; 2925 : 				SetMotionMode(CRaceMotionData::MODE_HORSE);

  00184	6a 09		 push	 9
  00186	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00189	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode
$LN2@RefreshSta:

; 2926 : 				break;
; 2927 : 		}
; 2928 : 	}

  0018e	eb 7e		 jmp	 SHORT $LN4@RefreshSta
$LN19@RefreshSta:

; 2929 : 	else
; 2930 : 	{
; 2931 : 		switch (bySubType)

  00190	8a 45 ff	 mov	 al, BYTE PTR _bySubType$[ebp]
  00193	88 45 f0	 mov	 BYTE PTR tv174[ebp], al
  00196	80 7d f0 00	 cmp	 BYTE PTR tv174[ebp], 0
  0019a	74 20		 je	 SHORT $LN28@RefreshSta
  0019c	80 7d f0 01	 cmp	 BYTE PTR tv174[ebp], 1
  001a0	74 32		 je	 SHORT $LN30@RefreshSta
  001a2	80 7d f0 02	 cmp	 BYTE PTR tv174[ebp], 2
  001a6	74 38		 je	 SHORT $LN31@RefreshSta
  001a8	80 7d f0 03	 cmp	 BYTE PTR tv174[ebp], 3
  001ac	74 1a		 je	 SHORT $LN29@RefreshSta
  001ae	80 7d f0 04	 cmp	 BYTE PTR tv174[ebp], 4
  001b2	74 44		 je	 SHORT $LN33@RefreshSta
  001b4	80 7d f0 05	 cmp	 BYTE PTR tv174[ebp], 5
  001b8	74 32		 je	 SHORT $LN32@RefreshSta
  001ba	eb 48		 jmp	 SHORT $LN34@RefreshSta
$LN28@RefreshSta:

; 2932 : 		{
; 2933 : 			case CItemData::WEAPON_SWORD:
; 2934 : 				SetMotionMode(CRaceMotionData::MODE_ONEHAND_SWORD);

  001bc	6a 02		 push	 2
  001be	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c1	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2935 : 				break;

  001c6	eb 46		 jmp	 SHORT $LN4@RefreshSta
$LN29@RefreshSta:

; 2936 : 
; 2937 : 			case CItemData::WEAPON_TWO_HANDED:
; 2938 : 				SetMotionMode(CRaceMotionData::MODE_TWOHAND_SWORD); // Only Warrior

  001c8	6a 03		 push	 3
  001ca	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cd	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2939 : 				break;

  001d2	eb 3a		 jmp	 SHORT $LN4@RefreshSta
$LN30@RefreshSta:

; 2940 : 
; 2941 : 			case CItemData::WEAPON_DAGGER:
; 2942 : 				SetMotionMode(CRaceMotionData::MODE_DUALHAND_SWORD); // Only Assassin

  001d4	6a 04		 push	 4
  001d6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d9	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2943 : 				break;

  001de	eb 2e		 jmp	 SHORT $LN4@RefreshSta
$LN31@RefreshSta:

; 2944 : 
; 2945 : 			case CItemData::WEAPON_BOW:
; 2946 : 				SetMotionMode(CRaceMotionData::MODE_BOW); // Only Assassin

  001e0	6a 05		 push	 5
  001e2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e5	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2947 : 				break;

  001ea	eb 22		 jmp	 SHORT $LN4@RefreshSta
$LN32@RefreshSta:

; 2948 : 
; 2949 : 			case CItemData::WEAPON_FAN:
; 2950 : 				SetMotionMode(CRaceMotionData::MODE_FAN); // Only Shaman

  001ec	6a 06		 push	 6
  001ee	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f1	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2951 : 				break;

  001f6	eb 16		 jmp	 SHORT $LN4@RefreshSta
$LN33@RefreshSta:

; 2952 : 
; 2953 : 			case CItemData::WEAPON_BELL:
; 2954 : 				SetMotionMode(CRaceMotionData::MODE_BELL); // Only Shaman

  001f8	6a 07		 push	 7
  001fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001fd	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 2955 : 				break;

  00202	eb 0a		 jmp	 SHORT $LN4@RefreshSta
$LN34@RefreshSta:

; 2956 : 
; 2957 : 			case CItemData::WEAPON_ARROW:
; 2958 : 			default:
; 2959 : 				SetMotionMode(CRaceMotionData::MODE_GENERAL);

  00204	6a 01		 push	 1
  00206	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode
$LN4@RefreshSta:

; 2960 : 				break;
; 2961 : 		}
; 2962 : 	}
; 2963 : 
; 2964 : 	if (isLoop)

  0020e	0f b6 45 0c	 movzx	 eax, BYTE PTR _isLoop$[ebp]
  00212	85 c0		 test	 eax, eax
  00214	74 21		 je	 SHORT $LN35@RefreshSta

; 2965 : 		m_GraphicThingInstance.InterceptLoopMotion(dwMotIndex);

  00216	51		 push	 ecx
  00217	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  0021f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00224	ff 75 08	 push	 DWORD PTR _dwMotIndex$[ebp]
  00227	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00230	e8 00 00 00 00	 call	 ?InterceptLoopMotion@CActorInstance@@QAE_NKM@Z ; CActorInstance::InterceptLoopMotion
  00235	eb 2f		 jmp	 SHORT $LN36@RefreshSta
$LN35@RefreshSta:

; 2966 : 	else
; 2967 : 		m_GraphicThingInstance.InterceptOnceMotion(dwMotIndex);

  00237	51		 push	 ecx
  00238	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00240	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00245	6a 00		 push	 0
  00247	51		 push	 ecx
  00248	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00250	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00255	ff 75 08	 push	 DWORD PTR _dwMotIndex$[ebp]
  00258	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025b	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00261	e8 00 00 00 00	 call	 ?InterceptOnceMotion@CActorInstance@@QAE_NKMIM@Z ; CActorInstance::InterceptOnceMotion
$LN36@RefreshSta:

; 2968 : 
; 2969 : 	RefreshActorInstance();

  00266	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00269	e8 00 00 00 00	 call	 ?RefreshActorInstance@CInstanceBase@@IAEXXZ ; CInstanceBase::RefreshActorInstance

; 2970 : }

  0026e	c9		 leave
  0026f	c2 08 00	 ret	 8
?RefreshState@CInstanceBase@@IAEXK_N@Z ENDP		; CInstanceBase::RefreshState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetLocalTime@CInstanceBase@@IAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetLocalTime@CInstanceBase@@IAEMXZ PROC		; CInstanceBase::GetLocalTime, COMDAT
; _this$ = ecx

; 1164 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1165 : 	return m_GraphicThingInstance.GetLocalTime();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?GetLocalTime@CGraphicThingInstance@@QAEMXZ ; CGraphicThingInstance::GetLocalTime

; 1166 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?GetLocalTime@CInstanceBase@@IAEMXZ ENDP		; CInstanceBase::GetLocalTime
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?StateProcess@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_uVID$1 = -36						; size = 4
__Xx$ = -32						; size = 4
_fz$ = -28						; size = 4
_fy$ = -24						; size = 4
_fx$ = -20						; size = 4
$T2 = -16						; size = 4
_dwDstChkTime$3 = -12					; size = 4
_dwCurChkTime$4 = -8					; size = 4
$T5 = -4						; size = 4
tv732 = 0						; size = 4
_uTargetVID$6 = 4					; size = 4
_this$ = 8						; size = 4
tv426 = 12						; size = 4
_eFunc$7 = 16						; size = 4
_fDirLen$8 = 20						; size = 4
tv165 = 24						; size = 4
$T9 = 31						; size = 1
_uArg$10 = 32						; size = 4
_fRotDst$11 = 36					; size = 4
_this$ = 40						; size = 4
_kCmdTop$12 = 44					; size = 36
_kPPosDir$13 = 80					; size = 12
_kPPosCur$14 = 92					; size = 12
_kPPosDst$15 = 104					; size = 12
__$ArrayPad$ = 116					; size = 4
?StateProcess@CInstanceBase@@IAEXXZ PROC		; CInstanceBase::StateProcess, COMDAT
; _this$ = ecx

; 1278 : {	

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 74	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	56		 push	 esi
  00016	57		 push	 edi
  00017	89 4d 28	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@StateProce:

; 1279 : 	while (1)

  0001a	33 c0		 xor	 eax, eax
  0001c	40		 inc	 eax
  0001d	0f 84 ed 07 00
	00		 je	 $LN3@StateProce
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1200 :         return _Mypair._Myval2._Mysize == 0;

  00023	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 b8 94 06 00
	00 00		 cmp	 DWORD PTR [eax+1684], 0
  0002d	75 09		 jne	 SHORT $LN49@StateProce
  0002f	c7 45 0c 01 00
	00 00		 mov	 DWORD PTR tv426[ebp], 1
  00036	eb 04		 jmp	 SHORT $LN50@StateProce
$LN49@StateProce:
  00038	83 65 0c 00	 and	 DWORD PTR tv426[ebp], 0
$LN50@StateProce:
  0003c	8a 45 0c	 mov	 al, BYTE PTR tv426[ebp]
  0003f	88 45 1f	 mov	 BYTE PTR $T9[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1281 : 		if (m_kQue_kCmdNew.empty())

  00042	0f b6 45 1f	 movzx	 eax, BYTE PTR $T9[ebp]
  00046	85 c0		 test	 eax, eax
  00048	74 05		 je	 SHORT $LN6@StateProce

; 1282 : 			return;	

  0004a	e9 c1 07 00 00	 jmp	 $LN1@StateProce
$LN6@StateProce:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1212 :         return _Mypair._Myval2._Myhead->_Next->_Myval;

  0004f	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00052	8b 80 90 06 00
	00		 mov	 eax, DWORD PTR [eax+1680]
  00058	8b 00		 mov	 eax, DWORD PTR [eax]
  0005a	83 c0 08	 add	 eax, 8
  0005d	89 45 fc	 mov	 DWORD PTR $T5[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1284 : 		DWORD dwDstChkTime = m_kQue_kCmdNew.front().m_dwChkTime;

  00060	8b 45 fc	 mov	 eax, DWORD PTR $T5[ebp]
  00063	8b 00		 mov	 eax, DWORD PTR [eax]
  00065	89 45 f4	 mov	 DWORD PTR _dwDstChkTime$3[ebp], eax

; 1285 : 		DWORD dwCurChkTime = ELTimer_GetServerFrameMSec();	

  00068	e8 00 00 00 00	 call	 ?ELTimer_GetServerFrameMSec@@YAKXZ ; ELTimer_GetServerFrameMSec
  0006d	89 45 f8	 mov	 DWORD PTR _dwCurChkTime$4[ebp], eax

; 1286 : 
; 1287 : 		if (dwCurChkTime < dwDstChkTime)

  00070	8b 45 f8	 mov	 eax, DWORD PTR _dwCurChkTime$4[ebp]
  00073	3b 45 f4	 cmp	 eax, DWORD PTR _dwDstChkTime$3[ebp]
  00076	73 05		 jae	 SHORT $LN7@StateProce

; 1288 : 			return;

  00078	e9 93 07 00 00	 jmp	 $LN1@StateProce
$LN7@StateProce:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1212 :         return _Mypair._Myval2._Myhead->_Next->_Myval;

  0007d	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00080	8b 80 90 06 00
	00		 mov	 eax, DWORD PTR [eax+1680]
  00086	8b 00		 mov	 eax, DWORD PTR [eax]
  00088	83 c0 08	 add	 eax, 8
  0008b	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1290 : 		SCommand kCmdTop = m_kQue_kCmdNew.front();

  0008e	6a 09		 push	 9
  00090	59		 pop	 ecx
  00091	8b 75 f0	 mov	 esi, DWORD PTR $T2[ebp]
  00094	8d 7d 2c	 lea	 edi, DWORD PTR _kCmdTop$12[ebp]
  00097	f3 a5		 rep movsd

; 1291 : 		m_kQue_kCmdNew.pop_front();	

  00099	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	05 90 06 00 00	 add	 eax, 1680		; 00000690H
  000a1	89 45 08	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1248 :         _Unchecked_erase(_Mypair._Myval2._Myhead->_Next);

  000a4	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	ff 30		 push	 DWORD PTR [eax]
  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?_Unchecked_erase@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@2@QAU32@@Z ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Unchecked_erase
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1293 : 		TPixelPosition kPPosDst = kCmdTop.m_kPPosDst;

  000b3	8d 75 44	 lea	 esi, DWORD PTR _kCmdTop$12[ebp+24]
  000b6	8d 7d 68	 lea	 edi, DWORD PTR _kPPosDst$15[ebp]
  000b9	a5		 movsd
  000ba	a5		 movsd
  000bb	a5		 movsd

; 1294 : 		//DWORD dwCmdTime = kCmdTop.m_dwCmdTime;	
; 1295 : 		FLOAT fRotDst = kCmdTop.m_fDstRot;

  000bc	f3 0f 10 45 34	 movss	 xmm0, DWORD PTR _kCmdTop$12[ebp+8]
  000c1	f3 0f 11 45 24	 movss	 DWORD PTR _fRotDst$11[ebp], xmm0

; 1296 : 		UINT eFunc = kCmdTop.m_eFunc;

  000c6	8b 45 38	 mov	 eax, DWORD PTR _kCmdTop$12[ebp+12]
  000c9	89 45 10	 mov	 DWORD PTR _eFunc$7[ebp], eax

; 1297 : 		UINT uArg = kCmdTop.m_uArg;

  000cc	8b 45 3c	 mov	 eax, DWORD PTR _kCmdTop$12[ebp+16]
  000cf	89 45 20	 mov	 DWORD PTR _uArg$10[ebp], eax

; 1298 : 		UINT uVID = GetVirtualID();	

  000d2	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  000da	89 45 dc	 mov	 DWORD PTR _uVID$1[ebp], eax

; 1299 : 		UINT uTargetVID = kCmdTop.m_uTargetVID;

  000dd	8b 45 40	 mov	 eax, DWORD PTR _kCmdTop$12[ebp+20]
  000e0	89 45 04	 mov	 DWORD PTR _uTargetVID$6[ebp], eax

; 1300 : 
; 1301 : 		TPixelPosition kPPosCur;
; 1302 : 		NEW_GetPixelPosition(&kPPosCur);

  000e3	8d 45 5c	 lea	 eax, DWORD PTR _kPPosCur$14[ebp]
  000e6	50		 push	 eax
  000e7	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ef	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp]
  000f4	f3 0f 5c 45 5c	 subss	 xmm0, DWORD PTR _kPPosCur$14[ebp]
  000f9	f3 0f 11 45 ec	 movss	 DWORD PTR _fx$[ebp], xmm0
  000fe	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp+4]
  00103	f3 0f 5c 45 60	 subss	 xmm0, DWORD PTR _kPPosCur$14[ebp+4]
  00108	f3 0f 11 45 e8	 movss	 DWORD PTR _fy$[ebp], xmm0
  0010d	f3 0f 10 45 70	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp+8]
  00112	f3 0f 5c 45 64	 subss	 xmm0, DWORD PTR _kPPosCur$14[ebp+8]
  00117	f3 0f 11 45 e4	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0011c	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00121	f3 0f 11 45 50	 movss	 DWORD PTR _kPPosDir$13[ebp], xmm0

; 181  :     y = fy;

  00126	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0012b	f3 0f 11 45 54	 movss	 DWORD PTR _kPPosDir$13[ebp+4], xmm0

; 182  :     z = fz;

  00130	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00135	f3 0f 11 45 58	 movss	 DWORD PTR _kPPosDir$13[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1314 : 		float fDirLen = (float)sqrt(kPPosDir.x * kPPosDir.x + kPPosDir.y * kPPosDir.y);

  0013a	f3 0f 10 45 54	 movss	 xmm0, DWORD PTR _kPPosDir$13[ebp+4]
  0013f	f3 0f 59 45 54	 mulss	 xmm0, DWORD PTR _kPPosDir$13[ebp+4]
  00144	f3 0f 10 4d 50	 movss	 xmm1, DWORD PTR _kPPosDir$13[ebp]
  00149	f3 0f 59 4d 50	 mulss	 xmm1, DWORD PTR _kPPosDir$13[ebp]
  0014e	f3 0f 58 c8	 addss	 xmm1, xmm0
  00152	f3 0f 11 4d e0	 movss	 DWORD PTR __Xx$[ebp], xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00157	f3 0f 5a 45 e0	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  0015c	51		 push	 ecx
  0015d	51		 push	 ecx
  0015e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00163	e8 00 00 00 00	 call	 _sqrt
  00168	59		 pop	 ecx
  00169	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 231  :     return _CSTD sqrtf(_Xx);

  0016a	d9 5d 14	 fstp	 DWORD PTR _fDirLen$8[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1318 : 		if (!__CanProcessNetworkStatePacket())

  0016d	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00170	e8 00 00 00 00	 call	 ?__CanProcessNetworkStatePacket@CInstanceBase@@IAEHXZ ; CInstanceBase::__CanProcessNetworkStatePacket
  00175	85 c0		 test	 eax, eax
  00177	75 35		 jne	 SHORT $LN8@StateProce

; 1319 : 		{
; 1320 : 			Lognf(0, "vid=%d      IsDead=%d, IsKnockDown=%d", uVID, m_GraphicThingInstance.IsDead(), m_GraphicThingInstance.IsKnockDown());

  00179	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00182	e8 00 00 00 00	 call	 ?IsKnockDown@CActorInstance@@QAEHXZ ; CActorInstance::IsKnockDown
  00187	50		 push	 eax
  00188	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0018b	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00191	e8 00 00 00 00	 call	 ?IsDead@CActorInstance@@QAEHXZ ; CActorInstance::IsDead
  00196	50		 push	 eax
  00197	ff 75 dc	 push	 DWORD PTR _uVID$1[ebp]
  0019a	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@EIDAANLK@vid?$DN?$CFd?5?$LP?r?A?w?$MA?O?5?$LM?v?5?$LO?x?$LE?B?5?$LL?s?E?B?$LG?s?5?$LN?$LK@
  0019f	6a 00		 push	 0
  001a1	e8 00 00 00 00	 call	 ?Lognf@@YAXIPBDZZ	; Lognf
  001a6	83 c4 14	 add	 esp, 20			; 00000014H

; 1321 : 			return;

  001a9	e9 62 06 00 00	 jmp	 $LN1@StateProce
$LN8@StateProce:

; 1322 : 		}
; 1323 : 
; 1324 : 		if (!__IsEnableTCPProcess(eFunc))

  001ae	ff 75 10	 push	 DWORD PTR _eFunc$7[ebp]
  001b1	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  001b4	e8 00 00 00 00	 call	 ?__IsEnableTCPProcess@CInstanceBase@@IAEHI@Z ; CInstanceBase::__IsEnableTCPProcess
  001b9	85 c0		 test	 eax, eax
  001bb	75 05		 jne	 SHORT $LN9@StateProce

; 1325 : 		{
; 1326 : 			return;

  001bd	e9 4e 06 00 00	 jmp	 $LN1@StateProce
$LN9@StateProce:

; 1327 : 		}
; 1328 : 
; 1329 : 		switch (eFunc)

  001c2	8b 45 10	 mov	 eax, DWORD PTR _eFunc$7[ebp]
  001c5	89 45 18	 mov	 DWORD PTR tv165[ebp], eax
  001c8	83 7d 18 00	 cmp	 DWORD PTR tv165[ebp], 0
  001cc	74 37		 je	 SHORT $LN10@StateProce
  001ce	83 7d 18 01	 cmp	 DWORD PTR tv165[ebp], 1
  001d2	0f 84 0a 01 00
	00		 je	 $LN15@StateProce
  001d8	83 7d 18 02	 cmp	 DWORD PTR tv165[ebp], 2
  001dc	0f 84 3c 02 00
	00		 je	 $LN23@StateProce
  001e2	83 7d 18 03	 cmp	 DWORD PTR tv165[ebp], 3
  001e6	0f 84 56 01 00
	00		 je	 $LN18@StateProce
  001ec	83 7d 18 04	 cmp	 DWORD PTR tv165[ebp], 4
  001f0	0f 84 16 03 00
	00		 je	 $LN28@StateProce
  001f6	83 7d 18 05	 cmp	 DWORD PTR tv165[ebp], 5
  001fa	0f 84 29 04 00
	00		 je	 $LN33@StateProce
  00200	e9 e0 04 00 00	 jmp	 $LN38@StateProce
$LN10@StateProce:

; 1330 : 		{
; 1331 : 			case FUNC_WAIT:
; 1332 : 			{
; 1333 : 				//Tracenf("%s (%f, %f) -> (%f, %f)  %f", GetNameString(), kPPosCur.x, kPPosCur.y, kPPosDst.x, kPPosDst.y, fDirLen);
; 1334 : 				if (fDirLen > 1.0f)

  00205	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fDirLen$8[ebp]
  0020a	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00211	76 5a		 jbe	 SHORT $LN11@StateProce

; 1335 : 				{
; 1336 : 					//NEW_GetSrcPixelPositionRef() = kPPosCur;
; 1337 : 					//NEW_GetDstPixelPositionRef() = kPPosDst;
; 1338 : 					NEW_SetSrcPixelPosition(kPPosCur);

  00213	8d 45 5c	 lea	 eax, DWORD PTR _kPPosCur$14[ebp]
  00216	50		 push	 eax
  00217	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0021a	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition

; 1339 : 					NEW_SetDstPixelPosition(kPPosDst);

  0021f	8d 45 68	 lea	 eax, DWORD PTR _kPPosDst$15[ebp]
  00222	50		 push	 eax
  00223	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00226	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition

; 1340 : 
; 1341 : 					__EnableSkipCollision();

  0022b	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	e8 00 00 00 00	 call	 ?__EnableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableSkipCollision

; 1342 : 
; 1343 : 					m_fDstRot = fRotDst;

  00233	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00236	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  0023b	f3 0f 11 80 c0
	01 00 00	 movss	 DWORD PTR [eax+448], xmm0

; 1344 : 					m_isGoing = TRUE;

  00243	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00246	c6 80 88 01 00
	00 01		 mov	 BYTE PTR [eax+392], 1

; 1345 : 
; 1346 : 					m_kMovAfterFunc.eFunc = FUNC_WAIT;

  0024d	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00250	83 a0 a8 01 00
	00 00		 and	 DWORD PTR [eax+424], 0

; 1347 : 
; 1348 : 					if (!IsWalking())

  00257	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0025a	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  0025f	85 c0		 test	 eax, eax
  00261	75 08		 jne	 SHORT $LN13@StateProce

; 1349 : 						StartWalking();

  00263	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00266	e8 00 00 00 00	 call	 ?StartWalking@CInstanceBase@@IAEXXZ ; CInstanceBase::StartWalking
$LN13@StateProce:

; 1350 : 
; 1351 : 					//Tracen("");
; 1352 : 				}

  0026b	eb 70		 jmp	 SHORT $LN12@StateProce
$LN11@StateProce:

; 1353 : 				else
; 1354 : 				{
; 1355 : 					//Tracen(" ");
; 1356 : 
; 1357 : 					m_isGoing = FALSE;

  0026d	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00270	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1358 : 
; 1359 : 					if (!IsWaiting())

  00277	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0027a	e8 00 00 00 00	 call	 ?IsWaiting@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWaiting
  0027f	85 c0		 test	 eax, eax
  00281	75 16		 jne	 SHORT $LN14@StateProce

; 1360 : 						EndWalking();

  00283	51		 push	 ecx
  00284	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  0028c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00291	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00294	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN14@StateProce:

; 1361 : 
; 1362 : 					SCRIPT_SetPixelPosition(kPPosDst.x, kPPosDst.y);

  00299	51		 push	 ecx
  0029a	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp+4]
  0029f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002a4	51		 push	 ecx
  002a5	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp]
  002aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002af	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  002b2	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1363 : 					SetAdvancingRotation(fRotDst);

  002b7	51		 push	 ecx
  002b8	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  002bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002c2	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  002c5	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1364 : 					SetRotation(fRotDst);

  002ca	51		 push	 ecx
  002cb	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  002d0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002d5	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  002d8	e8 00 00 00 00	 call	 ?SetRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetRotation
$LN12@StateProce:

; 1365 : 				}
; 1366 : 				break;

  002dd	e9 29 05 00 00	 jmp	 $LN4@StateProce
$LN15@StateProce:

; 1367 : 			}
; 1368 : 
; 1369 : 			case FUNC_MOVE:
; 1370 : 			{
; 1371 : 				//NEW_GetSrcPixelPositionRef() = kPPosCur;
; 1372 : 				//NEW_GetDstPixelPositionRef() = kPPosDst;
; 1373 : 				NEW_SetSrcPixelPosition(kPPosCur);

  002e2	8d 45 5c	 lea	 eax, DWORD PTR _kPPosCur$14[ebp]
  002e5	50		 push	 eax
  002e6	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  002e9	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition

; 1374 : 				NEW_SetDstPixelPosition(kPPosDst);

  002ee	8d 45 68	 lea	 eax, DWORD PTR _kPPosDst$15[ebp]
  002f1	50		 push	 eax
  002f2	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  002f5	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition

; 1375 : 				m_fDstRot = fRotDst;

  002fa	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  002fd	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  00302	f3 0f 11 80 c0
	01 00 00	 movss	 DWORD PTR [eax+448], xmm0

; 1376 : 				m_isGoing = TRUE;

  0030a	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0030d	c6 80 88 01 00
	00 01		 mov	 BYTE PTR [eax+392], 1

; 1377 : 				__EnableSkipCollision();

  00314	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00317	e8 00 00 00 00	 call	 ?__EnableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableSkipCollision

; 1378 : 				//m_isSyncMov = TRUE;
; 1379 : 
; 1380 : 				m_kMovAfterFunc.eFunc = FUNC_MOVE;

  0031c	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0031f	c7 80 a8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+424], 1

; 1381 : 
; 1382 : 				if (!IsWalking())

  00329	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0032c	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  00331	85 c0		 test	 eax, eax
  00333	75 08		 jne	 SHORT $LN16@StateProce

; 1383 : 				{
; 1384 : 					//Tracen("    ");
; 1385 : 					StartWalking();

  00335	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00338	e8 00 00 00 00	 call	 ?StartWalking@CInstanceBase@@IAEXXZ ; CInstanceBase::StartWalking
$LN16@StateProce:

; 1386 : 				}
; 1387 : 				else
; 1388 : 				{
; 1389 : 					//Tracen("  ");
; 1390 : 				}
; 1391 : 				break;

  0033d	e9 c9 04 00 00	 jmp	 $LN4@StateProce
$LN18@StateProce:

; 1392 : 			}
; 1393 : 
; 1394 : 			case FUNC_COMBO:
; 1395 : 			{
; 1396 : 				if (fDirLen >= 50.0f)

  00342	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fDirLen$8[ebp]
  00347	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@42480000
  0034e	72 69		 jb	 SHORT $LN19@StateProce

; 1397 : 				{
; 1398 : 					NEW_SetSrcPixelPosition(kPPosCur);

  00350	8d 45 5c	 lea	 eax, DWORD PTR _kPPosCur$14[ebp]
  00353	50		 push	 eax
  00354	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00357	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition

; 1399 : 					NEW_SetDstPixelPosition(kPPosDst);

  0035c	8d 45 68	 lea	 eax, DWORD PTR _kPPosDst$15[ebp]
  0035f	50		 push	 eax
  00360	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00363	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition

; 1400 : 					m_fDstRot=fRotDst;

  00368	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0036b	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  00370	f3 0f 11 80 c0
	01 00 00	 movss	 DWORD PTR [eax+448], xmm0

; 1401 : 					m_isGoing = TRUE;

  00378	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0037b	c6 80 88 01 00
	00 01		 mov	 BYTE PTR [eax+392], 1

; 1402 : 					__EnableSkipCollision();

  00382	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00385	e8 00 00 00 00	 call	 ?__EnableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableSkipCollision

; 1403 : 
; 1404 : 					m_kMovAfterFunc.eFunc = FUNC_COMBO;

  0038a	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0038d	c7 80 a8 01 00
	00 03 00 00 00	 mov	 DWORD PTR [eax+424], 3

; 1405 : 					m_kMovAfterFunc.uArg = uArg;

  00397	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0039a	8b 4d 20	 mov	 ecx, DWORD PTR _uArg$10[ebp]
  0039d	89 88 ac 01 00
	00		 mov	 DWORD PTR [eax+428], ecx

; 1406 : 
; 1407 : 					if (!IsWalking())

  003a3	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  003a6	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  003ab	85 c0		 test	 eax, eax
  003ad	75 08		 jne	 SHORT $LN21@StateProce

; 1408 : 						StartWalking();

  003af	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  003b2	e8 00 00 00 00	 call	 ?StartWalking@CInstanceBase@@IAEXXZ ; CInstanceBase::StartWalking
$LN21@StateProce:

; 1409 : 				}

  003b7	eb 60		 jmp	 SHORT $LN20@StateProce
$LN19@StateProce:

; 1410 : 				else
; 1411 : 				{
; 1412 : 					//Tracen("  ");
; 1413 : 
; 1414 : 					m_isGoing = FALSE;

  003b9	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  003bc	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1415 : 
; 1416 : 					if (IsWalking())

  003c3	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  003c6	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  003cb	85 c0		 test	 eax, eax
  003cd	74 16		 je	 SHORT $LN22@StateProce

; 1417 : 						EndWalking();

  003cf	51		 push	 ecx
  003d0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  003d8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003dd	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  003e0	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN22@StateProce:

; 1418 : 
; 1419 : 					SCRIPT_SetPixelPosition(kPPosDst.x, kPPosDst.y);

  003e5	51		 push	 ecx
  003e6	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp+4]
  003eb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003f0	51		 push	 ecx
  003f1	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp]
  003f6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003fb	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  003fe	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1420 : 					RunComboAttack(fRotDst, uArg);

  00403	ff 75 20	 push	 DWORD PTR _uArg$10[ebp]
  00406	51		 push	 ecx
  00407	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  0040c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00411	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00414	e8 00 00 00 00	 call	 ?RunComboAttack@CInstanceBase@@QAEXMK@Z ; CInstanceBase::RunComboAttack
$LN20@StateProce:

; 1421 : 				}
; 1422 : 				break;

  00419	e9 ed 03 00 00	 jmp	 $LN4@StateProce
$LN23@StateProce:

; 1423 : 			}
; 1424 : 
; 1425 : 			case FUNC_ATTACK:
; 1426 : 			{
; 1427 : 				if (fDirLen>=50.0f)

  0041e	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fDirLen$8[ebp]
  00423	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@42480000
  0042a	72 5d		 jb	 SHORT $LN24@StateProce

; 1428 : 				{
; 1429 : 					//NEW_GetSrcPixelPositionRef() = kPPosCur;
; 1430 : 					//NEW_GetDstPixelPositionRef() = kPPosDst;
; 1431 : 					NEW_SetSrcPixelPosition(kPPosCur);

  0042c	8d 45 5c	 lea	 eax, DWORD PTR _kPPosCur$14[ebp]
  0042f	50		 push	 eax
  00430	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00433	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition

; 1432 : 					NEW_SetDstPixelPosition(kPPosDst);

  00438	8d 45 68	 lea	 eax, DWORD PTR _kPPosDst$15[ebp]
  0043b	50		 push	 eax
  0043c	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0043f	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition

; 1433 : 					m_fDstRot = fRotDst;

  00444	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00447	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  0044c	f3 0f 11 80 c0
	01 00 00	 movss	 DWORD PTR [eax+448], xmm0

; 1434 : 					m_isGoing = TRUE;

  00454	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00457	c6 80 88 01 00
	00 01		 mov	 BYTE PTR [eax+392], 1

; 1435 : 					__EnableSkipCollision();

  0045e	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00461	e8 00 00 00 00	 call	 ?__EnableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableSkipCollision

; 1436 : 					//m_isSyncMov = TRUE;
; 1437 : 
; 1438 : 					m_kMovAfterFunc.eFunc = FUNC_ATTACK;

  00466	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00469	c7 80 a8 01 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+424], 2

; 1439 : 
; 1440 : 					if (!IsWalking())

  00473	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00476	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  0047b	85 c0		 test	 eax, eax
  0047d	75 08		 jne	 SHORT $LN26@StateProce

; 1441 : 						StartWalking();

  0047f	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00482	e8 00 00 00 00	 call	 ?StartWalking@CInstanceBase@@IAEXXZ ; CInstanceBase::StartWalking
$LN26@StateProce:

; 1442 : 
; 1443 : 					//Tracen("    ");
; 1444 : 				}

  00487	eb 7e		 jmp	 SHORT $LN25@StateProce
$LN24@StateProce:

; 1445 : 				else
; 1446 : 				{
; 1447 : 					//Tracen("  ");
; 1448 : 
; 1449 : 					m_isGoing = FALSE;

  00489	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0048c	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1450 : 
; 1451 : 					if (IsWalking())

  00493	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00496	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  0049b	85 c0		 test	 eax, eax
  0049d	74 16		 je	 SHORT $LN27@StateProce

; 1452 : 						EndWalking();

  0049f	51		 push	 ecx
  004a0	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  004a8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ad	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  004b0	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN27@StateProce:

; 1453 : 
; 1454 : 					SCRIPT_SetPixelPosition(kPPosDst.x, kPPosDst.y);

  004b5	51		 push	 ecx
  004b6	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp+4]
  004bb	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004c0	51		 push	 ecx
  004c1	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp]
  004c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004cb	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  004ce	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1455 : 					BlendRotation(fRotDst);

  004d3	51		 push	 ecx
  004d4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  004dc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004e1	51		 push	 ecx
  004e2	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  004e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ec	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  004ef	e8 00 00 00 00	 call	 ?BlendRotation@CInstanceBase@@QAEXMM@Z ; CInstanceBase::BlendRotation

; 1456 : 
; 1457 : 					RunNormalAttack(fRotDst);

  004f4	51		 push	 ecx
  004f5	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  004fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  004ff	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00502	e8 00 00 00 00	 call	 ?RunNormalAttack@CInstanceBase@@QAEXM@Z ; CInstanceBase::RunNormalAttack
$LN25@StateProce:

; 1458 : 
; 1459 : 					//Tracen("   ");
; 1460 : 				}
; 1461 : 				break;

  00507	e9 ff 02 00 00	 jmp	 $LN4@StateProce
$LN28@StateProce:

; 1462 : 			}
; 1463 : 
; 1464 : 			case FUNC_MOB_SKILL:
; 1465 : 			{
; 1466 : 				if (fDirLen >= 50.0f)

  0050c	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fDirLen$8[ebp]
  00511	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@42480000
  00518	72 6c		 jb	 SHORT $LN29@StateProce

; 1467 : 				{
; 1468 : 					NEW_SetSrcPixelPosition(kPPosCur);

  0051a	8d 45 5c	 lea	 eax, DWORD PTR _kPPosCur$14[ebp]
  0051d	50		 push	 eax
  0051e	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00521	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition

; 1469 : 					NEW_SetDstPixelPosition(kPPosDst);

  00526	8d 45 68	 lea	 eax, DWORD PTR _kPPosDst$15[ebp]
  00529	50		 push	 eax
  0052a	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0052d	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition

; 1470 : 					m_fDstRot = fRotDst;

  00532	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00535	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  0053a	f3 0f 11 80 c0
	01 00 00	 movss	 DWORD PTR [eax+448], xmm0

; 1471 : 					m_isGoing = TRUE;

  00542	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00545	c6 80 88 01 00
	00 01		 mov	 BYTE PTR [eax+392], 1

; 1472 : 					__EnableSkipCollision();

  0054c	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0054f	e8 00 00 00 00	 call	 ?__EnableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableSkipCollision

; 1473 : 
; 1474 : 					m_kMovAfterFunc.eFunc = FUNC_MOB_SKILL;

  00554	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00557	c7 80 a8 01 00
	00 04 00 00 00	 mov	 DWORD PTR [eax+424], 4

; 1475 : 					m_kMovAfterFunc.uArg = uArg;

  00561	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00564	8b 4d 20	 mov	 ecx, DWORD PTR _uArg$10[ebp]
  00567	89 88 ac 01 00
	00		 mov	 DWORD PTR [eax+428], ecx

; 1476 : 
; 1477 : 					if (!IsWalking())

  0056d	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00570	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  00575	85 c0		 test	 eax, eax
  00577	75 08		 jne	 SHORT $LN31@StateProce

; 1478 : 						StartWalking();

  00579	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0057c	e8 00 00 00 00	 call	 ?StartWalking@CInstanceBase@@IAEXXZ ; CInstanceBase::StartWalking
$LN31@StateProce:

; 1479 : 				}

  00581	e9 9e 00 00 00	 jmp	 $LN30@StateProce
$LN29@StateProce:

; 1480 : 				else
; 1481 : 				{
; 1482 : 					m_isGoing = FALSE;

  00586	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00589	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1483 : 
; 1484 : 					if (IsWalking())

  00590	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00593	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  00598	85 c0		 test	 eax, eax
  0059a	74 16		 je	 SHORT $LN32@StateProce

; 1485 : 						EndWalking();

  0059c	51		 push	 ecx
  0059d	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  005a5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005aa	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  005ad	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN32@StateProce:

; 1486 : 
; 1487 : 					SCRIPT_SetPixelPosition(kPPosDst.x, kPPosDst.y);

  005b2	51		 push	 ecx
  005b3	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp+4]
  005b8	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005bd	51		 push	 ecx
  005be	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp]
  005c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c8	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  005cb	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1488 : 					BlendRotation(fRotDst);

  005d0	51		 push	 ecx
  005d1	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  005d9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005de	51		 push	 ecx
  005df	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  005e4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005e9	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  005ec	e8 00 00 00 00	 call	 ?BlendRotation@CInstanceBase@@QAEXMM@Z ; CInstanceBase::BlendRotation

; 1489 : 
; 1490 : 					m_GraphicThingInstance.InterceptOnceMotion(CRaceMotionData::NAME_SPECIAL_1 + uArg);

  005f1	51		 push	 ecx
  005f2	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  005fa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005ff	6a 00		 push	 0
  00601	51		 push	 ecx
  00602	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  0060a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0060f	8b 45 20	 mov	 eax, DWORD PTR _uArg$10[ebp]
  00612	83 c0 21	 add	 eax, 33			; 00000021H
  00615	50		 push	 eax
  00616	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00619	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0061f	e8 00 00 00 00	 call	 ?InterceptOnceMotion@CActorInstance@@QAE_NKMIM@Z ; CActorInstance::InterceptOnceMotion
$LN30@StateProce:

; 1491 : 				}
; 1492 : 				break;

  00624	e9 e2 01 00 00	 jmp	 $LN4@StateProce
$LN33@StateProce:

; 1493 : 			}
; 1494 : 
; 1495 : 			case FUNC_EMOTION:
; 1496 : 			{
; 1497 : 				if (fDirLen>100.0f)

  00629	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fDirLen$8[ebp]
  0062e	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@42c80000
  00635	0f 86 93 00 00
	00		 jbe	 $LN34@StateProce

; 1498 : 				{
; 1499 : 					NEW_SetSrcPixelPosition(kPPosCur);

  0063b	8d 45 5c	 lea	 eax, DWORD PTR _kPPosCur$14[ebp]
  0063e	50		 push	 eax
  0063f	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00642	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition

; 1500 : 					NEW_SetDstPixelPosition(kPPosDst);

  00647	8d 45 68	 lea	 eax, DWORD PTR _kPPosDst$15[ebp]
  0064a	50		 push	 eax
  0064b	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0064e	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition

; 1501 : 					m_fDstRot = fRotDst;

  00653	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00656	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  0065b	f3 0f 11 80 c0
	01 00 00	 movss	 DWORD PTR [eax+448], xmm0

; 1502 : 					m_isGoing = TRUE;

  00663	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00666	c6 80 88 01 00
	00 01		 mov	 BYTE PTR [eax+392], 1

; 1503 : 
; 1504 : 					if (__IsMainInstance())

  0066d	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00670	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  00675	0f b6 c0	 movzx	 eax, al
  00678	85 c0		 test	 eax, eax
  0067a	74 08		 je	 SHORT $LN36@StateProce

; 1505 : 						__EnableSkipCollision();

  0067c	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  0067f	e8 00 00 00 00	 call	 ?__EnableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableSkipCollision
$LN36@StateProce:

; 1506 : 
; 1507 : 					m_kMovAfterFunc.eFunc = FUNC_EMOTION;

  00684	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00687	c7 80 a8 01 00
	00 05 00 00 00	 mov	 DWORD PTR [eax+424], 5

; 1508 : 					m_kMovAfterFunc.uArg = uArg;

  00691	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  00694	8b 4d 20	 mov	 ecx, DWORD PTR _uArg$10[ebp]
  00697	89 88 ac 01 00
	00		 mov	 DWORD PTR [eax+428], ecx

; 1509 : 					m_kMovAfterFunc.uArgExpanded = uTargetVID;

  0069d	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  006a0	8b 4d 04	 mov	 ecx, DWORD PTR _uTargetVID$6[ebp]
  006a3	89 88 b0 01 00
	00		 mov	 DWORD PTR [eax+432], ecx

; 1510 : 					m_kMovAfterFunc.kPosDst = kPPosDst;

  006a9	8b 7d 28	 mov	 edi, DWORD PTR _this$[ebp]
  006ac	81 c7 b4 01 00
	00		 add	 edi, 436		; 000001b4H
  006b2	8d 75 68	 lea	 esi, DWORD PTR _kPPosDst$15[ebp]
  006b5	a5		 movsd
  006b6	a5		 movsd
  006b7	a5		 movsd

; 1511 : 
; 1512 : 					if (!IsWalking())

  006b8	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  006bb	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  006c0	85 c0		 test	 eax, eax
  006c2	75 08		 jne	 SHORT $LN37@StateProce

; 1513 : 						StartWalking();

  006c4	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  006c7	e8 00 00 00 00	 call	 ?StartWalking@CInstanceBase@@IAEXXZ ; CInstanceBase::StartWalking
$LN37@StateProce:

; 1514 : 				}

  006cc	eb 12		 jmp	 SHORT $LN35@StateProce
$LN34@StateProce:

; 1515 : 				else
; 1516 : 				{
; 1517 : 					__ProcessFunctionEmotion(uArg, uTargetVID, kPPosDst);

  006ce	8d 45 68	 lea	 eax, DWORD PTR _kPPosDst$15[ebp]
  006d1	50		 push	 eax
  006d2	ff 75 04	 push	 DWORD PTR _uTargetVID$6[ebp]
  006d5	ff 75 20	 push	 DWORD PTR _uArg$10[ebp]
  006d8	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  006db	e8 00 00 00 00	 call	 ?__ProcessFunctionEmotion@CInstanceBase@@IAEXKKABUD3DXVECTOR3@@@Z ; CInstanceBase::__ProcessFunctionEmotion
$LN35@StateProce:

; 1518 : 				}
; 1519 : 				break;

  006e0	e9 26 01 00 00	 jmp	 $LN4@StateProce
$LN38@StateProce:

; 1520 : 			}
; 1521 : 
; 1522 : 			default:
; 1523 : 			{
; 1524 : 				if (eFunc & FUNC_SKILL)

  006e5	8b 45 10	 mov	 eax, DWORD PTR _eFunc$7[ebp]
  006e8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  006ed	0f 84 18 01 00
	00		 je	 $LN41@StateProce

; 1525 : 				{
; 1526 : 					if (fDirLen >= 50.0f)

  006f3	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _fDirLen$8[ebp]
  006f8	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@42480000
  006ff	72 6b		 jb	 SHORT $LN40@StateProce

; 1527 : 					{
; 1528 : 						//NEW_GetSrcPixelPositionRef() = kPPosCur;
; 1529 : 						//NEW_GetDstPixelPositionRef() = kPPosDst;
; 1530 : 						NEW_SetSrcPixelPosition(kPPosCur);

  00701	8d 45 5c	 lea	 eax, DWORD PTR _kPPosCur$14[ebp]
  00704	50		 push	 eax
  00705	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00708	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition

; 1531 : 						NEW_SetDstPixelPosition(kPPosDst);

  0070d	8d 45 68	 lea	 eax, DWORD PTR _kPPosDst$15[ebp]
  00710	50		 push	 eax
  00711	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00714	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition

; 1532 : 						m_fDstRot = fRotDst;

  00719	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0071c	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  00721	f3 0f 11 80 c0
	01 00 00	 movss	 DWORD PTR [eax+448], xmm0

; 1533 : 						m_isGoing = TRUE;

  00729	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0072c	c6 80 88 01 00
	00 01		 mov	 BYTE PTR [eax+392], 1

; 1534 : 						//m_isSyncMov = TRUE;
; 1535 : 						__EnableSkipCollision();

  00733	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00736	e8 00 00 00 00	 call	 ?__EnableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableSkipCollision

; 1536 : 
; 1537 : 						m_kMovAfterFunc.eFunc = eFunc;

  0073b	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0073e	8b 4d 10	 mov	 ecx, DWORD PTR _eFunc$7[ebp]
  00741	89 88 a8 01 00
	00		 mov	 DWORD PTR [eax+424], ecx

; 1538 : 						m_kMovAfterFunc.uArg = uArg;

  00747	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0074a	8b 4d 20	 mov	 ecx, DWORD PTR _uArg$10[ebp]
  0074d	89 88 ac 01 00
	00		 mov	 DWORD PTR [eax+428], ecx

; 1539 : 
; 1540 : 						if (!IsWalking())

  00753	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00756	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  0075b	85 c0		 test	 eax, eax
  0075d	75 08		 jne	 SHORT $LN42@StateProce

; 1541 : 							StartWalking();

  0075f	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00762	e8 00 00 00 00	 call	 ?StartWalking@CInstanceBase@@IAEXXZ ; CInstanceBase::StartWalking
$LN42@StateProce:

; 1542 : 
; 1543 : 						//Tracen("    ");
; 1544 : 					}

  00767	e9 9f 00 00 00	 jmp	 $LN41@StateProce
$LN40@StateProce:

; 1545 : 					else
; 1546 : 					{
; 1547 : 						//Tracen(" ");
; 1548 : 
; 1549 : 						m_isGoing = FALSE;

  0076c	8b 45 28	 mov	 eax, DWORD PTR _this$[ebp]
  0076f	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1550 : 
; 1551 : 						if (IsWalking())

  00776	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00779	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  0077e	85 c0		 test	 eax, eax
  00780	74 16		 je	 SHORT $LN43@StateProce

; 1552 : 							EndWalking();

  00782	51		 push	 ecx
  00783	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  0078b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00790	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00793	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN43@StateProce:

; 1553 : 
; 1554 : 						SCRIPT_SetPixelPosition(kPPosDst.x, kPPosDst.y);

  00798	51		 push	 ecx
  00799	f3 0f 10 45 6c	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp+4]
  0079e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007a3	51		 push	 ecx
  007a4	f3 0f 10 45 68	 movss	 xmm0, DWORD PTR _kPPosDst$15[ebp]
  007a9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007ae	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  007b1	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1555 : 						SetAdvancingRotation(fRotDst);

  007b6	51		 push	 ecx
  007b7	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  007bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007c1	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  007c4	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1556 : 						SetRotation(fRotDst);

  007c9	51		 push	 ecx
  007ca	f3 0f 10 45 24	 movss	 xmm0, DWORD PTR _fRotDst$11[ebp]
  007cf	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007d4	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  007d7	e8 00 00 00 00	 call	 ?SetRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetRotation

; 1557 : 
; 1558 : 						NEW_UseSkill(0, eFunc & 0x7f, uArg&0x0f, (uArg>>4) ? true : false);

  007dc	8b 45 20	 mov	 eax, DWORD PTR _uArg$10[ebp]
  007df	c1 e8 04	 shr	 eax, 4
  007e2	85 c0		 test	 eax, eax
  007e4	74 06		 je	 SHORT $LN45@StateProce
  007e6	c6 45 00 01	 mov	 BYTE PTR tv732[ebp], 1
  007ea	eb 04		 jmp	 SHORT $LN46@StateProce
$LN45@StateProce:
  007ec	c6 45 00 00	 mov	 BYTE PTR tv732[ebp], 0
$LN46@StateProce:
  007f0	ff 75 00	 push	 DWORD PTR tv732[ebp]
  007f3	8b 45 20	 mov	 eax, DWORD PTR _uArg$10[ebp]
  007f6	83 e0 0f	 and	 eax, 15			; 0000000fH
  007f9	50		 push	 eax
  007fa	8b 45 10	 mov	 eax, DWORD PTR _eFunc$7[ebp]
  007fd	83 e0 7f	 and	 eax, 127		; 0000007fH
  00800	50		 push	 eax
  00801	6a 00		 push	 0
  00803	8b 4d 28	 mov	 ecx, DWORD PTR _this$[ebp]
  00806	e8 00 00 00 00	 call	 ?NEW_UseSkill@CInstanceBase@@QAE_NIII_N@Z ; CInstanceBase::NEW_UseSkill
$LN41@StateProce:
$LN4@StateProce:

; 1559 : 						//Tracen("   ");
; 1560 : 					}
; 1561 : 				}
; 1562 : 				break;
; 1563 : 			}
; 1564 : 		}
; 1565 : 	}

  0080b	e9 0a f8 ff ff	 jmp	 $LN2@StateProce
$LN3@StateProce:
$LN1@StateProce:

; 1566 : }

  00810	5f		 pop	 edi
  00811	5e		 pop	 esi
  00812	8b 4d 74	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00815	33 cd		 xor	 ecx, ebp
  00817	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0081c	83 c5 78	 add	 ebp, 120		; 00000078H
  0081f	c9		 leave
  00820	c3		 ret	 0
?StateProcess@CInstanceBase@@IAEXXZ ENDP		; CInstanceBase::StateProcess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?MovementProcess@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
__X$ = -220						; size = 4
_fy$ = -216						; size = 4
_fx$ = -212						; size = 4
_fz$ = -208						; size = 4
_fy$ = -204						; size = 4
_dwTargetVID$1 = -200					; size = 4
tv1075 = -196						; size = 4
__X$ = -192						; size = 4
tv1062 = -188						; size = 4
_dwMotionNumber$2 = -184				; size = 4
_fx$ = -180						; size = 4
_fNextLen$ = -176					; size = 4
_fDstRot$3 = -172					; size = 4
_fDstRot$4 = -168					; size = 4
_dwMotionNumber$5 = -164				; size = 4
_dwTargetVID$6 = -160					; size = 4
_fDstRot$7 = -156					; size = 4
__X$ = -152						; size = 4
__X$ = -148						; size = 4
__X$ = -144						; size = 4
_fz$ = -140						; size = 4
_fy$ = -136						; size = 4
_fx$ = -132						; size = 4
_fz$ = -128						; size = 4
_fDustDistance$8 = -124					; size = 4
_iDirection$9 = -120					; size = 4
tv1025 = -116						; size = 4
_fCurLen$ = -112					; size = 4
_fRestLen$ = -108					; size = 4
_fAdvancingRotation$10 = -104				; size = 4
_fTotalLen$ = -100					; size = 4
_v$ = -96						; size = 4
_this$ = -92						; size = 4
_v$ = -88						; size = 4
_v$ = -84						; size = 4
_c_rkV3Mov$11 = -80					; size = 4
tv335 = -76						; size = 4
_fRotation$12 = -72					; size = 4
_this$ = -68						; size = 4
_kPPosNext$ = -64					; size = 12
_kPPosDeltaSD$ = -52					; size = 12
_kPPosDeltaSN$ = -40					; size = 12
_kPPosDeltaSC$ = -28					; size = 12
_kPPosCur$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?MovementProcess@CInstanceBase@@IAEXXZ PROC		; CInstanceBase::MovementProcess, COMDAT
; _this$ = ecx

; 1570 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx

; 1571 : 	TPixelPosition kPPosCur;
; 1572 : 	NEW_GetPixelPosition(&kPPosCur);

  00016	8d 45 f0	 lea	 eax, DWORD PTR _kPPosCur$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 1573 : 
; 1574 : 	//   y - .
; 1575 : 
; 1576 : 	TPixelPosition kPPosNext;
; 1577 : 	{
; 1578 : 		const D3DXVECTOR3 & c_rkV3Mov = m_GraphicThingInstance.GetMovementVectorRef();

  00022	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0002b	e8 00 00 00 00	 call	 ?GetMovementVectorRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::GetMovementVectorRef
  00030	89 45 b0	 mov	 DWORD PTR _c_rkV3Mov$11[ebp], eax

; 1579 : 
; 1580 : 		kPPosNext.x = kPPosCur.x + (+c_rkV3Mov.x);

  00033	8b 45 b0	 mov	 eax, DWORD PTR _c_rkV3Mov$11[ebp]
  00036	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _kPPosCur$[ebp]
  0003b	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  0003f	f3 0f 11 45 c0	 movss	 DWORD PTR _kPPosNext$[ebp], xmm0

; 1581 : 		kPPosNext.y = kPPosCur.y + (-c_rkV3Mov.y);

  00044	8b 45 b0	 mov	 eax, DWORD PTR _c_rkV3Mov$11[ebp]
  00047	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0004c	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  00053	f3 0f 58 45 f4	 addss	 xmm0, DWORD PTR _kPPosCur$[ebp+4]
  00058	f3 0f 11 45 c4	 movss	 DWORD PTR _kPPosNext$[ebp+4], xmm0

; 1582 : 		kPPosNext.z = kPPosCur.z + (+c_rkV3Mov.z);

  0005d	8b 45 b0	 mov	 eax, DWORD PTR _c_rkV3Mov$11[ebp]
  00060	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _kPPosCur$[ebp+8]
  00065	f3 0f 58 40 08	 addss	 xmm0, DWORD PTR [eax+8]
  0006a	f3 0f 11 45 c8	 movss	 DWORD PTR _kPPosNext$[ebp+8], xmm0

; 1583 : 	}
; 1584 : 
; 1585 : 	TPixelPosition kPPosDeltaSC = kPPosCur - NEW_GetSrcPixelPositionRef();

  0006f	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetSrcPixelPositionRef
  00077	89 45 ac	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0007a	8b 45 ac	 mov	 eax, DWORD PTR _v$[ebp]
  0007d	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _kPPosCur$[ebp]
  00082	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00086	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0008e	8b 45 ac	 mov	 eax, DWORD PTR _v$[ebp]
  00091	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _kPPosCur$[ebp+4]
  00096	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  0009b	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  000a3	8b 45 ac	 mov	 eax, DWORD PTR _v$[ebp]
  000a6	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR _kPPosCur$[ebp+8]
  000ab	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  000b0	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000b8	f3 0f 10 85 4c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000c0	f3 0f 11 45 e4	 movss	 DWORD PTR _kPPosDeltaSC$[ebp], xmm0

; 181  :     y = fy;

  000c5	f3 0f 10 85 34
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000cd	f3 0f 11 45 e8	 movss	 DWORD PTR _kPPosDeltaSC$[ebp+4], xmm0

; 182  :     z = fz;

  000d2	f3 0f 10 85 30
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000da	f3 0f 11 45 ec	 movss	 DWORD PTR _kPPosDeltaSC$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1586 : 	TPixelPosition kPPosDeltaSN = kPPosNext - NEW_GetSrcPixelPositionRef();

  000df	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	e8 00 00 00 00	 call	 ?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetSrcPixelPositionRef
  000e7	89 45 a8	 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000ea	8b 45 a8	 mov	 eax, DWORD PTR _v$[ebp]
  000ed	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _kPPosNext$[ebp]
  000f2	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  000f6	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  000fe	8b 45 a8	 mov	 eax, DWORD PTR _v$[ebp]
  00101	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _kPPosNext$[ebp+4]
  00106	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  0010b	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00113	8b 45 a8	 mov	 eax, DWORD PTR _v$[ebp]
  00116	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _kPPosNext$[ebp+8]
  0011b	f3 0f 5c 40 08	 subss	 xmm0, DWORD PTR [eax+8]
  00120	f3 0f 11 45 80	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00125	f3 0f 10 85 2c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0012d	f3 0f 11 45 d8	 movss	 DWORD PTR _kPPosDeltaSN$[ebp], xmm0

; 181  :     y = fy;

  00132	f3 0f 10 85 28
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0013a	f3 0f 11 45 dc	 movss	 DWORD PTR _kPPosDeltaSN$[ebp+4], xmm0

; 182  :     z = fz;

  0013f	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00144	f3 0f 11 45 e0	 movss	 DWORD PTR _kPPosDeltaSN$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1587 : 	TPixelPosition kPPosDeltaSD = NEW_GetDstPixelPositionRef() - NEW_GetSrcPixelPositionRef();

  00149	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetSrcPixelPositionRef
  00151	89 45 a0	 mov	 DWORD PTR _v$[ebp], eax
  00154	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  0015c	89 45 a4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  0015f	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  00162	8b 4d a0	 mov	 ecx, DWORD PTR _v$[ebp]
  00165	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00169	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  0016d	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00175	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  00178	8b 4d a0	 mov	 ecx, DWORD PTR _v$[ebp]
  0017b	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00180	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  00185	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0018d	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  00190	8b 4d a0	 mov	 ecx, DWORD PTR _v$[ebp]
  00193	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00198	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  0019d	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  001a5	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001ad	f3 0f 11 45 cc	 movss	 DWORD PTR _kPPosDeltaSD$[ebp], xmm0

; 181  :     y = fy;

  001b2	f3 0f 10 85 78
	ff ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001ba	f3 0f 11 45 d0	 movss	 DWORD PTR _kPPosDeltaSD$[ebp+4], xmm0

; 182  :     z = fz;

  001bf	f3 0f 10 85 74
	ff ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  001c7	f3 0f 11 45 d4	 movss	 DWORD PTR _kPPosDeltaSD$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1589 : 	float fCurLen = sqrtf(kPPosDeltaSC.x * kPPosDeltaSC.x + kPPosDeltaSC.y * kPPosDeltaSC.y);

  001cc	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _kPPosDeltaSC$[ebp+4]
  001d1	f3 0f 59 45 e8	 mulss	 xmm0, DWORD PTR _kPPosDeltaSC$[ebp+4]
  001d6	f3 0f 10 4d e4	 movss	 xmm1, DWORD PTR _kPPosDeltaSC$[ebp]
  001db	f3 0f 59 4d e4	 mulss	 xmm1, DWORD PTR _kPPosDeltaSC$[ebp]
  001e0	f3 0f 58 c8	 addss	 xmm1, xmm0
  001e4	f3 0f 11 8d 70
	ff ff ff	 movss	 DWORD PTR __X$[ebp], xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  001ec	f3 0f 5a 85 70
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  001f4	51		 push	 ecx
  001f5	51		 push	 ecx
  001f6	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001fb	e8 00 00 00 00	 call	 _sqrt
  00200	59		 pop	 ecx
  00201	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1589 : 	float fCurLen = sqrtf(kPPosDeltaSC.x * kPPosDeltaSC.x + kPPosDeltaSC.y * kPPosDeltaSC.y);

  00202	d9 5d 90	 fstp	 DWORD PTR _fCurLen$[ebp]

; 1590 : 	float fNextLen = sqrtf(kPPosDeltaSN.x * kPPosDeltaSN.x + kPPosDeltaSN.y * kPPosDeltaSN.y);

  00205	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _kPPosDeltaSN$[ebp+4]
  0020a	f3 0f 59 45 dc	 mulss	 xmm0, DWORD PTR _kPPosDeltaSN$[ebp+4]
  0020f	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR _kPPosDeltaSN$[ebp]
  00214	f3 0f 59 4d d8	 mulss	 xmm1, DWORD PTR _kPPosDeltaSN$[ebp]
  00219	f3 0f 58 c8	 addss	 xmm1, xmm0
  0021d	f3 0f 11 8d 6c
	ff ff ff	 movss	 DWORD PTR __X$[ebp], xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00225	f3 0f 5a 85 6c
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  0022d	51		 push	 ecx
  0022e	51		 push	 ecx
  0022f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00234	e8 00 00 00 00	 call	 _sqrt
  00239	59		 pop	 ecx
  0023a	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1590 : 	float fNextLen = sqrtf(kPPosDeltaSN.x * kPPosDeltaSN.x + kPPosDeltaSN.y * kPPosDeltaSN.y);

  0023b	d9 9d 50 ff ff
	ff		 fstp	 DWORD PTR _fNextLen$[ebp]

; 1591 : 	float fTotalLen = sqrtf(kPPosDeltaSD.x * kPPosDeltaSD.x + kPPosDeltaSD.y * kPPosDeltaSD.y);

  00241	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _kPPosDeltaSD$[ebp+4]
  00246	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _kPPosDeltaSD$[ebp+4]
  0024b	f3 0f 10 4d cc	 movss	 xmm1, DWORD PTR _kPPosDeltaSD$[ebp]
  00250	f3 0f 59 4d cc	 mulss	 xmm1, DWORD PTR _kPPosDeltaSD$[ebp]
  00255	f3 0f 58 c8	 addss	 xmm1, xmm0
  00259	f3 0f 11 8d 68
	ff ff ff	 movss	 DWORD PTR __X$[ebp], xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00261	f3 0f 5a 85 68
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00269	51		 push	 ecx
  0026a	51		 push	 ecx
  0026b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00270	e8 00 00 00 00	 call	 _sqrt
  00275	59		 pop	 ecx
  00276	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1591 : 	float fTotalLen = sqrtf(kPPosDeltaSD.x * kPPosDeltaSD.x + kPPosDeltaSD.y * kPPosDeltaSD.y);

  00277	d9 5d 9c	 fstp	 DWORD PTR _fTotalLen$[ebp]

; 1592 : 	float fRestLen = fTotalLen - fCurLen;

  0027a	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fTotalLen$[ebp]
  0027f	f3 0f 5c 45 90	 subss	 xmm0, DWORD PTR _fCurLen$[ebp]
  00284	f3 0f 11 45 94	 movss	 DWORD PTR _fRestLen$[ebp], xmm0

; 1593 : 
; 1594 : 	if (__IsMainInstance())

  00289	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0028c	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  00291	0f b6 c0	 movzx	 eax, al
  00294	85 c0		 test	 eax, eax
  00296	0f 84 f9 00 00
	00		 je	 $LN4@MovementPr

; 1595 : 	{
; 1596 : 		if (m_isGoing && IsWalking())

  0029c	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0029f	0f b6 80 88 01
	00 00		 movzx	 eax, BYTE PTR [eax+392]
  002a6	85 c0		 test	 eax, eax
  002a8	0f 84 e2 00 00
	00		 je	 $LN9@MovementPr
  002ae	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  002b6	85 c0		 test	 eax, eax
  002b8	0f 84 d2 00 00
	00		 je	 $LN9@MovementPr

; 1597 : 		{
; 1598 : 			float fDstRot = NEW_GetAdvancingRotationFromPixelPosition(NEW_GetSrcPixelPositionRef(), NEW_GetDstPixelPositionRef());

  002be	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002c1	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  002c6	50		 push	 eax
  002c7	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ca	e8 00 00 00 00	 call	 ?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetSrcPixelPositionRef
  002cf	50		 push	 eax
  002d0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002d3	e8 00 00 00 00	 call	 ?NEW_GetAdvancingRotationFromPixelPosition@CInstanceBase@@QAEMABUD3DXVECTOR3@@0@Z ; CInstanceBase::NEW_GetAdvancingRotationFromPixelPosition
  002d8	d9 9d 64 ff ff
	ff		 fstp	 DWORD PTR _fDstRot$7[ebp]

; 1599 : 
; 1600 : 			SetAdvancingRotation(fDstRot);

  002de	51		 push	 ecx
  002df	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR _fDstRot$7[ebp]
  002e7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002ec	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ef	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1601 : 
; 1602 : 			if (fRestLen<=0.0)

  002f4	f3 0f 5a 45 94	 cvtss2sd xmm0, DWORD PTR _fRestLen$[ebp]
  002f9	0f 57 c9	 xorps	 xmm1, xmm1
  002fc	66 0f 2f c8	 comisd	 xmm1, xmm0
  00300	0f 82 8a 00 00
	00		 jb	 $LN9@MovementPr

; 1603 : 			{
; 1604 : 				if (IsWalking())

  00306	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00309	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  0030e	85 c0		 test	 eax, eax
  00310	74 16		 je	 SHORT $LN8@MovementPr

; 1605 : 					EndWalking();

  00312	51		 push	 ecx
  00313	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  0031b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00320	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00323	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN8@MovementPr:

; 1606 : 
; 1607 : 				//Tracen("  ");
; 1608 : 
; 1609 : 				m_isGoing = FALSE;

  00328	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0032b	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1610 : 
; 1611 : 				BlockMovement();

  00332	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00335	e8 00 00 00 00	 call	 ?BlockMovement@CInstanceBase@@QAEXXZ ; CInstanceBase::BlockMovement

; 1612 : 
; 1613 : 				if (FUNC_EMOTION == m_kMovAfterFunc.eFunc)

  0033a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0033d	83 b8 a8 01 00
	00 05		 cmp	 DWORD PTR [eax+424], 5
  00344	75 4a		 jne	 SHORT $LN9@MovementPr

; 1614 : 				{
; 1615 : 					DWORD dwMotionNumber = m_kMovAfterFunc.uArg;

  00346	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00349	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  0034f	89 85 5c ff ff
	ff		 mov	 DWORD PTR _dwMotionNumber$5[ebp], eax

; 1616 : 					DWORD dwTargetVID = m_kMovAfterFunc.uArgExpanded;

  00355	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00358	8b 80 b0 01 00
	00		 mov	 eax, DWORD PTR [eax+432]
  0035e	89 85 60 ff ff
	ff		 mov	 DWORD PTR _dwTargetVID$6[ebp], eax

; 1617 : 					__ProcessFunctionEmotion(dwMotionNumber, dwTargetVID, m_kMovAfterFunc.kPosDst);

  00364	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00367	05 b4 01 00 00	 add	 eax, 436		; 000001b4H
  0036c	50		 push	 eax
  0036d	ff b5 60 ff ff
	ff		 push	 DWORD PTR _dwTargetVID$6[ebp]
  00373	ff b5 5c ff ff
	ff		 push	 DWORD PTR _dwMotionNumber$5[ebp]
  00379	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0037c	e8 00 00 00 00	 call	 ?__ProcessFunctionEmotion@CInstanceBase@@IAEXKKABUD3DXVECTOR3@@@Z ; CInstanceBase::__ProcessFunctionEmotion

; 1618 : 					m_kMovAfterFunc.eFunc = FUNC_WAIT;

  00381	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00384	83 a0 a8 01 00
	00 00		 and	 DWORD PTR [eax+424], 0

; 1619 : 					return;

  0038b	e9 4f 07 00 00	 jmp	 $LN1@MovementPr
$LN9@MovementPr:

; 1620 : 				}
; 1621 : 			}
; 1622 : 		}
; 1623 : 	}

  00390	e9 27 05 00 00	 jmp	 $LN2@MovementPr
$LN4@MovementPr:

; 1624 : 	else
; 1625 : 	{
; 1626 : 		if (m_isGoing && IsWalking())

  00395	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00398	0f b6 80 88 01
	00 00		 movzx	 eax, BYTE PTR [eax+392]
  0039f	85 c0		 test	 eax, eax
  003a1	0f 84 15 05 00
	00		 je	 $LN2@MovementPr
  003a7	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  003aa	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  003af	85 c0		 test	 eax, eax
  003b1	0f 84 05 05 00
	00		 je	 $LN2@MovementPr

; 1627 : 		{
; 1628 : 			float fDstRot = NEW_GetAdvancingRotationFromPixelPosition(NEW_GetSrcPixelPositionRef(), NEW_GetDstPixelPositionRef());

  003b7	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  003ba	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  003bf	50		 push	 eax
  003c0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  003c3	e8 00 00 00 00	 call	 ?NEW_GetSrcPixelPositionRef@CInstanceBase@@IAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetSrcPixelPositionRef
  003c8	50		 push	 eax
  003c9	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  003cc	e8 00 00 00 00	 call	 ?NEW_GetAdvancingRotationFromPixelPosition@CInstanceBase@@QAEMABUD3DXVECTOR3@@0@Z ; CInstanceBase::NEW_GetAdvancingRotationFromPixelPosition
  003d1	d9 9d 58 ff ff
	ff		 fstp	 DWORD PTR _fDstRot$4[ebp]

; 1629 : 
; 1630 : 			SetAdvancingRotation(fDstRot);

  003d7	51		 push	 ecx
  003d8	f3 0f 10 85 58
	ff ff ff	 movss	 xmm0, DWORD PTR _fDstRot$4[ebp]
  003e0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003e5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  003e8	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1631 : 
; 1632 : 			//      ..
; 1633 : 			if (fRestLen < -100.0f)

  003ed	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c2c80000
  003f5	0f 2f 45 94	 comiss	 xmm0, DWORD PTR _fRestLen$[ebp]
  003f9	76 58		 jbe	 SHORT $LN11@MovementPr

; 1634 : 			{
; 1635 : 				NEW_SetSrcPixelPosition(kPPosCur);

  003fb	8d 45 f0	 lea	 eax, DWORD PTR _kPPosCur$[ebp]
  003fe	50		 push	 eax
  003ff	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00402	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition

; 1636 : 
; 1637 : 				float fDstRot = NEW_GetAdvancingRotationFromPixelPosition(kPPosCur, NEW_GetDstPixelPositionRef());

  00407	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0040a	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  0040f	50		 push	 eax
  00410	8d 45 f0	 lea	 eax, DWORD PTR _kPPosCur$[ebp]
  00413	50		 push	 eax
  00414	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00417	e8 00 00 00 00	 call	 ?NEW_GetAdvancingRotationFromPixelPosition@CInstanceBase@@QAEMABUD3DXVECTOR3@@0@Z ; CInstanceBase::NEW_GetAdvancingRotationFromPixelPosition
  0041c	d9 9d 54 ff ff
	ff		 fstp	 DWORD PTR _fDstRot$3[ebp]

; 1638 : 				SetAdvancingRotation(fDstRot);

  00422	51		 push	 ecx
  00423	f3 0f 10 85 54
	ff ff ff	 movss	 xmm0, DWORD PTR _fDstRot$3[ebp]
  0042b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00430	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00433	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1639 : 				//Tracenf("VID %d   (%f, %f) %f rest %f", GetVirtualID(), kPPosCur.x, kPPosCur.y, fDstRot, fRestLen);			
; 1640 : 
; 1641 : 				//    
; 1642 : 				if (FUNC_MOVE == m_kMovAfterFunc.eFunc)

  00438	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0043b	83 b8 a8 01 00
	00 01		 cmp	 DWORD PTR [eax+424], 1
  00442	75 0a		 jne	 SHORT $LN13@MovementPr

; 1643 : 				{
; 1644 : 					m_kMovAfterFunc.eFunc = FUNC_WAIT;

  00444	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00447	83 a0 a8 01 00
	00 00		 and	 DWORD PTR [eax+424], 0
$LN13@MovementPr:

; 1645 : 				}
; 1646 : 			}

  0044e	e9 69 04 00 00	 jmp	 $LN2@MovementPr
$LN11@MovementPr:

; 1647 : 			// ...
; 1648 : 			else if (fCurLen <= fTotalLen && fTotalLen <= fNextLen)

  00453	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fTotalLen$[ebp]
  00458	0f 2f 45 90	 comiss	 xmm0, DWORD PTR _fCurLen$[ebp]
  0045c	0f 82 5a 04 00
	00		 jb	 $LN2@MovementPr
  00462	f3 0f 10 85 50
	ff ff ff	 movss	 xmm0, DWORD PTR _fNextLen$[ebp]
  0046a	0f 2f 45 9c	 comiss	 xmm0, DWORD PTR _fTotalLen$[ebp]
  0046e	0f 82 48 04 00
	00		 jb	 $LN2@MovementPr

; 1649 : 			{
; 1650 : 				if (m_GraphicThingInstance.IsDead() || m_GraphicThingInstance.IsKnockDown())

  00474	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00477	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0047d	e8 00 00 00 00	 call	 ?IsDead@CActorInstance@@QAEHXZ ; CActorInstance::IsDead
  00482	85 c0		 test	 eax, eax
  00484	75 12		 jne	 SHORT $LN17@MovementPr
  00486	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00489	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0048f	e8 00 00 00 00	 call	 ?IsKnockDown@CActorInstance@@QAEHXZ ; CActorInstance::IsKnockDown
  00494	85 c0		 test	 eax, eax
  00496	74 17		 je	 SHORT $LN15@MovementPr
$LN17@MovementPr:

; 1651 : 				{
; 1652 : 					__DisableSkipCollision();

  00498	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0049b	e8 00 00 00 00	 call	 ?__DisableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__DisableSkipCollision

; 1653 : 
; 1654 : 					//Tracen("   ");
; 1655 : 
; 1656 : 					m_isGoing = FALSE;

  004a0	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  004a3	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1657 : 
; 1658 : 					//Tracen("     ");
; 1659 : 				}

  004aa	e9 0d 04 00 00	 jmp	 $LN2@MovementPr
$LN15@MovementPr:

; 1660 : 				else
; 1661 : 				{
; 1662 : 					switch (m_kMovAfterFunc.eFunc)

  004af	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  004b2	8b 80 a8 01 00
	00		 mov	 eax, DWORD PTR [eax+424]
  004b8	89 45 b4	 mov	 DWORD PTR tv335[ebp], eax
  004bb	83 7d b4 01	 cmp	 DWORD PTR tv335[ebp], 1
  004bf	0f 84 d6 01 00
	00		 je	 $LN23@MovementPr
  004c5	83 7d b4 02	 cmp	 DWORD PTR tv335[ebp], 2
  004c9	74 23		 je	 SHORT $LN18@MovementPr
  004cb	83 7d b4 03	 cmp	 DWORD PTR tv335[ebp], 3
  004cf	0f 84 d2 00 00
	00		 je	 $LN20@MovementPr
  004d5	83 7d b4 04	 cmp	 DWORD PTR tv335[ebp], 4
  004d9	0f 84 c1 01 00
	00		 je	 $LN24@MovementPr
  004df	83 7d b4 05	 cmp	 DWORD PTR tv335[ebp], 5
  004e3	0f 84 4e 01 00
	00		 je	 $LN22@MovementPr
  004e9	e9 8b 02 00 00	 jmp	 $LN26@MovementPr
$LN18@MovementPr:

; 1663 : 					{
; 1664 : 						case FUNC_ATTACK:
; 1665 : 						{
; 1666 : 							if (IsWalking())

  004ee	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  004f1	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  004f6	85 c0		 test	 eax, eax
  004f8	74 16		 je	 SHORT $LN19@MovementPr

; 1667 : 								EndWalking();

  004fa	51		 push	 ecx
  004fb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  00503	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00508	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN19@MovementPr:

; 1668 : 
; 1669 : 							__DisableSkipCollision();

  00510	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00513	e8 00 00 00 00	 call	 ?__DisableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__DisableSkipCollision

; 1670 : 							m_isGoing = FALSE;

  00518	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0051b	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1671 : 
; 1672 : 							BlockMovement();

  00522	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00525	e8 00 00 00 00	 call	 ?BlockMovement@CInstanceBase@@QAEXXZ ; CInstanceBase::BlockMovement

; 1673 : 							SCRIPT_SetPixelPosition(NEW_GetDstPixelPositionRef().x, NEW_GetDstPixelPositionRef().y);

  0052a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0052d	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  00532	51		 push	 ecx
  00533	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00538	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0053d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00540	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  00545	51		 push	 ecx
  00546	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0054a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0054f	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00552	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1674 : 							SetAdvancingRotation(m_fDstRot);

  00557	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0055a	51		 push	 ecx
  0055b	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  00563	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00568	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0056b	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1675 : 							SetRotation(m_fDstRot);

  00570	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00573	51		 push	 ecx
  00574	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  0057c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00581	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00584	e8 00 00 00 00	 call	 ?SetRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetRotation

; 1676 : 
; 1677 : 							RunNormalAttack(m_fDstRot);

  00589	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0058c	51		 push	 ecx
  0058d	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  00595	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0059a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0059d	e8 00 00 00 00	 call	 ?RunNormalAttack@CInstanceBase@@QAEXM@Z ; CInstanceBase::RunNormalAttack

; 1678 : 							break;

  005a2	e9 15 03 00 00	 jmp	 $LN2@MovementPr
$LN20@MovementPr:

; 1679 : 						}
; 1680 : 
; 1681 : 						case FUNC_COMBO:
; 1682 : 						{
; 1683 : 							if (IsWalking())

  005a7	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  005aa	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  005af	85 c0		 test	 eax, eax
  005b1	74 16		 je	 SHORT $LN21@MovementPr

; 1684 : 								EndWalking();

  005b3	51		 push	 ecx
  005b4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  005bc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005c1	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  005c4	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN21@MovementPr:

; 1685 : 
; 1686 : 							__DisableSkipCollision();

  005c9	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  005cc	e8 00 00 00 00	 call	 ?__DisableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__DisableSkipCollision

; 1687 : 							m_isGoing = FALSE;

  005d1	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  005d4	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1688 : 
; 1689 : 							BlockMovement();

  005db	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  005de	e8 00 00 00 00	 call	 ?BlockMovement@CInstanceBase@@QAEXXZ ; CInstanceBase::BlockMovement

; 1690 : 							SCRIPT_SetPixelPosition(NEW_GetDstPixelPositionRef().x, NEW_GetDstPixelPositionRef().y);

  005e3	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  005e6	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  005eb	51		 push	 ecx
  005ec	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  005f1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  005f6	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  005f9	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  005fe	51		 push	 ecx
  005ff	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00603	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00608	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0060b	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1691 : 							RunComboAttack(m_fDstRot, m_kMovAfterFunc.uArg);

  00610	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00613	ff b0 ac 01 00
	00		 push	 DWORD PTR [eax+428]
  00619	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0061c	51		 push	 ecx
  0061d	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  00625	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0062a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0062d	e8 00 00 00 00	 call	 ?RunComboAttack@CInstanceBase@@QAEXMK@Z ; CInstanceBase::RunComboAttack

; 1692 : 							break;

  00632	e9 85 02 00 00	 jmp	 $LN2@MovementPr
$LN22@MovementPr:

; 1693 : 						}
; 1694 : 
; 1695 : 						case FUNC_EMOTION:
; 1696 : 						{
; 1697 : 							m_isGoing = FALSE;

  00637	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0063a	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1698 : 							m_kMovAfterFunc.eFunc = FUNC_WAIT;

  00641	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00644	83 a0 a8 01 00
	00 00		 and	 DWORD PTR [eax+424], 0

; 1699 : 							__DisableSkipCollision();

  0064b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0064e	e8 00 00 00 00	 call	 ?__DisableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__DisableSkipCollision

; 1700 : 							BlockMovement();

  00653	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00656	e8 00 00 00 00	 call	 ?BlockMovement@CInstanceBase@@QAEXXZ ; CInstanceBase::BlockMovement

; 1701 : 
; 1702 : 							DWORD dwMotionNumber = m_kMovAfterFunc.uArg;

  0065b	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0065e	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  00664	89 85 48 ff ff
	ff		 mov	 DWORD PTR _dwMotionNumber$2[ebp], eax

; 1703 : 							DWORD dwTargetVID = m_kMovAfterFunc.uArgExpanded;

  0066a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0066d	8b 80 b0 01 00
	00		 mov	 eax, DWORD PTR [eax+432]
  00673	89 85 38 ff ff
	ff		 mov	 DWORD PTR _dwTargetVID$1[ebp], eax

; 1704 : 							__ProcessFunctionEmotion(dwMotionNumber, dwTargetVID, m_kMovAfterFunc.kPosDst);

  00679	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0067c	05 b4 01 00 00	 add	 eax, 436		; 000001b4H
  00681	50		 push	 eax
  00682	ff b5 38 ff ff
	ff		 push	 DWORD PTR _dwTargetVID$1[ebp]
  00688	ff b5 48 ff ff
	ff		 push	 DWORD PTR _dwMotionNumber$2[ebp]
  0068e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00691	e8 00 00 00 00	 call	 ?__ProcessFunctionEmotion@CInstanceBase@@IAEXKKABUD3DXVECTOR3@@@Z ; CInstanceBase::__ProcessFunctionEmotion

; 1705 : 							break;

  00696	e9 21 02 00 00	 jmp	 $LN2@MovementPr
$LN23@MovementPr:

; 1706 : 						}
; 1707 : 
; 1708 : 						case FUNC_MOVE:
; 1709 : 						{
; 1710 : 							break;

  0069b	e9 1c 02 00 00	 jmp	 $LN2@MovementPr
$LN24@MovementPr:

; 1711 : 						}
; 1712 : 
; 1713 : 						case FUNC_MOB_SKILL:
; 1714 : 						{
; 1715 : 							if (IsWalking())

  006a0	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  006a3	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  006a8	85 c0		 test	 eax, eax
  006aa	74 16		 je	 SHORT $LN25@MovementPr

; 1716 : 								EndWalking();

  006ac	51		 push	 ecx
  006ad	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  006b5	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ba	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  006bd	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN25@MovementPr:

; 1717 : 
; 1718 : 							__DisableSkipCollision();

  006c2	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  006c5	e8 00 00 00 00	 call	 ?__DisableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__DisableSkipCollision

; 1719 : 							m_isGoing = FALSE;

  006ca	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  006cd	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1720 : 
; 1721 : 							BlockMovement();

  006d4	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  006d7	e8 00 00 00 00	 call	 ?BlockMovement@CInstanceBase@@QAEXXZ ; CInstanceBase::BlockMovement

; 1722 : 							SCRIPT_SetPixelPosition(NEW_GetDstPixelPositionRef().x, NEW_GetDstPixelPositionRef().y);

  006dc	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  006df	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  006e4	51		 push	 ecx
  006e5	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  006ea	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  006ef	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  006f2	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  006f7	51		 push	 ecx
  006f8	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  006fc	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00701	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00704	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1723 : 							SetAdvancingRotation(m_fDstRot);

  00709	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0070c	51		 push	 ecx
  0070d	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  00715	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0071a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0071d	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1724 : 							SetRotation(m_fDstRot);

  00722	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00725	51		 push	 ecx
  00726	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  0072e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00733	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00736	e8 00 00 00 00	 call	 ?SetRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetRotation

; 1725 : 
; 1726 : 							m_GraphicThingInstance.InterceptOnceMotion(CRaceMotionData::NAME_SPECIAL_1 + m_kMovAfterFunc.uArg);

  0073b	51		 push	 ecx
  0073c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00744	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00749	6a 00		 push	 0
  0074b	51		 push	 ecx
  0074c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00754	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00759	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0075c	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  00762	83 c0 21	 add	 eax, 33			; 00000021H
  00765	50		 push	 eax
  00766	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00769	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0076f	e8 00 00 00 00	 call	 ?InterceptOnceMotion@CActorInstance@@QAE_NKMIM@Z ; CActorInstance::InterceptOnceMotion

; 1727 : 							break;

  00774	e9 43 01 00 00	 jmp	 $LN2@MovementPr
$LN26@MovementPr:

; 1728 : 						}
; 1729 : 
; 1730 : 						default:
; 1731 : 						{
; 1732 : 							if (m_kMovAfterFunc.eFunc & FUNC_SKILL)

  00779	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0077c	8b 80 a8 01 00
	00		 mov	 eax, DWORD PTR [eax+424]
  00782	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00787	0f 84 86 00 00
	00		 je	 $LN27@MovementPr

; 1733 : 							{
; 1734 : 								SetAdvancingRotation(m_fDstRot);

  0078d	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00790	51		 push	 ecx
  00791	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  00799	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0079e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  007a1	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1735 : 								BlendRotation(m_fDstRot);

  007a6	51		 push	 ecx
  007a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  007af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007b4	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  007b7	51		 push	 ecx
  007b8	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  007c0	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007c5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  007c8	e8 00 00 00 00	 call	 ?BlendRotation@CInstanceBase@@QAEXMM@Z ; CInstanceBase::BlendRotation

; 1736 : 								NEW_UseSkill(0, m_kMovAfterFunc.eFunc & 0x7f, m_kMovAfterFunc.uArg&0x0f, (m_kMovAfterFunc.uArg>>4) ? true : false);

  007cd	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  007d0	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  007d6	c1 e8 04	 shr	 eax, 4
  007d9	85 c0		 test	 eax, eax
  007db	74 06		 je	 SHORT $LN43@MovementPr
  007dd	c6 45 8c 01	 mov	 BYTE PTR tv1025[ebp], 1
  007e1	eb 04		 jmp	 SHORT $LN44@MovementPr
$LN43@MovementPr:
  007e3	c6 45 8c 00	 mov	 BYTE PTR tv1025[ebp], 0
$LN44@MovementPr:
  007e7	ff 75 8c	 push	 DWORD PTR tv1025[ebp]
  007ea	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  007ed	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [eax+428]
  007f3	83 e0 0f	 and	 eax, 15			; 0000000fH
  007f6	50		 push	 eax
  007f7	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  007fa	8b 80 a8 01 00
	00		 mov	 eax, DWORD PTR [eax+424]
  00800	83 e0 7f	 and	 eax, 127		; 0000007fH
  00803	50		 push	 eax
  00804	6a 00		 push	 0
  00806	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00809	e8 00 00 00 00	 call	 ?NEW_UseSkill@CInstanceBase@@QAE_NIII_N@Z ; CInstanceBase::NEW_UseSkill

; 1737 : 							}

  0080e	e9 a9 00 00 00	 jmp	 $LN29@MovementPr
$LN27@MovementPr:

; 1738 : 							else
; 1739 : 							{
; 1740 : 								//Tracenf("VID %d   (%f, %f) rot %f", GetVirtualID(), NEW_GetDstPixelPositionRef().x, NEW_GetDstPixelPositionRef().y, m_fDstRot);
; 1741 : 
; 1742 : 								__DisableSkipCollision();

  00813	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00816	e8 00 00 00 00	 call	 ?__DisableSkipCollision@CInstanceBase@@IAEXXZ ; CInstanceBase::__DisableSkipCollision

; 1743 : 								m_isGoing = FALSE;

  0081b	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0081e	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0

; 1744 : 
; 1745 : 								BlockMovement();

  00825	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00828	e8 00 00 00 00	 call	 ?BlockMovement@CInstanceBase@@QAEXXZ ; CInstanceBase::BlockMovement

; 1746 : 								SCRIPT_SetPixelPosition(NEW_GetDstPixelPositionRef().x, NEW_GetDstPixelPositionRef().y);

  0082d	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00830	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  00835	51		 push	 ecx
  00836	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0083b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00840	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00843	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  00848	51		 push	 ecx
  00849	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0084d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00852	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00855	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1747 : 								SetAdvancingRotation(m_fDstRot);

  0085a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0085d	51		 push	 ecx
  0085e	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  00866	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0086b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0086e	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 1748 : 								BlendRotation(m_fDstRot);

  00873	51		 push	 ecx
  00874	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  0087c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00881	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00884	51		 push	 ecx
  00885	f3 0f 10 80 c0
	01 00 00	 movss	 xmm0, DWORD PTR [eax+448]
  0088d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00892	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00895	e8 00 00 00 00	 call	 ?BlendRotation@CInstanceBase@@QAEXMM@Z ; CInstanceBase::BlendRotation

; 1749 : 								if (!IsWaiting())

  0089a	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0089d	e8 00 00 00 00	 call	 ?IsWaiting@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWaiting
  008a2	85 c0		 test	 eax, eax
  008a4	75 16		 jne	 SHORT $LN29@MovementPr

; 1750 : 								{
; 1751 : 									EndWalking();

  008a6	51		 push	 ecx
  008a7	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  008af	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  008b4	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  008b7	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN29@MovementPr:
$LN2@MovementPr:

; 1752 : 								}
; 1753 : 
; 1754 : 								//Tracenf("VID %d  (%f, %f) rot %f IsWalking %d", GetVirtualID(), NEW_GetDstPixelPositionRef().x, NEW_GetDstPixelPositionRef().y, m_fDstRot, IsWalking());
; 1755 : 							}
; 1756 : 							break;
; 1757 : 						}
; 1758 : 					}
; 1759 : 
; 1760 : 				}
; 1761 : 			}
; 1762 : 
; 1763 : 		}
; 1764 : 	}
; 1765 : 
; 1766 : 	if (IsWalking() || m_GraphicThingInstance.IsUsingMovingSkill())

  008bc	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  008bf	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  008c4	85 c0		 test	 eax, eax
  008c6	75 16		 jne	 SHORT $LN31@MovementPr
  008c8	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  008cb	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  008d1	e8 00 00 00 00	 call	 ?IsUsingMovingSkill@CActorInstance@@QAEHXZ ; CActorInstance::IsUsingMovingSkill
  008d6	85 c0		 test	 eax, eax
  008d8	0f 84 01 02 00
	00		 je	 $LN41@MovementPr
$LN31@MovementPr:

; 1767 : 	{
; 1768 : 		float fRotation = m_GraphicThingInstance.GetRotation();

  008de	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  008e1	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  008e7	e8 00 00 00 00	 call	 ?GetRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetRotation
  008ec	d9 5d b8	 fstp	 DWORD PTR _fRotation$12[ebp]

; 1769 : 		float fAdvancingRotation = m_GraphicThingInstance.GetAdvancingRotation();

  008ef	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  008f2	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  008f8	e8 00 00 00 00	 call	 ?GetAdvancingRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetAdvancingRotation
  008fd	d9 5d 98	 fstp	 DWORD PTR _fAdvancingRotation$10[ebp]

; 1770 : 		int iDirection = GetRotatingDirection(fRotation, fAdvancingRotation);

  00900	51		 push	 ecx
  00901	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _fAdvancingRotation$10[ebp]
  00906	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0090b	51		 push	 ecx
  0090c	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fRotation$12[ebp]
  00911	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00916	e8 00 00 00 00	 call	 ?GetRotatingDirection@@YAHMM@Z ; GetRotatingDirection
  0091b	59		 pop	 ecx
  0091c	59		 pop	 ecx
  0091d	89 45 88	 mov	 DWORD PTR _iDirection$9[ebp], eax

; 1771 : 
; 1772 : 		if (DEGREE_DIRECTION_SAME != m_iRotatingDirection)

  00920	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00923	83 b8 74 01 00
	00 00		 cmp	 DWORD PTR [eax+372], 0
  0092a	0f 84 29 01 00
	00		 je	 $LN32@MovementPr

; 1773 : 		{
; 1774 : 			if (DEGREE_DIRECTION_LEFT == iDirection)

  00930	83 7d 88 02	 cmp	 DWORD PTR _iDirection$9[ebp], 2
  00934	75 5f		 jne	 SHORT $LN33@MovementPr

; 1776 : 				fRotation = fmodf(fRotation + m_fRotSpd*m_GraphicThingInstance.GetSecondElapsed(), 360.0f);

  00936	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00939	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0093f	e8 00 00 00 00	 call	 ?GetSecondElapsed@CGraphicThingInstance@@QAEMXZ ; CGraphicThingInstance::GetSecondElapsed
  00944	d9 9d 44 ff ff
	ff		 fstp	 DWORD PTR tv1062[ebp]
  0094a	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0094d	f3 0f 10 85 44
	ff ff ff	 movss	 xmm0, DWORD PTR tv1062[ebp]
  00955	f3 0f 59 80 c8
	01 00 00	 mulss	 xmm0, DWORD PTR [eax+456]
  0095d	f3 0f 58 45 b8	 addss	 xmm0, DWORD PTR _fRotation$12[ebp]
  00962	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR __X$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 691  :             return (float)fmod(_X, _Y);

  0096a	f3 0f 5a 05 00
	00 00 00	 cvtss2sd xmm0, DWORD PTR __real@43b40000
  00972	51		 push	 ecx
  00973	51		 push	 ecx
  00974	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00979	f3 0f 5a 85 40
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00981	51		 push	 ecx
  00982	51		 push	 ecx
  00983	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00988	e8 00 00 00 00	 call	 _fmod
  0098d	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1776 : 				fRotation = fmodf(fRotation + m_fRotSpd*m_GraphicThingInstance.GetSecondElapsed(), 360.0f);

  00990	d9 5d b8	 fstp	 DWORD PTR _fRotation$12[ebp]

; 1777 : 			}

  00993	eb 6f		 jmp	 SHORT $LN35@MovementPr
$LN33@MovementPr:

; 1778 : 			else if (DEGREE_DIRECTION_RIGHT == iDirection)

  00995	83 7d 88 01	 cmp	 DWORD PTR _iDirection$9[ebp], 1
  00999	75 69		 jne	 SHORT $LN35@MovementPr

; 1780 : 				fRotation = fmodf(fRotation - m_fRotSpd*m_GraphicThingInstance.GetSecondElapsed() + 360.0f, 360.0f);

  0099b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0099e	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  009a4	e8 00 00 00 00	 call	 ?GetSecondElapsed@CGraphicThingInstance@@QAEMXZ ; CGraphicThingInstance::GetSecondElapsed
  009a9	d9 9d 3c ff ff
	ff		 fstp	 DWORD PTR tv1075[ebp]
  009af	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  009b2	f3 0f 10 85 3c
	ff ff ff	 movss	 xmm0, DWORD PTR tv1075[ebp]
  009ba	f3 0f 59 80 c8
	01 00 00	 mulss	 xmm0, DWORD PTR [eax+456]
  009c2	f3 0f 10 4d b8	 movss	 xmm1, DWORD PTR _fRotation$12[ebp]
  009c7	f3 0f 5c c8	 subss	 xmm1, xmm0
  009cb	f3 0f 58 0d 00
	00 00 00	 addss	 xmm1, DWORD PTR __real@43b40000
  009d3	f3 0f 11 8d 24
	ff ff ff	 movss	 DWORD PTR __X$[ebp], xmm1
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 691  :             return (float)fmod(_X, _Y);

  009db	f3 0f 5a 05 00
	00 00 00	 cvtss2sd xmm0, DWORD PTR __real@43b40000
  009e3	51		 push	 ecx
  009e4	51		 push	 ecx
  009e5	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  009ea	f3 0f 5a 85 24
	ff ff ff	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  009f2	51		 push	 ecx
  009f3	51		 push	 ecx
  009f4	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  009f9	e8 00 00 00 00	 call	 _fmod
  009fe	83 c4 10	 add	 esp, 16			; 00000010H
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1780 : 				fRotation = fmodf(fRotation - m_fRotSpd*m_GraphicThingInstance.GetSecondElapsed() + 360.0f, 360.0f);

  00a01	d9 5d b8	 fstp	 DWORD PTR _fRotation$12[ebp]
$LN35@MovementPr:

; 1781 : 			}
; 1782 : 
; 1783 : 			if (m_iRotatingDirection != GetRotatingDirection(fRotation, fAdvancingRotation))

  00a04	51		 push	 ecx
  00a05	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _fAdvancingRotation$10[ebp]
  00a0a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a0f	51		 push	 ecx
  00a10	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fRotation$12[ebp]
  00a15	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a1a	e8 00 00 00 00	 call	 ?GetRotatingDirection@@YAHMM@Z ; GetRotatingDirection
  00a1f	59		 pop	 ecx
  00a20	59		 pop	 ecx
  00a21	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a24	39 81 74 01 00
	00		 cmp	 DWORD PTR [ecx+372], eax
  00a2a	74 14		 je	 SHORT $LN36@MovementPr

; 1784 : 			{
; 1785 : 				m_iRotatingDirection = DEGREE_DIRECTION_SAME;

  00a2c	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00a2f	83 a0 74 01 00
	00 00		 and	 DWORD PTR [eax+372], 0

; 1786 : 				fRotation = fAdvancingRotation;

  00a36	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR _fAdvancingRotation$10[ebp]
  00a3b	f3 0f 11 45 b8	 movss	 DWORD PTR _fRotation$12[ebp], xmm0
$LN36@MovementPr:

; 1787 : 			}
; 1788 : 
; 1789 : 			m_GraphicThingInstance.SetRotation(fRotation);

  00a40	51		 push	 ecx
  00a41	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fRotation$12[ebp]
  00a46	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00a4b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a4e	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00a54	e8 00 00 00 00	 call	 ?SetRotation@CActorInstance@@QAEXM@Z ; CActorInstance::SetRotation
$LN32@MovementPr:

; 1790 : 		}
; 1791 : 
; 1792 : 		if (__IsInDustRange())

  00a59	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a5c	e8 00 00 00 00	 call	 ?__IsInDustRange@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsInDustRange
  00a61	0f b6 c0	 movzx	 eax, al
  00a64	85 c0		 test	 eax, eax
  00a66	74 77		 je	 SHORT $LN41@MovementPr

; 1793 : 		{ 
; 1794 : 			float fDustDistance = NEW_GetDistanceFromDestPixelPosition(m_kPPosDust);

  00a68	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00a6b	05 8c 01 00 00	 add	 eax, 396		; 0000018cH
  00a70	50		 push	 eax
  00a71	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a74	e8 00 00 00 00	 call	 ?NEW_GetDistanceFromDestPixelPosition@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetDistanceFromDestPixelPosition
  00a79	d9 5d 84	 fstp	 DWORD PTR _fDustDistance$8[ebp]

; 1795 : 			if (IsMountingHorse())

  00a7c	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00a7f	e8 00 00 00 00	 call	 ?IsMountingHorse@CInstanceBase@@QAEHXZ ; CInstanceBase::IsMountingHorse
  00a84	85 c0		 test	 eax, eax
  00a86	74 2e		 je	 SHORT $LN38@MovementPr

; 1796 : 			{
; 1797 : 				if (fDustDistance > ms_fHorseDustGap)

  00a88	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _fDustDistance$8[ebp]
  00a8d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?ms_fHorseDustGap@CInstanceBase@@1MA
  00a94	76 1e		 jbe	 SHORT $LN40@MovementPr

; 1798 : 				{
; 1799 : 					NEW_GetPixelPosition(&m_kPPosDust);

  00a96	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00a99	05 8c 01 00 00	 add	 eax, 396		; 0000018cH
  00a9e	50		 push	 eax
  00a9f	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aa2	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 1800 : 					__AttachEffect(EFFECT_HORSE_DUST);

  00aa7	68 e4 00 00 00	 push	 228			; 000000e4H
  00aac	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00aaf	e8 00 00 00 00	 call	 ?__AttachEffect@CInstanceBase@@IAEKI@Z ; CInstanceBase::__AttachEffect
$LN40@MovementPr:

; 1801 : 				}
; 1802 : 			}

  00ab4	eb 29		 jmp	 SHORT $LN41@MovementPr
$LN38@MovementPr:

; 1803 : 			else
; 1804 : 			{
; 1805 : 				if (fDustDistance > ms_fDustGap)

  00ab6	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _fDustDistance$8[ebp]
  00abb	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR ?ms_fDustGap@CInstanceBase@@1MA
  00ac2	76 1b		 jbe	 SHORT $LN41@MovementPr

; 1806 : 				{
; 1807 : 					NEW_GetPixelPosition(&m_kPPosDust);

  00ac4	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  00ac7	05 8c 01 00 00	 add	 eax, 396		; 0000018cH
  00acc	50		 push	 eax
  00acd	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ad0	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 1808 : 					__AttachEffect(EFFECT_DUST);

  00ad5	6a 00		 push	 0
  00ad7	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00ada	e8 00 00 00 00	 call	 ?__AttachEffect@CInstanceBase@@IAEKI@Z ; CInstanceBase::__AttachEffect
$LN41@MovementPr:
$LN1@MovementPr:

; 1809 : 				}
; 1810 : 			}
; 1811 : 		}
; 1812 : 	}
; 1813 : }

  00adf	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00ae2	33 cd		 xor	 ecx, ebp
  00ae4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00ae9	c9		 leave
  00aea	c3		 ret	 0
?MovementProcess@CInstanceBase@@IAEXXZ ENDP		; CInstanceBase::MovementProcess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__GetAlphaValue@CInstanceBase@@IAEMXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__GetAlphaValue@CInstanceBase@@IAEMXZ PROC		; CInstanceBase::__GetAlphaValue, COMDAT
; _this$ = ecx

; 2555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2556 : 	return m_GraphicThingInstance.GetAlphaValue();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?GetAlphaValue@CActorInstance@@QAEMXZ ; CActorInstance::GetAlphaValue

; 2557 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?__GetAlphaValue@CInstanceBase@@IAEMXZ ENDP		; CInstanceBase::__GetAlphaValue
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__SetAlphaValue@CInstanceBase@@IAEXM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fAlpha$ = 8						; size = 4
?__SetAlphaValue@CInstanceBase@@IAEXM@Z PROC		; CInstanceBase::__SetAlphaValue, COMDAT
; _this$ = ecx

; 2550 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2551 : 	m_GraphicThingInstance.SetAlphaValue(fAlpha);

  00007	51		 push	 ecx
  00008	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _fAlpha$[ebp]
  0000d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0001b	e8 00 00 00 00	 call	 ?SetAlphaValue@CActorInstance@@QAEXM@Z ; CActorInstance::SetAlphaValue

; 2552 : }

  00020	c9		 leave
  00021	c2 04 00	 ret	 4
?__SetAlphaValue@CInstanceBase@@IAEXM@Z ENDP		; CInstanceBase::__SetAlphaValue
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__SetBlendRenderingMode@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__SetBlendRenderingMode@CInstanceBase@@IAEXXZ PROC	; CInstanceBase::__SetBlendRenderingMode, COMDAT
; _this$ = ecx

; 2545 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2546 : 	m_GraphicThingInstance.SetBlendRenderMode();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?SetBlendRenderMode@CActorInstance@@QAEXXZ ; CActorInstance::SetBlendRenderMode

; 2547 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?__SetBlendRenderingMode@CInstanceBase@@IAEXXZ ENDP	; CInstanceBase::__SetBlendRenderingMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__Initialize@SHORSE@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__Initialize@SHORSE@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::SHORSE::__Initialize, COMDAT
; _this$ = ecx

; 49   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   : 	m_isMounting=false;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 51   : 	m_pkActor=NULL;

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 52   : }

  00014	c9		 leave
  00015	c3		 ret	 0
?__Initialize@SHORSE@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::SHORSE::__Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsNewMount@SHORSE@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_mount$ = -4						; size = 4
?IsNewMount@SHORSE@CInstanceBase@@QAE_NXZ PROC		; CInstanceBase::SHORSE::IsNewMount, COMDAT
; _this$ = ecx

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 188  : 	if (!m_pkActor)

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	75 04		 jne	 SHORT $LN2@IsNewMount

; 189  : 		return false;

  00011	32 c0		 xor	 al, al
  00013	eb 69		 jmp	 SHORT $LN1@IsNewMount
$LN2@IsNewMount:

; 190  : 	DWORD mount = m_pkActor->GetRace();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001b	e8 00 00 00 00	 call	 ?GetRace@CActorInstance@@QAEKXZ ; CActorInstance::GetRace
  00020	89 45 fc	 mov	 DWORD PTR _mount$[ebp], eax

; 191  : 
; 192  : 	if ((20205 <= mount &&  20208 >= mount) ||
; 193  : 		(20214 == mount) || (20217 == mount)			//  ,  

  00023	81 7d fc ed 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20205 ; 00004eedH
  0002a	72 09		 jb	 SHORT $LN5@IsNewMount
  0002c	81 7d fc f0 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20208 ; 00004ef0H
  00033	76 12		 jbe	 SHORT $LN4@IsNewMount
$LN5@IsNewMount:
  00035	81 7d fc f6 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20214 ; 00004ef6H
  0003c	74 09		 je	 SHORT $LN4@IsNewMount
  0003e	81 7d fc f9 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20217 ; 00004ef9H
  00045	75 04		 jne	 SHORT $LN3@IsNewMount
$LN4@IsNewMount:

; 194  : 		)
; 195  : 		return true;

  00047	b0 01		 mov	 al, 1
  00049	eb 33		 jmp	 SHORT $LN1@IsNewMount
$LN3@IsNewMount:

; 196  : 
; 197  : 	//  
; 198  : 	if ((20209 <= mount &&  20212 >= mount) || 
; 199  : 		(20215 == mount) || (20218 == mount) ||			//  ,  

  0004b	81 7d fc f1 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20209 ; 00004ef1H
  00052	72 09		 jb	 SHORT $LN8@IsNewMount
  00054	81 7d fc f4 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20212 ; 00004ef4H
  0005b	76 1b		 jbe	 SHORT $LN7@IsNewMount
$LN8@IsNewMount:
  0005d	81 7d fc f7 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20215 ; 00004ef7H
  00064	74 12		 je	 SHORT $LN7@IsNewMount
  00066	81 7d fc fa 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20218 ; 00004efaH
  0006d	74 09		 je	 SHORT $LN7@IsNewMount
  0006f	81 7d fc fc 4e
	00 00		 cmp	 DWORD PTR _mount$[ebp], 20220 ; 00004efcH
  00076	75 04		 jne	 SHORT $LN6@IsNewMount
$LN7@IsNewMount:

; 200  : 		(20220 == mount)
; 201  : 		)
; 202  : 		return true;

  00078	b0 01		 mov	 al, 1
  0007a	eb 02		 jmp	 SHORT $LN1@IsNewMount
$LN6@IsNewMount:

; 203  : 
; 204  : 	return false;

  0007c	32 c0		 xor	 al, al
$LN1@IsNewMount:

; 205  : }

  0007e	c9		 leave
  0007f	c3		 ret	 0
?IsNewMount@SHORSE@CInstanceBase@@QAE_NXZ ENDP		; CInstanceBase::SHORSE::IsNewMount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetLevel@SHORSE@CInstanceBase@@QAEIXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_mount$1 = -8						; size = 4
tv69 = -4						; size = 4
?GetLevel@SHORSE@CInstanceBase@@QAEIXZ PROC		; CInstanceBase::SHORSE::GetLevel, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 126  : 	if (m_pkActor)

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	0f 84 f3 00 00
	00		 je	 $LN4@GetLevel

; 127  : 	{
; 128  : 		DWORD mount = m_pkActor->GetRace();

  00016	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ?GetRace@CActorInstance@@QAEKXZ ; CActorInstance::GetRace
  00021	89 45 f8	 mov	 DWORD PTR _mount$1[ebp], eax

; 129  : 		switch (mount)

  00024	8b 45 f8	 mov	 eax, DWORD PTR _mount$1[ebp]
  00027	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  0002a	81 7d fc 97 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20119 ; 00004e97H
  00031	77 41		 ja	 SHORT $LN16@GetLevel
  00033	81 7d fc 97 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20119 ; 00004e97H
  0003a	74 6d		 je	 SHORT $LN8@GetLevel
  0003c	81 7d fc 85 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20101 ; 00004e85H
  00043	72 69		 jb	 SHORT $LN2@GetLevel
  00045	81 7d fc 87 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20103 ; 00004e87H
  0004c	76 4c		 jbe	 SHORT $LN5@GetLevel
  0004e	81 7d fc 87 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20103 ; 00004e87H
  00055	76 57		 jbe	 SHORT $LN2@GetLevel
  00057	81 7d fc 8a 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20106 ; 00004e8aH
  0005e	76 3f		 jbe	 SHORT $LN6@GetLevel
  00060	81 7d fc 8a 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20106 ; 00004e8aH
  00067	76 45		 jbe	 SHORT $LN2@GetLevel
  00069	81 7d fc 96 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20118 ; 00004e96H
  00070	76 32		 jbe	 SHORT $LN7@GetLevel
  00072	eb 3a		 jmp	 SHORT $LN2@GetLevel
$LN16@GetLevel:
  00074	81 7d fc 98 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20120 ; 00004e98H
  0007b	72 31		 jb	 SHORT $LN2@GetLevel
  0007d	81 7d fc 9d 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20125 ; 00004e9dH
  00084	76 1e		 jbe	 SHORT $LN7@GetLevel
  00086	81 7d fc fa 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20218 ; 00004efaH
  0008d	76 1f		 jbe	 SHORT $LN2@GetLevel
  0008f	81 7d fc fe 4e
	00 00		 cmp	 DWORD PTR tv69[ebp], 20222 ; 00004efeH
  00096	76 11		 jbe	 SHORT $LN8@GetLevel
  00098	eb 14		 jmp	 SHORT $LN2@GetLevel
$LN5@GetLevel:

; 130  : 		{
; 131  : 			case 20101:
; 132  : 			case 20102:
; 133  : 			case 20103:
; 134  : 				return 1;

  0009a	33 c0		 xor	 eax, eax
  0009c	40		 inc	 eax
  0009d	eb 6c		 jmp	 SHORT $LN1@GetLevel
$LN6@GetLevel:

; 135  : 			case 20104:
; 136  : 			case 20105:
; 137  : 			case 20106:
; 138  : 				return 2;

  0009f	6a 02		 push	 2
  000a1	58		 pop	 eax
  000a2	eb 67		 jmp	 SHORT $LN1@GetLevel
$LN7@GetLevel:

; 139  : 			case 20107:
; 140  : 			case 20108:
; 141  : 			case 20109:
; 142  : 			case 20110: // #0000673: [M2EU]      
; 143  : 			case 20111: // #0000673: [M2EU]      
; 144  : 			case 20112: // #0000673: [M2EU]      
; 145  : 			case 20113: // #0000673: [M2EU]      
; 146  : 			case 20114:
; 147  : 			case 20115:
; 148  : 			case 20116:
; 149  : 			case 20117:
; 150  : 			case 20118:
; 151  : 			case 20120:
; 152  : 			case 20121:
; 153  : 			case 20122:
; 154  : 			case 20123:
; 155  : 			case 20124:
; 156  : 			case 20125:
; 157  : 				return 3;

  000a4	6a 03		 push	 3
  000a6	58		 pop	 eax
  000a7	eb 62		 jmp	 SHORT $LN1@GetLevel
$LN8@GetLevel:

; 158  : 			case 20119: //    ,  2 
; 159  : 			case 20219: //    ,  2  (=  )
; 160  : 			case 20220:
; 161  : 			case 20221:
; 162  : 			case 20222:
; 163  : 				return 2;

  000a9	6a 02		 push	 2
  000ab	58		 pop	 eax
  000ac	eb 5d		 jmp	 SHORT $LN1@GetLevel
$LN2@GetLevel:

; 164  : 		}
; 165  : 
; 166  : 		//      (20201 ~ 20212    4  , , )
; 167  : 		//	--     /         .. [hyo]
; 168  : 		{
; 169  : 			//   2 ( ,  )
; 170  : 			if ((20205 <= mount &&  20208 >= mount) ||
; 171  : 				(20214 == mount) || (20217 == mount)			//  ,  

  000ae	81 7d f8 ed 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20205 ; 00004eedH
  000b5	72 09		 jb	 SHORT $LN11@GetLevel
  000b7	81 7d f8 f0 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20208 ; 00004ef0H
  000be	76 12		 jbe	 SHORT $LN10@GetLevel
$LN11@GetLevel:
  000c0	81 7d f8 f6 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20214 ; 00004ef6H
  000c7	74 09		 je	 SHORT $LN10@GetLevel
  000c9	81 7d f8 f9 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20217 ; 00004ef9H
  000d0	75 05		 jne	 SHORT $LN9@GetLevel
$LN10@GetLevel:

; 172  : 				)
; 173  : 				return 2;

  000d2	6a 02		 push	 2
  000d4	58		 pop	 eax
  000d5	eb 34		 jmp	 SHORT $LN1@GetLevel
$LN9@GetLevel:

; 174  : 
; 175  : 			//   3 ( ,  )
; 176  : 			if ((20209 <= mount &&  20212 >= mount) || 
; 177  : 				(20215 == mount) || (20218 == mount) ||			//  ,  

  000d7	81 7d f8 f1 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20209 ; 00004ef1H
  000de	72 09		 jb	 SHORT $LN14@GetLevel
  000e0	81 7d f8 f4 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20212 ; 00004ef4H
  000e7	76 1b		 jbe	 SHORT $LN13@GetLevel
$LN14@GetLevel:
  000e9	81 7d f8 f7 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20215 ; 00004ef7H
  000f0	74 12		 je	 SHORT $LN13@GetLevel
  000f2	81 7d f8 fa 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20218 ; 00004efaH
  000f9	74 09		 je	 SHORT $LN13@GetLevel
  000fb	81 7d f8 fc 4e
	00 00		 cmp	 DWORD PTR _mount$1[ebp], 20220 ; 00004efcH
  00102	75 05		 jne	 SHORT $LN4@GetLevel
$LN13@GetLevel:

; 178  : 				(20220 == mount)
; 179  : 				)
; 180  : 				return 3;

  00104	6a 03		 push	 3
  00106	58		 pop	 eax
  00107	eb 02		 jmp	 SHORT $LN1@GetLevel
$LN4@GetLevel:

; 181  : 		}
; 182  : 	}
; 183  : 	return 0;

  00109	33 c0		 xor	 eax, eax
$LN1@GetLevel:

; 184  : }

  0010b	c9		 leave
  0010c	c3		 ret	 0
?GetLevel@SHORSE@CInstanceBase@@QAEIXZ ENDP		; CInstanceBase::SHORSE::GetLevel
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanUseSkill@SHORSE@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
?CanUseSkill@SHORSE@CInstanceBase@@QAE_NXZ PROC		; CInstanceBase::SHORSE::CanUseSkill, COMDAT
; _this$ = ecx

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  : 	//    3  .
; 209  : 	if (IsMounting())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  00010	0f b6 c0	 movzx	 eax, al
  00013	85 c0		 test	 eax, eax
  00015	74 1f		 je	 SHORT $LN2@CanUseSkil

; 210  : 		return 2 < GetLevel();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?GetLevel@SHORSE@CInstanceBase@@QAEIXZ ; CInstanceBase::SHORSE::GetLevel
  0001f	83 f8 02	 cmp	 eax, 2
  00022	76 09		 jbe	 SHORT $LN4@CanUseSkil
  00024	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0002b	eb 04		 jmp	 SHORT $LN5@CanUseSkil
$LN4@CanUseSkil:
  0002d	83 65 f8 00	 and	 DWORD PTR tv71[ebp], 0
$LN5@CanUseSkil:
  00031	8a 45 f8	 mov	 al, BYTE PTR tv71[ebp]
  00034	eb 02		 jmp	 SHORT $LN1@CanUseSkil
$LN2@CanUseSkil:

; 211  : 
; 212  : 	return true;

  00036	b0 01		 mov	 al, 1
$LN1@CanUseSkil:

; 213  : }

  00038	c9		 leave
  00039	c3		 ret	 0
?CanUseSkill@SHORSE@CInstanceBase@@QAE_NXZ ENDP		; CInstanceBase::SHORSE::CanUseSkill
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanAttack@SHORSE@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanAttack@SHORSE@CInstanceBase@@QAE_NXZ PROC		; CInstanceBase::SHORSE::CanAttack, COMDAT
; _this$ = ecx

; 216  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 217  : 	if (IsMounting())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	74 11		 je	 SHORT $LN2@CanAttack

; 218  : 		if (GetLevel()<=1)

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetLevel@SHORSE@CInstanceBase@@QAEIXZ ; CInstanceBase::SHORSE::GetLevel
  0001e	83 f8 01	 cmp	 eax, 1
  00021	77 04		 ja	 SHORT $LN2@CanAttack

; 219  : 			return false;

  00023	32 c0		 xor	 al, al
  00025	eb 02		 jmp	 SHORT $LN1@CanAttack
$LN2@CanAttack:

; 220  : 
; 221  : 	return true;

  00027	b0 01		 mov	 al, 1
$LN1@CanAttack:

; 222  : }

  00029	c9		 leave
  0002a	c3		 ret	 0
?CanAttack@SHORSE@CInstanceBase@@QAE_NXZ ENDP		; CInstanceBase::SHORSE::CanAttack
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ PROC		; CInstanceBase::SHORSE::IsMounting, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 	return m_isMounting;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 00		 mov	 al, BYTE PTR [eax]

; 227  : }

  0000c	c9		 leave
  0000d	c3		 ret	 0
?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ENDP		; CInstanceBase::SHORSE::IsMounting
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetActorPtr@SHORSE@CInstanceBase@@QAEPAVCActorInstance@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetActorPtr@SHORSE@CInstanceBase@@QAEPAVCActorInstance@@XZ PROC ; CInstanceBase::SHORSE::GetActorPtr, COMDAT
; _this$ = ecx

; 120  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  : 	return m_pkActor;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 122  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetActorPtr@SHORSE@CInstanceBase@@QAEPAVCActorInstance@@XZ ENDP ; CInstanceBase::SHORSE::GetActorPtr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ PROC ; CInstanceBase::SHORSE::GetActorRef, COMDAT
; _this$ = ecx

; 114  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 115  : 	assert(NULL!=m_pkActor && "CInstanceBase::SHORSE::GetActorRef");
; 116  : 	return *m_pkActor;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 117  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ ENDP ; CInstanceBase::SHORSE::GetActorRef
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Render@SHORSE@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_rkActor$ = -8						; size = 4
_this$ = -4						; size = 4
?Render@SHORSE@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::SHORSE::Render, COMDAT
; _this$ = ecx

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 240  : 	if (!IsMounting())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  00010	0f b6 c0	 movzx	 eax, al
  00013	85 c0		 test	 eax, eax
  00015	75 02		 jne	 SHORT $LN2@Render

; 241  : 		return;

  00017	eb 13		 jmp	 SHORT $LN1@Render
$LN2@Render:

; 242  : 
; 243  : 	CActorInstance& rkActor=GetActorRef();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::SHORSE::GetActorRef
  00021	89 45 f8	 mov	 DWORD PTR _rkActor$[ebp], eax

; 244  : 	rkActor.Render();

  00024	8b 4d f8	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00027	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render
$LN1@Render:

; 245  : }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?Render@SHORSE@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::SHORSE::Render
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Deform@SHORSE@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_rkActor$ = -8						; size = 4
_this$ = -4						; size = 4
?Deform@SHORSE@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::SHORSE::Deform, COMDAT
; _this$ = ecx

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 231  : 	if (!IsMounting())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  00010	0f b6 c0	 movzx	 eax, al
  00013	85 c0		 test	 eax, eax
  00015	75 02		 jne	 SHORT $LN2@Deform

; 232  : 		return;

  00017	eb 13		 jmp	 SHORT $LN1@Deform
$LN2@Deform:

; 233  : 
; 234  : 	CActorInstance& rkActor=GetActorRef();

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::SHORSE::GetActorRef
  00021	89 45 f8	 mov	 DWORD PTR _rkActor$[ebp], eax

; 235  : 	rkActor.INSTANCEBASE_Deform();

  00024	8b 4d f8	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00027	e8 00 00 00 00	 call	 ?INSTANCEBASE_Deform@CActorInstance@@QAEXXZ ; CActorInstance::INSTANCEBASE_Deform
$LN1@Deform:

; 236  : }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?Deform@SHORSE@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::SHORSE::Deform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetMoveSpeed@SHORSE@CInstanceBase@@QAEXI@Z
_TEXT	SEGMENT
tv80 = -20						; size = 8
_rkActor$ = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
_uMovSpd$ = 8						; size = 4
?SetMoveSpeed@SHORSE@CInstanceBase@@QAEXI@Z PROC	; CInstanceBase::SHORSE::SetMoveSpeed, COMDAT
; _this$ = ecx

; 64   : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 65   : 	if (!IsMounting())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 02		 jne	 SHORT $LN2@SetMoveSpe

; 66   : 		return;

  00018	eb 45		 jmp	 SHORT $LN1@SetMoveSpe
$LN2@SetMoveSpe:

; 67   : 
; 68   : 	CActorInstance& rkActor=GetActorRef();

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::SHORSE::GetActorRef
  00022	89 45 f4	 mov	 DWORD PTR _rkActor$[ebp], eax

; 69   : 	rkActor.SetMoveSpeed(uMovSpd/100.0f);

  00025	8b 45 08	 mov	 eax, DWORD PTR _uMovSpd$[ebp]
  00028	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  0002b	f2 0f 2a 45 f8	 cvtsi2sd xmm0, DWORD PTR tv76[ebp]
  00030	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]
  00033	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00036	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0003f	f2 0f 11 45 ec	 movsd	 QWORD PTR tv80[ebp], xmm0
  00044	f2 0f 5a 45 ec	 cvtsd2ss xmm0, QWORD PTR tv80[ebp]
  00049	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00051	51		 push	 ecx
  00052	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00057	8b 4d f4	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  0005a	e8 00 00 00 00	 call	 ?SetMoveSpeed@CActorInstance@@QAEXM@Z ; CActorInstance::SetMoveSpeed
$LN1@SetMoveSpe:

; 70   : }

  0005f	c9		 leave
  00060	c2 04 00	 ret	 4
?SetMoveSpeed@SHORSE@CInstanceBase@@QAEXI@Z ENDP	; CInstanceBase::SHORSE::SetMoveSpeed
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetAttackSpeed@SHORSE@CInstanceBase@@QAEXI@Z
_TEXT	SEGMENT
tv80 = -20						; size = 8
_rkActor$ = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
_uAtkSpd$ = 8						; size = 4
?SetAttackSpeed@SHORSE@CInstanceBase@@QAEXI@Z PROC	; CInstanceBase::SHORSE::SetAttackSpeed, COMDAT
; _this$ = ecx

; 55   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 56   : 	if (!IsMounting())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 02		 jne	 SHORT $LN2@SetAttackS

; 57   : 		return;

  00018	eb 45		 jmp	 SHORT $LN1@SetAttackS
$LN2@SetAttackS:

; 58   : 
; 59   : 	CActorInstance& rkActor=GetActorRef();

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::SHORSE::GetActorRef
  00022	89 45 f4	 mov	 DWORD PTR _rkActor$[ebp], eax

; 60   : 	rkActor.SetAttackSpeed(uAtkSpd/100.0f);	

  00025	8b 45 08	 mov	 eax, DWORD PTR _uAtkSpd$[ebp]
  00028	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  0002b	f2 0f 2a 45 f8	 cvtsi2sd xmm0, DWORD PTR tv76[ebp]
  00030	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]
  00033	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00036	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0003f	f2 0f 11 45 ec	 movsd	 QWORD PTR tv80[ebp], xmm0
  00044	f2 0f 5a 45 ec	 cvtsd2ss xmm0, QWORD PTR tv80[ebp]
  00049	f3 0f 5e 05 00
	00 00 00	 divss	 xmm0, DWORD PTR __real@42c80000
  00051	51		 push	 ecx
  00052	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00057	8b 4d f4	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  0005a	e8 00 00 00 00	 call	 ?SetAttackSpeed@CActorInstance@@QAEXM@Z ; CActorInstance::SetAttackSpeed
$LN1@SetAttackS:

; 61   : }

  0005f	c9		 leave
  00060	c2 04 00	 ret	 4
?SetAttackSpeed@SHORSE@CInstanceBase@@QAEXI@Z ENDP	; CInstanceBase::SHORSE::SetAttackSpeed
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z
_TEXT	SEGMENT
tv129 = -40						; size = 4
$T2 = -36						; size = 4
tv76 = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
_this$ = -20						; size = 4
_rkActor$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_c_rkPPos$ = 8						; size = 4
_eRace$ = 12						; size = 4
_eHitEffect$ = 16					; size = 4
?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z PROC ; CInstanceBase::SHORSE::Create, COMDAT
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 74   : 	assert(NULL==m_pkActor && "CInstanceBase::SHORSE::Create - ALREADY MOUNT");
; 75   : 
; 76   : 	m_pkActor=new CActorInstance;

  00028	68 b0 04 00 00	 push	 1200			; 000004b0H
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00032	59		 pop	 ecx
  00033	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  00036	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  0003a	83 7d e4 00	 cmp	 DWORD PTR $T3[ebp], 0
  0003e	74 0d		 je	 SHORT $LN4@Create
  00040	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  00043	e8 00 00 00 00	 call	 ??0CActorInstance@@QAE@XZ ; CActorInstance::CActorInstance
  00048	89 45 e0	 mov	 DWORD PTR tv76[ebp], eax
  0004b	eb 04		 jmp	 SHORT $LN5@Create
$LN4@Create:
  0004d	83 65 e0 00	 and	 DWORD PTR tv76[ebp], 0
$LN5@Create:
  00051	8b 45 e0	 mov	 eax, DWORD PTR tv76[ebp]
  00054	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  00057	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0005b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  00061	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 77   : 
; 78   : 	CActorInstance& rkActor=GetActorRef();

  00064	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?GetActorRef@SHORSE@CInstanceBase@@QAEAAVCActorInstance@@XZ ; CInstanceBase::SHORSE::GetActorRef
  0006c	89 45 f0	 mov	 DWORD PTR _rkActor$[ebp], eax

; 79   : 	rkActor.SetEventHandler(CActorInstance::IEventHandler::GetEmptyPtr());

  0006f	e8 00 00 00 00	 call	 ?GetEmptyPtr@IEventHandler@CActorInstance@@SAPAV12@XZ ; CActorInstance::IEventHandler::GetEmptyPtr
  00074	50		 push	 eax
  00075	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00078	e8 00 00 00 00	 call	 ?SetEventHandler@CActorInstance@@QAEXPAVIEventHandler@1@@Z ; CActorInstance::SetEventHandler

; 80   : 	if (!rkActor.SetRace(eRace))

  0007d	ff 75 0c	 push	 DWORD PTR _eRace$[ebp]
  00080	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00083	e8 00 00 00 00	 call	 ?SetRace@CActorInstance@@QAE_NK@Z ; CActorInstance::SetRace
  00088	0f b6 c0	 movzx	 eax, al
  0008b	85 c0		 test	 eax, eax
  0008d	75 30		 jne	 SHORT $LN2@Create

; 81   : 	{
; 82   : 		delete m_pkActor;

  0008f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00095	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
  00098	83 7d e8 00	 cmp	 DWORD PTR $T4[ebp], 0
  0009c	74 11		 je	 SHORT $LN6@Create
  0009e	6a 01		 push	 1
  000a0	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  000a3	8b 00		 mov	 eax, DWORD PTR [eax]
  000a5	8b 4d e8	 mov	 ecx, DWORD PTR $T4[ebp]
  000a8	ff 10		 call	 DWORD PTR [eax]
  000aa	89 45 d8	 mov	 DWORD PTR tv129[ebp], eax
  000ad	eb 04		 jmp	 SHORT $LN7@Create
$LN6@Create:
  000af	83 65 d8 00	 and	 DWORD PTR tv129[ebp], 0
$LN7@Create:

; 83   : 		m_pkActor=NULL;

  000b3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 84   : 		return;

  000ba	e9 b8 00 00 00	 jmp	 $LN1@Create
$LN2@Create:

; 85   : 	}
; 86   : 
; 87   : 	rkActor.SetShape(0);

  000bf	51		 push	 ecx
  000c0	0f 57 c0	 xorps	 xmm0, xmm0
  000c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c8	6a 00		 push	 0
  000ca	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  000cd	e8 00 00 00 00	 call	 ?SetShape@CActorInstance@@QAEXKM@Z ; CActorInstance::SetShape

; 88   : 	rkActor.SetBattleHitEffect(eHitEffect);

  000d2	ff 75 10	 push	 DWORD PTR _eHitEffect$[ebp]
  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  000d8	e8 00 00 00 00	 call	 ?SetBattleHitEffect@CActorInstance@@QAEXK@Z ; CActorInstance::SetBattleHitEffect

; 89   : 	rkActor.SetAlphaValue(0.0f);

  000dd	51		 push	 ecx
  000de	0f 57 c0	 xorps	 xmm0, xmm0
  000e1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000e6	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  000e9	e8 00 00 00 00	 call	 ?SetAlphaValue@CActorInstance@@QAEXM@Z ; CActorInstance::SetAlphaValue

; 90   : 	rkActor.BlendAlphaValue(1.0f, 0.5f);

  000ee	51		 push	 ecx
  000ef	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  000f7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000fc	51		 push	 ecx
  000fd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00105	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010a	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  0010d	e8 00 00 00 00	 call	 ?BlendAlphaValue@CActorInstance@@QAEXMM@Z ; CActorInstance::BlendAlphaValue

; 91   : 	rkActor.SetMoveSpeed(1.0f);

  00112	51		 push	 ecx
  00113	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0011b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00120	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00123	e8 00 00 00 00	 call	 ?SetMoveSpeed@CActorInstance@@QAEXM@Z ; CActorInstance::SetMoveSpeed

; 92   : 	rkActor.SetAttackSpeed(1.0f);

  00128	51		 push	 ecx
  00129	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00131	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00136	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00139	e8 00 00 00 00	 call	 ?SetAttackSpeed@CActorInstance@@QAEXM@Z ; CActorInstance::SetAttackSpeed

; 93   : 	rkActor.SetMotionMode(CRaceMotionData::MODE_GENERAL);

  0013e	6a 01		 push	 1
  00140	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00143	e8 00 00 00 00	 call	 ?SetMotionMode@CActorInstance@@QAEXH@Z ; CActorInstance::SetMotionMode

; 94   : 	rkActor.Stop();

  00148	51		 push	 ecx
  00149	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  00151	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00156	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00159	e8 00 00 00 00	 call	 ?Stop@CActorInstance@@QAEXM@Z ; CActorInstance::Stop

; 95   : 	rkActor.RefreshActorInstance();

  0015e	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  00161	e8 00 00 00 00	 call	 ?RefreshActorInstance@CActorInstance@@QAEXXZ ; CActorInstance::RefreshActorInstance

; 96   : 
; 97   : 	rkActor.SetCurPixelPosition(c_rkPPos);

  00166	ff 75 08	 push	 DWORD PTR _c_rkPPos$[ebp]
  00169	8b 4d f0	 mov	 ecx, DWORD PTR _rkActor$[ebp]
  0016c	e8 00 00 00 00	 call	 ?SetCurPixelPosition@CActorInstance@@QAEXABUD3DXVECTOR3@@@Z ; CActorInstance::SetCurPixelPosition

; 98   : 
; 99   : 	m_isMounting=true;

  00171	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00174	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN1@Create:

; 100  : }

  00177	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00181	59		 pop	 ecx
  00182	c9		 leave
  00183	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z$0:
  00000	68 b0 04 00 00	 push	 1200			; 000004b0H
  00005	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  00008	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx
  0000f	c3		 ret	 0
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z ENDP ; CInstanceBase::SHORSE::Create
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Destroy@SHORSE@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
tv79 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?Destroy@SHORSE@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::SHORSE::Destroy, COMDAT
; _this$ = ecx

; 103  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  : 	if (m_pkActor)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 2f		 je	 SHORT $LN2@Destroy

; 105  : 	{
; 106  : 		m_pkActor->Destroy();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00018	e8 00 00 00 00	 call	 ?Destroy@CActorInstance@@QAEXXZ ; CActorInstance::Destroy

; 107  : 		delete m_pkActor;	

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00023	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00026	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  0002a	74 11		 je	 SHORT $LN4@Destroy
  0002c	6a 01		 push	 1
  0002e	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00031	8b 00		 mov	 eax, DWORD PTR [eax]
  00033	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00036	ff 10		 call	 DWORD PTR [eax]
  00038	89 45 f4	 mov	 DWORD PTR tv79[ebp], eax
  0003b	eb 04		 jmp	 SHORT $LN2@Destroy
$LN4@Destroy:
  0003d	83 65 f4 00	 and	 DWORD PTR tv79[ebp], 0
$LN2@Destroy:

; 108  : 	}	
; 109  : 
; 110  : 	__Initialize();

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?__Initialize@SHORSE@CInstanceBase@@QAEXXZ ; CInstanceBase::SHORSE::__Initialize

; 111  : }

  00049	c9		 leave
  0004a	c3		 ret	 0
?Destroy@SHORSE@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::SHORSE::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ??1SHORSE@CInstanceBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1SHORSE@CInstanceBase@@QAE@XZ PROC			; CInstanceBase::SHORSE::~SHORSE, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   : 	assert(m_pkActor==NULL);
; 46   : }

  00007	c9		 leave
  00008	c3		 ret	 0
??1SHORSE@CInstanceBase@@QAE@XZ ENDP			; CInstanceBase::SHORSE::~SHORSE
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ??0SHORSE@CInstanceBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0SHORSE@CInstanceBase@@QAE@XZ PROC			; CInstanceBase::SHORSE::SHORSE, COMDAT
; _this$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 40   : 	__Initialize();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__Initialize@SHORSE@CInstanceBase@@QAEXXZ ; CInstanceBase::SHORSE::__Initialize

; 41   : }

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c9		 leave
  00013	c3		 ret	 0
??0SHORSE@CInstanceBase@@QAE@XZ ENDP			; CInstanceBase::SHORSE::SHORSE
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__DetachHorseSaddle@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__DetachHorseSaddle@CInstanceBase@@IAEXXZ PROC		; CInstanceBase::__DetachHorseSaddle, COMDAT
; _this$ = ecx

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 	if (!IsMountingHorse())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsMountingHorse@CInstanceBase@@QAEHXZ ; CInstanceBase::IsMountingHorse
  0000f	85 c0		 test	 eax, eax
  00011	75 02		 jne	 SHORT $LN2@DetachHors

; 257  : 		return;

  00013	eb 18		 jmp	 SHORT $LN1@DetachHors
$LN2@DetachHors:

; 258  : 	m_kHorse.m_pkActor->DetachModelInstance(CRaceData::PART_MAIN, m_GraphicThingInstance, CRaceData::PART_MAIN);

  00015	6a 00		 push	 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	05 d4 01 00 00	 add	 eax, 468		; 000001d4H
  0001f	50		 push	 eax
  00020	6a 00		 push	 0
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00028	e8 00 00 00 00	 call	 ?DetachModelInstance@CGraphicThingInstance@@QAEXHAAV1@H@Z ; CGraphicThingInstance::DetachModelInstance
$LN1@DetachHors:

; 259  : }

  0002d	c9		 leave
  0002e	c3		 ret	 0
?__DetachHorseSaddle@CInstanceBase@@IAEXXZ ENDP		; CInstanceBase::__DetachHorseSaddle
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__AttachHorseSaddle@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__AttachHorseSaddle@CInstanceBase@@IAEXXZ PROC		; CInstanceBase::__AttachHorseSaddle, COMDAT
; _this$ = ecx

; 248  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 249  : 	if (!IsMountingHorse())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsMountingHorse@CInstanceBase@@QAEHXZ ; CInstanceBase::IsMountingHorse
  0000f	85 c0		 test	 eax, eax
  00011	75 02		 jne	 SHORT $LN2@AttachHors

; 250  : 		return;

  00013	eb 1d		 jmp	 SHORT $LN1@AttachHors
$LN2@AttachHors:

; 251  : 	m_kHorse.m_pkActor->AttachModelInstance(CRaceData::PART_MAIN, "saddle", m_GraphicThingInstance, CRaceData::PART_MAIN);

  00015	6a 00		 push	 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	05 d4 01 00 00	 add	 eax, 468		; 000001d4H
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_06PNAKCKLH@saddle@
  00025	6a 00		 push	 0
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002d	e8 00 00 00 00	 call	 ?AttachModelInstance@CGraphicThingInstance@@QAEXHPBDAAV1@H@Z ; CGraphicThingInstance::AttachModelInstance
$LN1@AttachHors:

; 252  : }

  00032	c9		 leave
  00033	c3		 ret	 0
?__AttachHorseSaddle@CInstanceBase@@IAEXXZ ENDP		; CInstanceBase::__AttachHorseSaddle
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__IsInViewFrustum@CInstanceBase@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__IsInViewFrustum@CInstanceBase@@IAE_NXZ PROC		; CInstanceBase::__IsInViewFrustum, COMDAT
; _this$ = ecx

; 2452 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2453 : 	return m_GraphicThingInstance.isShow();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?isShow@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::isShow

; 2454 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?__IsInViewFrustum@CInstanceBase@@IAE_NXZ ENDP		; CInstanceBase::__IsInViewFrustum
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__CanRender@CInstanceBase@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__CanRender@CInstanceBase@@IAE_NXZ PROC		; CInstanceBase::__CanRender, COMDAT
; _this$ = ecx

; 2457 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2458 : 	if (!__IsInViewFrustum())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__IsInViewFrustum@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsInViewFrustum
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 04		 jne	 SHORT $LN2@CanRender

; 2459 : 		return false;

  00016	32 c0		 xor	 al, al
  00018	eb 17		 jmp	 SHORT $LN1@CanRender
$LN2@CanRender:

; 2460 : 	if (IsAffect(AFFECT_INVISIBILITY))

  0001a	6a 01		 push	 1
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?IsAffect@CInstanceBase@@QAE_NI@Z ; CInstanceBase::IsAffect
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	74 04		 je	 SHORT $LN3@CanRender

; 2461 : 		return false;

  0002b	32 c0		 xor	 al, al
  0002d	eb 02		 jmp	 SHORT $LN1@CanRender
$LN3@CanRender:

; 2462 : 
; 2463 : 	return true;

  0002f	b0 01		 mov	 al, 1
$LN1@CanRender:

; 2464 : }

  00031	c9		 leave
  00032	c3		 ret	 0
?__CanRender@CInstanceBase@@IAE_NXZ ENDP		; CInstanceBase::__CanRender
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__IsEnableTCPProcess@CInstanceBase@@IAEHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eCurFunc$ = 8						; size = 4
?__IsEnableTCPProcess@CInstanceBase@@IAEHI@Z PROC	; CInstanceBase::__IsEnableTCPProcess, COMDAT
; _this$ = ecx

; 1260 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1261 : 	if (m_GraphicThingInstance.IsActEmotion())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsActEmotion@CActorInstance@@QAEHXZ ; CActorInstance::IsActEmotion
  00015	85 c0		 test	 eax, eax
  00017	74 04		 je	 SHORT $LN2@IsEnableTC

; 1262 : 	{
; 1263 : 		return FALSE;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 19		 jmp	 SHORT $LN1@IsEnableTC
$LN2@IsEnableTC:

; 1264 : 	}
; 1265 : 
; 1266 : 	if (!m_bEnableTCPState)

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 b8 d0 01 00
	00 00		 cmp	 DWORD PTR [eax+464], 0
  00027	75 0a		 jne	 SHORT $LN3@IsEnableTC

; 1267 : 	{
; 1268 : 		if (FUNC_EMOTION != eCurFunc)

  00029	83 7d 08 05	 cmp	 DWORD PTR _eCurFunc$[ebp], 5
  0002d	74 04		 je	 SHORT $LN3@IsEnableTC

; 1269 : 		{
; 1270 : 			return FALSE;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 03		 jmp	 SHORT $LN1@IsEnableTC
$LN3@IsEnableTC:

; 1271 : 		}
; 1272 : 	}
; 1273 : 
; 1274 : 	return TRUE;

  00033	33 c0		 xor	 eax, eax
  00035	40		 inc	 eax
$LN1@IsEnableTC:

; 1275 : }

  00036	c9		 leave
  00037	c2 04 00	 ret	 4
?__IsEnableTCPProcess@CInstanceBase@@IAEHI@Z ENDP	; CInstanceBase::__IsEnableTCPProcess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__ProcessFunctionEmotion@CInstanceBase@@IAEXKKABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_JOB_NUM$1 = -52					; size = 4
_JOB_NUM$2 = -48					; size = 4
_src_job$3 = -44					; size = 4
_dst_job$4 = -40					; size = 4
_race$ = -36						; size = 4
_race$ = -32						; size = 4
_rPlayer$5 = -28					; size = 4
_rPlayer$6 = -24					; size = 4
tv88 = -20						; size = 4
_this$ = -16						; size = 4
_pTargetInstance$ = -12					; size = 4
_wMotionNumber2$7 = -8					; size = 2
_wMotionNumber1$8 = -4					; size = 2
_dwMotionNumber$ = 8					; size = 4
_dwTargetVID$ = 12					; size = 4
_c_rkPosDst$ = 16					; size = 4
?__ProcessFunctionEmotion@CInstanceBase@@IAEXKKABUD3DXVECTOR3@@@Z PROC ; CInstanceBase::__ProcessFunctionEmotion, COMDAT
; _this$ = ecx

; 1816 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1817 : 	if (IsWalking())

  00009	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  00011	85 c0		 test	 eax, eax
  00013	74 08		 je	 SHORT $LN2@ProcessFun

; 1818 : 		EndWalkingWithoutBlending();

  00015	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?EndWalkingWithoutBlending@CInstanceBase@@QAEXXZ ; CInstanceBase::EndWalkingWithoutBlending
$LN2@ProcessFun:

; 1819 : 
; 1820 : 	__EnableChangingTCPState();

  0001d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?__EnableChangingTCPState@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableChangingTCPState

; 1821 : 	SCRIPT_SetPixelPosition(c_rkPosDst.x, c_rkPosDst.y);

  00025	8b 45 10	 mov	 eax, DWORD PTR _c_rkPosDst$[ebp]
  00028	51		 push	 ecx
  00029	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0002e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00033	8b 45 10	 mov	 eax, DWORD PTR _c_rkPosDst$[ebp]
  00036	51		 push	 ecx
  00037	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0003b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00040	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition

; 1822 : 
; 1823 : 	CInstanceBase * pTargetInstance = CPythonCharacterManager::Instance().GetInstancePtr(dwTargetVID);

  00048	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0004d	83 c0 04	 add	 eax, 4
  00050	89 45 ec	 mov	 DWORD PTR tv88[ebp], eax
  00053	ff 75 0c	 push	 DWORD PTR _dwTargetVID$[ebp]
  00056	8b 45 ec	 mov	 eax, DWORD PTR tv88[ebp]
  00059	8b 00		 mov	 eax, DWORD PTR [eax]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR tv88[ebp]
  0005e	ff 50 08	 call	 DWORD PTR [eax+8]
  00061	89 45 f4	 mov	 DWORD PTR _pTargetInstance$[ebp], eax

; 1824 : 	if (pTargetInstance)

  00064	83 7d f4 00	 cmp	 DWORD PTR _pTargetInstance$[ebp], 0
  00068	0f 84 a2 01 00
	00		 je	 $LN5@ProcessFun

; 1825 : 	{
; 1826 : 		pTargetInstance->__EnableChangingTCPState();

  0006e	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  00071	e8 00 00 00 00	 call	 ?__EnableChangingTCPState@CInstanceBase@@IAEXXZ ; CInstanceBase::__EnableChangingTCPState

; 1827 : 
; 1828 : 		if (pTargetInstance->IsWalking())

  00076	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  00079	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  0007e	85 c0		 test	 eax, eax
  00080	74 08		 je	 SHORT $LN4@ProcessFun

; 1829 : 			pTargetInstance->EndWalkingWithoutBlending();

  00082	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  00085	e8 00 00 00 00	 call	 ?EndWalkingWithoutBlending@CInstanceBase@@QAEXXZ ; CInstanceBase::EndWalkingWithoutBlending
$LN4@ProcessFun:

; 1830 : 
; 1831 : 		WORD wMotionNumber1 = HIWORD(dwMotionNumber);

  0008a	8b 45 08	 mov	 eax, DWORD PTR _dwMotionNumber$[ebp]
  0008d	c1 e8 10	 shr	 eax, 16			; 00000010H
  00090	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00095	66 89 45 fc	 mov	 WORD PTR _wMotionNumber1$8[ebp], ax

; 1832 : 		WORD wMotionNumber2 = LOWORD(dwMotionNumber);

  00099	8b 45 08	 mov	 eax, DWORD PTR _dwMotionNumber$[ebp]
  0009c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000a1	66 89 45 f8	 mov	 WORD PTR _wMotionNumber2$7[ebp], ax

; 1834 : 		int src_job = RaceToJob(GetRace());

  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  000ad	89 45 e0	 mov	 DWORD PTR _race$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.h

; 1108 : 	const int JOB_NUM = 4;

  000b0	c7 45 d0 04 00
	00 00		 mov	 DWORD PTR _JOB_NUM$2[ebp], 4

; 1109 : 	return race % JOB_NUM;

  000b7	8b 45 e0	 mov	 eax, DWORD PTR _race$[ebp]
  000ba	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000bf	79 05		 jns	 SHORT $LN18@ProcessFun
  000c1	48		 dec	 eax
  000c2	83 c8 fc	 or	 eax, -4			; fffffffcH
  000c5	40		 inc	 eax
$LN18@ProcessFun:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1834 : 		int src_job = RaceToJob(GetRace());

  000c6	89 45 d4	 mov	 DWORD PTR _src_job$3[ebp], eax

; 1835 : 		int dst_job = RaceToJob(pTargetInstance->GetRace());

  000c9	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  000cc	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  000d1	89 45 dc	 mov	 DWORD PTR _race$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.h

; 1108 : 	const int JOB_NUM = 4;

  000d4	c7 45 cc 04 00
	00 00		 mov	 DWORD PTR _JOB_NUM$1[ebp], 4

; 1109 : 	return race % JOB_NUM;

  000db	8b 45 dc	 mov	 eax, DWORD PTR _race$[ebp]
  000de	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  000e3	79 05		 jns	 SHORT $LN19@ProcessFun
  000e5	48		 dec	 eax
  000e6	83 c8 fc	 or	 eax, -4			; fffffffcH
  000e9	40		 inc	 eax
$LN19@ProcessFun:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1835 : 		int dst_job = RaceToJob(pTargetInstance->GetRace());

  000ea	89 45 d8	 mov	 DWORD PTR _dst_job$4[ebp], eax

; 1836 : 
; 1837 : 		NEW_LookAtDestInstance(*pTargetInstance);

  000ed	ff 75 f4	 push	 DWORD PTR _pTargetInstance$[ebp]
  000f0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	e8 00 00 00 00	 call	 ?NEW_LookAtDestInstance@CInstanceBase@@QAEXAAV1@@Z ; CInstanceBase::NEW_LookAtDestInstance

; 1838 : 		m_GraphicThingInstance.InterceptOnceMotion(wMotionNumber1 + dst_job);

  000f8	51		 push	 ecx
  000f9	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00101	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00106	6a 00		 push	 0
  00108	51		 push	 ecx
  00109	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00111	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00116	0f b7 45 fc	 movzx	 eax, WORD PTR _wMotionNumber1$8[ebp]
  0011a	03 45 d8	 add	 eax, DWORD PTR _dst_job$4[ebp]
  0011d	50		 push	 eax
  0011e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00121	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00127	e8 00 00 00 00	 call	 ?InterceptOnceMotion@CActorInstance@@QAE_NKMIM@Z ; CActorInstance::InterceptOnceMotion

; 1839 : 		m_GraphicThingInstance.SetRotation(m_GraphicThingInstance.GetTargetRotation());

  0012c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00135	e8 00 00 00 00	 call	 ?GetTargetRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetTargetRotation
  0013a	51		 push	 ecx
  0013b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0013e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00141	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00147	e8 00 00 00 00	 call	 ?SetRotation@CActorInstance@@QAEXM@Z ; CActorInstance::SetRotation

; 1840 : 		m_GraphicThingInstance.SetAdvancingRotation(m_GraphicThingInstance.GetTargetRotation());

  0014c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00155	e8 00 00 00 00	 call	 ?GetTargetRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetTargetRotation
  0015a	51		 push	 ecx
  0015b	d9 1c 24	 fstp	 DWORD PTR [esp]
  0015e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00167	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CActorInstance@@QAEXM@Z ; CActorInstance::SetAdvancingRotation

; 1841 : 
; 1842 : 		pTargetInstance->NEW_LookAtDestInstance(*this);

  0016c	ff 75 f0	 push	 DWORD PTR _this$[ebp]
  0016f	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  00172	e8 00 00 00 00	 call	 ?NEW_LookAtDestInstance@CInstanceBase@@QAEXAAV1@@Z ; CInstanceBase::NEW_LookAtDestInstance

; 1843 : 		pTargetInstance->m_GraphicThingInstance.InterceptOnceMotion(wMotionNumber2 + src_job);

  00177	51		 push	 ecx
  00178	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00180	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00185	6a 00		 push	 0
  00187	51		 push	 ecx
  00188	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3dcccccd
  00190	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00195	0f b7 45 f8	 movzx	 eax, WORD PTR _wMotionNumber2$7[ebp]
  00199	03 45 d4	 add	 eax, DWORD PTR _src_job$3[ebp]
  0019c	50		 push	 eax
  0019d	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  001a0	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  001a6	e8 00 00 00 00	 call	 ?InterceptOnceMotion@CActorInstance@@QAE_NKMIM@Z ; CActorInstance::InterceptOnceMotion

; 1844 : 		pTargetInstance->m_GraphicThingInstance.SetRotation(pTargetInstance->m_GraphicThingInstance.GetTargetRotation());

  001ab	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  001ae	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  001b4	e8 00 00 00 00	 call	 ?GetTargetRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetTargetRotation
  001b9	51		 push	 ecx
  001ba	d9 1c 24	 fstp	 DWORD PTR [esp]
  001bd	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  001c0	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  001c6	e8 00 00 00 00	 call	 ?SetRotation@CActorInstance@@QAEXM@Z ; CActorInstance::SetRotation

; 1845 : 		pTargetInstance->m_GraphicThingInstance.SetAdvancingRotation(pTargetInstance->m_GraphicThingInstance.GetTargetRotation());

  001cb	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  001ce	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  001d4	e8 00 00 00 00	 call	 ?GetTargetRotation@CActorInstance@@QAEMXZ ; CActorInstance::GetTargetRotation
  001d9	51		 push	 ecx
  001da	d9 1c 24	 fstp	 DWORD PTR [esp]
  001dd	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  001e0	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  001e6	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CActorInstance@@QAEXM@Z ; CActorInstance::SetAdvancingRotation

; 1846 : 
; 1847 : 		if (pTargetInstance->__IsMainInstance())

  001eb	8b 4d f4	 mov	 ecx, DWORD PTR _pTargetInstance$[ebp]
  001ee	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  001f3	0f b6 c0	 movzx	 eax, al
  001f6	85 c0		 test	 eax, eax
  001f8	74 16		 je	 SHORT $LN5@ProcessFun

; 1848 : 		{
; 1849 : 			IAbstractPlayer & rPlayer=IAbstractPlayer::GetSingleton();

  001fa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  001ff	89 45 e8	 mov	 DWORD PTR _rPlayer$6[ebp], eax

; 1850 : 			rPlayer.EndEmotionProcess();

  00202	8b 45 e8	 mov	 eax, DWORD PTR _rPlayer$6[ebp]
  00205	8b 00		 mov	 eax, DWORD PTR [eax]
  00207	8b 4d e8	 mov	 ecx, DWORD PTR _rPlayer$6[ebp]
  0020a	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
$LN5@ProcessFun:

; 1851 : 		}
; 1852 : 	}
; 1853 : 
; 1854 : 	if (__IsMainInstance())

  00210	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00213	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  00218	0f b6 c0	 movzx	 eax, al
  0021b	85 c0		 test	 eax, eax
  0021d	74 16		 je	 SHORT $LN6@ProcessFun

; 1855 : 	{
; 1856 : 		IAbstractPlayer & rPlayer=IAbstractPlayer::GetSingleton();

  0021f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  00224	89 45 e4	 mov	 DWORD PTR _rPlayer$5[ebp], eax

; 1857 : 		rPlayer.EndEmotionProcess();

  00227	8b 45 e4	 mov	 eax, DWORD PTR _rPlayer$5[ebp]
  0022a	8b 00		 mov	 eax, DWORD PTR [eax]
  0022c	8b 4d e4	 mov	 ecx, DWORD PTR _rPlayer$5[ebp]
  0022f	ff 90 84 00 00
	00		 call	 DWORD PTR [eax+132]
$LN6@ProcessFun:

; 1858 : 	}
; 1859 : }

  00235	c9		 leave
  00236	c2 0c 00	 ret	 12			; 0000000cH
?__ProcessFunctionEmotion@CInstanceBase@@IAEXKKABUD3DXVECTOR3@@@Z ENDP ; CInstanceBase::__ProcessFunctionEmotion
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__IsInDustRange@CInstanceBase@@IAE_NXZ
_TEXT	SEGMENT
_pkInstMain$ = -12					; size = 4
_fDistance$ = -8					; size = 4
_this$ = -4						; size = 4
?__IsInDustRange@CInstanceBase@@IAE_NXZ PROC		; CInstanceBase::__IsInDustRange, COMDAT
; _this$ = ecx

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 390  : 	if (!__IsExistMainInstance())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__IsExistMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsExistMainInstance
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 04		 jne	 SHORT $LN2@IsInDustRa

; 391  : 		return false;

  00018	32 c0		 xor	 al, al
  0001a	eb 4b		 jmp	 SHORT $LN1@IsInDustRa
$LN2@IsInDustRa:

; 392  : 
; 393  : 	CInstanceBase* pkInstMain=__GetMainInstancePtr();

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?__GetMainInstancePtr@CInstanceBase@@IAEPAV1@XZ ; CInstanceBase::__GetMainInstancePtr
  00024	89 45 f4	 mov	 DWORD PTR _pkInstMain$[ebp], eax

; 394  : 
; 395  : 	float fDistance=NEW_GetDistanceFromDestInstance(*pkInstMain);

  00027	ff 75 f4	 push	 DWORD PTR _pkInstMain$[ebp]
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?NEW_GetDistanceFromDestInstance@CInstanceBase@@QAEMAAV1@@Z ; CInstanceBase::NEW_GetDistanceFromDestInstance
  00032	d9 5d f8	 fstp	 DWORD PTR _fDistance$[ebp]

; 396  : 
; 397  : 	if (IsPC())

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  0003d	85 c0		 test	 eax, eax
  0003f	74 12		 je	 SHORT $LN4@IsInDustRa

; 398  : 	{
; 399  : 		if (fDistance<=PC_DUST_RANGE)

  00041	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44fa0000
  00049	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fDistance$[ebp]
  0004d	72 04		 jb	 SHORT $LN4@IsInDustRa

; 400  : 			return true;

  0004f	b0 01		 mov	 al, 1
  00051	eb 14		 jmp	 SHORT $LN1@IsInDustRa
$LN4@IsInDustRa:

; 401  : 	}
; 402  : 
; 403  : 	if (fDistance<=NPC_DUST_RANGE)

  00053	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@447a0000
  0005b	0f 2f 45 f8	 comiss	 xmm0, DWORD PTR _fDistance$[ebp]
  0005f	72 04		 jb	 SHORT $LN5@IsInDustRa

; 404  : 		return true;

  00061	b0 01		 mov	 al, 1
  00063	eb 02		 jmp	 SHORT $LN1@IsInDustRa
$LN5@IsInDustRa:

; 405  : 
; 406  : 	return false;

  00065	32 c0		 xor	 al, al
$LN1@IsInDustRa:

; 407  : }

  00067	c9		 leave
  00068	c3		 ret	 0
?__IsInDustRange@CInstanceBase@@IAE_NXZ ENDP		; CInstanceBase::__IsInDustRange
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__CanProcessNetworkStatePacket@CInstanceBase@@IAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__CanProcessNetworkStatePacket@CInstanceBase@@IAEHXZ PROC ; CInstanceBase::__CanProcessNetworkStatePacket, COMDAT
; _this$ = ecx

; 1247 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1248 : 	if (m_GraphicThingInstance.IsDead())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsDead@CActorInstance@@QAEHXZ ; CActorInstance::IsDead
  00015	85 c0		 test	 eax, eax
  00017	74 04		 je	 SHORT $LN2@CanProcess

; 1249 : 		return FALSE;

  00019	33 c0		 xor	 eax, eax
  0001b	eb 41		 jmp	 SHORT $LN1@CanProcess
$LN2@CanProcess:

; 1250 : 	if (m_GraphicThingInstance.IsKnockDown())

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00026	e8 00 00 00 00	 call	 ?IsKnockDown@CActorInstance@@QAEHXZ ; CActorInstance::IsKnockDown
  0002b	85 c0		 test	 eax, eax
  0002d	74 04		 je	 SHORT $LN3@CanProcess

; 1251 : 		return FALSE;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 2b		 jmp	 SHORT $LN1@CanProcess
$LN3@CanProcess:

; 1252 : 	if (m_GraphicThingInstance.IsUsingSkill())

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0003c	e8 00 00 00 00	 call	 ?IsUsingSkill@CActorInstance@@QAEHXZ ; CActorInstance::IsUsingSkill
  00041	85 c0		 test	 eax, eax
  00043	74 16		 je	 SHORT $LN4@CanProcess

; 1253 : 		if (!m_GraphicThingInstance.CanCancelSkill())

  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0004e	e8 00 00 00 00	 call	 ?CanCancelSkill@CActorInstance@@QAEHXZ ; CActorInstance::CanCancelSkill
  00053	85 c0		 test	 eax, eax
  00055	75 04		 jne	 SHORT $LN4@CanProcess

; 1254 : 			return FALSE;

  00057	33 c0		 xor	 eax, eax
  00059	eb 03		 jmp	 SHORT $LN1@CanProcess
$LN4@CanProcess:

; 1255 : 
; 1256 : 	return TRUE;

  0005b	33 c0		 xor	 eax, eax
  0005d	40		 inc	 eax
$LN1@CanProcess:

; 1257 : }

  0005e	c9		 leave
  0005f	c3		 ret	 0
?__CanProcessNetworkStatePacket@CInstanceBase@@IAEHXZ ENDP ; CInstanceBase::__CanProcessNetworkStatePacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__ClearMainInstance@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rkChrMgr$ = -4						; size = 4
?__ClearMainInstance@CInstanceBase@@IAEXXZ PROC		; CInstanceBase::__ClearMainInstance, COMDAT
; _this$ = ecx

; 664  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 665  : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0000d	89 45 fc	 mov	 DWORD PTR _rkChrMgr$[ebp], eax

; 666  : 	rkChrMgr.ClearMainInstance();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _rkChrMgr$[ebp]
  00013	e8 00 00 00 00	 call	 ?ClearMainInstance@CPythonCharacterManager@@QAEXXZ ; CPythonCharacterManager::ClearMainInstance

; 667  : }

  00018	c9		 leave
  00019	c3		 ret	 0
?__ClearMainInstance@CInstanceBase@@IAEXXZ ENDP		; CInstanceBase::__ClearMainInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__DisableSkipCollision@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__DisableSkipCollision@CInstanceBase@@IAEXXZ PROC	; CInstanceBase::__DisableSkipCollision, COMDAT
; _this$ = ecx

; 420  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 421  : 	m_GraphicThingInstance.DisableSkipCollision();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?DisableSkipCollision@CActorInstance@@QAEXXZ ; CActorInstance::DisableSkipCollision

; 422  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?__DisableSkipCollision@CInstanceBase@@IAEXXZ ENDP	; CInstanceBase::__DisableSkipCollision
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__EnableSkipCollision@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__EnableSkipCollision@CInstanceBase@@IAEXXZ PROC	; CInstanceBase::__EnableSkipCollision, COMDAT
; _this$ = ecx

; 410  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 411  : 	if (__IsMainInstance())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	74 0d		 je	 SHORT $LN2@EnableSkip

; 412  : 	{
; 413  : 		TraceError("CInstanceBase::__EnableSkipCollision -    !!");

  00016	68 00 00 00 00	 push	 OFFSET ??_C@_0EL@PHAIMNFF@CInstanceBase?3?3__EnableSkipColl@
  0001b	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00020	59		 pop	 ecx

; 414  : 		return;

  00021	eb 0e		 jmp	 SHORT $LN1@EnableSkip
$LN2@EnableSkip:

; 415  : 	}
; 416  : 	m_GraphicThingInstance.EnableSkipCollision();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0002c	e8 00 00 00 00	 call	 ?EnableSkipCollision@CActorInstance@@QAEXXZ ; CActorInstance::EnableSkipCollision
$LN1@EnableSkip:

; 417  : }

  00031	c9		 leave
  00032	c3		 ret	 0
?__EnableSkipCollision@CInstanceBase@@IAEXXZ ENDP	; CInstanceBase::__EnableSkipCollision
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__IsChangableWeapon@CInstanceBase@@IAEHH@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
_i$1 = -28						; size = 4
_c_iBouquets$2 = -24					; size = 20
__$ArrayPad$ = -4					; size = 4
_iWeaponID$ = 8						; size = 4
?__IsChangableWeapon@CInstanceBase@@IAEHH@Z PROC	; CInstanceBase::__IsChangableWeapon, COMDAT
; _this$ = ecx

; 901  : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 902  : 	//       ..
; 903  : 	if (IsWearingDress())

  00013	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?IsWearingDress@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWearingDress
  0001b	85 c0		 test	 eax, eax
  0001d	74 50		 je	 SHORT $LN5@IsChangabl

; 904  : 	{
; 905  : 		const int c_iBouquets[] =
; 906  : 		{
; 907  : 			50201,	// Bouquet for Assassin

  0001f	c7 45 e8 19 c4
	00 00		 mov	 DWORD PTR _c_iBouquets$2[ebp], 50201 ; 0000c419H

; 908  : 			50202,	// Bouquet for Shaman

  00026	c7 45 ec 1a c4
	00 00		 mov	 DWORD PTR _c_iBouquets$2[ebp+4], 50202 ; 0000c41aH

; 909  : 			50203,

  0002d	c7 45 f0 1b c4
	00 00		 mov	 DWORD PTR _c_iBouquets$2[ebp+8], 50203 ; 0000c41bH

; 910  : 			50204,

  00034	c7 45 f4 1c c4
	00 00		 mov	 DWORD PTR _c_iBouquets$2[ebp+12], 50204 ; 0000c41cH

; 911  : 			0, // #0000545: [M2CN]     

  0003b	83 65 f8 00	 and	 DWORD PTR _c_iBouquets$2[ebp+16], 0

; 912  : 		};
; 913  : 
; 914  : 		for (int i = 0; c_iBouquets[i] != 0; ++i)

  0003f	83 65 e4 00	 and	 DWORD PTR _i$1[ebp], 0
  00043	eb 07		 jmp	 SHORT $LN4@IsChangabl
$LN2@IsChangabl:
  00045	8b 45 e4	 mov	 eax, DWORD PTR _i$1[ebp]
  00048	40		 inc	 eax
  00049	89 45 e4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@IsChangabl:
  0004c	8b 45 e4	 mov	 eax, DWORD PTR _i$1[ebp]
  0004f	83 7c 85 e8 00	 cmp	 DWORD PTR _c_iBouquets$2[ebp+eax*4], 0
  00054	74 13		 je	 SHORT $LN3@IsChangabl

; 915  : 			if (iWeaponID == c_iBouquets[i])

  00056	8b 45 e4	 mov	 eax, DWORD PTR _i$1[ebp]
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _iWeaponID$[ebp]
  0005c	3b 4c 85 e8	 cmp	 ecx, DWORD PTR _c_iBouquets$2[ebp+eax*4]
  00060	75 05		 jne	 SHORT $LN7@IsChangabl

; 916  : 				return true;

  00062	33 c0		 xor	 eax, eax
  00064	40		 inc	 eax
  00065	eb 0b		 jmp	 SHORT $LN1@IsChangabl
$LN7@IsChangabl:
  00067	eb dc		 jmp	 SHORT $LN2@IsChangabl
$LN3@IsChangabl:

; 917  : 
; 918  : 		return false;

  00069	33 c0		 xor	 eax, eax
  0006b	eb 05		 jmp	 SHORT $LN1@IsChangabl

; 919  : 	}

  0006d	eb 03		 jmp	 SHORT $LN1@IsChangabl
$LN5@IsChangabl:

; 920  : 	else
; 921  : 		return true;

  0006f	33 c0		 xor	 eax, eax
  00071	40		 inc	 eax
$LN1@IsChangabl:

; 922  : }

  00072	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00075	33 cd		 xor	 ecx, ebp
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	c9		 leave
  0007d	c2 04 00	 ret	 4
?__IsChangableWeapon@CInstanceBase@@IAEHH@Z ENDP	; CInstanceBase::__IsChangableWeapon
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__IsShapeAnimalWear@CInstanceBase@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__IsShapeAnimalWear@CInstanceBase@@IAE_NXZ PROC	; CInstanceBase::__IsShapeAnimalWear, COMDAT
; _this$ = ecx

; 2834 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2835 : 	if (100 == GetShape() ||
; 2836 : 		101 == GetShape() ||
; 2837 : 		102 == GetShape() ||

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  0000f	83 f8 64	 cmp	 eax, 100		; 00000064H
  00012	74 27		 je	 SHORT $LN3@IsShapeAni
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  0001c	83 f8 65	 cmp	 eax, 101		; 00000065H
  0001f	74 1a		 je	 SHORT $LN3@IsShapeAni
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  00029	83 f8 66	 cmp	 eax, 102		; 00000066H
  0002c	74 0d		 je	 SHORT $LN3@IsShapeAni
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  00036	83 f8 67	 cmp	 eax, 103		; 00000067H
  00039	75 04		 jne	 SHORT $LN2@IsShapeAni
$LN3@IsShapeAni:

; 2838 : 		103 == GetShape())
; 2839 : 		return true;

  0003b	b0 01		 mov	 al, 1
  0003d	eb 02		 jmp	 SHORT $LN1@IsShapeAni
$LN2@IsShapeAni:

; 2840 : 
; 2841 : 	return false;

  0003f	32 c0		 xor	 al, al
$LN1@IsShapeAni:

; 2842 : }

  00041	c9		 leave
  00042	c3		 ret	 0
?__IsShapeAnimalWear@CInstanceBase@@IAE_NXZ ENDP	; CInstanceBase::__IsShapeAnimalWear
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__GetRaceType@CInstanceBase@@IAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__GetRaceType@CInstanceBase@@IAEKXZ PROC		; CInstanceBase::__GetRaceType, COMDAT
; _this$ = ecx

; 2845 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2846 : 	return m_eRaceType;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 80 5d 01
	00 00		 movzx	 eax, BYTE PTR [eax+349]

; 2847 : }

  00011	c9		 leave
  00012	c3		 ret	 0
?__GetRaceType@CInstanceBase@@IAEKXZ ENDP		; CInstanceBase::__GetRaceType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__FindRaceType@CInstanceBase@@IAE_NKPAE@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rkNonPlayer$ = -4					; size = 4
_dwRace$ = 8						; size = 4
_pbType$ = 12						; size = 4
?__FindRaceType@CInstanceBase@@IAE_NKPAE@Z PROC		; CInstanceBase::__FindRaceType, COMDAT
; _this$ = ecx

; 713  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 714  : 	CPythonNonPlayer& rkNonPlayer=CPythonNonPlayer::Instance();

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNonPlayer@@@@0PAVCPythonNonPlayer@@A ; CSingleton<CPythonNonPlayer>::ms_singleton
  0000d	89 45 fc	 mov	 DWORD PTR _rkNonPlayer$[ebp], eax

; 715  : 	return rkNonPlayer.GetInstanceType(dwRace, pbType);

  00010	ff 75 0c	 push	 DWORD PTR _pbType$[ebp]
  00013	ff 75 08	 push	 DWORD PTR _dwRace$[ebp]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _rkNonPlayer$[ebp]
  00019	e8 00 00 00 00	 call	 ?GetInstanceType@CPythonNonPlayer@@QAE_NKPAE@Z ; CPythonNonPlayer::GetInstanceType

; 716  : }

  0001e	c9		 leave
  0001f	c2 08 00	 ret	 8
?__FindRaceType@CInstanceBase@@IAE_NKPAE@Z ENDP		; CInstanceBase::__FindRaceType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__FindInstancePtr@CInstanceBase@@IAEPAV1@K@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rkChrMgr$ = -4						; size = 4
_dwVID$ = 8						; size = 4
?__FindInstancePtr@CInstanceBase@@IAEPAV1@K@Z PROC	; CInstanceBase::__FindInstancePtr, COMDAT
; _this$ = ecx

; 707  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 708  : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0000d	89 45 fc	 mov	 DWORD PTR _rkChrMgr$[ebp], eax

; 709  : 	return rkChrMgr.GetInstancePtr(dwVID);

  00010	ff 75 08	 push	 DWORD PTR _dwVID$[ebp]
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _rkChrMgr$[ebp]
  00016	83 c1 04	 add	 ecx, 4
  00019	8b 45 fc	 mov	 eax, DWORD PTR _rkChrMgr$[ebp]
  0001c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001f	ff 50 08	 call	 DWORD PTR [eax+8]

; 710  : }

  00022	c9		 leave
  00023	c2 04 00	 ret	 4
?__FindInstancePtr@CInstanceBase@@IAEPAV1@K@Z ENDP	; CInstanceBase::__FindInstancePtr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__GetMainInstancePtr@CInstanceBase@@IAEPAV1@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_rkChrMgr$ = -4						; size = 4
?__GetMainInstancePtr@CInstanceBase@@IAEPAV1@XZ PROC	; CInstanceBase::__GetMainInstancePtr, COMDAT
; _this$ = ecx

; 658  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 659  : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0000d	89 45 fc	 mov	 DWORD PTR _rkChrMgr$[ebp], eax

; 660  : 	return rkChrMgr.GetMainInstancePtr();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _rkChrMgr$[ebp]
  00013	e8 00 00 00 00	 call	 ?GetMainInstancePtr@CPythonCharacterManager@@QAEPAVCInstanceBase@@XZ ; CPythonCharacterManager::GetMainInstancePtr

; 661  : }

  00018	c9		 leave
  00019	c3		 ret	 0
?__GetMainInstancePtr@CInstanceBase@@IAEPAV1@XZ ENDP	; CInstanceBase::__GetMainInstancePtr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z
_TEXT	SEGMENT
$T2 = -64						; size = 4
$T3 = -60						; size = 4
_c_szName$ = -56					; size = 4
$T4 = -52						; size = 4
_this$ = -48						; size = 4
_iFindingPos$5 = -44					; size = 4
_strName$6 = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_rkCreateData$ = 8					; size = 4
?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z PROC ; CInstanceBase::__Create_SetWarpName, COMDAT
; _this$ = ecx

; 863  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNonPlayer@@@@0PAVCPythonNonPlayer@@A ; CSingleton<CPythonNonPlayer>::ms_singleton
  00030	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 865  : 	if (CPythonNonPlayer::Instance().GetName(c_rkCreateData.m_dwRace, &c_szName))

  00033	8d 45 c8	 lea	 eax, DWORD PTR _c_szName$[ebp]
  00036	50		 push	 eax
  00037	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  0003a	ff 70 18	 push	 DWORD PTR [eax+24]
  0003d	8b 4d cc	 mov	 ecx, DWORD PTR $T4[ebp]
  00040	e8 00 00 00 00	 call	 ?GetName@CPythonNonPlayer@@QAE_NKPAPBD@Z ; CPythonNonPlayer::GetName
  00045	0f b6 c0	 movzx	 eax, al
  00048	85 c0		 test	 eax, eax
  0004a	74 5c		 je	 SHORT $LN2@Create_Set

; 866  : 	{
; 867  : 		std::string strName = c_szName;

  0004c	ff 75 c8	 push	 DWORD PTR _c_szName$[ebp]
  0004f	8d 4d d8	 lea	 ecx, DWORD PTR _strName$6[ebp]
  00052	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00057	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 868  : 		int iFindingPos = strName.find_first_of(" ", 0);

  0005b	6a 00		 push	 0
  0005d	68 00 00 00 00	 push	 OFFSET ??_C@_01CLKCMJKC@?5@
  00062	8d 4d d8	 lea	 ecx, DWORD PTR _strName$6[ebp]
  00065	e8 00 00 00 00	 call	 ?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_of
  0006a	89 45 d4	 mov	 DWORD PTR _iFindingPos$5[ebp], eax

; 869  : 		if (iFindingPos > 0)

  0006d	83 7d d4 00	 cmp	 DWORD PTR _iFindingPos$5[ebp], 0
  00071	7e 0d		 jle	 SHORT $LN4@Create_Set

; 870  : 		{
; 871  : 			strName.resize(iFindingPos);

  00073	6a 00		 push	 0
  00075	ff 75 d4	 push	 DWORD PTR _iFindingPos$5[ebp]
  00078	8d 4d d8	 lea	 ecx, DWORD PTR _strName$6[ebp]
  0007b	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
$LN4@Create_Set:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  00080	8b 45 e8	 mov	 eax, DWORD PTR _strName$6[ebp+16]
  00083	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 873  : 		SetNameString(strName.c_str(), strName.length());

  00086	ff 75 c4	 push	 DWORD PTR $T3[ebp]
  00089	8d 4d d8	 lea	 ecx, DWORD PTR _strName$6[ebp]
  0008c	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00091	50		 push	 eax
  00092	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?SetNameString@CInstanceBase@@QAEXPBDH@Z ; CInstanceBase::SetNameString

; 874  : 	}

  0009a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0009e	8d 4d d8	 lea	 ecx, DWORD PTR _strName$6[ebp]
  000a1	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 874  : 	}

  000a6	eb 20		 jmp	 SHORT $LN1@Create_Set
$LN2@Create_Set:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  000a8	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  000ab	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  000ae	89 45 c0	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 877  : 		SetNameString(c_rkCreateData.m_stName.c_str(), c_rkCreateData.m_stName.length());

  000b1	ff 75 c0	 push	 DWORD PTR $T2[ebp]
  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _c_rkCreateData$[ebp]
  000b7	83 c1 4c	 add	 ecx, 76			; 0000004cH
  000ba	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  000bf	50		 push	 eax
  000c0	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	e8 00 00 00 00	 call	 ?SetNameString@CInstanceBase@@QAEXPBDH@Z ; CInstanceBase::SetNameString
$LN1@Create_Set:

; 878  : 	}
; 879  : }

  000c8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000cb	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d2	59		 pop	 ecx
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	c9		 leave
  000de	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _strName$6[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z ENDP ; CInstanceBase::__Create_SetWarpName
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__Create_SetName@CInstanceBase@@IAEXABUSCreateData@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_c_rkCreateData$ = 8					; size = 4
?__Create_SetName@CInstanceBase@@IAEXABUSCreateData@1@@Z PROC ; CInstanceBase::__Create_SetName, COMDAT
; _this$ = ecx

; 847  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 848  : 	if (IsGoto())

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?IsGoto@CInstanceBase@@QAEHXZ ; CInstanceBase::IsGoto
  00010	85 c0		 test	 eax, eax
  00012	74 11		 je	 SHORT $LN2@Create_Set

; 849  : 	{
; 850  : 		SetNameString("", 0);

  00014	6a 00		 push	 0
  00016	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?SetNameString@CInstanceBase@@QAEXPBDH@Z ; CInstanceBase::SetNameString

; 851  : 		return;

  00023	eb 39		 jmp	 SHORT $LN1@Create_Set
$LN2@Create_Set:

; 852  : 	}
; 853  : 	if (IsWarp())

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?IsWarp@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWarp
  0002d	85 c0		 test	 eax, eax
  0002f	74 0d		 je	 SHORT $LN3@Create_Set

; 854  : 	{
; 855  : 		__Create_SetWarpName(c_rkCreateData);

  00031	ff 75 08	 push	 DWORD PTR _c_rkCreateData$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?__Create_SetWarpName@CInstanceBase@@IAEXABUSCreateData@1@@Z ; CInstanceBase::__Create_SetWarpName

; 856  : 		return;

  0003c	eb 20		 jmp	 SHORT $LN1@Create_Set
$LN3@Create_Set:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3766 :         return _Mypair._Myval2._Mysize;

  0003e	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00041	8b 40 5c	 mov	 eax, DWORD PTR [eax+92]
  00044	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 859  : 	SetNameString(c_rkCreateData.m_stName.c_str(), c_rkCreateData.m_stName.length());

  00047	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR _c_rkCreateData$[ebp]
  0004d	83 c1 4c	 add	 ecx, 76			; 0000004cH
  00050	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00055	50		 push	 eax
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?SetNameString@CInstanceBase@@QAEXPBDH@Z ; CInstanceBase::SetNameString
$LN1@Create_Set:

; 860  : }

  0005e	c9		 leave
  0005f	c2 04 00	 ret	 4
?__Create_SetName@CInstanceBase@@IAEXABUSCreateData@1@@Z ENDP ; CInstanceBase::__Create_SetName
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__InitializeRotationSpeed@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__InitializeRotationSpeed@CInstanceBase@@IAEXXZ PROC	; CInstanceBase::__InitializeRotationSpeed, COMDAT
; _this$ = ecx

; 3018 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3019 : 	SetRotationSpeed(c_fDefaultRotationSpeed);

  00007	51		 push	 ecx
  00008	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@44960000
  00010	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?SetRotationSpeed@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetRotationSpeed

; 3020 : }

  0001d	c9		 leave
  0001e	c3		 ret	 0
?__InitializeRotationSpeed@CInstanceBase@@IAEXXZ ENDP	; CInstanceBase::__InitializeRotationSpeed
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__Initialize@CInstanceBase@@IAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
_this$ = -44						; size = 4
$T3 = -40						; size = 12
$T4 = -28						; size = 12
$T5 = -16						; size = 12
__$ArrayPad$ = -4					; size = 4
?__Initialize@CInstanceBase@@IAEXXZ PROC		; CInstanceBase::__Initialize, COMDAT
; _this$ = ecx

; 3028 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 3029 : 	__Warrior_Initialize();

  00015	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?__Warrior_Initialize@CInstanceBase@@IAEXXZ ; CInstanceBase::__Warrior_Initialize

; 3030 : 	__StoneSmoke_Inialize();

  0001d	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?__StoneSmoke_Inialize@CInstanceBase@@IAEXXZ ; CInstanceBase::__StoneSmoke_Inialize

; 3031 : 	__EffectContainer_Initialize();

  00025	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?__EffectContainer_Initialize@CInstanceBase@@IAEXXZ ; CInstanceBase::__EffectContainer_Initialize

; 3032 : 	__InitializeRotationSpeed();

  0002d	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?__InitializeRotationSpeed@CInstanceBase@@IAEXXZ ; CInstanceBase::__InitializeRotationSpeed

; 3033 : 
; 3034 : 	SetEventHandler(CActorInstance::IEventHandler::GetEmptyPtr());

  00035	e8 00 00 00 00	 call	 ?GetEmptyPtr@IEventHandler@CActorInstance@@SAPAV12@XZ ; CActorInstance::IEventHandler::GetEmptyPtr
  0003a	50		 push	 eax
  0003b	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?SetEventHandler@CInstanceBase@@QAEXPAVIEventHandler@CActorInstance@@@Z ; CInstanceBase::SetEventHandler

; 3035 : 
; 3036 : 	m_kAffectFlagContainer.Clear();

  00043	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 c1 48	 add	 ecx, 72			; 00000048H
  00049	e8 00 00 00 00	 call	 ?Clear@CAffectFlagContainer@@QAEXXZ ; CAffectFlagContainer::Clear

; 3037 : 
; 3038 : 	m_dwLevel = 0;

  0004e	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 60 3c 00	 and	 DWORD PTR [eax+60], 0

; 3039 : 	m_dwGuildID = 0;

  00055	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00058	83 60 44 00	 and	 DWORD PTR [eax+68], 0

; 3040 : 	m_dwEmpireID = 0;

  0005c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	83 60 40 00	 and	 DWORD PTR [eax+64], 0

; 3041 : 
; 3042 : 	m_eType = 0;

  00063	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00066	c6 80 5c 01 00
	00 00		 mov	 BYTE PTR [eax+348], 0

; 3043 : 	m_eRaceType = 0;

  0006d	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00070	c6 80 5d 01 00
	00 00		 mov	 BYTE PTR [eax+349], 0

; 3044 : 	m_eShape = 0;

  00077	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	83 a0 60 01 00
	00 00		 and	 DWORD PTR [eax+352], 0

; 3045 : 	m_dwRace = 0;

  00081	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00084	83 a0 64 01 00
	00 00		 and	 DWORD PTR [eax+356], 0

; 3046 : 	m_dwVirtualNumber = 0;

  0008b	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0008e	83 a0 68 01 00
	00 00		 and	 DWORD PTR [eax+360], 0

; 3047 : 
; 3048 : 	m_dwBaseCmdTime=0;

  00095	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00098	83 a0 88 06 00
	00 00		 and	 DWORD PTR [eax+1672], 0

; 3049 : 	m_dwBaseChkTime=0;

  0009f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	83 a0 84 06 00
	00 00		 and	 DWORD PTR [eax+1668], 0

; 3050 : 	m_dwSkipTime=0;

  000a9	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000ac	83 a0 8c 06 00
	00 00		 and	 DWORD PTR [eax+1676], 0

; 3051 : 
; 3052 : 	m_GraphicThingInstance.Initialize();

  000b3	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b6	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  000bc	e8 00 00 00 00	 call	 ?Initialize@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::Initialize

; 3053 : 
; 3054 : 	m_dwAdvActorVID=0;

  000c1	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000c4	83 a0 78 01 00
	00 00		 and	 DWORD PTR [eax+376], 0

; 3055 : 	m_dwLastDmgActorVID=0;

  000cb	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	83 a0 7c 01 00
	00 00		 and	 DWORD PTR [eax+380], 0

; 3056 : 
; 3057 : 	m_nAverageNetworkGap=0;

  000d5	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	83 a0 80 01 00
	00 00		 and	 DWORD PTR [eax+384], 0

; 3058 : 	m_dwNextUpdateHeightTime=0;

  000df	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	83 a0 84 01 00
	00 00		 and	 DWORD PTR [eax+388], 0

; 3059 : 
; 3060 : 	// Moving by keyboard
; 3061 : 	m_iRotatingDirection = DEGREE_DIRECTION_SAME;

  000e9	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000ec	83 a0 74 01 00
	00 00		 and	 DWORD PTR [eax+372], 0

; 3062 : 
; 3063 : 	// Moving by mouse	
; 3064 : 	m_isTextTail = FALSE;

  000f3	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000f6	83 60 0c 00	 and	 DWORD PTR [eax+12], 0

; 3065 : 	m_isGoing = FALSE;

  000fa	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	c6 80 88 01 00
	00 00		 mov	 BYTE PTR [eax+392], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00104	0f 57 c0	 xorps	 xmm0, xmm0
  00107	f3 0f 11 45 f0	 movss	 DWORD PTR $T5[ebp], xmm0

; 181  :     y = fy;

  0010c	0f 57 c0	 xorps	 xmm0, xmm0
  0010f	f3 0f 11 45 f4	 movss	 DWORD PTR $T5[ebp+4], xmm0

; 182  :     z = fz;

  00114	0f 57 c0	 xorps	 xmm0, xmm0
  00117	f3 0f 11 45 f8	 movss	 DWORD PTR $T5[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3066 : 	NEW_SetSrcPixelPosition(TPixelPosition(0, 0, 0));

  0011c	8d 45 f0	 lea	 eax, DWORD PTR $T5[ebp]
  0011f	50		 push	 eax
  00120	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00123	e8 00 00 00 00	 call	 ?NEW_SetSrcPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetSrcPixelPosition
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00128	0f 57 c0	 xorps	 xmm0, xmm0
  0012b	f3 0f 11 45 e4	 movss	 DWORD PTR $T4[ebp], xmm0

; 181  :     y = fy;

  00130	0f 57 c0	 xorps	 xmm0, xmm0
  00133	f3 0f 11 45 e8	 movss	 DWORD PTR $T4[ebp+4], xmm0

; 182  :     z = fz;

  00138	0f 57 c0	 xorps	 xmm0, xmm0
  0013b	f3 0f 11 45 ec	 movss	 DWORD PTR $T4[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3067 : 	NEW_SetDstPixelPosition(TPixelPosition(0, 0, 0));

  00140	8d 45 e4	 lea	 eax, DWORD PTR $T4[ebp]
  00143	50		 push	 eax
  00144	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00147	e8 00 00 00 00	 call	 ?NEW_SetDstPixelPosition@CInstanceBase@@IAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetDstPixelPosition
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  0014c	0f 57 c0	 xorps	 xmm0, xmm0
  0014f	f3 0f 11 45 d8	 movss	 DWORD PTR $T3[ebp], xmm0

; 181  :     y = fy;

  00154	0f 57 c0	 xorps	 xmm0, xmm0
  00157	f3 0f 11 45 dc	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 182  :     z = fz;

  0015c	0f 57 c0	 xorps	 xmm0, xmm0
  0015f	f3 0f 11 45 e0	 movss	 DWORD PTR $T3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3069 : 	m_kPPosDust = TPixelPosition(0, 0, 0);

  00164	8b 7d d4	 mov	 edi, DWORD PTR _this$[ebp]
  00167	81 c7 8c 01 00
	00		 add	 edi, 396		; 0000018cH
  0016d	8d 75 d8	 lea	 esi, DWORD PTR $T3[ebp]
  00170	a5		 movsd
  00171	a5		 movsd
  00172	a5		 movsd

; 3070 : 
; 3071 : 
; 3072 : 	m_kQue_kCmdNew.clear();

  00173	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00176	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  0017c	e8 00 00 00 00	 call	 ?clear@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEXXZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::clear

; 3073 : 
; 3074 : 	m_dwLastComboIndex = 0;

  00181	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00184	83 a0 98 01 00
	00 00		 and	 DWORD PTR [eax+408], 0

; 3075 : 
; 3076 : 	m_swordRefineEffectRight = 0;

  0018b	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0018e	83 a0 9c 01 00
	00 00		 and	 DWORD PTR [eax+412], 0

; 3077 : 	m_swordRefineEffectLeft = 0;

  00195	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00198	83 a0 a0 01 00
	00 00		 and	 DWORD PTR [eax+416], 0

; 3078 : 	m_armorRefineEffect = 0;

  0019f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001a2	83 a0 a4 01 00
	00 00		 and	 DWORD PTR [eax+420], 0

; 3079 : 
; 3080 : 	m_sAlignment = 0;

  001a9	33 c0		 xor	 eax, eax
  001ab	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	66 89 81 6c 01
	00 00		 mov	 WORD PTR [ecx+364], ax

; 3081 : 	m_byPKMode = 0;

  001b5	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001b8	c6 80 6e 01 00
	00 00		 mov	 BYTE PTR [eax+366], 0

; 3082 : 	m_isKiller = false;

  001bf	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001c2	c6 80 6f 01 00
	00 00		 mov	 BYTE PTR [eax+367], 0

; 3083 : 	m_isPartyMember = false;

  001c9	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001cc	c6 80 70 01 00
	00 00		 mov	 BYTE PTR [eax+368], 0

; 3084 : 
; 3085 : 	m_bEnableTCPState = TRUE;

  001d3	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  001d6	c7 80 d0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+464], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  001e0	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  001e5	e8 00 00 00 00	 call	 _strlen
  001ea	59		 pop	 ecx
  001eb	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  001ee	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  001f1	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  001f4	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  001f7	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3087 : 	m_stName = "";

  001fc	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00202	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3089 : 	memset(m_awPart, 0, sizeof(m_awPart));

  00207	6a 14		 push	 20			; 00000014H
  00209	6a 00		 push	 0
  0020b	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0020e	83 c0 28	 add	 eax, 40			; 00000028H
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 _memset
  00217	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3090 : 	memset(m_adwCRCAffectEffect, 0, sizeof(m_adwCRCAffectEffect));

  0021a	68 00 01 00 00	 push	 256			; 00000100H
  0021f	6a 00		 push	 0
  00221	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00224	83 c0 50	 add	 eax, 80			; 00000050H
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 _memset
  0022d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3091 : 	//memset(m_adwCRCEmoticonEffect, 0, sizeof(m_adwCRCEmoticonEffect));
; 3092 : 	memset(&m_kMovAfterFunc, 0, sizeof(m_kMovAfterFunc));

  00230	6a 18		 push	 24			; 00000018H
  00232	6a 00		 push	 0
  00234	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00237	05 a8 01 00 00	 add	 eax, 424		; 000001a8H
  0023c	50		 push	 eax
  0023d	e8 00 00 00 00	 call	 _memset
  00242	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3093 : 
; 3094 : 	m_bDamageEffectType = false;

  00245	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00248	83 a0 98 06 00
	00 00		 and	 DWORD PTR [eax+1688], 0

; 3095 : 	m_dwDuelMode = DUEL_NONE;

  0024f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00252	83 a0 a8 06 00
	00 00		 and	 DWORD PTR [eax+1704], 0

; 3096 : 	m_dwEmoticonTime = 0;

  00259	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0025c	83 a0 ac 06 00
	00 00		 and	 DWORD PTR [eax+1708], 0

; 3097 : }

  00263	5f		 pop	 edi
  00264	5e		 pop	 esi
  00265	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00268	33 cd		 xor	 ecx, ebp
  0026a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0026f	c9		 leave
  00270	c3		 ret	 0
?__Initialize@CInstanceBase@@IAEXXZ ENDP		; CInstanceBase::__Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__LessRenderOrder_GetLODLevel@CInstanceBase@@IAEIXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_pLODCtrl$ = -8						; size = 4
$T1 = -1						; size = 1
?__LessRenderOrder_GetLODLevel@CInstanceBase@@IAEIXZ PROC ; CInstanceBase::__LessRenderOrder_GetLODLevel, COMDAT
; _this$ = ecx

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 356  : 	CGrannyLODController* pLODCtrl=m_GraphicThingInstance.GetLODControllerPointer(0);

  00009	6a 00		 push	 0
  0000b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00014	e8 00 00 00 00	 call	 ?GetLODControllerPointer@CGraphicThingInstance@@QAEPAVCGrannyLODController@@K@Z ; CGraphicThingInstance::GetLODControllerPointer
  00019	89 45 f8	 mov	 DWORD PTR _pLODCtrl$[ebp], eax

; 357  : 	if (!pLODCtrl)

  0001c	83 7d f8 00	 cmp	 DWORD PTR _pLODCtrl$[ebp], 0
  00020	75 04		 jne	 SHORT $LN2@LessRender

; 358  : 		return 0;

  00022	33 c0		 xor	 eax, eax
  00024	eb 0d		 jmp	 SHORT $LN1@LessRender
$LN2@LessRender:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterGrnLib\LODController.h

; 237  : 		BYTE	GetLODLevel() { return m_bLODLevel; }

  00026	8b 45 f8	 mov	 eax, DWORD PTR _pLODCtrl$[ebp]
  00029	8a 40 1c	 mov	 al, BYTE PTR [eax+28]
  0002c	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 360  : 	return pLODCtrl->GetLODLevel();

  0002f	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
$LN1@LessRender:

; 361  : }

  00033	c9		 leave
  00034	c3		 ret	 0
?__LessRenderOrder_GetLODLevel@CInstanceBase@@IAEIXZ ENDP ; CInstanceBase::__LessRenderOrder_GetLODLevel
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__Background_GetWaterHeight@CInstanceBase@@QAE_NABUD3DXVECTOR3@@PAM@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_lHeight$ = -8						; size = 4
$T1 = -4						; size = 4
_c_rkPPos$ = 8						; size = 4
_pfHeight$ = 12						; size = 4
?__Background_GetWaterHeight@CInstanceBase@@QAE_NABUD3DXVECTOR3@@PAM@Z PROC ; CInstanceBase::__Background_GetWaterHeight, COMDAT
; _this$ = ecx

; 364  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0000e	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 366  : 	if (!CPythonBackground::Instance().GetWaterHeight(int(c_rkPPos.x), int(c_rkPPos.y), &lHeight))

  00011	8d 45 f8	 lea	 eax, DWORD PTR _lHeight$[ebp]
  00014	50		 push	 eax
  00015	8b 45 08	 mov	 eax, DWORD PTR _c_rkPPos$[ebp]
  00018	f3 0f 2c 40 04	 cvttss2si eax, DWORD PTR [eax+4]
  0001d	50		 push	 eax
  0001e	8b 45 08	 mov	 eax, DWORD PTR _c_rkPPos$[ebp]
  00021	f3 0f 2c 00	 cvttss2si eax, DWORD PTR [eax]
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00029	e8 00 00 00 00	 call	 ?GetWaterHeight@CMapManager@@QAE_NHHPAJ@Z ; CMapManager::GetWaterHeight
  0002e	0f b6 c0	 movzx	 eax, al
  00031	85 c0		 test	 eax, eax
  00033	75 04		 jne	 SHORT $LN2@Background

; 367  : 		return false;

  00035	32 c0		 xor	 al, al
  00037	eb 0e		 jmp	 SHORT $LN1@Background
$LN2@Background:

; 368  : 
; 369  : 	*pfHeight = float(lHeight);

  00039	f3 0f 2a 45 f8	 cvtsi2ss xmm0, DWORD PTR _lHeight$[ebp]
  0003e	8b 45 0c	 mov	 eax, DWORD PTR _pfHeight$[ebp]
  00041	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 370  : 
; 371  : 	return true;

  00045	b0 01		 mov	 al, 1
$LN1@Background:

; 372  : }

  00047	c9		 leave
  00048	c2 08 00	 ret	 8
?__Background_GetWaterHeight@CInstanceBase@@QAE_NABUD3DXVECTOR3@@PAM@Z ENDP ; CInstanceBase::__Background_GetWaterHeight
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__Background_IsWaterPixelPosition@CInstanceBase@@QAE_NABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_c_rkPPos$ = 8						; size = 4
?__Background_IsWaterPixelPosition@CInstanceBase@@QAE_NABUD3DXVECTOR3@@@Z PROC ; CInstanceBase::__Background_IsWaterPixelPosition, COMDAT
; _this$ = ecx

; 375  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0000d	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 376  : 	return CPythonBackground::Instance().isAttrOn(c_rkPPos.x, c_rkPPos.y, CTerrainImpl::ATTRIBUTE_WATER);

  00010	6a 02		 push	 2
  00012	8b 45 08	 mov	 eax, DWORD PTR _c_rkPPos$[ebp]
  00015	51		 push	 ecx
  00016	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0001b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00020	8b 45 08	 mov	 eax, DWORD PTR _c_rkPPos$[ebp]
  00023	51		 push	 ecx
  00024	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00028	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00030	e8 00 00 00 00	 call	 ?isAttrOn@CMapManager@@QAE_NMME@Z ; CMapManager::isAttrOn

; 377  : }

  00035	c9		 leave
  00036	c2 04 00	 ret	 4
?__Background_IsWaterPixelPosition@CInstanceBase@@QAE_NABUD3DXVECTOR3@@@Z ENDP ; CInstanceBase::__Background_IsWaterPixelPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ PROC ; CInstanceBase::GetGraphicThingInstancePtr, COMDAT
; _this$ = ecx

; 2505 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2506 : 	return &m_GraphicThingInstance;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 d4 01 00 00	 add	 eax, 468		; 000001d4H

; 2507 : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetGraphicThingInstancePtr@CInstanceBase@@QAEPAVCActorInstance@@XZ ENDP ; CInstanceBase::GetGraphicThingInstancePtr
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetGraphicThingInstanceRef@CInstanceBase@@QAEAAVCActorInstance@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGraphicThingInstanceRef@CInstanceBase@@QAEAAVCActorInstance@@XZ PROC ; CInstanceBase::GetGraphicThingInstanceRef, COMDAT
; _this$ = ecx

; 2500 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2501 : 	return m_GraphicThingInstance;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	05 d4 01 00 00	 add	 eax, 468		; 000001d4H

; 2502 : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?GetGraphicThingInstanceRef@CInstanceBase@@QAEAAVCActorInstance@@XZ ENDP ; CInstanceBase::GetGraphicThingInstanceRef
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetDistance@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
tv144 = -32						; size = 4
_this$ = -28						; size = 4
_fdx$ = -24						; size = 4
_fdy$ = -20						; size = 4
_PixelPosition$ = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
_c_rPixelPosition$ = 8					; size = 4
?GetDistance@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z PROC	; CInstanceBase::GetDistance, COMDAT
; _this$ = ecx

; 2489 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 2490 : 	TPixelPosition PixelPosition;
; 2491 : 	m_GraphicThingInstance.GetPixelPosition(&PixelPosition);

  00013	8d 45 f0	 lea	 eax, DWORD PTR _PixelPosition$[ebp]
  00016	50		 push	 eax
  00017	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00020	e8 00 00 00 00	 call	 ?GetPixelPosition@CActorInstance@@QAEXPAUD3DXVECTOR3@@@Z ; CActorInstance::GetPixelPosition

; 2492 : 
; 2493 : 	float fdx = PixelPosition.x - c_rPixelPosition.x;

  00025	8b 45 08	 mov	 eax, DWORD PTR _c_rPixelPosition$[ebp]
  00028	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _PixelPosition$[ebp]
  0002d	f3 0f 5c 00	 subss	 xmm0, DWORD PTR [eax]
  00031	f3 0f 11 45 e8	 movss	 DWORD PTR _fdx$[ebp], xmm0

; 2494 : 	float fdy = PixelPosition.y - c_rPixelPosition.y;

  00036	8b 45 08	 mov	 eax, DWORD PTR _c_rPixelPosition$[ebp]
  00039	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _PixelPosition$[ebp+4]
  0003e	f3 0f 5c 40 04	 subss	 xmm0, DWORD PTR [eax+4]
  00043	f3 0f 11 45 ec	 movss	 DWORD PTR _fdy$[ebp], xmm0

; 2495 : 
; 2496 : 	return sqrtf((fdx*fdx) + (fdy*fdy));

  00048	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _fdy$[ebp]
  0004d	f3 0f 59 45 ec	 mulss	 xmm0, DWORD PTR _fdy$[ebp]
  00052	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _fdx$[ebp]
  00057	f3 0f 59 4d e8	 mulss	 xmm1, DWORD PTR _fdx$[ebp]
  0005c	f3 0f 58 c8	 addss	 xmm1, xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00060	f3 0f 5a c1	 cvtss2sd xmm0, xmm1
  00064	51		 push	 ecx
  00065	51		 push	 ecx
  00066	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0006b	e8 00 00 00 00	 call	 _sqrt
  00070	59		 pop	 ecx
  00071	59		 pop	 ecx
  00072	d9 5d e0	 fstp	 DWORD PTR tv144[ebp]
  00075	d9 45 e0	 fld	 DWORD PTR tv144[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 2497 : }

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007b	33 cd		 xor	 ecx, ebp
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	c9		 leave
  00083	c2 04 00	 ret	 4
?GetDistance@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z ENDP	; CInstanceBase::GetDistance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetDistance@CInstanceBase@@QAEMPAV1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_TargetPixelPosition$ = -16				; size = 12
__$ArrayPad$ = -4					; size = 4
_pkTargetInst$ = 8					; size = 4
?GetDistance@CInstanceBase@@QAEMPAV1@@Z PROC		; CInstanceBase::GetDistance, COMDAT
; _this$ = ecx

; 2482 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2483 : 	TPixelPosition TargetPixelPosition;
; 2484 : 	pkTargetInst->m_GraphicThingInstance.GetPixelPosition(&TargetPixelPosition);

  00013	8d 45 f0	 lea	 eax, DWORD PTR _TargetPixelPosition$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pkTargetInst$[ebp]
  0001a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00020	e8 00 00 00 00	 call	 ?GetPixelPosition@CActorInstance@@QAEXPAUD3DXVECTOR3@@@Z ; CActorInstance::GetPixelPosition

; 2485 : 	return GetDistance(TargetPixelPosition);

  00025	8d 45 f0	 lea	 eax, DWORD PTR _TargetPixelPosition$[ebp]
  00028	50		 push	 eax
  00029	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?GetDistance@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z ; CInstanceBase::GetDistance

; 2486 : }

  00031	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00034	33 cd		 xor	 ecx, ebp
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	c9		 leave
  0003c	c2 04 00	 ret	 4
?GetDistance@CInstanceBase@@QAEMPAV1@@Z ENDP		; CInstanceBase::GetDistance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Refresh@CInstanceBase@@QAEXK_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwMotIndex$ = 8					; size = 4
_isLoop$ = 12						; size = 1
?Refresh@CInstanceBase@@QAEXK_N@Z PROC			; CInstanceBase::Refresh, COMDAT
; _this$ = ecx

; 2515 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2516 : 	RefreshState(dwMotIndex, isLoop);

  00007	ff 75 0c	 push	 DWORD PTR _isLoop$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _dwMotIndex$[ebp]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?RefreshState@CInstanceBase@@IAEXK_N@Z ; CInstanceBase::RefreshState

; 2517 : }

  00015	c9		 leave
  00016	c2 08 00	 ret	 8
?Refresh@CInstanceBase@@QAEXK_N@Z ENDP			; CInstanceBase::Refresh
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IntersectBoundingBox@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_u$ = -16						; size = 4
_v$ = -12						; size = 4
_t$ = -8						; size = 4
_this$ = -4						; size = 4
?IntersectBoundingBox@CInstanceBase@@QAE_NXZ PROC	; CInstanceBase::IntersectBoundingBox, COMDAT
; _this$ = ecx

; 2471 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2472 : 	float u, v, t;
; 2473 : 	return m_GraphicThingInstance.Intersect(&u, &v, &t);

  00009	8d 45 f8	 lea	 eax, DWORD PTR _t$[ebp]
  0000c	50		 push	 eax
  0000d	8d 45 f4	 lea	 eax, DWORD PTR _v$[ebp]
  00010	50		 push	 eax
  00011	8d 45 f0	 lea	 eax, DWORD PTR _u$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0001e	e8 00 00 00 00	 call	 ?Intersect@CGraphicThingInstance@@QAE_NPAM00@Z ; CGraphicThingInstance::Intersect

; 2474 : }

  00023	c9		 leave
  00024	c3		 ret	 0
?IntersectBoundingBox@CInstanceBase@@QAE_NXZ ENDP	; CInstanceBase::IntersectBoundingBox
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IntersectDefendingSphere@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IntersectDefendingSphere@CInstanceBase@@QAE_NXZ PROC	; CInstanceBase::IntersectDefendingSphere, COMDAT
; _this$ = ecx

; 2477 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2478 : 	return m_GraphicThingInstance.IntersectDefendingSphere();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IntersectDefendingSphere@CActorInstance@@QAE_NXZ ; CActorInstance::IntersectDefendingSphere

; 2479 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?IntersectDefendingSphere@CInstanceBase@@QAE_NXZ ENDP	; CInstanceBase::IntersectDefendingSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetAddColor@CInstanceBase@@QAEXABUD3DXCOLOR@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rColor$ = 8						; size = 4
?SetAddColor@CInstanceBase@@QAEXABUD3DXCOLOR@@@Z PROC	; CInstanceBase::SetAddColor, COMDAT
; _this$ = ecx

; 2540 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2541 : 	m_GraphicThingInstance.SetAddColor(c_rColor);

  00007	ff 75 08	 push	 DWORD PTR _c_rColor$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?SetAddColor@CActorInstance@@QAEXABUD3DXCOLOR@@@Z ; CActorInstance::SetAddColor

; 2542 : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?SetAddColor@CInstanceBase@@QAEXABUD3DXCOLOR@@@Z ENDP	; CInstanceBase::SetAddColor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetRenderMode@CInstanceBase@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iRenderMode$ = 8					; size = 4
?SetRenderMode@CInstanceBase@@QAEXH@Z PROC		; CInstanceBase::SetRenderMode, COMDAT
; _this$ = ecx

; 2535 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2536 : 	m_GraphicThingInstance.SetRenderMode(iRenderMode);

  00007	ff 75 08	 push	 DWORD PTR _iRenderMode$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?SetRenderMode@CActorInstance@@QAEXH@Z ; CActorInstance::SetRenderMode

; 2537 : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?SetRenderMode@CInstanceBase@@QAEXH@Z ENDP		; CInstanceBase::SetRenderMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetModulateRenderMode@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetModulateRenderMode@CInstanceBase@@QAEXXZ PROC	; CInstanceBase::SetModulateRenderMode, COMDAT
; _this$ = ecx

; 2530 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2531 : 	m_GraphicThingInstance.SetModulateRenderMode();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?SetModulateRenderMode@CActorInstance@@QAEXXZ ; CActorInstance::SetModulateRenderMode

; 2532 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?SetModulateRenderMode@CInstanceBase@@QAEXXZ ENDP	; CInstanceBase::SetModulateRenderMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetAddRenderMode@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?SetAddRenderMode@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::SetAddRenderMode, COMDAT
; _this$ = ecx

; 2525 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2526 : 	m_GraphicThingInstance.SetAddRenderMode();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?SetAddRenderMode@CActorInstance@@QAEXXZ ; CActorInstance::SetAddRenderMode

; 2527 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?SetAddRenderMode@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::SetAddRenderMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?RestoreRenderMode@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RestoreRenderMode@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::RestoreRenderMode, COMDAT
; _this$ = ecx

; 2520 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2521 : 	m_GraphicThingInstance.RestoreRenderMode();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?RestoreRenderMode@CActorInstance@@QAEXXZ ; CActorInstance::RestoreRenderMode

; 2522 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?RestoreRenderMode@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::RestoreRenderMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?BlockMovement@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?BlockMovement@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::BlockMovement, COMDAT
; _this$ = ecx

; 264  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 265  : 	m_GraphicThingInstance.BlockMovement();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?BlockMovement@CActorInstance@@QAEXXZ ; CActorInstance::BlockMovement

; 266  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?BlockMovement@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::BlockMovement
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsBlockObject@CInstanceBase@@QAE_NABVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rkBGObj$ = 8						; size = 4
?IsBlockObject@CInstanceBase@@QAE_NABVCGraphicObjectInstance@@@Z PROC ; CInstanceBase::IsBlockObject, COMDAT
; _this$ = ecx

; 269  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 270  : 	return m_GraphicThingInstance.IsBlockObject(c_rkBGObj);

  00007	ff 75 08	 push	 DWORD PTR _c_rkBGObj$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?IsBlockObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z ; CActorInstance::IsBlockObject

; 271  : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?IsBlockObject@CInstanceBase@@QAE_NABVCGraphicObjectInstance@@@Z ENDP ; CInstanceBase::IsBlockObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?AvoidObject@CInstanceBase@@QAE_NABVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_rkBGObj$ = 8						; size = 4
?AvoidObject@CInstanceBase@@QAE_NABVCGraphicObjectInstance@@@Z PROC ; CInstanceBase::AvoidObject, COMDAT
; _this$ = ecx

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 275  : 	return m_GraphicThingInstance.AvoidObject(c_rkBGObj);

  00007	ff 75 08	 push	 DWORD PTR _c_rkBGObj$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?AvoidObject@CActorInstance@@QAE_NABVCGraphicObjectInstance@@@Z ; CActorInstance::AvoidObject

; 276  : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?AvoidObject@CInstanceBase@@QAE_NABVCGraphicObjectInstance@@@Z ENDP ; CInstanceBase::AvoidObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_GetLastPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NEW_GetLastPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ PROC ; CInstanceBase::NEW_GetLastPixelPositionRef, COMDAT
; _this$ = ecx

; 990  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 991  : 	return m_GraphicThingInstance.NEW_GetLastPixelPositionRef();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?NEW_GetLastPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetLastPixelPositionRef

; 992  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?NEW_GetLastPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ENDP ; CInstanceBase::NEW_GetLastPixelPositionRef
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_IsLastPixelPosition@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?NEW_IsLastPixelPosition@CInstanceBase@@QAE_NXZ PROC	; CInstanceBase::NEW_IsLastPixelPosition, COMDAT
; _this$ = ecx

; 985  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 986  : 	return m_GraphicThingInstance.IsPushing();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsPushing@CActorInstance@@QAE_NXZ ; CActorInstance::IsPushing

; 987  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?NEW_IsLastPixelPosition@CInstanceBase@@QAE_NXZ ENDP	; CInstanceBase::NEW_IsLastPixelPosition
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?NEW_SetOwner@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwVIDOwner$ = 8					; size = 4
?NEW_SetOwner@CInstanceBase@@QAEXK@Z PROC		; CInstanceBase::NEW_SetOwner, COMDAT
; _this$ = ecx

; 1159 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1160 : 	m_GraphicThingInstance.SetOwner(dwVIDOwner);

  00007	ff 75 08	 push	 DWORD PTR _dwVIDOwner$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?SetOwner@CActorInstance@@QAEXK@Z ; CActorInstance::SetOwner

; 1161 : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?NEW_SetOwner@CInstanceBase@@QAEXK@Z ENDP		; CInstanceBase::NEW_SetOwner
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?PushTCPStateExpanded@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MIII@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
_this$ = -44						; size = 4
_kCmdNew$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_dwCmdTime$ = 8						; size = 4
_c_rkPPosDst$ = 12					; size = 4
_fDstRot$ = 16						; size = 4
_eFunc$ = 20						; size = 4
_uArg$ = 24						; size = 4
_uTargetVID$ = 28					; size = 4
?PushTCPStateExpanded@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MIII@Z PROC ; CInstanceBase::PushTCPStateExpanded, COMDAT
; _this$ = ecx

; 1176 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 1177 : 	SCommand kCmdNew;
; 1178 : 	kCmdNew.m_kPPosDst = c_rkPPosDst;

  00015	8b 75 0c	 mov	 esi, DWORD PTR _c_rkPPosDst$[ebp]
  00018	8d 7d f0	 lea	 edi, DWORD PTR _kCmdNew$[ebp+24]
  0001b	a5		 movsd
  0001c	a5		 movsd
  0001d	a5		 movsd

; 1179 : 	kCmdNew.m_dwChkTime = dwCmdTime+100;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _dwCmdTime$[ebp]
  00021	83 c0 64	 add	 eax, 100		; 00000064H
  00024	89 45 d8	 mov	 DWORD PTR _kCmdNew$[ebp], eax

; 1180 : 	kCmdNew.m_dwCmdTime = dwCmdTime;

  00027	8b 45 08	 mov	 eax, DWORD PTR _dwCmdTime$[ebp]
  0002a	89 45 dc	 mov	 DWORD PTR _kCmdNew$[ebp+4], eax

; 1181 : 	kCmdNew.m_fDstRot = fDstRot;

  0002d	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDstRot$[ebp]
  00032	f3 0f 11 45 e0	 movss	 DWORD PTR _kCmdNew$[ebp+8], xmm0

; 1182 : 	kCmdNew.m_eFunc = eFunc;

  00037	8b 45 14	 mov	 eax, DWORD PTR _eFunc$[ebp]
  0003a	89 45 e4	 mov	 DWORD PTR _kCmdNew$[ebp+12], eax

; 1183 : 	kCmdNew.m_uArg = uArg;

  0003d	8b 45 18	 mov	 eax, DWORD PTR _uArg$[ebp]
  00040	89 45 e8	 mov	 DWORD PTR _kCmdNew$[ebp+16], eax

; 1184 : 	kCmdNew.m_uTargetVID = uTargetVID;

  00043	8b 45 1c	 mov	 eax, DWORD PTR _uTargetVID$[ebp]
  00046	89 45 ec	 mov	 DWORD PTR _kCmdNew$[ebp+20], eax

; 1185 : 	m_kQue_kCmdNew.push_back(kCmdNew);

  00049	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	05 90 06 00 00	 add	 eax, 1680		; 00000690H
  00051	89 45 d4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  00054	8d 45 d8	 lea	 eax, DWORD PTR _kCmdNew$[ebp]
  00057	50		 push	 eax
  00058	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	ff 30		 push	 DWORD PTR [eax]
  0005d	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ??$_Emplace@ABUSCommand@CInstanceBase@@@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@1@QAU21@ABUSCommand@CInstanceBase@@@Z ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Emplace<CInstanceBase::SCommand const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1186 : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006a	33 cd		 xor	 ecx, ebp
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	c9		 leave
  00072	c2 18 00	 ret	 24			; 00000018H
?PushTCPStateExpanded@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MIII@Z ENDP ; CInstanceBase::PushTCPStateExpanded
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?PushTCPState@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MII@Z
_TEXT	SEGMENT
_nNetworkGap$ = -52					; size = 4
_this$ = -48						; size = 4
_this$ = -44						; size = 4
_kCmdNew$ = -40						; size = 36
__$ArrayPad$ = -4					; size = 4
_dwCmdTime$ = 8						; size = 4
_c_rkPPosDst$ = 12					; size = 4
_fDstRot$ = 16						; size = 4
_eFunc$ = 20						; size = 4
_uArg$ = 24						; size = 4
?PushTCPState@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MII@Z PROC ; CInstanceBase::PushTCPState, COMDAT
; _this$ = ecx

; 1189 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 1190 : 	if (__IsMainInstance())

  00015	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 0d		 je	 SHORT $LN2@PushTCPSta

; 1191 : 	{
; 1192 : 		//assert(!"CInstanceBase::PushTCPState     !");
; 1193 : 		TraceError("CInstanceBase::PushTCPState     !");

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@IFLKAGDE@CInstanceBase?3?3PushTCPState?5?G?C?$LH@
  00029	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  0002e	59		 pop	 ecx

; 1194 : 		return;

  0002f	eb 7a		 jmp	 SHORT $LN1@PushTCPSta
$LN2@PushTCPSta:

; 1195 : 	}
; 1196 : 
; 1197 : 	int nNetworkGap=ELTimer_GetServerFrameMSec()-dwCmdTime;

  00031	e8 00 00 00 00	 call	 ?ELTimer_GetServerFrameMSec@@YAKXZ ; ELTimer_GetServerFrameMSec
  00036	2b 45 08	 sub	 eax, DWORD PTR _dwCmdTime$[ebp]
  00039	89 45 cc	 mov	 DWORD PTR _nNetworkGap$[ebp], eax

; 1198 : 	
; 1199 : 	m_nAverageNetworkGap=(m_nAverageNetworkGap*70+nNetworkGap*30)/100;

  0003c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	6b 80 80 01 00
	00 46		 imul	 eax, DWORD PTR [eax+384], 70
  00046	6b 4d cc 1e	 imul	 ecx, DWORD PTR _nNetworkGap$[ebp], 30
  0004a	03 c1		 add	 eax, ecx
  0004c	99		 cdq
  0004d	6a 64		 push	 100			; 00000064H
  0004f	59		 pop	 ecx
  00050	f7 f9		 idiv	 ecx
  00052	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	89 81 80 01 00
	00		 mov	 DWORD PTR [ecx+384], eax

; 1200 : 	
; 1201 : 	/*
; 1202 : 	if (m_dwBaseCmdTime == 0)
; 1203 : 	{
; 1204 : 		m_dwBaseChkTime = ELTimer_GetFrameMSec()-nNetworkGap;
; 1205 : 		m_dwBaseCmdTime = dwCmdTime;
; 1206 : 
; 1207 : 		Tracenf("VID[%d]  [%d]", GetVirtualID(), nNetworkGap);
; 1208 : 	}
; 1209 : 	*/
; 1210 : 
; 1211 : 	//m_dwBaseChkTime-m_dwBaseCmdTime+ELTimer_GetServerMSec();
; 1212 : 
; 1213 : 	SCommand kCmdNew;
; 1214 : 	kCmdNew.m_kPPosDst = c_rkPPosDst;

  0005b	8b 75 0c	 mov	 esi, DWORD PTR _c_rkPPosDst$[ebp]
  0005e	8d 7d f0	 lea	 edi, DWORD PTR _kCmdNew$[ebp+24]
  00061	a5		 movsd
  00062	a5		 movsd
  00063	a5		 movsd

; 1215 : 	kCmdNew.m_dwChkTime = dwCmdTime+m_nAverageNetworkGap;//m_dwBaseChkTime + (dwCmdTime - m_dwBaseCmdTime);// + nNetworkGap;

  00064	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 4d 08	 mov	 ecx, DWORD PTR _dwCmdTime$[ebp]
  0006a	03 88 80 01 00
	00		 add	 ecx, DWORD PTR [eax+384]
  00070	89 4d d8	 mov	 DWORD PTR _kCmdNew$[ebp], ecx

; 1216 : 	kCmdNew.m_dwCmdTime = dwCmdTime;

  00073	8b 45 08	 mov	 eax, DWORD PTR _dwCmdTime$[ebp]
  00076	89 45 dc	 mov	 DWORD PTR _kCmdNew$[ebp+4], eax

; 1217 : 	kCmdNew.m_fDstRot = fDstRot;

  00079	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _fDstRot$[ebp]
  0007e	f3 0f 11 45 e0	 movss	 DWORD PTR _kCmdNew$[ebp+8], xmm0

; 1218 : 	kCmdNew.m_eFunc = eFunc;

  00083	8b 45 14	 mov	 eax, DWORD PTR _eFunc$[ebp]
  00086	89 45 e4	 mov	 DWORD PTR _kCmdNew$[ebp+12], eax

; 1219 : 	kCmdNew.m_uArg = uArg;

  00089	8b 45 18	 mov	 eax, DWORD PTR _uArg$[ebp]
  0008c	89 45 e8	 mov	 DWORD PTR _kCmdNew$[ebp+16], eax

; 1220 : 	m_kQue_kCmdNew.push_back(kCmdNew);

  0008f	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00092	05 90 06 00 00	 add	 eax, 1680		; 00000690H
  00097	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  0009a	8d 45 d8	 lea	 eax, DWORD PTR _kCmdNew$[ebp]
  0009d	50		 push	 eax
  0009e	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	ff 30		 push	 DWORD PTR [eax]
  000a3	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ??$_Emplace@ABUSCommand@CInstanceBase@@@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEPAU?$_List_node@USCommand@CInstanceBase@@PAX@1@QAU21@ABUSCommand@CInstanceBase@@@Z ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Emplace<CInstanceBase::SCommand const &>
$LN1@PushTCPSta:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1226 : }

  000ab	5f		 pop	 edi
  000ac	5e		 pop	 esi
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b0	33 cd		 xor	 ecx, ebp
  000b2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b7	c9		 leave
  000b8	c2 14 00	 ret	 20			; 00000014H
?PushTCPState@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MII@Z ENDP ; CInstanceBase::PushTCPState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?PushUDPState@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwCmdTime$ = 8						; size = 4
_c_rkPPosDst$ = 12					; size = 4
_fDstRot$ = 16						; size = 4
_eFunc$ = 20						; size = 4
_uArg$ = 24						; size = 4
?PushUDPState@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MII@Z PROC ; CInstanceBase::PushUDPState, COMDAT
; _this$ = ecx

; 1170 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1171 : }

  00007	c9		 leave
  00008	c2 14 00	 ret	 20			; 00000014H
?PushUDPState@CInstanceBase@@QAEXKABUD3DXVECTOR3@@MII@Z ENDP ; CInstanceBase::PushUDPState
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__IsSyncing@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__IsSyncing@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::__IsSyncing, COMDAT
; _this$ = ecx

; 1152 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1153 : 	return m_GraphicThingInstance.__IsSyncing();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?__IsSyncing@CActorInstance@@QAE_NXZ ; CActorInstance::__IsSyncing
  00015	0f b6 c0	 movzx	 eax, al

; 1154 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?__IsSyncing@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::__IsSyncing
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsSleep@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsSleep@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsSleep, COMDAT
; _this$ = ecx

; 1146 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1147 : 	return m_GraphicThingInstance.IsSleep();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsSleep@CActorInstance@@QAEHXZ ; CActorInstance::IsSleep

; 1148 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?IsSleep@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsSleep
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsStun@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStun@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsStun, COMDAT
; _this$ = ecx

; 1141 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1142 : 	return m_GraphicThingInstance.IsStun();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsStun@CActorInstance@@QAEHXZ ; CActorInstance::IsStun

; 1143 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?IsStun@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsStun
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsDead@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDead@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsDead, COMDAT
; _this$ = ecx

; 1136 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1137 : 	return m_GraphicThingInstance.IsDead();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsDead@CActorInstance@@QAEHXZ ; CActorInstance::IsDead

; 1138 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?IsDead@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsDead
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsGuildWall@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGuildWall@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsGuildWall, COMDAT
; _this$ = ecx

; 2331 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2332 : 	return IsWall(m_dwRace);		

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	ff b0 64 01 00
	00		 push	 DWORD PTR [eax+356]
  00010	e8 00 00 00 00	 call	 ?IsWall@@YA_NI@Z	; IsWall
  00015	59		 pop	 ecx
  00016	0f b6 c0	 movzx	 eax, al

; 2333 : }

  00019	c9		 leave
  0001a	c3		 ret	 0
?IsGuildWall@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsGuildWall
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsFlag@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFlag@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsFlag, COMDAT
; _this$ = ecx

; 2413 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2414 : 	if (GetRace() == 20035)

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  0000f	3d 43 4e 00 00	 cmp	 eax, 20035		; 00004e43H
  00014	75 05		 jne	 SHORT $LN2@IsFlag

; 2415 : 		return TRUE;

  00016	33 c0		 xor	 eax, eax
  00018	40		 inc	 eax
  00019	eb 2a		 jmp	 SHORT $LN1@IsFlag
$LN2@IsFlag:

; 2416 : 	if (GetRace() == 20036)

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  00023	3d 44 4e 00 00	 cmp	 eax, 20036		; 00004e44H
  00028	75 05		 jne	 SHORT $LN3@IsFlag

; 2417 : 		return TRUE;

  0002a	33 c0		 xor	 eax, eax
  0002c	40		 inc	 eax
  0002d	eb 16		 jmp	 SHORT $LN1@IsFlag
$LN3@IsFlag:

; 2418 : 	if (GetRace() == 20037)

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  00037	3d 45 4e 00 00	 cmp	 eax, 20037		; 00004e45H
  0003c	75 05		 jne	 SHORT $LN4@IsFlag

; 2419 : 		return TRUE;

  0003e	33 c0		 xor	 eax, eax
  00040	40		 inc	 eax
  00041	eb 02		 jmp	 SHORT $LN1@IsFlag
$LN4@IsFlag:

; 2420 : 
; 2421 : 	return FALSE;

  00043	33 c0		 xor	 eax, eax
$LN1@IsFlag:

; 2422 : }

  00045	c9		 leave
  00046	c3		 ret	 0
?IsFlag@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsFlag
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsStoneDoor@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?IsStoneDoor@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsStoneDoor, COMDAT
; _this$ = ecx

; 2408 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2409 : 	return m_GraphicThingInstance.IsDoor() && 13001 == GetVirtualNumber();

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00011	e8 00 00 00 00	 call	 ?IsDoor@CActorInstance@@QAE_NXZ ; CActorInstance::IsDoor
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 18		 je	 SHORT $LN3@IsStoneDoo
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetVirtualNumber@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualNumber
  00025	3d c9 32 00 00	 cmp	 eax, 13001		; 000032c9H
  0002a	75 09		 jne	 SHORT $LN3@IsStoneDoo
  0002c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00033	eb 04		 jmp	 SHORT $LN4@IsStoneDoo
$LN3@IsStoneDoo:
  00035	83 65 f8 00	 and	 DWORD PTR tv72[ebp], 0
$LN4@IsStoneDoo:
  00039	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]

; 2410 : }

  0003c	c9		 leave
  0003d	c3		 ret	 0
?IsStoneDoor@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsStoneDoor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsWoodenDoor@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_vnum$1 = -4						; size = 4
?IsWoodenDoor@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::IsWoodenDoor, COMDAT
; _this$ = ecx

; 2390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2391 : 	if (m_GraphicThingInstance.IsDoor())

  00008	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00011	e8 00 00 00 00	 call	 ?IsDoor@CActorInstance@@QAE_NXZ ; CActorInstance::IsDoor
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 3a		 je	 SHORT $LN2@IsWoodenDo

; 2392 : 	{
; 2393 : 		int vnum = GetVirtualNumber();

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetVirtualNumber@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualNumber
  00025	89 45 fc	 mov	 DWORD PTR _vnum$1[ebp], eax

; 2394 : 		if (vnum == 13000) // 

  00028	81 7d fc c8 32
	00 00		 cmp	 DWORD PTR _vnum$1[ebp], 13000 ; 000032c8H
  0002f	75 07		 jne	 SHORT $LN4@IsWoodenDo

; 2395 : 			return true;

  00031	33 c0		 xor	 eax, eax
  00033	40		 inc	 eax
  00034	eb 23		 jmp	 SHORT $LN1@IsWoodenDo
  00036	eb 1d		 jmp	 SHORT $LN5@IsWoodenDo
$LN4@IsWoodenDo:

; 2396 : 		else if (vnum >= 30111 && vnum <= 30119) // 

  00038	81 7d fc 9f 75
	00 00		 cmp	 DWORD PTR _vnum$1[ebp], 30111 ; 0000759fH
  0003f	7c 10		 jl	 SHORT $LN6@IsWoodenDo
  00041	81 7d fc a7 75
	00 00		 cmp	 DWORD PTR _vnum$1[ebp], 30119 ; 000075a7H
  00048	7f 07		 jg	 SHORT $LN6@IsWoodenDo

; 2397 : 			return true;

  0004a	33 c0		 xor	 eax, eax
  0004c	40		 inc	 eax
  0004d	eb 0a		 jmp	 SHORT $LN1@IsWoodenDo
  0004f	eb 04		 jmp	 SHORT $LN5@IsWoodenDo
$LN6@IsWoodenDo:

; 2398 : 		else
; 2399 : 			return false;

  00051	33 c0		 xor	 eax, eax
  00053	eb 04		 jmp	 SHORT $LN1@IsWoodenDo
$LN5@IsWoodenDo:

; 2400 : 	}

  00055	eb 02		 jmp	 SHORT $LN1@IsWoodenDo
$LN2@IsWoodenDo:

; 2401 : 	else
; 2402 : 	{
; 2403 : 		return false;

  00057	33 c0		 xor	 eax, eax
$LN1@IsWoodenDo:

; 2404 : 	}
; 2405 : }

  00059	c9		 leave
  0005a	c3		 ret	 0
?IsWoodenDoor@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::IsWoodenDoor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsBuilding@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBuilding@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsBuilding, COMDAT
; _this$ = ecx

; 2380 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2381 : 	return m_GraphicThingInstance.IsBuilding();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsBuilding@CActorInstance@@QAE_NXZ ; CActorInstance::IsBuilding
  00015	0f b6 c0	 movzx	 eax, al

; 2382 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsBuilding@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsBuilding
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsDoor@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsDoor@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsDoor, COMDAT
; _this$ = ecx

; 2385 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2386 : 	return m_GraphicThingInstance.IsDoor();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsDoor@CActorInstance@@QAE_NXZ ; CActorInstance::IsDoor
  00015	0f b6 c0	 movzx	 eax, al

; 2387 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsDoor@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsDoor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsObject@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsObject@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsObject, COMDAT
; _this$ = ecx

; 2375 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2376 : 	return m_GraphicThingInstance.IsObject();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsObject@CActorInstance@@QAE_NXZ ; CActorInstance::IsObject
  00015	0f b6 c0	 movzx	 eax, al

; 2377 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsObject@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsObject
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsGoto@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGoto@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsGoto, COMDAT
; _this$ = ecx

; 2370 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2371 : 	return m_GraphicThingInstance.IsGoto();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsGoto@CActorInstance@@QAE_NXZ ; CActorInstance::IsGoto
  00015	0f b6 c0	 movzx	 eax, al

; 2372 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsGoto@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsGoto
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsWarp@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsWarp@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsWarp, COMDAT
; _this$ = ecx

; 2365 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2366 : 	return m_GraphicThingInstance.IsWarp();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsWarp@CActorInstance@@QAE_NXZ ; CActorInstance::IsWarp
  00015	0f b6 c0	 movzx	 eax, al

; 2367 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsWarp@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsWarp
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsPoly@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPoly@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsPoly, COMDAT
; _this$ = ecx

; 2305 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2306 : 	return m_GraphicThingInstance.IsPoly();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsPoly@CActorInstance@@QAE_NXZ ; CActorInstance::IsPoly
  00015	0f b6 c0	 movzx	 eax, al

; 2307 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsPoly@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsPoly
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsPC@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPC@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsPC, COMDAT
; _this$ = ecx

; 2310 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2311 : 	return m_GraphicThingInstance.IsPC();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsPC@CActorInstance@@QAE_NXZ ; CActorInstance::IsPC
  00015	0f b6 c0	 movzx	 eax, al

; 2312 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsPC@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsPC
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsNPC@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNPC@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsNPC, COMDAT
; _this$ = ecx

; 2315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2316 : 	return m_GraphicThingInstance.IsNPC();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsNPC@CActorInstance@@QAE_NXZ ; CActorInstance::IsNPC
  00015	0f b6 c0	 movzx	 eax, al

; 2317 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsNPC@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsNPC
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsResource@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv65 = -4						; size = 4
?IsResource@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsResource, COMDAT
; _this$ = ecx

; 2337 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2338 : 	switch (m_dwVirtualNumber)

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [eax+360]
  00011	89 45 fc	 mov	 DWORD PTR tv65[ebp], eax
  00014	81 7d fc 4f 4e
	00 00		 cmp	 DWORD PTR tv65[ebp], 20047 ; 00004e4fH
  0001b	72 22		 jb	 SHORT $LN2@IsResource
  0001d	81 7d fc 5b 4e
	00 00		 cmp	 DWORD PTR tv65[ebp], 20059 ; 00004e5bH
  00024	76 14		 jbe	 SHORT $LN4@IsResource
  00026	81 7d fc 5c 76
	00 00		 cmp	 DWORD PTR tv65[ebp], 30300 ; 0000765cH
  0002d	76 10		 jbe	 SHORT $LN2@IsResource
  0002f	81 7d fc 61 76
	00 00		 cmp	 DWORD PTR tv65[ebp], 30305 ; 00007661H
  00036	76 02		 jbe	 SHORT $LN4@IsResource
  00038	eb 05		 jmp	 SHORT $LN2@IsResource
$LN4@IsResource:

; 2339 : 	{
; 2340 : 		case 20047:
; 2341 : 		case 20048:
; 2342 : 		case 20049:
; 2343 : 		case 20050:
; 2344 : 		case 20051:
; 2345 : 		case 20052:
; 2346 : 		case 20053:
; 2347 : 		case 20054:
; 2348 : 		case 20055:
; 2349 : 		case 20056:
; 2350 : 		case 20057:
; 2351 : 		case 20058:
; 2352 : 		case 20059:
; 2353 : 		case 30301:
; 2354 : 		case 30302:
; 2355 : 		case 30303:
; 2356 : 		case 30304:
; 2357 : 		case 30305:
; 2358 : 			return TRUE;

  0003a	33 c0		 xor	 eax, eax
  0003c	40		 inc	 eax
  0003d	eb 02		 jmp	 SHORT $LN1@IsResource
$LN2@IsResource:

; 2359 : 	}
; 2360 : 
; 2361 : 	return FALSE;

  0003f	33 c0		 xor	 eax, eax
$LN1@IsResource:

; 2362 : }

  00041	c9		 leave
  00042	c3		 ret	 0
?IsResource@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsResource
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsStone@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsStone@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsStone, COMDAT
; _this$ = ecx

; 2325 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2326 : 	return m_GraphicThingInstance.IsStone();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsStone@CActorInstance@@QAE_NXZ ; CActorInstance::IsStone
  00015	0f b6 c0	 movzx	 eax, al

; 2327 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsStone@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsStone
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsEnemy@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsEnemy@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsEnemy, COMDAT
; _this$ = ecx

; 2320 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2321 : 	return m_GraphicThingInstance.IsEnemy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsEnemy@CActorInstance@@QAE_NXZ ; CActorInstance::IsEnemy
  00015	0f b6 c0	 movzx	 eax, al

; 2322 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsEnemy@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsEnemy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsInSafe@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
_this$ = -8						; size = 4
_c_rkPPosCur$ = -4					; size = 4
?IsInSafe@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsInSafe, COMDAT
; _this$ = ecx

; 565  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 566  : 	const TPixelPosition& c_rkPPosCur=m_GraphicThingInstance.NEW_GetCurPixelPositionRef();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00012	e8 00 00 00 00	 call	 ?NEW_GetCurPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetCurPixelPositionRef
  00017	89 45 fc	 mov	 DWORD PTR _c_rkPPosCur$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0001f	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 567  : 	if (CPythonBackground::Instance().isAttrOn(c_rkPPosCur.x, c_rkPPosCur.y, CTerrainImpl::ATTRIBUTE_BANPK))

  00022	6a 04		 push	 4
  00024	8b 45 fc	 mov	 eax, DWORD PTR _c_rkPPosCur$[ebp]
  00027	51		 push	 ecx
  00028	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  0002d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00032	8b 45 fc	 mov	 eax, DWORD PTR _c_rkPPosCur$[ebp]
  00035	51		 push	 ecx
  00036	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0003a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0003f	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00042	e8 00 00 00 00	 call	 ?isAttrOn@CMapManager@@QAE_NMME@Z ; CMapManager::isAttrOn
  00047	0f b6 c0	 movzx	 eax, al
  0004a	85 c0		 test	 eax, eax
  0004c	74 05		 je	 SHORT $LN2@IsInSafe

; 568  : 		return TRUE;

  0004e	33 c0		 xor	 eax, eax
  00050	40		 inc	 eax
  00051	eb 02		 jmp	 SHORT $LN1@IsInSafe
$LN2@IsInSafe:

; 569  : 
; 570  : 	return FALSE;

  00053	33 c0		 xor	 eax, eax
$LN1@IsInSafe:

; 571  : }

  00055	c9		 leave
  00056	c3		 ret	 0
?IsInSafe@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsInSafe
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsForceVisible@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsForceVisible@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::IsForceVisible, COMDAT
; _this$ = ecx

; 2425 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2426 : 	if (IsAffect(AFFECT_SHOW_ALWAYS))

  00007	6a 07		 push	 7
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsAffect@CInstanceBase@@QAE_NI@Z ; CInstanceBase::IsAffect
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	74 05		 je	 SHORT $LN2@IsForceVis

; 2427 : 		return TRUE;

  00018	33 c0		 xor	 eax, eax
  0001a	40		 inc	 eax
  0001b	eb 2b		 jmp	 SHORT $LN1@IsForceVis
$LN2@IsForceVis:

; 2428 : 
; 2429 : 	if (IsObject() || IsBuilding() || IsDoor() )

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?IsObject@CInstanceBase@@QAEHXZ ; CInstanceBase::IsObject
  00025	85 c0		 test	 eax, eax
  00027	75 18		 jne	 SHORT $LN4@IsForceVis
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?IsBuilding@CInstanceBase@@QAEHXZ ; CInstanceBase::IsBuilding
  00031	85 c0		 test	 eax, eax
  00033	75 0c		 jne	 SHORT $LN4@IsForceVis
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?IsDoor@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDoor
  0003d	85 c0		 test	 eax, eax
  0003f	74 05		 je	 SHORT $LN3@IsForceVis
$LN4@IsForceVis:

; 2430 : 		return TRUE;

  00041	33 c0		 xor	 eax, eax
  00043	40		 inc	 eax
  00044	eb 02		 jmp	 SHORT $LN1@IsForceVis
$LN3@IsForceVis:

; 2431 : 
; 2432 : 	return FALSE;

  00046	33 c0		 xor	 eax, eax
$LN1@IsForceVis:

; 2433 : }

  00048	c9		 leave
  00049	c3		 ret	 0
?IsForceVisible@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::IsForceVisible
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsNewMount@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsNewMount@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsNewMount, COMDAT
; _this$ = ecx

; 938  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 939  : 	return m_kHorse.IsNewMount();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ?IsNewMount@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsNewMount
  00012	0f b6 c0	 movzx	 eax, al

; 940  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?IsNewMount@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsNewMount
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsMountingHorse@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsMountingHorse@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::IsMountingHorse, COMDAT
; _this$ = ecx

; 943  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 944  : 	return m_kHorse.IsMounting();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ?IsMounting@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::IsMounting
  00012	0f b6 c0	 movzx	 eax, al

; 945  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?IsMountingHorse@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::IsMountingHorse
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsHoldingPickAxe@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_c_iPickAxeEnd$ = -16					; size = 4
_c_iPickAxeStart$ = -12					; size = 4
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?IsHoldingPickAxe@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::IsHoldingPickAxe, COMDAT
; _this$ = ecx

; 931  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 932  : 	const int c_iPickAxeStart = 29101;

  00009	c7 45 f4 ad 71
	00 00		 mov	 DWORD PTR _c_iPickAxeStart$[ebp], 29101 ; 000071adH

; 933  : 	const int c_iPickAxeEnd = 29110;

  00010	c7 45 f0 b6 71
	00 00		 mov	 DWORD PTR _c_iPickAxeEnd$[ebp], 29110 ; 000071b6H

; 934  : 	return m_awPart[CRaceData::PART_WEAPON] >= c_iPickAxeStart && m_awPart[CRaceData::PART_WEAPON] <= c_iPickAxeEnd;

  00017	6a 04		 push	 4
  00019	58		 pop	 eax
  0001a	c1 e0 00	 shl	 eax, 0
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	81 7c 01 28 ad
	71 00 00	 cmp	 DWORD PTR [ecx+eax+40], 29101 ; 000071adH
  00028	72 1c		 jb	 SHORT $LN3@IsHoldingP
  0002a	6a 04		 push	 4
  0002c	58		 pop	 eax
  0002d	c1 e0 00	 shl	 eax, 0
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	81 7c 01 28 b6
	71 00 00	 cmp	 DWORD PTR [ecx+eax+40], 29110 ; 000071b6H
  0003b	77 09		 ja	 SHORT $LN3@IsHoldingP
  0003d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv72[ebp], 1
  00044	eb 04		 jmp	 SHORT $LN4@IsHoldingP
$LN3@IsHoldingP:
  00046	83 65 f8 00	 and	 DWORD PTR tv72[ebp], 0
$LN4@IsHoldingP:
  0004a	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]

; 935  : }

  0004d	c9		 leave
  0004e	c3		 ret	 0
?IsHoldingPickAxe@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::IsHoldingPickAxe
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsWearingDress@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_c_iWeddingDressShape$ = -12				; size = 4
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?IsWearingDress@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::IsWearingDress, COMDAT
; _this$ = ecx

; 925  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 926  : 	const int c_iWeddingDressShape = 201;

  00009	c7 45 f4 c9 00
	00 00		 mov	 DWORD PTR _c_iWeddingDressShape$[ebp], 201 ; 000000c9H

; 927  : 	return c_iWeddingDressShape == m_eShape;

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	81 b8 60 01 00
	00 c9 00 00 00	 cmp	 DWORD PTR [eax+352], 201 ; 000000c9H
  0001d	75 09		 jne	 SHORT $LN3@IsWearingD
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00026	eb 04		 jmp	 SHORT $LN4@IsWearingD
$LN3@IsWearingD:
  00028	83 65 fc 00	 and	 DWORD PTR tv66[ebp], 0
$LN4@IsWearingD:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR tv66[ebp]

; 928  : }

  0002f	c9		 leave
  00030	c3		 ret	 0
?IsWearingDress@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::IsWearingDress
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsFishing@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFishing@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsFishing, COMDAT
; _this$ = ecx

; 1131 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1132 : 	return m_GraphicThingInstance.IsFishing();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsFishing@CActorInstance@@QAEHXZ ; CActorInstance::IsFishing

; 1133 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?IsFishing@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsFishing
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsFishingMode@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsFishingMode@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::IsFishingMode, COMDAT
; _this$ = ecx

; 1123 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1124 : 	if (CRaceMotionData::MODE_FISHING == m_GraphicThingInstance.GetMotionMode())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?GetMotionMode@CActorInstance@@QAEHXZ ; CActorInstance::GetMotionMode
  00015	83 f8 08	 cmp	 eax, 8
  00018	75 05		 jne	 SHORT $LN2@IsFishingM

; 1125 : 		return true;

  0001a	33 c0		 xor	 eax, eax
  0001c	40		 inc	 eax
  0001d	eb 02		 jmp	 SHORT $LN1@IsFishingM
$LN2@IsFishingM:

; 1126 : 
; 1127 : 	return false;

  0001f	33 c0		 xor	 eax, eax
$LN1@IsFishingM:

; 1128 : }

  00021	c9		 leave
  00022	c3		 ret	 0
?IsFishingMode@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::IsFishingMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsHandMode@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsHandMode@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsHandMode, COMDAT
; _this$ = ecx

; 1118 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1119 : 	return m_GraphicThingInstance.IsHandMode();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsHandMode@CActorInstance@@QAE_NXZ ; CActorInstance::IsHandMode
  00015	0f b6 c0	 movzx	 eax, al

; 1120 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsHandMode@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsHandMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsBowMode@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsBowMode@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsBowMode, COMDAT
; _this$ = ecx

; 1113 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1114 : 	return m_GraphicThingInstance.IsBowMode();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsBowMode@CActorInstance@@QAE_NXZ ; CActorInstance::IsBowMode
  00015	0f b6 c0	 movzx	 eax, al

; 1115 : }

  00018	c9		 leave
  00019	c3		 ret	 0
?IsBowMode@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsBowMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsSameEmpire@CInstanceBase@@QAEHAAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkInstDst$ = 8						; size = 4
?IsSameEmpire@CInstanceBase@@QAEHAAV1@@Z PROC		; CInstanceBase::IsSameEmpire, COMDAT
; _this$ = ecx

; 470  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 471  : 	if (0 == rkInstDst.m_dwEmpireID)

  00007	8b 45 08	 mov	 eax, DWORD PTR _rkInstDst$[ebp]
  0000a	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  0000e	75 05		 jne	 SHORT $LN2@IsSameEmpi

; 472  : 		return TRUE;

  00010	33 c0		 xor	 eax, eax
  00012	40		 inc	 eax
  00013	eb 37		 jmp	 SHORT $LN1@IsSameEmpi
$LN2@IsSameEmpi:

; 473  : 
; 474  : 	if (IsGameMaster())

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?IsGameMaster@CInstanceBase@@QAEHXZ ; CInstanceBase::IsGameMaster
  0001d	85 c0		 test	 eax, eax
  0001f	74 05		 je	 SHORT $LN3@IsSameEmpi

; 475  : 		return TRUE;

  00021	33 c0		 xor	 eax, eax
  00023	40		 inc	 eax
  00024	eb 26		 jmp	 SHORT $LN1@IsSameEmpi
$LN3@IsSameEmpi:

; 476  : 
; 477  : 	if (rkInstDst.IsGameMaster())

  00026	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstDst$[ebp]
  00029	e8 00 00 00 00	 call	 ?IsGameMaster@CInstanceBase@@QAEHXZ ; CInstanceBase::IsGameMaster
  0002e	85 c0		 test	 eax, eax
  00030	74 05		 je	 SHORT $LN4@IsSameEmpi

; 478  : 		return TRUE;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	eb 15		 jmp	 SHORT $LN1@IsSameEmpi
$LN4@IsSameEmpi:

; 479  : 
; 480  : 	if (rkInstDst.m_dwEmpireID==m_dwEmpireID)

  00037	8b 45 08	 mov	 eax, DWORD PTR _rkInstDst$[ebp]
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	8b 40 40	 mov	 eax, DWORD PTR [eax+64]
  00040	3b 41 40	 cmp	 eax, DWORD PTR [ecx+64]
  00043	75 05		 jne	 SHORT $LN5@IsSameEmpi

; 481  : 		return TRUE;

  00045	33 c0		 xor	 eax, eax
  00047	40		 inc	 eax
  00048	eb 02		 jmp	 SHORT $LN1@IsSameEmpi
$LN5@IsSameEmpi:

; 482  : 
; 483  : 	return FALSE;

  0004a	33 c0		 xor	 eax, eax
$LN1@IsSameEmpi:

; 484  : }

  0004c	c9		 leave
  0004d	c2 04 00	 ret	 4
?IsSameEmpire@CInstanceBase@@QAEHAAV1@@Z ENDP		; CInstanceBase::IsSameEmpire
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsGameMaster@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsGameMaster@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::IsGameMaster, COMDAT
; _this$ = ecx

; 462  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 463  : 	if (m_kAffectFlagContainer.IsSet(AFFECT_YMIR))

  00007	6a 00		 push	 0
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 48	 add	 ecx, 72			; 00000048H
  0000f	e8 00 00 00 00	 call	 ?IsSet@CAffectFlagContainer@@QBE_NI@Z ; CAffectFlagContainer::IsSet
  00014	0f b6 c0	 movzx	 eax, al
  00017	85 c0		 test	 eax, eax
  00019	74 05		 je	 SHORT $LN2@IsGameMast

; 464  : 		return true;

  0001b	33 c0		 xor	 eax, eax
  0001d	40		 inc	 eax
  0001e	eb 02		 jmp	 SHORT $LN1@IsGameMast
$LN2@IsGameMast:

; 465  : 	return false;

  00020	33 c0		 xor	 eax, eax
$LN1@IsGameMast:

; 466  : }

  00022	c9		 leave
  00023	c3		 ret	 0
?IsGameMaster@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::IsGameMaster
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsParalysis@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsParalysis@CInstanceBase@@QAEHXZ PROC			; CInstanceBase::IsParalysis, COMDAT
; _this$ = ecx

; 457  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 458  : 	return m_GraphicThingInstance.IsParalysis();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?IsParalysis@CActorInstance@@QAEHXZ ; CActorInstance::IsParalysis

; 459  : }

  00015	c9		 leave
  00016	c3		 ret	 0
?IsParalysis@CInstanceBase@@QAEHXZ ENDP			; CInstanceBase::IsParalysis
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsInvisibility@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsInvisibility@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::IsInvisibility, COMDAT
; _this$ = ecx

; 449  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 450  : 	if (IsAffect(AFFECT_INVISIBILITY))

  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsAffect@CInstanceBase@@QAE_NI@Z ; CInstanceBase::IsAffect
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	74 05		 je	 SHORT $LN2@IsInvisibi

; 451  : 		return true;

  00018	33 c0		 xor	 eax, eax
  0001a	40		 inc	 eax
  0001b	eb 02		 jmp	 SHORT $LN1@IsInvisibi
$LN2@IsInvisibi:

; 452  : 
; 453  : 	return false;

  0001d	33 c0		 xor	 eax, eax
$LN1@IsInvisibi:

; 454  : }

  0001f	c9		 leave
  00020	c3		 ret	 0
?IsInvisibility@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::IsInvisibility
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanViewTargetHP@CInstanceBase@@QAE_NAAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkInstVictim$ = 8					; size = 4
?CanViewTargetHP@CInstanceBase@@QAE_NAAV1@@Z PROC	; CInstanceBase::CanViewTargetHP, COMDAT
; _this$ = ecx

; 2293 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2294 : 	if (rkInstVictim.IsStone())

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsStone@CInstanceBase@@QAEHXZ ; CInstanceBase::IsStone
  0000f	85 c0		 test	 eax, eax
  00011	74 04		 je	 SHORT $LN2@CanViewTar

; 2295 : 		return true;

  00013	b0 01		 mov	 al, 1
  00015	eb 22		 jmp	 SHORT $LN1@CanViewTar
$LN2@CanViewTar:

; 2296 : 	if (rkInstVictim.IsWoodenDoor())

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0001a	e8 00 00 00 00	 call	 ?IsWoodenDoor@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWoodenDoor
  0001f	85 c0		 test	 eax, eax
  00021	74 04		 je	 SHORT $LN3@CanViewTar

; 2297 : 		return true;

  00023	b0 01		 mov	 al, 1
  00025	eb 12		 jmp	 SHORT $LN1@CanViewTar
$LN3@CanViewTar:

; 2298 : 	if (rkInstVictim.IsEnemy())

  00027	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0002a	e8 00 00 00 00	 call	 ?IsEnemy@CInstanceBase@@QAEHXZ ; CInstanceBase::IsEnemy
  0002f	85 c0		 test	 eax, eax
  00031	74 04		 je	 SHORT $LN4@CanViewTar

; 2299 : 		return true;

  00033	b0 01		 mov	 al, 1
  00035	eb 02		 jmp	 SHORT $LN1@CanViewTar
$LN4@CanViewTar:

; 2300 : 
; 2301 : 	return false;

  00037	32 c0		 xor	 al, al
$LN1@CanViewTar:

; 2302 : }

  00039	c9		 leave
  0003a	c2 04 00	 ret	 4
?CanViewTargetHP@CInstanceBase@@QAE_NAAV1@@Z ENDP	; CInstanceBase::CanViewTargetHP
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanPickInstance@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanPickInstance@CInstanceBase@@QAE_NXZ PROC		; CInstanceBase::CanPickInstance, COMDAT
; _this$ = ecx

; 2263 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2264 : 	if (!__IsInViewFrustum())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__IsInViewFrustum@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsInViewFrustum
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 07		 jne	 SHORT $LN2@CanPickIns

; 2265 : 		return false;

  00016	32 c0		 xor	 al, al
  00018	e9 88 00 00 00	 jmp	 $LN1@CanPickIns
$LN2@CanPickIns:

; 2266 : 
; 2267 : 	if (IsDoor())

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?IsDoor@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDoor
  00025	85 c0		 test	 eax, eax
  00027	74 10		 je	 SHORT $LN3@CanPickIns

; 2268 : 	{
; 2269 : 		if (IsDead())

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?IsDead@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDead
  00031	85 c0		 test	 eax, eax
  00033	74 04		 je	 SHORT $LN3@CanPickIns

; 2270 : 			return false;

  00035	32 c0		 xor	 al, al
  00037	eb 6c		 jmp	 SHORT $LN1@CanPickIns
$LN3@CanPickIns:

; 2271 : 	}
; 2272 : 
; 2273 : 	if (IsPC())

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  00041	85 c0		 test	 eax, eax
  00043	74 4e		 je	 SHORT $LN5@CanPickIns

; 2274 : 	{
; 2275 : 		if (IsAffect(AFFECT_EUNHYEONG))

  00045	6a 12		 push	 18			; 00000012H
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?IsAffect@CInstanceBase@@QAE_NI@Z ; CInstanceBase::IsAffect
  0004f	0f b6 c0	 movzx	 eax, al
  00052	85 c0		 test	 eax, eax
  00054	74 13		 je	 SHORT $LN6@CanPickIns

; 2276 : 		{
; 2277 : 			if (!__MainCanSeeHiddenThing())

  00056	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?__MainCanSeeHiddenThing@CInstanceBase@@IAE_NXZ ; CInstanceBase::__MainCanSeeHiddenThing
  0005e	0f b6 c0	 movzx	 eax, al
  00061	85 c0		 test	 eax, eax
  00063	75 04		 jne	 SHORT $LN6@CanPickIns

; 2278 : 				return false;

  00065	32 c0		 xor	 al, al
  00067	eb 3c		 jmp	 SHORT $LN1@CanPickIns
$LN6@CanPickIns:

; 2279 : 		}
; 2280 : 		if (IsAffect(AFFECT_REVIVE_INVISIBILITY))

  00069	6a 1b		 push	 27			; 0000001bH
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?IsAffect@CInstanceBase@@QAE_NI@Z ; CInstanceBase::IsAffect
  00073	0f b6 c0	 movzx	 eax, al
  00076	85 c0		 test	 eax, eax
  00078	74 04		 je	 SHORT $LN8@CanPickIns

; 2281 : 			return false;

  0007a	32 c0		 xor	 al, al
  0007c	eb 27		 jmp	 SHORT $LN1@CanPickIns
$LN8@CanPickIns:

; 2282 : 		if (IsAffect(AFFECT_INVISIBILITY))

  0007e	6a 01		 push	 1
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?IsAffect@CInstanceBase@@QAE_NI@Z ; CInstanceBase::IsAffect
  00088	0f b6 c0	 movzx	 eax, al
  0008b	85 c0		 test	 eax, eax
  0008d	74 04		 je	 SHORT $LN5@CanPickIns

; 2283 : 			return false;

  0008f	32 c0		 xor	 al, al
  00091	eb 12		 jmp	 SHORT $LN1@CanPickIns
$LN5@CanPickIns:

; 2284 : 	}
; 2285 : 
; 2286 : 	if (IsDead())

  00093	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?IsDead@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDead
  0009b	85 c0		 test	 eax, eax
  0009d	74 04		 je	 SHORT $LN10@CanPickIns

; 2287 : 		return false;

  0009f	32 c0		 xor	 al, al
  000a1	eb 02		 jmp	 SHORT $LN1@CanPickIns
$LN10@CanPickIns:

; 2288 : 
; 2289 : 	return true;

  000a3	b0 01		 mov	 al, 1
$LN1@CanPickIns:

; 2290 : }

  000a5	c9		 leave
  000a6	c3		 ret	 0
?CanPickInstance@CInstanceBase@@QAE_NXZ ENDP		; CInstanceBase::CanPickInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanChangeTarget@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanChangeTarget@CInstanceBase@@QAE_NXZ PROC		; CInstanceBase::CanChangeTarget, COMDAT
; _this$ = ecx

; 2257 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2258 : 	return m_GraphicThingInstance.CanChangeTarget();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?CanChangeTarget@CActorInstance@@QAE_NXZ ; CActorInstance::CanChangeTarget

; 2259 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?CanChangeTarget@CInstanceBase@@QAE_NXZ ENDP		; CInstanceBase::CanChangeTarget
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsTargetableInstance@CInstanceBase@@QAE_NAAV1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rkInstVictim$ = 8					; size = 4
?IsTargetableInstance@CInstanceBase@@QAE_NAAV1@@Z PROC	; CInstanceBase::IsTargetableInstance, COMDAT
; _this$ = ecx

; 2251 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2252 : 	return rkInstVictim.CanPickInstance();

  00007	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0000a	e8 00 00 00 00	 call	 ?CanPickInstance@CInstanceBase@@QAE_NXZ ; CInstanceBase::CanPickInstance

; 2253 : }

  0000f	c9		 leave
  00010	c2 04 00	 ret	 4
?IsTargetableInstance@CInstanceBase@@QAE_NAAV1@@Z ENDP	; CInstanceBase::IsTargetableInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsAttackableInstance@CInstanceBase@@QAE_NAAV1@@Z
_TEXT	SEGMENT
_rkPlayer$1 = -28					; size = 4
tv237 = -24						; size = 4
tv205 = -20						; size = 4
tv183 = -16						; size = 4
tv157 = -12						; size = 4
tv130 = -8						; size = 4
_this$ = -4						; size = 4
_rkInstVictim$ = 8					; size = 4
?IsAttackableInstance@CInstanceBase@@QAE_NAAV1@@Z PROC	; CInstanceBase::IsAttackableInstance, COMDAT
; _this$ = ecx

; 2147 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2148 : 	if (__IsMainInstance())

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 1e		 je	 SHORT $LN4@IsAttackab

; 2149 : 	{		
; 2150 : 		CPythonPlayer& rkPlayer=CPythonPlayer::Instance();

  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonPlayer@@@@0PAVCPythonPlayer@@A ; CSingleton<CPythonPlayer>::ms_singleton
  0001e	89 45 e4	 mov	 DWORD PTR _rkPlayer$1[ebp], eax

; 2151 : 		if(rkPlayer.IsObserverMode())

  00021	8b 4d e4	 mov	 ecx, DWORD PTR _rkPlayer$1[ebp]
  00024	e8 00 00 00 00	 call	 ?IsObserverMode@CPythonPlayer@@QAE_NXZ ; CPythonPlayer::IsObserverMode
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	74 07		 je	 SHORT $LN4@IsAttackab

; 2152 : 			return false;

  00030	32 c0		 xor	 al, al
  00032	e9 10 03 00 00	 jmp	 $LN1@IsAttackab
$LN4@IsAttackab:

; 2153 : 	}
; 2154 : 
; 2155 : 	if (GetVirtualID() == rkInstVictim.GetVirtualID())

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  0003f	8b f0		 mov	 esi, eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00044	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  00049	3b f0		 cmp	 esi, eax
  0004b	75 07		 jne	 SHORT $LN6@IsAttackab

; 2156 : 		return false;

  0004d	32 c0		 xor	 al, al
  0004f	e9 f3 02 00 00	 jmp	 $LN1@IsAttackab
$LN6@IsAttackab:

; 2157 : 
; 2158 : 	if (IsStone())

  00054	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	e8 00 00 00 00	 call	 ?IsStone@CInstanceBase@@QAEHXZ ; CInstanceBase::IsStone
  0005c	85 c0		 test	 eax, eax
  0005e	74 18		 je	 SHORT $LN7@IsAttackab

; 2159 : 	{
; 2160 : 		if (rkInstVictim.IsPC())

  00060	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00063	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  00068	85 c0		 test	 eax, eax
  0006a	74 07		 je	 SHORT $LN9@IsAttackab

; 2161 : 			return true;

  0006c	b0 01		 mov	 al, 1
  0006e	e9 d4 02 00 00	 jmp	 $LN1@IsAttackab
$LN9@IsAttackab:

; 2162 : 	}

  00073	e9 cd 02 00 00	 jmp	 $LN8@IsAttackab
$LN7@IsAttackab:

; 2163 : 	else if (IsPC())

  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  00080	85 c0		 test	 eax, eax
  00082	0f 84 63 02 00
	00		 je	 $LN10@IsAttackab

; 2164 : 	{
; 2165 : 		if (rkInstVictim.IsStone())

  00088	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0008b	e8 00 00 00 00	 call	 ?IsStone@CInstanceBase@@QAEHXZ ; CInstanceBase::IsStone
  00090	85 c0		 test	 eax, eax
  00092	74 07		 je	 SHORT $LN12@IsAttackab

; 2166 : 			return true;

  00094	b0 01		 mov	 al, 1
  00096	e9 ac 02 00 00	 jmp	 $LN1@IsAttackab
$LN12@IsAttackab:

; 2167 : 
; 2168 : 		if (rkInstVictim.IsPC())

  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0009e	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  000a3	85 c0		 test	 eax, eax
  000a5	0f 84 1e 02 00
	00		 je	 $LN13@IsAttackab

; 2169 : 		{
; 2170 : 			if (GetDuelMode())

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?GetDuelMode@CInstanceBase@@QAEKXZ ; CInstanceBase::GetDuelMode
  000b3	85 c0		 test	 eax, eax
  000b5	74 50		 je	 SHORT $LN14@IsAttackab

; 2171 : 			{
; 2172 : 				switch(GetDuelMode())

  000b7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	e8 00 00 00 00	 call	 ?GetDuelMode@CInstanceBase@@QAEKXZ ; CInstanceBase::GetDuelMode
  000bf	89 45 f8	 mov	 DWORD PTR tv130[ebp], eax
  000c2	83 7d f8 01	 cmp	 DWORD PTR tv130[ebp], 1
  000c6	74 08		 je	 SHORT $LN15@IsAttackab
  000c8	83 7d f8 02	 cmp	 DWORD PTR tv130[ebp], 2
  000cc	74 09		 je	 SHORT $LN16@IsAttackab
  000ce	eb 37		 jmp	 SHORT $LN14@IsAttackab
$LN15@IsAttackab:

; 2173 : 				{
; 2174 : 				case DUEL_CANNOTATTACK:
; 2175 : 					return false;

  000d0	32 c0		 xor	 al, al
  000d2	e9 70 02 00 00	 jmp	 $LN1@IsAttackab
$LN16@IsAttackab:

; 2176 : 				case DUEL_START:
; 2177 : 					if(__FindDUELKey(GetVirtualID(),rkInstVictim.GetVirtualID()))

  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  000da	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  000df	50		 push	 eax
  000e0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  000e8	50		 push	 eax
  000e9	e8 00 00 00 00	 call	 ?__FindDUELKey@CInstanceBase@@KA_NKK@Z ; CInstanceBase::__FindDUELKey
  000ee	59		 pop	 ecx
  000ef	59		 pop	 ecx
  000f0	0f b6 c0	 movzx	 eax, al
  000f3	85 c0		 test	 eax, eax
  000f5	74 09		 je	 SHORT $LN17@IsAttackab

; 2178 : 						return true;

  000f7	b0 01		 mov	 al, 1
  000f9	e9 49 02 00 00	 jmp	 $LN1@IsAttackab
  000fe	eb 07		 jmp	 SHORT $LN14@IsAttackab
$LN17@IsAttackab:

; 2179 : 					else
; 2180 : 						return false;

  00100	32 c0		 xor	 al, al
  00102	e9 40 02 00 00	 jmp	 $LN1@IsAttackab
$LN14@IsAttackab:

; 2181 : 				}
; 2182 : 			}
; 2183 : 			if (PK_MODE_GUILD == GetPKMode())

  00107	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010a	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  0010f	0f b6 c0	 movzx	 eax, al
  00112	83 f8 04	 cmp	 eax, 4
  00115	75 1d		 jne	 SHORT $LN19@IsAttackab

; 2184 : 				if (GetGuildID() == rkInstVictim.GetGuildID())

  00117	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011a	e8 00 00 00 00	 call	 ?GetGuildID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetGuildID
  0011f	8b f0		 mov	 esi, eax
  00121	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00124	e8 00 00 00 00	 call	 ?GetGuildID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetGuildID
  00129	3b f0		 cmp	 esi, eax
  0012b	75 07		 jne	 SHORT $LN19@IsAttackab

; 2185 : 					return false;

  0012d	32 c0		 xor	 al, al
  0012f	e9 13 02 00 00	 jmp	 $LN1@IsAttackab
$LN19@IsAttackab:

; 2186 : 
; 2187 : 			if (rkInstVictim.IsKiller())

  00134	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00137	e8 00 00 00 00	 call	 ?IsKiller@CInstanceBase@@QAE_NXZ ; CInstanceBase::IsKiller
  0013c	0f b6 c0	 movzx	 eax, al
  0013f	85 c0		 test	 eax, eax
  00141	74 33		 je	 SHORT $LN21@IsAttackab

; 2188 : 				if (!IAbstractPlayer::GetSingleton().IsSamePartyMember(GetVirtualID(), rkInstVictim.GetVirtualID()))

  00143	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  00148	89 45 f4	 mov	 DWORD PTR tv157[ebp], eax
  0014b	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0014e	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  00153	50		 push	 eax
  00154	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  0015c	50		 push	 eax
  0015d	8b 45 f4	 mov	 eax, DWORD PTR tv157[ebp]
  00160	8b 00		 mov	 eax, DWORD PTR [eax]
  00162	8b 4d f4	 mov	 ecx, DWORD PTR tv157[ebp]
  00165	ff 50 2c	 call	 DWORD PTR [eax+44]
  00168	0f b6 c0	 movzx	 eax, al
  0016b	85 c0		 test	 eax, eax
  0016d	75 07		 jne	 SHORT $LN21@IsAttackab

; 2189 : 					return true;

  0016f	b0 01		 mov	 al, 1
  00171	e9 d1 01 00 00	 jmp	 $LN1@IsAttackab
$LN21@IsAttackab:

; 2190 : 
; 2191 : 			if (PK_MODE_PROTECT != GetPKMode())

  00176	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00179	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  0017e	0f b6 c0	 movzx	 eax, al
  00181	83 f8 03	 cmp	 eax, 3
  00184	0f 84 bc 00 00
	00		 je	 $LN23@IsAttackab

; 2192 : 			{
; 2193 : 				if (PK_MODE_FREE == GetPKMode())

  0018a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0018d	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  00192	0f b6 c0	 movzx	 eax, al
  00195	83 f8 02	 cmp	 eax, 2
  00198	75 43		 jne	 SHORT $LN24@IsAttackab

; 2194 : 				{
; 2195 : 					if (PK_MODE_PROTECT != rkInstVictim.GetPKMode())

  0019a	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0019d	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  001a2	0f b6 c0	 movzx	 eax, al
  001a5	83 f8 03	 cmp	 eax, 3
  001a8	74 33		 je	 SHORT $LN24@IsAttackab

; 2196 : 						if (!IAbstractPlayer::GetSingleton().IsSamePartyMember(GetVirtualID(), rkInstVictim.GetVirtualID()))

  001aa	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  001af	89 45 f0	 mov	 DWORD PTR tv183[ebp], eax
  001b2	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  001b5	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  001ba	50		 push	 eax
  001bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001be	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  001c3	50		 push	 eax
  001c4	8b 45 f0	 mov	 eax, DWORD PTR tv183[ebp]
  001c7	8b 00		 mov	 eax, DWORD PTR [eax]
  001c9	8b 4d f0	 mov	 ecx, DWORD PTR tv183[ebp]
  001cc	ff 50 2c	 call	 DWORD PTR [eax+44]
  001cf	0f b6 c0	 movzx	 eax, al
  001d2	85 c0		 test	 eax, eax
  001d4	75 07		 jne	 SHORT $LN24@IsAttackab

; 2197 : 							return true;

  001d6	b0 01		 mov	 al, 1
  001d8	e9 6a 01 00 00	 jmp	 $LN1@IsAttackab
$LN24@IsAttackab:

; 2198 : 				}
; 2199 : 				if (PK_MODE_GUILD == GetPKMode())

  001dd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  001e5	0f b6 c0	 movzx	 eax, al
  001e8	83 f8 04	 cmp	 eax, 4
  001eb	75 59		 jne	 SHORT $LN23@IsAttackab

; 2200 : 				{
; 2201 : 					if (PK_MODE_PROTECT != rkInstVictim.GetPKMode())

  001ed	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  001f0	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  001f5	0f b6 c0	 movzx	 eax, al
  001f8	83 f8 03	 cmp	 eax, 3
  001fb	74 49		 je	 SHORT $LN23@IsAttackab

; 2202 : 						if (!IAbstractPlayer::GetSingleton().IsSamePartyMember(GetVirtualID(), rkInstVictim.GetVirtualID()))

  001fd	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  00202	89 45 ec	 mov	 DWORD PTR tv205[ebp], eax
  00205	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00208	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  0020d	50		 push	 eax
  0020e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00211	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  00216	50		 push	 eax
  00217	8b 45 ec	 mov	 eax, DWORD PTR tv205[ebp]
  0021a	8b 00		 mov	 eax, DWORD PTR [eax]
  0021c	8b 4d ec	 mov	 ecx, DWORD PTR tv205[ebp]
  0021f	ff 50 2c	 call	 DWORD PTR [eax+44]
  00222	0f b6 c0	 movzx	 eax, al
  00225	85 c0		 test	 eax, eax
  00227	75 1d		 jne	 SHORT $LN23@IsAttackab

; 2203 : 							if (GetGuildID() != rkInstVictim.GetGuildID())

  00229	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0022c	e8 00 00 00 00	 call	 ?GetGuildID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetGuildID
  00231	8b f0		 mov	 esi, eax
  00233	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00236	e8 00 00 00 00	 call	 ?GetGuildID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetGuildID
  0023b	3b f0		 cmp	 esi, eax
  0023d	74 07		 je	 SHORT $LN23@IsAttackab

; 2204 : 								return true;

  0023f	b0 01		 mov	 al, 1
  00241	e9 01 01 00 00	 jmp	 $LN1@IsAttackab
$LN23@IsAttackab:

; 2205 : 				}
; 2206 : 			}
; 2207 : 
; 2208 : 			if (IsSameEmpire(rkInstVictim))

  00246	ff 75 08	 push	 DWORD PTR _rkInstVictim$[ebp]
  00249	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0024c	e8 00 00 00 00	 call	 ?IsSameEmpire@CInstanceBase@@QAEHAAV1@@Z ; CInstanceBase::IsSameEmpire
  00251	85 c0		 test	 eax, eax
  00253	74 70		 je	 SHORT $LN31@IsAttackab

; 2209 : 			{
; 2210 : 				if (IsPVPInstance(rkInstVictim))

  00255	ff 75 08	 push	 DWORD PTR _rkInstVictim$[ebp]
  00258	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0025b	e8 00 00 00 00	 call	 ?IsPVPInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsPVPInstance
  00260	0f b6 c0	 movzx	 eax, al
  00263	85 c0		 test	 eax, eax
  00265	74 07		 je	 SHORT $LN33@IsAttackab

; 2211 : 					return true;

  00267	b0 01		 mov	 al, 1
  00269	e9 d9 00 00 00	 jmp	 $LN1@IsAttackab
$LN33@IsAttackab:

; 2212 : 
; 2213 : 				if (PK_MODE_REVENGE == GetPKMode())

  0026e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00271	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  00276	0f b6 c0	 movzx	 eax, al
  00279	83 f8 01	 cmp	 eax, 1
  0027c	75 45		 jne	 SHORT $LN34@IsAttackab

; 2214 : 					if (!IAbstractPlayer::GetSingleton().IsSamePartyMember(GetVirtualID(), rkInstVictim.GetVirtualID()))

  0027e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  00283	89 45 e8	 mov	 DWORD PTR tv237[ebp], eax
  00286	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00289	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  0028e	50		 push	 eax
  0028f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00292	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  00297	50		 push	 eax
  00298	8b 45 e8	 mov	 eax, DWORD PTR tv237[ebp]
  0029b	8b 00		 mov	 eax, DWORD PTR [eax]
  0029d	8b 4d e8	 mov	 ecx, DWORD PTR tv237[ebp]
  002a0	ff 50 2c	 call	 DWORD PTR [eax+44]
  002a3	0f b6 c0	 movzx	 eax, al
  002a6	85 c0		 test	 eax, eax
  002a8	75 19		 jne	 SHORT $LN34@IsAttackab

; 2215 : 						if (IsConflictAlignmentInstance(rkInstVictim))

  002aa	ff 75 08	 push	 DWORD PTR _rkInstVictim$[ebp]
  002ad	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002b0	e8 00 00 00 00	 call	 ?IsConflictAlignmentInstance@CInstanceBase@@QAE_NAAV1@@Z ; CInstanceBase::IsConflictAlignmentInstance
  002b5	0f b6 c0	 movzx	 eax, al
  002b8	85 c0		 test	 eax, eax
  002ba	74 07		 je	 SHORT $LN34@IsAttackab

; 2216 : 							return true;

  002bc	b0 01		 mov	 al, 1
  002be	e9 84 00 00 00	 jmp	 $LN1@IsAttackab
$LN34@IsAttackab:

; 2217 : 			}

  002c3	eb 04		 jmp	 SHORT $LN13@IsAttackab
$LN31@IsAttackab:

; 2218 : 			else
; 2219 : 			{
; 2220 : 				return true;

  002c5	b0 01		 mov	 al, 1
  002c7	eb 7e		 jmp	 SHORT $LN1@IsAttackab
$LN13@IsAttackab:

; 2221 : 			}
; 2222 : 		}
; 2223 : 
; 2224 : 		if (rkInstVictim.IsEnemy())

  002c9	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  002cc	e8 00 00 00 00	 call	 ?IsEnemy@CInstanceBase@@QAEHXZ ; CInstanceBase::IsEnemy
  002d1	85 c0		 test	 eax, eax
  002d3	74 04		 je	 SHORT $LN37@IsAttackab

; 2225 : 			return true;

  002d5	b0 01		 mov	 al, 1
  002d7	eb 6e		 jmp	 SHORT $LN1@IsAttackab
$LN37@IsAttackab:

; 2226 : 
; 2227 : 		if (rkInstVictim.IsWoodenDoor())

  002d9	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  002dc	e8 00 00 00 00	 call	 ?IsWoodenDoor@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWoodenDoor
  002e1	85 c0		 test	 eax, eax
  002e3	74 04		 je	 SHORT $LN38@IsAttackab

; 2228 : 			return true;

  002e5	b0 01		 mov	 al, 1
  002e7	eb 5e		 jmp	 SHORT $LN1@IsAttackab
$LN38@IsAttackab:

; 2229 : 	}

  002e9	eb 5a		 jmp	 SHORT $LN8@IsAttackab
$LN10@IsAttackab:

; 2230 : 	else if (IsEnemy())

  002eb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  002ee	e8 00 00 00 00	 call	 ?IsEnemy@CInstanceBase@@QAEHXZ ; CInstanceBase::IsEnemy
  002f3	85 c0		 test	 eax, eax
  002f5	74 22		 je	 SHORT $LN39@IsAttackab

; 2231 : 	{
; 2232 : 		if (rkInstVictim.IsPC())

  002f7	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  002fa	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  002ff	85 c0		 test	 eax, eax
  00301	74 04		 je	 SHORT $LN41@IsAttackab

; 2233 : 			return true;

  00303	b0 01		 mov	 al, 1
  00305	eb 40		 jmp	 SHORT $LN1@IsAttackab
$LN41@IsAttackab:

; 2234 : 
; 2235 : 		if (rkInstVictim.IsBuilding())

  00307	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0030a	e8 00 00 00 00	 call	 ?IsBuilding@CInstanceBase@@QAEHXZ ; CInstanceBase::IsBuilding
  0030f	85 c0		 test	 eax, eax
  00311	74 04		 je	 SHORT $LN42@IsAttackab

; 2236 : 			return true;

  00313	b0 01		 mov	 al, 1
  00315	eb 30		 jmp	 SHORT $LN1@IsAttackab
$LN42@IsAttackab:

; 2237 : 		
; 2238 : 	}

  00317	eb 2c		 jmp	 SHORT $LN8@IsAttackab
$LN39@IsAttackab:

; 2239 : 	else if (IsPoly())

  00319	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0031c	e8 00 00 00 00	 call	 ?IsPoly@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPoly
  00321	85 c0		 test	 eax, eax
  00323	74 20		 je	 SHORT $LN8@IsAttackab

; 2240 : 	{
; 2241 : 		if (rkInstVictim.IsPC())

  00325	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00328	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  0032d	85 c0		 test	 eax, eax
  0032f	74 04		 je	 SHORT $LN44@IsAttackab

; 2242 : 			return true;

  00331	b0 01		 mov	 al, 1
  00333	eb 12		 jmp	 SHORT $LN1@IsAttackab
$LN44@IsAttackab:

; 2243 : 
; 2244 : 		if (rkInstVictim.IsEnemy())

  00335	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  00338	e8 00 00 00 00	 call	 ?IsEnemy@CInstanceBase@@QAEHXZ ; CInstanceBase::IsEnemy
  0033d	85 c0		 test	 eax, eax
  0033f	74 04		 je	 SHORT $LN8@IsAttackab

; 2245 : 			return true;

  00341	b0 01		 mov	 al, 1
  00343	eb 02		 jmp	 SHORT $LN1@IsAttackab
$LN8@IsAttackab:

; 2246 : 	}
; 2247 : 	return false;

  00345	32 c0		 xor	 al, al
$LN1@IsAttackab:

; 2248 : }

  00347	5e		 pop	 esi
  00348	c9		 leave
  00349	c2 04 00	 ret	 4
?IsAttackableInstance@CInstanceBase@@QAE_NAAV1@@Z ENDP	; CInstanceBase::IsAttackableInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsConflictAlignmentInstance@CInstanceBase@@QAE_NAAV1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv70 = -4						; size = 4
_rkInstVictim$ = 8					; size = 4
?IsConflictAlignmentInstance@CInstanceBase@@QAE_NAAV1@@Z PROC ; CInstanceBase::IsConflictAlignmentInstance, COMDAT
; _this$ = ecx

; 2116 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2117 : 	if (PK_MODE_PROTECT == rkInstVictim.GetPKMode())

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0000c	e8 00 00 00 00	 call	 ?GetPKMode@CInstanceBase@@QAEEXZ ; CInstanceBase::GetPKMode
  00011	0f b6 c0	 movzx	 eax, al
  00014	83 f8 03	 cmp	 eax, 3
  00017	75 04		 jne	 SHORT $LN4@IsConflict

; 2118 : 		return false;

  00019	32 c0		 xor	 al, al
  0001b	eb 4e		 jmp	 SHORT $LN1@IsConflict
$LN4@IsConflict:

; 2119 : 
; 2120 : 	switch (GetAlignmentType())

  0001d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?GetAlignmentType@CInstanceBase@@QAEHXZ ; CInstanceBase::GetAlignmentType
  00025	89 45 fc	 mov	 DWORD PTR tv70[ebp], eax
  00028	83 7d fc 00	 cmp	 DWORD PTR tv70[ebp], 0
  0002c	7c 3b		 jl	 SHORT $LN2@IsConflict
  0002e	83 7d fc 01	 cmp	 DWORD PTR tv70[ebp], 1
  00032	7e 08		 jle	 SHORT $LN5@IsConflict
  00034	83 7d fc 02	 cmp	 DWORD PTR tv70[ebp], 2
  00038	74 15		 je	 SHORT $LN7@IsConflict
  0003a	eb 2d		 jmp	 SHORT $LN2@IsConflict
$LN5@IsConflict:

; 2121 : 	{
; 2122 : 		case ALIGNMENT_TYPE_NORMAL:
; 2123 : 		case ALIGNMENT_TYPE_WHITE:
; 2124 : 			if (ALIGNMENT_TYPE_DARK == rkInstVictim.GetAlignmentType())

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0003f	e8 00 00 00 00	 call	 ?GetAlignmentType@CInstanceBase@@QAEHXZ ; CInstanceBase::GetAlignmentType
  00044	83 f8 02	 cmp	 eax, 2
  00047	75 04		 jne	 SHORT $LN6@IsConflict

; 2125 : 				return true;

  00049	b0 01		 mov	 al, 1
  0004b	eb 1e		 jmp	 SHORT $LN1@IsConflict
$LN6@IsConflict:

; 2126 : 			break;

  0004d	eb 1a		 jmp	 SHORT $LN2@IsConflict
$LN7@IsConflict:

; 2127 : 		case ALIGNMENT_TYPE_DARK:
; 2128 : 			if (GetAlignmentType() != rkInstVictim.GetAlignmentType())

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?GetAlignmentType@CInstanceBase@@QAEHXZ ; CInstanceBase::GetAlignmentType
  00057	8b f0		 mov	 esi, eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR _rkInstVictim$[ebp]
  0005c	e8 00 00 00 00	 call	 ?GetAlignmentType@CInstanceBase@@QAEHXZ ; CInstanceBase::GetAlignmentType
  00061	3b f0		 cmp	 esi, eax
  00063	74 04		 je	 SHORT $LN2@IsConflict

; 2129 : 				return true;

  00065	b0 01		 mov	 al, 1
  00067	eb 02		 jmp	 SHORT $LN1@IsConflict
$LN2@IsConflict:

; 2130 : 			break;
; 2131 : 	}
; 2132 : 
; 2133 : 	return false;

  00069	32 c0		 xor	 al, al
$LN1@IsConflict:

; 2134 : }

  0006b	5e		 pop	 esi
  0006c	c9		 leave
  0006d	c2 04 00	 ret	 4
?IsConflictAlignmentInstance@CInstanceBase@@QAE_NAAV1@@Z ENDP ; CInstanceBase::IsConflictAlignmentInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanFishing@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanFishing@CInstanceBase@@QAE_NXZ PROC			; CInstanceBase::CanFishing, COMDAT
; _this$ = ecx

; 1107 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1108 : 	return m_GraphicThingInstance.CanFishing();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?CanFishing@CActorInstance@@QAE_NXZ ; CActorInstance::CanFishing

; 1109 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?CanFishing@CInstanceBase@@QAE_NXZ ENDP			; CInstanceBase::CanFishing
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanUseSkill@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanUseSkill@CInstanceBase@@QAE_NXZ PROC		; CInstanceBase::CanUseSkill, COMDAT
; _this$ = ecx

; 1071 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1072 : 	if (IsPoly())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsPoly@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPoly
  0000f	85 c0		 test	 eax, eax
  00011	74 04		 je	 SHORT $LN2@CanUseSkil

; 1073 : 		return false;

  00013	32 c0		 xor	 al, al
  00015	eb 51		 jmp	 SHORT $LN1@CanUseSkil
$LN2@CanUseSkil:

; 1074 : 
; 1075 : 	if (IsWearingDress())

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?IsWearingDress@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWearingDress
  0001f	85 c0		 test	 eax, eax
  00021	74 04		 je	 SHORT $LN3@CanUseSkil

; 1076 : 		return false;

  00023	32 c0		 xor	 al, al
  00025	eb 41		 jmp	 SHORT $LN1@CanUseSkil
$LN3@CanUseSkil:

; 1077 : 
; 1078 : 	if (IsHoldingPickAxe())

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?IsHoldingPickAxe@CInstanceBase@@QAEHXZ ; CInstanceBase::IsHoldingPickAxe
  0002f	85 c0		 test	 eax, eax
  00031	74 04		 je	 SHORT $LN4@CanUseSkil

; 1079 : 		return false;

  00033	32 c0		 xor	 al, al
  00035	eb 31		 jmp	 SHORT $LN1@CanUseSkil
$LN4@CanUseSkil:

; 1080 : 
; 1081 : 	if (!m_kHorse.CanUseSkill())

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ?CanUseSkill@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::CanUseSkill
  00042	0f b6 c0	 movzx	 eax, al
  00045	85 c0		 test	 eax, eax
  00047	75 04		 jne	 SHORT $LN5@CanUseSkil

; 1082 : 		return false;

  00049	32 c0		 xor	 al, al
  0004b	eb 1b		 jmp	 SHORT $LN1@CanUseSkil
$LN5@CanUseSkil:

; 1083 : 
; 1084 : 	if (!m_GraphicThingInstance.CanUseSkill())

  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00056	e8 00 00 00 00	 call	 ?CanUseSkill@CActorInstance@@QAE_NXZ ; CActorInstance::CanUseSkill
  0005b	0f b6 c0	 movzx	 eax, al
  0005e	85 c0		 test	 eax, eax
  00060	75 04		 jne	 SHORT $LN6@CanUseSkil

; 1085 : 		return false;

  00062	32 c0		 xor	 al, al
  00064	eb 02		 jmp	 SHORT $LN1@CanUseSkil
$LN6@CanUseSkil:

; 1086 : 
; 1087 : 	return true;

  00066	b0 01		 mov	 al, 1
$LN1@CanUseSkil:

; 1088 : }

  00068	c9		 leave
  00069	c3		 ret	 0
?CanUseSkill@CInstanceBase@@QAE_NXZ ENDP		; CInstanceBase::CanUseSkill
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanAttack@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanAttack@CInstanceBase@@QAE_NXZ PROC			; CInstanceBase::CanAttack, COMDAT
; _this$ = ecx

; 1091 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1092 : 	if (!m_kHorse.CanAttack())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ?CanAttack@SHORSE@CInstanceBase@@QAE_NXZ ; CInstanceBase::SHORSE::CanAttack
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 04		 jne	 SHORT $LN2@CanAttack

; 1093 : 		return false;

  00019	32 c0		 xor	 al, al
  0001b	eb 2e		 jmp	 SHORT $LN1@CanAttack
$LN2@CanAttack:

; 1094 : 
; 1095 : 	if (IsWearingDress())

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?IsWearingDress@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWearingDress
  00025	85 c0		 test	 eax, eax
  00027	74 04		 je	 SHORT $LN3@CanAttack

; 1096 : 		return false;

  00029	32 c0		 xor	 al, al
  0002b	eb 1e		 jmp	 SHORT $LN1@CanAttack
$LN3@CanAttack:

; 1097 : 
; 1098 : 	if (IsHoldingPickAxe())

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?IsHoldingPickAxe@CInstanceBase@@QAEHXZ ; CInstanceBase::IsHoldingPickAxe
  00035	85 c0		 test	 eax, eax
  00037	74 04		 je	 SHORT $LN4@CanAttack

; 1099 : 		return false;

  00039	32 c0		 xor	 al, al
  0003b	eb 0e		 jmp	 SHORT $LN1@CanAttack
$LN4@CanAttack:

; 1100 : 	
; 1101 : 	return m_GraphicThingInstance.CanAttack();

  0003d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00046	e8 00 00 00 00	 call	 ?CanAttack@CActorInstance@@QAE_NXZ ; CActorInstance::CanAttack
$LN1@CanAttack:

; 1102 : }

  0004b	c9		 leave
  0004c	c3		 ret	 0
?CanAttack@CInstanceBase@@QAE_NXZ ENDP			; CInstanceBase::CanAttack
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanMove@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanMove@CInstanceBase@@QAE_NXZ PROC			; CInstanceBase::CanMove, COMDAT
; _this$ = ecx

; 1066 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1067 : 	return m_GraphicThingInstance.CanMove();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?CanMove@CActorInstance@@QAE_NXZ ; CActorInstance::CanMove

; 1068 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?CanMove@CInstanceBase@@QAE_NXZ ENDP			; CInstanceBase::CanMove
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CanAct@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CanAct@CInstanceBase@@QAE_NXZ PROC			; CInstanceBase::CanAct, COMDAT
; _this$ = ecx

; 1061 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1062 : 	return m_GraphicThingInstance.CanAct();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?CanAct@CActorInstance@@QAE_NXZ ; CActorInstance::CanAct

; 1063 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?CanAct@CInstanceBase@@QAE_NXZ ENDP			; CInstanceBase::CanAct
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsPartyMember@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsPartyMember@CInstanceBase@@QAE_NXZ PROC		; CInstanceBase::IsPartyMember, COMDAT
; _this$ = ecx

; 560  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 561  : 	return m_isPartyMember;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 80 70 01 00
	00		 mov	 al, BYTE PTR [eax+368]

; 562  : }

  00010	c9		 leave
  00011	c3		 ret	 0
?IsPartyMember@CInstanceBase@@QAE_NXZ ENDP		; CInstanceBase::IsPartyMember
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?IsKiller@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?IsKiller@CInstanceBase@@QAE_NXZ PROC			; CInstanceBase::IsKiller, COMDAT
; _this$ = ecx

; 555  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 556  : 	return m_isKiller;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 80 6f 01 00
	00		 mov	 al, BYTE PTR [eax+367]

; 557  : }

  00010	c9		 leave
  00011	c3		 ret	 0
?IsKiller@CInstanceBase@@QAE_NXZ ENDP			; CInstanceBase::IsKiller
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetPKMode@CInstanceBase@@QAEEXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetPKMode@CInstanceBase@@QAEEXZ PROC			; CInstanceBase::GetPKMode, COMDAT
; _this$ = ecx

; 550  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 551  : 	return m_byPKMode;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 80 6e 01 00
	00		 mov	 al, BYTE PTR [eax+366]

; 552  : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetPKMode@CInstanceBase@@QAEEXZ ENDP			; CInstanceBase::GetPKMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetAlignmentType@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?GetAlignmentType@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::GetAlignmentType, COMDAT
; _this$ = ecx

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 525  : 	switch (GetAlignmentGrade())

  00008	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	e8 00 00 00 00	 call	 ?GetAlignmentGrade@CInstanceBase@@QAEIXZ ; CInstanceBase::GetAlignmentGrade
  00010	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  00013	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00017	72 1f		 jb	 SHORT $LN2@GetAlignme
  00019	83 7d fc 03	 cmp	 DWORD PTR tv66[ebp], 3
  0001d	76 0e		 jbe	 SHORT $LN4@GetAlignme
  0001f	83 7d fc 04	 cmp	 DWORD PTR tv66[ebp], 4
  00023	76 13		 jbe	 SHORT $LN2@GetAlignme
  00025	83 7d fc 08	 cmp	 DWORD PTR tv66[ebp], 8
  00029	76 08		 jbe	 SHORT $LN5@GetAlignme
  0002b	eb 0b		 jmp	 SHORT $LN2@GetAlignme
$LN4@GetAlignme:

; 526  : 	{
; 527  : 		case 0:
; 528  : 		case 1:
; 529  : 		case 2:
; 530  : 		case 3:
; 531  : 		{
; 532  : 			return ALIGNMENT_TYPE_WHITE;

  0002d	33 c0		 xor	 eax, eax
  0002f	eb 0a		 jmp	 SHORT $LN1@GetAlignme

; 533  : 			break;

  00031	eb 05		 jmp	 SHORT $LN2@GetAlignme
$LN5@GetAlignme:

; 534  : 		}
; 535  : 
; 536  : 		case 5:
; 537  : 		case 6:
; 538  : 		case 7:
; 539  : 		case 8:
; 540  : 		{
; 541  : 			return ALIGNMENT_TYPE_DARK;

  00033	6a 02		 push	 2
  00035	58		 pop	 eax
  00036	eb 03		 jmp	 SHORT $LN1@GetAlignme
$LN2@GetAlignme:

; 542  : 			break;
; 543  : 		}
; 544  : 	}
; 545  : 
; 546  : 	return ALIGNMENT_TYPE_NORMAL;

  00038	33 c0		 xor	 eax, eax
  0003a	40		 inc	 eax
$LN1@GetAlignme:

; 547  : }

  0003b	c9		 leave
  0003c	c3		 ret	 0
?GetAlignmentType@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::GetAlignmentType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetAlignmentGrade@CInstanceBase@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAlignmentGrade@CInstanceBase@@QAEIXZ PROC		; CInstanceBase::GetAlignmentGrade, COMDAT
; _this$ = ecx

; 502  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 503  : 	if (m_sAlignment >= 12000)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]
  00011	3d e0 2e 00 00	 cmp	 eax, 12000		; 00002ee0H
  00016	7c 0c		 jl	 SHORT $LN2@GetAlignme

; 504  : 		return 0;

  00018	33 c0		 xor	 eax, eax
  0001a	e9 b1 00 00 00	 jmp	 $LN1@GetAlignme
  0001f	e9 a9 00 00 00	 jmp	 $LN3@GetAlignme
$LN2@GetAlignme:

; 505  : 	else if (m_sAlignment >= 8000)

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]
  0002e	3d 40 1f 00 00	 cmp	 eax, 8000		; 00001f40H
  00033	7c 0d		 jl	 SHORT $LN4@GetAlignme

; 506  : 		return 1;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	e9 93 00 00 00	 jmp	 $LN1@GetAlignme
  0003d	e9 8b 00 00 00	 jmp	 $LN3@GetAlignme
$LN4@GetAlignme:

; 507  : 	else if (m_sAlignment >= 4000)

  00042	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00045	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]
  0004c	3d a0 0f 00 00	 cmp	 eax, 4000		; 00000fa0H
  00051	7c 07		 jl	 SHORT $LN6@GetAlignme

; 508  : 		return 2;

  00053	6a 02		 push	 2
  00055	58		 pop	 eax
  00056	eb 78		 jmp	 SHORT $LN1@GetAlignme
  00058	eb 73		 jmp	 SHORT $LN3@GetAlignme
$LN6@GetAlignme:

; 509  : 	else if (m_sAlignment >= 1000)

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005d	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]
  00064	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00069	7c 07		 jl	 SHORT $LN8@GetAlignme

; 510  : 		return 3;

  0006b	6a 03		 push	 3
  0006d	58		 pop	 eax
  0006e	eb 60		 jmp	 SHORT $LN1@GetAlignme
  00070	eb 5b		 jmp	 SHORT $LN3@GetAlignme
$LN8@GetAlignme:

; 511  : 	else if (m_sAlignment >= 0)

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]
  0007c	85 c0		 test	 eax, eax
  0007e	7c 07		 jl	 SHORT $LN10@GetAlignme

; 512  : 		return 4;

  00080	6a 04		 push	 4
  00082	58		 pop	 eax
  00083	eb 4b		 jmp	 SHORT $LN1@GetAlignme
  00085	eb 46		 jmp	 SHORT $LN3@GetAlignme
$LN10@GetAlignme:

; 513  : 	else if (m_sAlignment > -4000)

  00087	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0008a	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]
  00091	3d 60 f0 ff ff	 cmp	 eax, -4000		; fffff060H
  00096	7e 07		 jle	 SHORT $LN12@GetAlignme

; 514  : 		return 5;

  00098	6a 05		 push	 5
  0009a	58		 pop	 eax
  0009b	eb 33		 jmp	 SHORT $LN1@GetAlignme
  0009d	eb 2e		 jmp	 SHORT $LN3@GetAlignme
$LN12@GetAlignme:

; 515  : 	else if (m_sAlignment > -8000)

  0009f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a2	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]
  000a9	3d c0 e0 ff ff	 cmp	 eax, -8000		; ffffe0c0H
  000ae	7e 07		 jle	 SHORT $LN14@GetAlignme

; 516  : 		return 6;

  000b0	6a 06		 push	 6
  000b2	58		 pop	 eax
  000b3	eb 1b		 jmp	 SHORT $LN1@GetAlignme
  000b5	eb 16		 jmp	 SHORT $LN3@GetAlignme
$LN14@GetAlignme:

; 517  : 	else if (m_sAlignment > -12000)

  000b7	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ba	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]
  000c1	3d 20 d1 ff ff	 cmp	 eax, -12000		; ffffd120H
  000c6	7e 05		 jle	 SHORT $LN3@GetAlignme

; 518  : 		return 7;

  000c8	6a 07		 push	 7
  000ca	58		 pop	 eax
  000cb	eb 03		 jmp	 SHORT $LN1@GetAlignme
$LN3@GetAlignme:

; 519  : 
; 520  : 	return 8;

  000cd	6a 08		 push	 8
  000cf	58		 pop	 eax
$LN1@GetAlignme:

; 521  : }

  000d0	c9		 leave
  000d1	c3		 ret	 0
?GetAlignmentGrade@CInstanceBase@@QAEIXZ ENDP		; CInstanceBase::GetAlignmentGrade
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetAlignment@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetAlignment@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::GetAlignment, COMDAT
; _this$ = ecx

; 497  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 498  : 	return m_sAlignment;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f bf 80 6c 01
	00 00		 movsx	 eax, WORD PTR [eax+364]

; 499  : }

  00011	c9		 leave
  00012	c3		 ret	 0
?GetAlignment@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::GetAlignment
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetGuildID@CInstanceBase@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetGuildID@CInstanceBase@@QAEKXZ PROC			; CInstanceBase::GetGuildID, COMDAT
; _this$ = ecx

; 492  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 493  : 	return m_dwGuildID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 44	 mov	 eax, DWORD PTR [eax+68]

; 494  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetGuildID@CInstanceBase@@QAEKXZ ENDP			; CInstanceBase::GetGuildID
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetEmpireID@CInstanceBase@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetEmpireID@CInstanceBase@@QAEKXZ PROC			; CInstanceBase::GetEmpireID, COMDAT
; _this$ = ecx

; 487  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 488  : 	return m_dwEmpireID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 40	 mov	 eax, DWORD PTR [eax+64]

; 489  : }

  0000d	c9		 leave
  0000e	c3		 ret	 0
?GetEmpireID@CInstanceBase@@QAEKXZ ENDP			; CInstanceBase::GetEmpireID
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetVirtualNumber@CInstanceBase@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVirtualNumber@CInstanceBase@@QAEKXZ PROC		; CInstanceBase::GetVirtualNumber, COMDAT
; _this$ = ecx

; 2446 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2447 : 	return m_dwVirtualNumber;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 68 01 00
	00		 mov	 eax, DWORD PTR [eax+360]

; 2448 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetVirtualNumber@CInstanceBase@@QAEKXZ ENDP		; CInstanceBase::GetVirtualNumber
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetVirtualID@CInstanceBase@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetVirtualID@CInstanceBase@@QAEKXZ PROC		; CInstanceBase::GetVirtualID, COMDAT
; _this$ = ecx

; 2441 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2442 : 	return m_GraphicThingInstance.GetVirtualID();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 80 d4 01 00
	00		 mov	 eax, DWORD PTR [eax+468]
  00019	ff 50 48	 call	 DWORD PTR [eax+72]

; 2443 : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?GetVirtualID@CInstanceBase@@QAEKXZ ENDP		; CInstanceBase::GetVirtualID
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetRace@CInstanceBase@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetRace@CInstanceBase@@QAEKXZ PROC			; CInstanceBase::GetRace, COMDAT
; _this$ = ecx

; 2110 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2111 : 	return m_dwRace;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 64 01 00
	00		 mov	 eax, DWORD PTR [eax+356]

; 2112 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetRace@CInstanceBase@@QAEKXZ ENDP			; CInstanceBase::GetRace
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetShape@CInstanceBase@@QAEKXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetShape@CInstanceBase@@QAEKXZ PROC			; CInstanceBase::GetShape, COMDAT
; _this$ = ecx

; 1056 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 : 	return m_eShape;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 80 60 01 00
	00		 mov	 eax, DWORD PTR [eax+352]

; 1058 : }

  00010	c9		 leave
  00011	c3		 ret	 0
?GetShape@CInstanceBase@@QAEKXZ ENDP			; CInstanceBase::GetShape
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetPart@CInstanceBase@@QAEKW4EParts@CRaceData@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_part$ = 8						; size = 4
?GetPart@CInstanceBase@@QAEKW4EParts@CRaceData@@@Z PROC	; CInstanceBase::GetPart, COMDAT
; _this$ = ecx

; 1050 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1051 : 	assert(part >= 0 && part < CRaceData::PART_MAX_NUM);
; 1052 : 	return m_awPart[part];

  00007	8b 45 08	 mov	 eax, DWORD PTR _part$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 44 81 28	 mov	 eax, DWORD PTR [ecx+eax*4+40]

; 1053 : }

  00011	c9		 leave
  00012	c2 04 00	 ret	 4
?GetPart@CInstanceBase@@QAEKW4EParts@CRaceData@@@Z ENDP	; CInstanceBase::GetPart
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetInstanceType@CInstanceBase@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetInstanceType@CInstanceBase@@QAEHXZ PROC		; CInstanceBase::GetInstanceType, COMDAT
; _this$ = ecx

; 2436 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2437 : 	return m_GraphicThingInstance.GetActorType();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?GetActorType@CActorInstance@@QBEIXZ ; CActorInstance::GetActorType

; 2438 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?GetInstanceType@CInstanceBase@@QAEHXZ ENDP		; CInstanceBase::GetInstanceType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetNameString@CInstanceBase@@QAEPBDXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?GetNameString@CInstanceBase@@QAEPBDXZ PROC		; CInstanceBase::GetNameString, COMDAT
; _this$ = ecx

; 2105 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 10	 add	 ecx, 16			; 00000010H
  0000e	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00013	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 2106 : 	return m_stName.c_str();

  00016	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 2107 : }

  00019	c9		 leave
  0001a	c3		 ret	 0
?GetNameString@CInstanceBase@@QAEPBDXZ ENDP		; CInstanceBase::GetNameString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetComboType@CInstanceBase@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_uComboType$ = 8					; size = 4
?SetComboType@CInstanceBase@@QAEXI@Z PROC		; CInstanceBase::SetComboType, COMDAT
; _this$ = ecx

; 2100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2101 : 	m_GraphicThingInstance.SetComboType(uComboType);

  00007	ff 75 08	 push	 DWORD PTR _uComboType$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?SetComboType@CActorInstance@@QAEXG@Z ; CActorInstance::SetComboType

; 2102 : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?SetComboType@CInstanceBase@@QAEXI@Z ENDP		; CInstanceBase::SetComboType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetWeaponType@CInstanceBase@@QAEKXZ
_TEXT	SEGMENT
_pItemData$ = -16					; size = 4
$T1 = -12						; size = 4
_dwWeapon$ = -8						; size = 4
_this$ = -4						; size = 4
?GetWeaponType@CInstanceBase@@QAEKXZ PROC		; CInstanceBase::GetWeaponType, COMDAT
; _this$ = ecx

; 2629 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2630 : 	DWORD dwWeapon = GetPart(CRaceData::PART_WEAPON);

  00009	6a 01		 push	 1
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?GetPart@CInstanceBase@@QAEKW4EParts@CRaceData@@@Z ; CInstanceBase::GetPart
  00013	89 45 f8	 mov	 DWORD PTR _dwWeapon$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  0001b	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 2632 : 	if (!CItemManager::Instance().GetItemDataPointer(dwWeapon, &pItemData))

  0001e	8d 45 f0	 lea	 eax, DWORD PTR _pItemData$[ebp]
  00021	50		 push	 eax
  00022	ff 75 f8	 push	 DWORD PTR _dwWeapon$[ebp]
  00025	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00028	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  0002d	85 c0		 test	 eax, eax
  0002f	75 05		 jne	 SHORT $LN2@GetWeaponT

; 2633 : 		return CItemData::WEAPON_NONE;

  00031	6a 08		 push	 8
  00033	58		 pop	 eax
  00034	eb 08		 jmp	 SHORT $LN1@GetWeaponT
$LN2@GetWeaponT:

; 2634 : 
; 2635 : 	return pItemData->GetWeaponType();

  00036	8b 4d f0	 mov	 ecx, DWORD PTR _pItemData$[ebp]
  00039	e8 00 00 00 00	 call	 ?GetWeaponType@CItemData@@QBEKXZ ; CItemData::GetWeaponType
$LN1@GetWeaponT:

; 2636 : }

  0003e	c9		 leave
  0003f	c3		 ret	 0
?GetWeaponType@CInstanceBase@@QAEKXZ ENDP		; CInstanceBase::GetWeaponType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?ChangeGuild@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwGuildID$ = 8						; size = 4
?ChangeGuild@CInstanceBase@@QAEXK@Z PROC		; CInstanceBase::ChangeGuild, COMDAT
; _this$ = ecx

; 1041 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1042 : 	m_dwGuildID=dwGuildID;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwGuildID$[ebp]
  0000d	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 1043 : 
; 1044 : 	DetachTextTail();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?DetachTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::DetachTextTail

; 1045 : 	AttachTextTail();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?AttachTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::AttachTextTail

; 1046 : 	RefreshTextTail();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?RefreshTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::RefreshTextTail

; 1047 : }

  00028	c9		 leave
  00029	c2 04 00	 ret	 4
?ChangeGuild@CInstanceBase@@QAEXK@Z ENDP		; CInstanceBase::ChangeGuild
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?ChangeHair@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eHair$ = 8						; size = 4
?ChangeHair@CInstanceBase@@QAEXK@Z PROC			; CInstanceBase::ChangeHair, COMDAT
; _this$ = ecx

; 2574 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2575 : 	if (!HAIR_COLOR_ENABLE)

  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?HAIR_COLOR_ENABLE@@3HA, 0 ; HAIR_COLOR_ENABLE
  0000e	75 02		 jne	 SHORT $LN2@ChangeHair

; 2576 : 		return;

  00010	eb 36		 jmp	 SHORT $LN1@ChangeHair
$LN2@ChangeHair:

; 2577 : 
; 2578 : 	if (IsPC()==false)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  0001a	85 c0		 test	 eax, eax
  0001c	75 02		 jne	 SHORT $LN3@ChangeHair

; 2579 : 		return;

  0001e	eb 28		 jmp	 SHORT $LN1@ChangeHair
$LN3@ChangeHair:

; 2580 : 
; 2581 : 	if (GetPart(CRaceData::PART_HAIR)==eHair)

  00020	6a 04		 push	 4
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?GetPart@CInstanceBase@@QAEKW4EParts@CRaceData@@@Z ; CInstanceBase::GetPart
  0002a	3b 45 08	 cmp	 eax, DWORD PTR _eHair$[ebp]
  0002d	75 02		 jne	 SHORT $LN4@ChangeHair

; 2582 : 		return;

  0002f	eb 17		 jmp	 SHORT $LN1@ChangeHair
$LN4@ChangeHair:

; 2583 : 
; 2584 : 	SetHair(eHair);

  00031	ff 75 08	 push	 DWORD PTR _eHair$[ebp]
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?SetHair@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetHair

; 2585 : 
; 2586 : 	//int type = m_GraphicThingInstance.GetMotionMode();
; 2587 : 
; 2588 : 	RefreshState(CRaceMotionData::NAME_WAIT, true);

  0003c	6a 01		 push	 1
  0003e	6a 01		 push	 1
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?RefreshState@CInstanceBase@@IAEXK_N@Z ; CInstanceBase::RefreshState
$LN1@ChangeHair:

; 2589 : 	//RefreshState(type, true);
; 2590 : }

  00048	c9		 leave
  00049	c2 04 00	 ret	 4
?ChangeHair@CInstanceBase@@QAEXK@Z ENDP			; CInstanceBase::ChangeHair
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?ChangeWeapon@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eWeapon$ = 8						; size = 4
?ChangeWeapon@CInstanceBase@@QAEXK@Z PROC		; CInstanceBase::ChangeWeapon, COMDAT
; _this$ = ecx

; 2771 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2772 : 	if (eWeapon == m_GraphicThingInstance.GetPartItemID(CRaceData::PART_WEAPON))

  00007	6a 01		 push	 1
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00012	e8 00 00 00 00	 call	 ?GetPartItemID@CActorInstance@@QAEKK@Z ; CActorInstance::GetPartItemID
  00017	39 45 08	 cmp	 DWORD PTR _eWeapon$[ebp], eax
  0001a	75 02		 jne	 SHORT $LN2@ChangeWeap

; 2773 : 		return;

  0001c	eb 1e		 jmp	 SHORT $LN1@ChangeWeap
$LN2@ChangeWeap:

; 2774 : 
; 2775 : 	if (SetWeapon(eWeapon))

  0001e	ff 75 08	 push	 DWORD PTR _eWeapon$[ebp]
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?SetWeapon@CInstanceBase@@QAE_NK@Z ; CInstanceBase::SetWeapon
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	74 0c		 je	 SHORT $LN1@ChangeWeap

; 2776 : 		RefreshState(CRaceMotionData::NAME_WAIT, true);

  00030	6a 01		 push	 1
  00032	6a 01		 push	 1
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?RefreshState@CInstanceBase@@IAEXK_N@Z ; CInstanceBase::RefreshState
$LN1@ChangeWeap:

; 2777 : }

  0003c	c9		 leave
  0003d	c2 04 00	 ret	 4
?ChangeWeapon@CInstanceBase@@QAEXK@Z ENDP		; CInstanceBase::ChangeWeapon
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?ChangeArmor@CInstanceBase@@QAE_NK@Z
_TEXT	SEGMENT
_fAdvRot$ = -64						; size = 4
_fRot$ = -60						; size = 4
_eWeapon$ = -56						; size = 4
_eHair$ = -52						; size = 4
_dwVID$ = -48						; size = 4
_eShape$ = -44						; size = 4
_rkEventHandler$ = -40					; size = 4
_dwRace$ = -36						; size = 4
$T2 = -30						; size = 1
$T3 = -29						; size = 1
_this$ = -28						; size = 4
_kAffectFlagContainer$ = -24				; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dwArmor$ = 8						; size = 4
?ChangeArmor@CInstanceBase@@QAE_NK@Z PROC		; CInstanceBase::ChangeArmor, COMDAT
; _this$ = ecx

; 2780 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ChangeArmor@CInstanceBase@@QAE_NK@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 2781 : 	DWORD eShape;
; 2782 : 	__ArmorVnumToShape(dwArmor, &eShape);

  0002b	8d 45 d4	 lea	 eax, DWORD PTR _eShape$[ebp]
  0002e	50		 push	 eax
  0002f	ff 75 08	 push	 DWORD PTR _dwArmor$[ebp]
  00032	e8 00 00 00 00	 call	 ?__ArmorVnumToShape@@YA_NHPAK@Z ; __ArmorVnumToShape
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 2783 : 
; 2784 : 	if (GetShape()==eShape)

  00039	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  00041	3b 45 d4	 cmp	 eax, DWORD PTR _eShape$[ebp]
  00044	75 07		 jne	 SHORT $LN2@ChangeArmo

; 2785 : 		return false;

  00046	32 c0		 xor	 al, al
  00048	e9 58 01 00 00	 jmp	 $LN1@ChangeArmo
$LN2@ChangeArmo:

; 2786 : 
; 2787 : 	CAffectFlagContainer kAffectFlagContainer;

  0004d	8d 4d e8	 lea	 ecx, DWORD PTR _kAffectFlagContainer$[ebp]
  00050	e8 00 00 00 00	 call	 ??0CAffectFlagContainer@@QAE@XZ ; CAffectFlagContainer::CAffectFlagContainer
  00055	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2788 : 	kAffectFlagContainer.CopyInstance(m_kAffectFlagContainer);

  00059	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	83 c0 48	 add	 eax, 72			; 00000048H
  0005f	50		 push	 eax
  00060	8d 4d e8	 lea	 ecx, DWORD PTR _kAffectFlagContainer$[ebp]
  00063	e8 00 00 00 00	 call	 ?CopyInstance@CAffectFlagContainer@@QAEXABV1@@Z ; CAffectFlagContainer::CopyInstance

; 2789 : 
; 2790 : 	DWORD dwVID = GetVirtualID();

  00068	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  00070	89 45 d0	 mov	 DWORD PTR _dwVID$[ebp], eax

; 2791 : 	DWORD dwRace = GetRace();

  00073	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  0007b	89 45 dc	 mov	 DWORD PTR _dwRace$[ebp], eax

; 2792 : 	DWORD eHair = GetPart(CRaceData::PART_HAIR);

  0007e	6a 04		 push	 4
  00080	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?GetPart@CInstanceBase@@QAEKW4EParts@CRaceData@@@Z ; CInstanceBase::GetPart
  00088	89 45 cc	 mov	 DWORD PTR _eHair$[ebp], eax

; 2793 : 	DWORD eWeapon = GetPart(CRaceData::PART_WEAPON);

  0008b	6a 01		 push	 1
  0008d	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?GetPart@CInstanceBase@@QAEKW4EParts@CRaceData@@@Z ; CInstanceBase::GetPart
  00095	89 45 c8	 mov	 DWORD PTR _eWeapon$[ebp], eax

; 2794 : 	float fRot = GetRotation();

  00098	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?GetRotation@CInstanceBase@@QAEMXZ ; CInstanceBase::GetRotation
  000a0	d9 5d c4	 fstp	 DWORD PTR _fRot$[ebp]

; 2795 : 	float fAdvRot = GetAdvancingRotation();

  000a3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a6	e8 00 00 00 00	 call	 ?GetAdvancingRotation@CInstanceBase@@QAEMXZ ; CInstanceBase::GetAdvancingRotation
  000ab	d9 5d c0	 fstp	 DWORD PTR _fAdvRot$[ebp]

; 2796 : 
; 2797 : 	if (IsWalking())

  000ae	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  000b6	85 c0		 test	 eax, eax
  000b8	74 16		 je	 SHORT $LN3@ChangeArmo

; 2798 : 		EndWalking();

  000ba	51		 push	 ecx
  000bb	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  000c3	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c8	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?EndWalking@CInstanceBase@@QAEXM@Z ; CInstanceBase::EndWalking
$LN3@ChangeArmo:

; 2799 : 
; 2800 : 	// 2004.07.25.myevan.   
; 2801 : 	//////////////////////////////////////////////////////
; 2802 : 	__ClearAffects();

  000d0	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?__ClearAffects@CInstanceBase@@QAEXXZ ; CInstanceBase::__ClearAffects

; 2803 : 	//////////////////////////////////////////////////////
; 2804 : 
; 2805 : 	if (!SetRace(dwRace))

  000d8	ff 75 dc	 push	 DWORD PTR _dwRace$[ebp]
  000db	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	e8 00 00 00 00	 call	 ?SetRace@CInstanceBase@@QAE_NK@Z ; CInstanceBase::SetRace
  000e3	0f b6 c0	 movzx	 eax, al
  000e6	85 c0		 test	 eax, eax
  000e8	75 2b		 jne	 SHORT $LN4@ChangeArmo

; 2806 : 	{
; 2807 : 		TraceError("CPythonCharacterManager::ChangeArmor - SetRace VID[%d] Race[%d] ERROR", dwVID, dwRace);

  000ea	ff 75 dc	 push	 DWORD PTR _dwRace$[ebp]
  000ed	ff 75 d0	 push	 DWORD PTR _dwVID$[ebp]
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_0EG@MNIPPABI@CPythonCharacterManager?3?3Change@
  000f5	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  000fa	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2808 : 		return false;

  000fd	c6 45 e3 00	 mov	 BYTE PTR $T3[ebp], 0
  00101	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00105	8d 4d e8	 lea	 ecx, DWORD PTR _kAffectFlagContainer$[ebp]
  00108	e8 00 00 00 00	 call	 ??1CAffectFlagContainer@@QAE@XZ ; CAffectFlagContainer::~CAffectFlagContainer
  0010d	8a 45 e3	 mov	 al, BYTE PTR $T3[ebp]
  00110	e9 90 00 00 00	 jmp	 $LN1@ChangeArmo
$LN4@ChangeArmo:

; 2809 : 	}
; 2810 : 
; 2811 : 	SetArmor(dwArmor);

  00115	ff 75 08	 push	 DWORD PTR _dwArmor$[ebp]
  00118	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011b	e8 00 00 00 00	 call	 ?SetArmor@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetArmor

; 2812 : 	SetHair(eHair);

  00120	ff 75 cc	 push	 DWORD PTR _eHair$[ebp]
  00123	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	e8 00 00 00 00	 call	 ?SetHair@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetHair

; 2813 : 	SetWeapon(eWeapon);

  0012b	ff 75 c8	 push	 DWORD PTR _eWeapon$[ebp]
  0012e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	e8 00 00 00 00	 call	 ?SetWeapon@CInstanceBase@@QAE_NK@Z ; CInstanceBase::SetWeapon

; 2814 : 
; 2815 : 	SetRotation(fRot);

  00136	51		 push	 ecx
  00137	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fRot$[ebp]
  0013c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00141	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00144	e8 00 00 00 00	 call	 ?SetRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetRotation

; 2816 : 	SetAdvancingRotation(fAdvRot);

  00149	51		 push	 ecx
  0014a	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fAdvRot$[ebp]
  0014f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00154	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00157	e8 00 00 00 00	 call	 ?SetAdvancingRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetAdvancingRotation

; 2817 : 
; 2818 : 	__AttachHorseSaddle();

  0015c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0015f	e8 00 00 00 00	 call	 ?__AttachHorseSaddle@CInstanceBase@@IAEXXZ ; CInstanceBase::__AttachHorseSaddle

; 2819 : 
; 2820 : 	RefreshState(CRaceMotionData::NAME_WAIT, TRUE);

  00164	6a 01		 push	 1
  00166	6a 01		 push	 1
  00168	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016b	e8 00 00 00 00	 call	 ?RefreshState@CInstanceBase@@IAEXK_N@Z ; CInstanceBase::RefreshState

; 2821 : 
; 2822 : 	// 2004.07.25.myevan.   
; 2823 : 	/////////////////////////////////////////////////
; 2824 : 	SetAffectFlagContainer(kAffectFlagContainer);

  00170	8d 45 e8	 lea	 eax, DWORD PTR _kAffectFlagContainer$[ebp]
  00173	50		 push	 eax
  00174	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00177	e8 00 00 00 00	 call	 ?SetAffectFlagContainer@CInstanceBase@@QAEXABVCAffectFlagContainer@@@Z ; CInstanceBase::SetAffectFlagContainer

; 2825 : 	/////////////////////////////////////////////////
; 2826 : 
; 2827 : 	CActorInstance::IEventHandler& rkEventHandler=GetEventHandlerRef();

  0017c	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	e8 00 00 00 00	 call	 ?GetEventHandlerRef@CInstanceBase@@IAEAAVIEventHandler@CActorInstance@@XZ ; CInstanceBase::GetEventHandlerRef
  00184	89 45 d8	 mov	 DWORD PTR _rkEventHandler$[ebp], eax

; 2828 : 	rkEventHandler.OnChangeShape();

  00187	8b 45 d8	 mov	 eax, DWORD PTR _rkEventHandler$[ebp]
  0018a	8b 00		 mov	 eax, DWORD PTR [eax]
  0018c	8b 4d d8	 mov	 ecx, DWORD PTR _rkEventHandler$[ebp]
  0018f	ff 50 34	 call	 DWORD PTR [eax+52]

; 2829 : 
; 2830 : 	return true;

  00192	c6 45 e2 01	 mov	 BYTE PTR $T2[ebp], 1
  00196	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0019a	8d 4d e8	 lea	 ecx, DWORD PTR _kAffectFlagContainer$[ebp]
  0019d	e8 00 00 00 00	 call	 ??1CAffectFlagContainer@@QAE@XZ ; CAffectFlagContainer::~CAffectFlagContainer
  001a2	8a 45 e2	 mov	 al, BYTE PTR $T2[ebp]
$LN1@ChangeArmo:

; 2831 : }

  001a5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001a8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001af	59		 pop	 ecx
  001b0	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001b3	33 cd		 xor	 ecx, ebp
  001b5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001ba	c9		 leave
  001bb	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ChangeArmor@CInstanceBase@@QAE_NK@Z$0:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _kAffectFlagContainer$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CAffectFlagContainer@@QAE@XZ ; CAffectFlagContainer::~CAffectFlagContainer
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?ChangeArmor@CInstanceBase@@QAE_NK@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ChangeArmor@CInstanceBase@@QAE_NK@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ChangeArmor@CInstanceBase@@QAE_NK@Z ENDP		; CInstanceBase::ChangeArmor
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetWeapon@CInstanceBase@@QAE_NK@Z
_TEXT	SEGMENT
_pItemData$ = -12					; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_eWeapon$ = 8						; size = 4
?SetWeapon@CInstanceBase@@QAE_NK@Z PROC			; CInstanceBase::SetWeapon, COMDAT
; _this$ = ecx

; 2747 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2748 : 	if (IsPoly())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsPoly@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPoly
  00011	85 c0		 test	 eax, eax
  00013	74 04		 je	 SHORT $LN2@SetWeapon

; 2749 : 		return false;

  00015	32 c0		 xor	 al, al
  00017	eb 7d		 jmp	 SHORT $LN1@SetWeapon
$LN2@SetWeapon:

; 2750 : 	
; 2751 : 	if (__IsShapeAnimalWear())

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?__IsShapeAnimalWear@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsShapeAnimalWear
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	74 04		 je	 SHORT $LN3@SetWeapon

; 2752 : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	eb 6a		 jmp	 SHORT $LN1@SetWeapon
$LN3@SetWeapon:

; 2753 : 	
; 2754 : 	if (__IsChangableWeapon(eWeapon) == false)

  0002c	ff 75 08	 push	 DWORD PTR _eWeapon$[ebp]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?__IsChangableWeapon@CInstanceBase@@IAEHH@Z ; CInstanceBase::__IsChangableWeapon
  00037	85 c0		 test	 eax, eax
  00039	75 04		 jne	 SHORT $LN4@SetWeapon

; 2755 : 		eWeapon = 0;

  0003b	83 65 08 00	 and	 DWORD PTR _eWeapon$[ebp], 0
$LN4@SetWeapon:

; 2756 : 
; 2757 : 	m_GraphicThingInstance.AttachWeapon(eWeapon);

  0003f	6a 01		 push	 1
  00041	6a 00		 push	 0
  00043	ff 75 08	 push	 DWORD PTR _eWeapon$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0004f	e8 00 00 00 00	 call	 ?AttachWeapon@CActorInstance@@QAEXKKK@Z ; CActorInstance::AttachWeapon

; 2758 : 	m_awPart[CRaceData::PART_WEAPON] = eWeapon;

  00054	6a 04		 push	 4
  00056	58		 pop	 eax
  00057	c1 e0 00	 shl	 eax, 0
  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 55 08	 mov	 edx, DWORD PTR _eWeapon$[ebp]
  00060	89 54 01 28	 mov	 DWORD PTR [ecx+eax+40], edx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00064	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00069	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 2762 : 	if (CItemManager::Instance().GetItemDataPointer(eWeapon, &pItemData))

  0006c	8d 45 f4	 lea	 eax, DWORD PTR _pItemData$[ebp]
  0006f	50		 push	 eax
  00070	ff 75 08	 push	 DWORD PTR _eWeapon$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00076	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  0007b	85 c0		 test	 eax, eax
  0007d	74 0d		 je	 SHORT $LN5@SetWeapon

; 2763 : 		__GetRefinedEffect(pItemData);

  0007f	ff 75 f4	 push	 DWORD PTR _pItemData$[ebp]
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	e8 00 00 00 00	 call	 ?__GetRefinedEffect@CInstanceBase@@IAEIPAVCItemData@@@Z ; CInstanceBase::__GetRefinedEffect
  0008a	eb 08		 jmp	 SHORT $LN6@SetWeapon
$LN5@SetWeapon:

; 2764 : 	else
; 2765 : 		__ClearWeaponRefineEffect();

  0008c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?__ClearWeaponRefineEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__ClearWeaponRefineEffect
$LN6@SetWeapon:

; 2766 : 
; 2767 : 	return true;

  00094	b0 01		 mov	 al, 1
$LN1@SetWeapon:

; 2768 : }

  00096	c9		 leave
  00097	c2 04 00	 ret	 4
?SetWeapon@CInstanceBase@@QAE_NK@Z ENDP			; CInstanceBase::SetWeapon
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetHair@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eHair$ = 8						; size = 4
?SetHair@CInstanceBase@@QAEXK@Z PROC			; CInstanceBase::SetHair, COMDAT
; _this$ = ecx

; 2563 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2564 : 	if (!HAIR_COLOR_ENABLE)

  00007	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?HAIR_COLOR_ENABLE@@3HA, 0 ; HAIR_COLOR_ENABLE
  0000e	75 02		 jne	 SHORT $LN2@SetHair

; 2565 : 		return;

  00010	eb 2f		 jmp	 SHORT $LN1@SetHair
$LN2@SetHair:

; 2566 : 
; 2567 : 	if (IsPC()==false)

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  0001a	85 c0		 test	 eax, eax
  0001c	75 02		 jne	 SHORT $LN3@SetHair

; 2568 : 		return;

  0001e	eb 21		 jmp	 SHORT $LN1@SetHair
$LN3@SetHair:

; 2569 : 	m_awPart[CRaceData::PART_HAIR] = eHair;

  00020	6a 04		 push	 4
  00022	58		 pop	 eax
  00023	c1 e0 02	 shl	 eax, 2
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 55 08	 mov	 edx, DWORD PTR _eHair$[ebp]
  0002c	89 54 01 28	 mov	 DWORD PTR [ecx+eax+40], edx

; 2570 : 	m_GraphicThingInstance.SetHair(eHair);

  00030	ff 75 08	 push	 DWORD PTR _eHair$[ebp]
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0003c	e8 00 00 00 00	 call	 ?SetHair@CActorInstance@@QAEXK@Z ; CActorInstance::SetHair
$LN1@SetHair:

; 2571 : }

  00041	c9		 leave
  00042	c2 04 00	 ret	 4
?SetHair@CInstanceBase@@QAEXK@Z ENDP			; CInstanceBase::SetHair
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetShape@CInstanceBase@@QAEXKM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eShape$ = 8						; size = 4
_fSpecular$ = 12					; size = 4
?SetShape@CInstanceBase@@QAEXKM@Z PROC			; CInstanceBase::SetShape, COMDAT
; _this$ = ecx

; 2613 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2614 : 	if (IsPoly())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsPoly@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPoly
  0000f	85 c0		 test	 eax, eax
  00011	74 1b		 je	 SHORT $LN2@SetShape

; 2615 : 	{
; 2616 : 		m_GraphicThingInstance.SetShape(0);	

  00013	51		 push	 ecx
  00014	0f 57 c0	 xorps	 xmm0, xmm0
  00017	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001c	6a 00		 push	 0
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00027	e8 00 00 00 00	 call	 ?SetShape@CActorInstance@@QAEXKM@Z ; CActorInstance::SetShape

; 2617 : 	}

  0002c	eb 1c		 jmp	 SHORT $LN3@SetShape
$LN2@SetShape:

; 2618 : 	else
; 2619 : 	{
; 2620 : 		m_GraphicThingInstance.SetShape(eShape, fSpecular);		

  0002e	51		 push	 ecx
  0002f	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _fSpecular$[ebp]
  00034	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00039	ff 75 08	 push	 DWORD PTR _eShape$[ebp]
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00045	e8 00 00 00 00	 call	 ?SetShape@CActorInstance@@QAEXKM@Z ; CActorInstance::SetShape
$LN3@SetShape:

; 2621 : 	}
; 2622 : 
; 2623 : 	m_eShape = eShape;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _eShape$[ebp]
  00050	89 88 60 01 00
	00		 mov	 DWORD PTR [eax+352], ecx

; 2624 : }

  00056	c9		 leave
  00057	c2 08 00	 ret	 8
?SetShape@CInstanceBase@@QAEXKM@Z ENDP			; CInstanceBase::SetShape
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetArmor@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_dwShape$ = -20						; size = 4
_fSpecularPower$1 = -16					; size = 4
$T2 = -12						; size = 4
_pItemData$3 = -8					; size = 4
_this$ = -4						; size = 4
_dwArmor$ = 8						; size = 4
?SetArmor@CInstanceBase@@QAEXK@Z PROC			; CInstanceBase::SetArmor, COMDAT
; _this$ = ecx

; 2593 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2594 : 	DWORD dwShape;
; 2595 : 	if (__ArmorVnumToShape(dwArmor, &dwShape))

  00009	8d 45 ec	 lea	 eax, DWORD PTR _dwShape$[ebp]
  0000c	50		 push	 eax
  0000d	ff 75 08	 push	 DWORD PTR _dwArmor$[ebp]
  00010	e8 00 00 00 00	 call	 ?__ArmorVnumToShape@@YA_NHPAK@Z ; __ArmorVnumToShape
  00015	59		 pop	 ecx
  00016	59		 pop	 ecx
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 53		 je	 SHORT $LN4@SetArmor
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCItemManager@@@@0PAVCItemManager@@A ; CSingleton<CItemManager>::ms_singleton
  00023	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 2598 : 		if (CItemManager::Instance().GetItemDataPointer(dwArmor, &pItemData))

  00026	8d 45 f8	 lea	 eax, DWORD PTR _pItemData$3[ebp]
  00029	50		 push	 eax
  0002a	ff 75 08	 push	 DWORD PTR _dwArmor$[ebp]
  0002d	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp]
  00030	e8 00 00 00 00	 call	 ?GetItemDataPointer@CItemManager@@QAEHKPAPAVCItemData@@@Z ; CItemManager::GetItemDataPointer
  00035	85 c0		 test	 eax, eax
  00037	74 30		 je	 SHORT $LN3@SetArmor

; 2599 : 		{
; 2600 : 			float fSpecularPower=pItemData->GetSpecularPowerf();

  00039	8b 4d f8	 mov	 ecx, DWORD PTR _pItemData$3[ebp]
  0003c	e8 00 00 00 00	 call	 ?GetSpecularPowerf@CItemData@@QBEMXZ ; CItemData::GetSpecularPowerf
  00041	d9 5d f0	 fstp	 DWORD PTR _fSpecularPower$1[ebp]

; 2601 : 			SetShape(dwShape, fSpecularPower);

  00044	51		 push	 ecx
  00045	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fSpecularPower$1[ebp]
  0004a	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0004f	ff 75 ec	 push	 DWORD PTR _dwShape$[ebp]
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?SetShape@CInstanceBase@@QAEXKM@Z ; CInstanceBase::SetShape

; 2602 : 			__GetRefinedEffect(pItemData);

  0005a	ff 75 f8	 push	 DWORD PTR _pItemData$3[ebp]
  0005d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	e8 00 00 00 00	 call	 ?__GetRefinedEffect@CInstanceBase@@IAEIPAVCItemData@@@Z ; CInstanceBase::__GetRefinedEffect

; 2603 : 			return;

  00065	eb 1e		 jmp	 SHORT $LN1@SetArmor

; 2604 : 		}

  00067	eb 08		 jmp	 SHORT $LN4@SetArmor
$LN3@SetArmor:

; 2605 : 		else
; 2606 : 			__ClearArmorRefineEffect();

  00069	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ?__ClearArmorRefineEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__ClearArmorRefineEffect
$LN4@SetArmor:

; 2607 : 	}
; 2608 : 
; 2609 : 	SetShape(dwArmor);

  00071	51		 push	 ecx
  00072	0f 57 c0	 xorps	 xmm0, xmm0
  00075	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0007a	ff 75 08	 push	 DWORD PTR _dwArmor$[ebp]
  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	e8 00 00 00 00	 call	 ?SetShape@CInstanceBase@@QAEXKM@Z ; CInstanceBase::SetShape
$LN1@SetArmor:

; 2610 : }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?SetArmor@CInstanceBase@@QAEXK@Z ENDP			; CInstanceBase::SetArmor
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetStateFlags@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwStateFlags$ = 8					; size = 4
?SetStateFlags@CInstanceBase@@QAEXK@Z PROC		; CInstanceBase::SetStateFlags, COMDAT
; _this$ = ecx

; 2087 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2088 : 	if (dwStateFlags & ADD_CHARACTER_STATE_KILLER)

  00007	8b 45 08	 mov	 eax, DWORD PTR _dwStateFlags$[ebp]
  0000a	83 e0 08	 and	 eax, 8
  0000d	74 0c		 je	 SHORT $LN2@SetStateFl

; 2089 : 		SetKiller(TRUE);

  0000f	6a 01		 push	 1
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?SetKiller@CInstanceBase@@QAEX_N@Z ; CInstanceBase::SetKiller
  00019	eb 0a		 jmp	 SHORT $LN3@SetStateFl
$LN2@SetStateFl:

; 2090 : 	else
; 2091 : 		SetKiller(FALSE);

  0001b	6a 00		 push	 0
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?SetKiller@CInstanceBase@@QAEX_N@Z ; CInstanceBase::SetKiller
$LN3@SetStateFl:

; 2092 : 
; 2093 : 	if (dwStateFlags & ADD_CHARACTER_STATE_PARTY)

  00025	8b 45 08	 mov	 eax, DWORD PTR _dwStateFlags$[ebp]
  00028	83 e0 10	 and	 eax, 16			; 00000010H
  0002b	74 0c		 je	 SHORT $LN4@SetStateFl

; 2094 : 		SetPartyMemberFlag(TRUE);

  0002d	6a 01		 push	 1
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?SetPartyMemberFlag@CInstanceBase@@QAEX_N@Z ; CInstanceBase::SetPartyMemberFlag
  00037	eb 0a		 jmp	 SHORT $LN1@SetStateFl
$LN4@SetStateFl:

; 2095 : 	else
; 2096 : 		SetPartyMemberFlag(FALSE);

  00039	6a 00		 push	 0
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?SetPartyMemberFlag@CInstanceBase@@QAEX_N@Z ; CInstanceBase::SetPartyMemberFlag
$LN1@SetStateFl:

; 2097 : }

  00043	c9		 leave
  00044	c2 04 00	 ret	 4
?SetStateFlags@CInstanceBase@@QAEXK@Z ENDP		; CInstanceBase::SetStateFlags
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetPartyMemberFlag@CInstanceBase@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bFlag$ = 8						; size = 1
?SetPartyMemberFlag@CInstanceBase@@QAEX_N@Z PROC	; CInstanceBase::SetPartyMemberFlag, COMDAT
; _this$ = ecx

; 2082 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2083 : 	m_isPartyMember = bFlag;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8a 4d 08	 mov	 cl, BYTE PTR _bFlag$[ebp]
  0000d	88 88 70 01 00
	00		 mov	 BYTE PTR [eax+368], cl

; 2084 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetPartyMemberFlag@CInstanceBase@@QAEX_N@Z ENDP	; CInstanceBase::SetPartyMemberFlag
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetKiller@CInstanceBase@@QAEX_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_bFlag$ = 8						; size = 1
?SetKiller@CInstanceBase@@QAEX_N@Z PROC			; CInstanceBase::SetKiller, COMDAT
; _this$ = ecx

; 2073 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2074 : 	if (m_isKiller == bFlag)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 80 6f 01
	00 00		 movzx	 eax, BYTE PTR [eax+367]
  00011	0f b6 4d 08	 movzx	 ecx, BYTE PTR _bFlag$[ebp]
  00015	3b c1		 cmp	 eax, ecx
  00017	75 02		 jne	 SHORT $LN2@SetKiller

; 2075 : 		return;

  00019	eb 14		 jmp	 SHORT $LN1@SetKiller
$LN2@SetKiller:

; 2076 : 
; 2077 : 	m_isKiller = bFlag;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8a 4d 08	 mov	 cl, BYTE PTR _bFlag$[ebp]
  00021	88 88 6f 01 00
	00		 mov	 BYTE PTR [eax+367], cl

; 2078 : 	RefreshTextTail();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?RefreshTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::RefreshTextTail
$LN1@SetKiller:

; 2079 : }

  0002f	c9		 leave
  00030	c2 04 00	 ret	 4
?SetKiller@CInstanceBase@@QAEX_N@Z ENDP			; CInstanceBase::SetKiller
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetPKMode@CInstanceBase@@QAEXE@Z
_TEXT	SEGMENT
_rPlayer$1 = -8						; size = 4
_this$ = -4						; size = 4
_byPKMode$ = 8						; size = 1
?SetPKMode@CInstanceBase@@QAEXE@Z PROC			; CInstanceBase::SetPKMode, COMDAT
; _this$ = ecx

; 2059 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2060 : 	if (m_byPKMode == byPKMode)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	0f b6 80 6e 01
	00 00		 movzx	 eax, BYTE PTR [eax+366]
  00012	0f b6 4d 08	 movzx	 ecx, BYTE PTR _byPKMode$[ebp]
  00016	3b c1		 cmp	 eax, ecx
  00018	75 02		 jne	 SHORT $LN2@SetPKMode

; 2061 : 		return;

  0001a	eb 2e		 jmp	 SHORT $LN1@SetPKMode
$LN2@SetPKMode:

; 2062 : 
; 2063 : 	m_byPKMode = byPKMode;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8a 4d 08	 mov	 cl, BYTE PTR _byPKMode$[ebp]
  00022	88 88 6e 01 00
	00		 mov	 BYTE PTR [eax+366], cl

; 2064 : 
; 2065 : 	if (__IsMainInstance())

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	74 13		 je	 SHORT $LN1@SetPKMode

; 2066 : 	{
; 2067 : 		IAbstractPlayer& rPlayer=IAbstractPlayer::GetSingleton();

  00037	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  0003c	89 45 f8	 mov	 DWORD PTR _rPlayer$1[ebp], eax

; 2068 : 		rPlayer.NotifyChangePKMode();

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _rPlayer$1[ebp]
  00042	8b 00		 mov	 eax, DWORD PTR [eax]
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _rPlayer$1[ebp]
  00047	ff 50 70	 call	 DWORD PTR [eax+112]
$LN1@SetPKMode:

; 2069 : 	}	
; 2070 : }

  0004a	c9		 leave
  0004b	c2 04 00	 ret	 4
?SetPKMode@CInstanceBase@@QAEXE@Z ENDP			; CInstanceBase::SetPKMode
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetAlignment@CInstanceBase@@QAEXF@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_sAlignment$ = 8					; size = 2
?SetAlignment@CInstanceBase@@QAEXF@Z PROC		; CInstanceBase::SetAlignment, COMDAT
; _this$ = ecx

; 2053 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2054 : 	m_sAlignment = sAlignment;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	66 8b 4d 08	 mov	 cx, WORD PTR _sAlignment$[ebp]
  0000e	66 89 88 6c 01
	00 00		 mov	 WORD PTR [eax+364], cx

; 2055 : 	RefreshTextTailTitle();

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?RefreshTextTailTitle@CInstanceBase@@QAEXXZ ; CInstanceBase::RefreshTextTailTitle

; 2056 : }

  0001d	c9		 leave
  0001e	c2 04 00	 ret	 4
?SetAlignment@CInstanceBase@@QAEXF@Z ENDP		; CInstanceBase::SetAlignment
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetInstanceType@CInstanceBase@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_iInstanceType$ = 8					; size = 4
?SetInstanceType@CInstanceBase@@QAEXH@Z PROC		; CInstanceBase::SetInstanceType, COMDAT
; _this$ = ecx

; 2048 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2049 : 	m_GraphicThingInstance.SetActorType(iInstanceType);

  00007	ff 75 08	 push	 DWORD PTR _iInstanceType$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?SetActorType@CActorInstance@@QAEXI@Z ; CActorInstance::SetActorType

; 2050 : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?SetInstanceType@CInstanceBase@@QAEXH@Z ENDP		; CInstanceBase::SetInstanceType
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetVirtualNumber@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwVirtualNumber$ = 8					; size = 4
?SetVirtualNumber@CInstanceBase@@QAEXK@Z PROC		; CInstanceBase::SetVirtualNumber, COMDAT
; _this$ = ecx

; 2043 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2044 : 	m_dwVirtualNumber = dwVirtualNumber;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _dwVirtualNumber$[ebp]
  0000d	89 88 68 01 00
	00		 mov	 DWORD PTR [eax+360], ecx

; 2045 : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetVirtualNumber@CInstanceBase@@QAEXK@Z ENDP		; CInstanceBase::SetVirtualNumber
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetVirtualID@CInstanceBase@@QAEXK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_dwVirtualID$ = 8					; size = 4
?SetVirtualID@CInstanceBase@@QAEXK@Z PROC		; CInstanceBase::SetVirtualID, COMDAT
; _this$ = ecx

; 2038 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2039 : 	m_GraphicThingInstance.SetVirtualID(dwVirtualID);		

  00007	ff 75 08	 push	 DWORD PTR _dwVirtualID$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00013	e8 00 00 00 00	 call	 ?SetVirtualID@CActorInstance@@QAEXK@Z ; CActorInstance::SetVirtualID

; 2040 : }

  00018	c9		 leave
  00019	c2 04 00	 ret	 4
?SetVirtualID@CInstanceBase@@QAEXK@Z ENDP		; CInstanceBase::SetVirtualID
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetRace@CInstanceBase@@QAE_NK@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eRace$ = 8						; size = 4
?SetRace@CInstanceBase@@QAE_NK@Z PROC			; CInstanceBase::SetRace, COMDAT
; _this$ = ecx

; 888  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 889  : 	m_dwRace = eRace;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _eRace$[ebp]
  0000d	89 88 64 01 00
	00		 mov	 DWORD PTR [eax+356], ecx

; 890  : 
; 891  : 	if (!m_GraphicThingInstance.SetRace(eRace))

  00013	ff 75 08	 push	 DWORD PTR _eRace$[ebp]
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0001f	e8 00 00 00 00	 call	 ?SetRace@CActorInstance@@QAE_NK@Z ; CActorInstance::SetRace
  00024	0f b6 c0	 movzx	 eax, al
  00027	85 c0		 test	 eax, eax
  00029	75 04		 jne	 SHORT $LN2@SetRace

; 892  : 		return false;

  0002b	32 c0		 xor	 al, al
  0002d	eb 2d		 jmp	 SHORT $LN1@SetRace
$LN2@SetRace:

; 893  : 
; 894  : 	if (!__FindRaceType(m_dwRace, &m_eRaceType))

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	05 5d 01 00 00	 add	 eax, 349		; 0000015dH
  00037	50		 push	 eax
  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	ff b0 64 01 00
	00		 push	 DWORD PTR [eax+356]
  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ?__FindRaceType@CInstanceBase@@IAE_NKPAE@Z ; CInstanceBase::__FindRaceType
  00049	0f b6 c0	 movzx	 eax, al
  0004c	85 c0		 test	 eax, eax
  0004e	75 0a		 jne	 SHORT $LN3@SetRace

; 895  : 		m_eRaceType=CActorInstance::TYPE_PC;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	c6 80 5d 01 00
	00 06		 mov	 BYTE PTR [eax+349], 6
$LN3@SetRace:

; 896  : 
; 897  : 	return true;

  0005a	b0 01		 mov	 al, 1
$LN1@SetRace:

; 898  : }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?SetRace@CInstanceBase@@QAE_NK@Z ENDP			; CInstanceBase::SetRace
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetNameString@CInstanceBase@@QAEXPBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_c_szName$ = 8						; size = 4
_len$ = 12						; size = 4
?SetNameString@CInstanceBase@@QAEXPBDH@Z PROC		; CInstanceBase::SetNameString, COMDAT
; _this$ = ecx

; 882  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 883  : 	m_stName.assign(c_szName, len);

  00007	ff 75 0c	 push	 DWORD PTR _len$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _c_szName$[ebp]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	83 c1 10	 add	 ecx, 16			; 00000010H
  00013	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 884  : }

  00018	c9		 leave
  00019	c2 08 00	 ret	 8
?SetNameString@CInstanceBase@@QAEXPBDH@Z ENDP		; CInstanceBase::SetNameString
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?GetBoundBox@CInstanceBase@@QAEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_vtMin$ = 8						; size = 4
_vtMax$ = 12						; size = 4
?GetBoundBox@CInstanceBase@@QAEXPAUD3DXVECTOR3@@0@Z PROC ; CInstanceBase::GetBoundBox, COMDAT
; _this$ = ecx

; 3111 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3112 : 	m_GraphicThingInstance.GetBoundBox(vtMin, vtMax);

  00007	ff 75 0c	 push	 DWORD PTR _vtMax$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _vtMin$[ebp]
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00016	e8 00 00 00 00	 call	 ?GetBoundBox@CGraphicThingInstance@@QAEXPAUD3DXVECTOR3@@0@Z ; CGraphicThingInstance::GetBoundBox

; 3113 : }

  0001b	c9		 leave
  0001c	c2 08 00	 ret	 8
?GetBoundBox@CInstanceBase@@QAEXPAUD3DXVECTOR3@@0@Z ENDP ; CInstanceBase::GetBoundBox
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?RegisterBoundingSphere@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RegisterBoundingSphere@CInstanceBase@@QAEXXZ PROC	; CInstanceBase::RegisterBoundingSphere, COMDAT
; _this$ = ecx

; 2976 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2977 : 	// Stone   DeforomNoSkin  
; 2978 : 	//     
; 2979 : 	//        .
; 2980 : 	if (!IsStone())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsStone@CInstanceBase@@QAEHXZ ; CInstanceBase::IsStone
  0000f	85 c0		 test	 eax, eax
  00011	75 0e		 jne	 SHORT $LN2@RegisterBo

; 2981 : 	{
; 2982 : 		m_GraphicThingInstance.DeformNoSkin();

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0001c	e8 00 00 00 00	 call	 ?DeformNoSkin@CGraphicThingInstance@@QAEXXZ ; CGraphicThingInstance::DeformNoSkin
$LN2@RegisterBo:

; 2983 : 	}
; 2984 : 
; 2985 : 	m_GraphicThingInstance.RegisterBoundingSphere();

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0002a	e8 00 00 00 00	 call	 ?RegisterBoundingSphere@CGraphicObjectInstance@@QAEXXZ ; CGraphicObjectInstance::RegisterBoundingSphere

; 2986 : }

  0002f	c9		 leave
  00030	c3		 ret	 0
?RegisterBoundingSphere@CInstanceBase@@QAEXXZ ENDP	; CInstanceBase::RegisterBoundingSphere
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?RenderCollision@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderCollision@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::RenderCollision, COMDAT
; _this$ = ecx

; 2030 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2031 : 	m_GraphicThingInstance.RenderCollisionData();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?RenderCollisionData@CActorInstance@@QAEXXZ ; CActorInstance::RenderCollisionData

; 2032 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?RenderCollision@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::RenderCollision
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?RenderToShadowMap@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_SHADOW_APPLY_DISTANCE$ = -16				; size = 4
_fDistance$ = -12					; size = 4
_pkInstMain$ = -8					; size = 4
_this$ = -4						; size = 4
?RenderToShadowMap@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::RenderToShadowMap, COMDAT
; _this$ = ecx

; 2005 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2006 : 	if (IsDoor())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?IsDoor@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDoor
  00011	85 c0		 test	 eax, eax
  00013	74 02		 je	 SHORT $LN2@RenderToSh

; 2007 : 		return;

  00015	eb 74		 jmp	 SHORT $LN1@RenderToSh
$LN2@RenderToSh:

; 2008 : 
; 2009 : 	if (IsBuilding())

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?IsBuilding@CInstanceBase@@QAEHXZ ; CInstanceBase::IsBuilding
  0001f	85 c0		 test	 eax, eax
  00021	74 02		 je	 SHORT $LN3@RenderToSh

; 2010 : 		return;

  00023	eb 66		 jmp	 SHORT $LN1@RenderToSh
$LN3@RenderToSh:

; 2011 : 
; 2012 : 	if (!__CanRender())

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?__CanRender@CInstanceBase@@IAE_NXZ ; CInstanceBase::__CanRender
  0002d	0f b6 c0	 movzx	 eax, al
  00030	85 c0		 test	 eax, eax
  00032	75 02		 jne	 SHORT $LN4@RenderToSh

; 2013 : 		return;

  00034	eb 55		 jmp	 SHORT $LN1@RenderToSh
$LN4@RenderToSh:

; 2014 : 
; 2015 : 	if (!__IsExistMainInstance())

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__IsExistMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsExistMainInstance
  0003e	0f b6 c0	 movzx	 eax, al
  00041	85 c0		 test	 eax, eax
  00043	75 02		 jne	 SHORT $LN5@RenderToSh

; 2016 : 		return;

  00045	eb 44		 jmp	 SHORT $LN1@RenderToSh
$LN5@RenderToSh:

; 2017 : 
; 2018 : 	CInstanceBase* pkInstMain=__GetMainInstancePtr();

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?__GetMainInstancePtr@CInstanceBase@@IAEPAV1@XZ ; CInstanceBase::__GetMainInstancePtr
  0004f	89 45 f8	 mov	 DWORD PTR _pkInstMain$[ebp], eax

; 2019 : 
; 2020 : 	const float SHADOW_APPLY_DISTANCE = 2500.0f;

  00052	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@451c4000
  0005a	f3 0f 11 45 f0	 movss	 DWORD PTR _SHADOW_APPLY_DISTANCE$[ebp], xmm0

; 2021 : 
; 2022 : 	float fDistance=NEW_GetDistanceFromDestInstance(*pkInstMain);

  0005f	ff 75 f8	 push	 DWORD PTR _pkInstMain$[ebp]
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ?NEW_GetDistanceFromDestInstance@CInstanceBase@@QAEMAAV1@@Z ; CInstanceBase::NEW_GetDistanceFromDestInstance
  0006a	d9 5d f4	 fstp	 DWORD PTR _fDistance$[ebp]

; 2023 : 	if (fDistance>=SHADOW_APPLY_DISTANCE)

  0006d	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _fDistance$[ebp]
  00072	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@451c4000
  00079	72 02		 jb	 SHORT $LN6@RenderToSh

; 2024 : 		return;

  0007b	eb 0e		 jmp	 SHORT $LN1@RenderToSh
$LN6@RenderToSh:

; 2025 : 
; 2026 : 	m_GraphicThingInstance.RenderToShadowMap();	

  0007d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00086	e8 00 00 00 00	 call	 ?RenderToShadowMap@CActorInstance@@QAEXXZ ; CActorInstance::RenderToShadowMap
$LN1@RenderToSh:

; 2027 : }

  0008b	c9		 leave
  0008c	c3		 ret	 0
?RenderToShadowMap@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::RenderToShadowMap
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?RenderTrace@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?RenderTrace@CInstanceBase@@QAEXXZ PROC			; CInstanceBase::RenderTrace, COMDAT
; _this$ = ecx

; 1951 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1952 : 	if (!__CanRender())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__CanRender@CInstanceBase@@IAE_NXZ ; CInstanceBase::__CanRender
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@RenderTrac

; 1953 : 		return;

  00016	eb 0e		 jmp	 SHORT $LN1@RenderTrac
$LN2@RenderTrac:

; 1954 : 
; 1955 : 	m_GraphicThingInstance.RenderTrace();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00021	e8 00 00 00 00	 call	 ?RenderTrace@CActorInstance@@QAEXXZ ; CActorInstance::RenderTrace
$LN1@RenderTrac:

; 1956 : }

  00026	c9		 leave
  00027	c3		 ret	 0
?RenderTrace@CInstanceBase@@QAEXXZ ENDP			; CInstanceBase::RenderTrace
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Render@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_fz$ = -80						; size = 4
_fy$ = -76						; size = 4
_fx$ = -72						; size = 4
_fz$ = -68						; size = 4
_fy$ = -64						; size = 4
_fx$ = -60						; size = 4
_this$ = -56						; size = 4
_kD3DVt3Cur$2 = -52					; size = 12
_kD3DVt3Dest$3 = -40					; size = 12
_px$4 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?Render@CInstanceBase@@QAEXXZ PROC			; CInstanceBase::Render, COMDAT
; _this$ = ecx

; 1962 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Render@CInstanceBase@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 44	 sub	 esp, 68			; 00000044H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 1963 : 	// 2004.07.17.levites.isShow ViewFrustumCheck 
; 1964 : 	if (!__CanRender())

  0002b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?__CanRender@CInstanceBase@@IAE_NXZ ; CInstanceBase::__CanRender
  00033	0f b6 c0	 movzx	 eax, al
  00036	85 c0		 test	 eax, eax
  00038	75 05		 jne	 SHORT $LN3@Render

; 1965 : 		return;

  0003a	e9 67 02 00 00	 jmp	 $LN1@Render
$LN3@Render:

; 1966 : 
; 1967 : 	++ms_dwRenderCounter;

  0003f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwRenderCounter@CInstanceBase@@1KA ; CInstanceBase::ms_dwRenderCounter
  00044	40		 inc	 eax
  00045	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwRenderCounter@CInstanceBase@@1KA, eax ; CInstanceBase::ms_dwRenderCounter

; 1968 : 
; 1969 : 	m_kHorse.Render();

  0004a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	e8 00 00 00 00	 call	 ?Render@SHORSE@CInstanceBase@@QAEXXZ ; CInstanceBase::SHORSE::Render

; 1970 : 	m_GraphicThingInstance.Render();	

  00055	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0005e	e8 00 00 00 00	 call	 ?Render@CGraphicObjectInstance@@QAE_NXZ ; CGraphicObjectInstance::Render

; 1971 : 	
; 1972 : 	if (CActorInstance::IsDirLine())

  00063	e8 00 00 00 00	 call	 ?IsDirLine@CActorInstance@@SA_NXZ ; CActorInstance::IsDirLine
  00068	0f b6 c0	 movzx	 eax, al
  0006b	85 c0		 test	 eax, eax
  0006d	0f 84 33 02 00
	00		 je	 $LN5@Render

; 1973 : 	{	
; 1974 : 		if (NEW_GetDstPixelPositionRef().x != 0.0f)

  00073	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  0007b	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0007f	0f 2e 05 00 00
	00 00		 ucomiss xmm0, DWORD PTR __real@00000000
  00086	9f		 lahf
  00087	f6 c4 44	 test	 ah, 68			; 00000044H
  0008a	0f 8b 16 02 00
	00		 jnp	 $LN5@Render

; 1975 : 		{
; 1976 : 			static CScreen s_kScreen;

  00090	a1 00 00 00 00	 mov	 eax, DWORD PTR __tls_index
  00095	64 8b 0d 00 00
	00 00		 mov	 ecx, DWORD PTR fs:__tls_array
  0009c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]
  0009f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?$TSS0@?9??Render@CInstanceBase@@QAEXXZ@4HA
  000a5	3b 88 00 00 00
	00		 cmp	 ecx, DWORD PTR __Init_thread_epoch[eax]
  000ab	7e 3c		 jle	 SHORT $LN2@Render
  000ad	68 00 00 00 00	 push	 OFFSET ?$TSS0@?9??Render@CInstanceBase@@QAEXXZ@4HA
  000b2	e8 00 00 00 00	 call	 __Init_thread_header
  000b7	59		 pop	 ecx
  000b8	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?$TSS0@?9??Render@CInstanceBase@@QAEXXZ@4HA, -1
  000bf	75 28		 jne	 SHORT $LN2@Render
  000c1	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kScreen@?9??Render@CInstanceBase@@QAEXXZ@4VCScreen@@A
  000ca	e8 00 00 00 00	 call	 ??0CScreen@@QAE@XZ	; CScreen::CScreen
  000cf	68 00 00 00 00	 push	 OFFSET ??__Fs_kScreen@?9??Render@CInstanceBase@@QAEXXZ@YAXXZ ; `CInstanceBase::Render'::`10'::`dynamic atexit destructor for 's_kScreen''
  000d4	e8 00 00 00 00	 call	 _atexit
  000d9	59		 pop	 ecx
  000da	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000de	68 00 00 00 00	 push	 OFFSET ?$TSS0@?9??Render@CInstanceBase@@QAEXXZ@4HA
  000e3	e8 00 00 00 00	 call	 __Init_thread_footer
  000e8	59		 pop	 ecx
$LN2@Render:

; 1977 : 
; 1978 : 			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLORARG1,	D3DTA_DIFFUSE);

  000e9	6a 00		 push	 0
  000eb	6a 02		 push	 2
  000ed	6a 00		 push	 0
  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  000f5	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1979 : 			STATEMANAGER.SetTextureStageState(0, D3DTSS_COLOROP,	D3DTOP_SELECTARG1);

  000fa	6a 02		 push	 2
  000fc	6a 01		 push	 1
  000fe	6a 00		 push	 0
  00100	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00106	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1980 : 			STATEMANAGER.SetTextureStageState(0, D3DTSS_ALPHAOP,	D3DTOP_DISABLE);	

  0010b	6a 01		 push	 1
  0010d	6a 04		 push	 4
  0010f	6a 00		 push	 0
  00111	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00117	e8 00 00 00 00	 call	 ?SetTextureStageState@CStateManager@@QAEXKW4_D3DTEXTURESTAGESTATETYPE@@K@Z ; CStateManager::SetTextureStageState

; 1981 : 			STATEMANAGER.SaveRenderState(D3DRS_ZENABLE, FALSE);

  0011c	6a 00		 push	 0
  0011e	6a 07		 push	 7
  00120	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00126	e8 00 00 00 00	 call	 ?SaveRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SaveRenderState

; 1982 : 			STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, FALSE);

  0012b	6a 00		 push	 0
  0012d	6a 1c		 push	 28			; 0000001cH
  0012f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00135	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1983 : 			STATEMANAGER.SetRenderState(D3DRS_LIGHTING, FALSE);

  0013a	6a 00		 push	 0
  0013c	68 89 00 00 00	 push	 137			; 00000089H
  00141	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00147	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1984 : 			
; 1985 : 			TPixelPosition px;
; 1986 : 			m_GraphicThingInstance.GetPixelPosition(&px);

  0014c	8d 45 e4	 lea	 eax, DWORD PTR _px$4[ebp]
  0014f	50		 push	 eax
  00150	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00153	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00159	e8 00 00 00 00	 call	 ?GetPixelPosition@CActorInstance@@QAEXPAUD3DXVECTOR3@@@Z ; CActorInstance::GetPixelPosition

; 1987 : 			D3DXVECTOR3 kD3DVt3Cur(px.x, px.y, px.z);

  0015e	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _px$4[ebp]
  00163	f3 0f 11 45 c4	 movss	 DWORD PTR _fx$[ebp], xmm0
  00168	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _px$4[ebp+4]
  0016d	f3 0f 11 45 c0	 movss	 DWORD PTR _fy$[ebp], xmm0
  00172	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _px$4[ebp+8]
  00177	f3 0f 11 45 bc	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  0017c	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00181	f3 0f 11 45 cc	 movss	 DWORD PTR _kD3DVt3Cur$2[ebp], xmm0

; 181  :     y = fy;

  00186	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0018b	f3 0f 11 45 d0	 movss	 DWORD PTR _kD3DVt3Cur$2[ebp+4], xmm0

; 182  :     z = fz;

  00190	f3 0f 10 45 bc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00195	f3 0f 11 45 d4	 movss	 DWORD PTR _kD3DVt3Cur$2[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1989 : 			D3DXVECTOR3 kD3DVt3Dest(NEW_GetDstPixelPositionRef().x, -NEW_GetDstPixelPositionRef().y, NEW_GetDstPixelPositionRef().z);

  0019a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  001a2	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  001a6	f3 0f 11 45 b8	 movss	 DWORD PTR _fx$[ebp], xmm0
  001ab	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ae	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  001b3	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001b8	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  001bf	f3 0f 11 45 b4	 movss	 DWORD PTR _fy$[ebp], xmm0
  001c4	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	e8 00 00 00 00	 call	 ?NEW_GetDstPixelPositionRef@CInstanceBase@@QAEABUD3DXVECTOR3@@XZ ; CInstanceBase::NEW_GetDstPixelPositionRef
  001cc	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001d1	f3 0f 11 45 b0	 movss	 DWORD PTR _fz$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  001d6	f3 0f 10 45 b8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001db	f3 0f 11 45 d8	 movss	 DWORD PTR _kD3DVt3Dest$3[ebp], xmm0

; 181  :     y = fy;

  001e0	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001e5	f3 0f 11 45 dc	 movss	 DWORD PTR _kD3DVt3Dest$3[ebp+4], xmm0

; 182  :     z = fz;

  001ea	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  001ef	f3 0f 11 45 e0	 movss	 DWORD PTR _kD3DVt3Dest$3[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 1995 : 			s_kScreen.SetDiffuseColor(0.0f, 0.0f, 1.0f);

  001f4	51		 push	 ecx
  001f5	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001fd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00202	51		 push	 ecx
  00203	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0020b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00210	51		 push	 ecx
  00211	0f 57 c0	 xorps	 xmm0, xmm0
  00214	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00219	51		 push	 ecx
  0021a	0f 57 c0	 xorps	 xmm0, xmm0
  0021d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00222	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kScreen@?9??Render@CInstanceBase@@QAEXXZ@4VCScreen@@A
  00227	e8 00 00 00 00	 call	 ?SetDiffuseColor@CScreen@@QAEXMMMM@Z ; CScreen::SetDiffuseColor

; 1996 : 			s_kScreen.RenderLine3d(kD3DVt3Cur.x, kD3DVt3Cur.y, px.z, kD3DVt3Dest.x, kD3DVt3Dest.y, px.z);

  0022c	51		 push	 ecx
  0022d	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _px$4[ebp+8]
  00232	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00237	51		 push	 ecx
  00238	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _kD3DVt3Dest$3[ebp+4]
  0023d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00242	51		 push	 ecx
  00243	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _kD3DVt3Dest$3[ebp]
  00248	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0024d	51		 push	 ecx
  0024e	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _px$4[ebp+8]
  00253	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00258	51		 push	 ecx
  00259	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _kD3DVt3Cur$2[ebp+4]
  0025e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00263	51		 push	 ecx
  00264	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _kD3DVt3Cur$2[ebp]
  00269	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0026e	b9 00 00 00 00	 mov	 ecx, OFFSET ?s_kScreen@?9??Render@CInstanceBase@@QAEXXZ@4VCScreen@@A
  00273	e8 00 00 00 00	 call	 ?RenderLine3d@CScreen@@QAEXMMMMMM@Z ; CScreen::RenderLine3d

; 1997 : 			STATEMANAGER.RestoreRenderState(D3DRS_ZENABLE);

  00278	6a 07		 push	 7
  0027a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  00280	e8 00 00 00 00	 call	 ?RestoreRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@@Z ; CStateManager::RestoreRenderState

; 1998 : 			STATEMANAGER.SetRenderState(D3DRS_FOGENABLE, TRUE);

  00285	6a 01		 push	 1
  00287	6a 1c		 push	 28			; 0000001cH
  00289	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  0028f	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState

; 1999 : 			STATEMANAGER.SetRenderState(D3DRS_LIGHTING, TRUE);

  00294	6a 01		 push	 1
  00296	68 89 00 00 00	 push	 137			; 00000089H
  0029b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCStateManager@@@@0PAVCStateManager@@A ; CSingleton<CStateManager>::ms_singleton
  002a1	e8 00 00 00 00	 call	 ?SetRenderState@CStateManager@@QAEXW4_D3DRENDERSTATETYPE@@K@Z ; CStateManager::SetRenderState
$LN5@Render:
$LN1@Render:

; 2000 : 		}
; 2001 : 	}	
; 2002 : }

  002a6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002a9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002b0	59		 pop	 ecx
  002b1	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002b4	33 cd		 xor	 ecx, ebp
  002b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002bb	c9		 leave
  002bc	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Render@CInstanceBase@@QAEXXZ$0:
  00000	68 00 00 00 00	 push	 OFFSET ?$TSS0@?9??Render@CInstanceBase@@QAEXXZ@4HA
  00005	e8 00 00 00 00	 call	 __Init_thread_abort
  0000a	59		 pop	 ecx
  0000b	c3		 ret	 0
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
  00010	cc		 int	 3
__ehhandler$?Render@CInstanceBase@@QAEXXZ:
  00011	90		 npad	 1
  00012	90		 npad	 1
  00013	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00017	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001a	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Render@CInstanceBase@@QAEXXZ
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Render@CInstanceBase@@QAEXXZ ENDP			; CInstanceBase::Render
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Deform@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Deform@CInstanceBase@@QAEXXZ PROC			; CInstanceBase::Deform, COMDAT
; _this$ = ecx

; 1938 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1939 : 	// 2004.07.17.levites.isShow ViewFrustumCheck 
; 1940 : 	if (!__CanRender())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__CanRender@CInstanceBase@@IAE_NXZ ; CInstanceBase::__CanRender
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	75 02		 jne	 SHORT $LN2@Deform

; 1941 : 		return;

  00016	eb 24		 jmp	 SHORT $LN1@Deform
$LN2@Deform:

; 1942 : 
; 1943 : 	++ms_dwDeformCounter;

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwDeformCounter@CInstanceBase@@1KA ; CInstanceBase::ms_dwDeformCounter
  0001d	40		 inc	 eax
  0001e	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwDeformCounter@CInstanceBase@@1KA, eax ; CInstanceBase::ms_dwDeformCounter

; 1944 : 
; 1945 : 	m_GraphicThingInstance.INSTANCEBASE_Deform();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0002c	e8 00 00 00 00	 call	 ?INSTANCEBASE_Deform@CActorInstance@@QAEXXZ ; CActorInstance::INSTANCEBASE_Deform

; 1946 : 
; 1947 : 	m_kHorse.Deform();

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 04	 add	 ecx, 4
  00037	e8 00 00 00 00	 call	 ?Deform@SHORSE@CInstanceBase@@QAEXXZ ; CInstanceBase::SHORSE::Deform
$LN1@Deform:

; 1948 : }

  0003c	c9		 leave
  0003d	c3		 ret	 0
?Deform@CInstanceBase@@QAEXXZ ENDP			; CInstanceBase::Deform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Transform@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_len$1 = -12						; size = 4
_c_rv3Movment$2 = -8					; size = 4
_this$ = -4						; size = 4
?Transform@CInstanceBase@@QAEXXZ PROC			; CInstanceBase::Transform, COMDAT
; _this$ = ecx

; 1914 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1915 : 	if (__IsSyncing())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?__IsSyncing@CInstanceBase@@QAEHXZ ; CInstanceBase::__IsSyncing
  00011	85 c0		 test	 eax, eax
  00013	74 02		 je	 SHORT $LN2@Transform

; 1916 : 	{
; 1917 : 		//OnSyncing();
; 1918 : 	}

  00015	eb 76		 jmp	 SHORT $LN7@Transform
$LN2@Transform:

; 1919 : 	else
; 1920 : 	{
; 1921 : 		if (IsWalking() || m_GraphicThingInstance.IsUsingMovingSkill())

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?IsWalking@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWalking
  0001f	85 c0		 test	 eax, eax
  00021	75 12		 jne	 SHORT $LN5@Transform
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0002c	e8 00 00 00 00	 call	 ?IsUsingMovingSkill@CActorInstance@@QAEHXZ ; CActorInstance::IsUsingMovingSkill
  00031	85 c0		 test	 eax, eax
  00033	74 58		 je	 SHORT $LN7@Transform
$LN5@Transform:

; 1922 : 		{
; 1923 : 			const D3DXVECTOR3& c_rv3Movment=m_GraphicThingInstance.GetMovementVectorRef();

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0003e	e8 00 00 00 00	 call	 ?GetMovementVectorRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::GetMovementVectorRef
  00043	89 45 f8	 mov	 DWORD PTR _c_rv3Movment$2[ebp], eax

; 1924 : 
; 1925 : 			float len=(c_rv3Movment.x*c_rv3Movment.x)+(c_rv3Movment.y*c_rv3Movment.y);

  00046	8b 45 f8	 mov	 eax, DWORD PTR _c_rv3Movment$2[ebp]
  00049	8b 4d f8	 mov	 ecx, DWORD PTR _c_rv3Movment$2[ebp]
  0004c	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00050	f3 0f 59 01	 mulss	 xmm0, DWORD PTR [ecx]
  00054	8b 45 f8	 mov	 eax, DWORD PTR _c_rv3Movment$2[ebp]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _c_rv3Movment$2[ebp]
  0005a	f3 0f 10 48 04	 movss	 xmm1, DWORD PTR [eax+4]
  0005f	f3 0f 59 49 04	 mulss	 xmm1, DWORD PTR [ecx+4]
  00064	f3 0f 58 c1	 addss	 xmm0, xmm1
  00068	f3 0f 11 45 f4	 movss	 DWORD PTR _len$1[ebp], xmm0

; 1926 : 			if (len>1.0f)

  0006d	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _len$1[ebp]
  00072	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@3f800000
  00079	76 0a		 jbe	 SHORT $LN6@Transform

; 1927 : 				OnMoving();

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?OnMoving@CInstanceBase@@IAEXXZ ; CInstanceBase::OnMoving
  00083	eb 08		 jmp	 SHORT $LN7@Transform
$LN6@Transform:

; 1928 : 			else
; 1929 : 				OnWaiting();	

  00085	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?OnWaiting@CInstanceBase@@IAEXXZ ; CInstanceBase::OnWaiting
$LN7@Transform:

; 1930 : 		}	
; 1931 : 	}
; 1932 : 
; 1933 : 	m_GraphicThingInstance.INSTANCEBASE_Transform();

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00096	e8 00 00 00 00	 call	 ?INSTANCEBASE_Transform@CActorInstance@@QAEXXZ ; CActorInstance::INSTANCEBASE_Transform

; 1934 : }

  0009b	c9		 leave
  0009c	c3		 ret	 0
?Transform@CInstanceBase@@QAEXXZ ENDP			; CInstanceBase::Transform
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Update@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_dwMtrlColor$1 = -28					; size = 4
_dwCurTime$2 = -24					; size = 4
_this$ = -20						; size = 4
_kPPosCur$3 = -16					; size = 12
__$ArrayPad$ = -4					; size = 4
?Update@CInstanceBase@@QAEXXZ PROC			; CInstanceBase::Update, COMDAT
; _this$ = ecx

; 1867 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 1868 : 	++ms_dwUpdateCounter;	

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_dwUpdateCounter@CInstanceBase@@1KA ; CInstanceBase::ms_dwUpdateCounter
  00018	40		 inc	 eax
  00019	a3 00 00 00 00	 mov	 DWORD PTR ?ms_dwUpdateCounter@CInstanceBase@@1KA, eax ; CInstanceBase::ms_dwUpdateCounter

; 1869 : 
; 1870 : 	StateProcess();

  0001e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?StateProcess@CInstanceBase@@IAEXXZ ; CInstanceBase::StateProcess

; 1871 : 	m_GraphicThingInstance.PhysicsProcess();

  00026	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0002f	e8 00 00 00 00	 call	 ?PhysicsProcess@CActorInstance@@QAEXXZ ; CActorInstance::PhysicsProcess

; 1872 : 	m_GraphicThingInstance.RotationProcess();

  00034	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0003d	e8 00 00 00 00	 call	 ?RotationProcess@CActorInstance@@QAEXXZ ; CActorInstance::RotationProcess

; 1873 : 	m_GraphicThingInstance.ComboProcess();

  00042	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0004b	e8 00 00 00 00	 call	 ?ComboProcess@CActorInstance@@QAEXXZ ; CActorInstance::ComboProcess

; 1874 : 	m_GraphicThingInstance.AccumulationMovement();

  00050	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00059	e8 00 00 00 00	 call	 ?AccumulationMovement@CActorInstance@@QAEXXZ ; CActorInstance::AccumulationMovement

; 1875 : 
; 1876 : 	if (m_GraphicThingInstance.IsMovement())

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00067	e8 00 00 00 00	 call	 ?IsMovement@CActorInstance@@QAEHXZ ; CActorInstance::IsMovement
  0006c	85 c0		 test	 eax, eax
  0006e	74 7d		 je	 SHORT $LN2@Update

; 1877 : 	{
; 1878 : 		TPixelPosition kPPosCur;
; 1879 : 		NEW_GetPixelPosition(&kPPosCur);

  00070	8d 45 f0	 lea	 eax, DWORD PTR _kPPosCur$3[ebp]
  00073	50		 push	 eax
  00074	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?NEW_GetPixelPosition@CInstanceBase@@QAEXPAUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_GetPixelPosition

; 1880 : 
; 1881 : 		DWORD dwCurTime=ELTimer_GetFrameMSec();

  0007c	e8 00 00 00 00	 call	 ?ELTimer_GetFrameMSec@@YAKXZ ; ELTimer_GetFrameMSec
  00081	89 45 e8	 mov	 DWORD PTR _dwCurTime$2[ebp], eax

; 1882 : 		//if (m_dwNextUpdateHeightTime<dwCurTime)
; 1883 : 		{
; 1884 : 			m_dwNextUpdateHeightTime=dwCurTime;

  00084	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00087	8b 4d e8	 mov	 ecx, DWORD PTR _dwCurTime$2[ebp]
  0008a	89 88 84 01 00
	00		 mov	 DWORD PTR [eax+388], ecx

; 1885 : 			kPPosCur.z = __GetBackgroundHeight(kPPosCur.x, kPPosCur.y);

  00090	51		 push	 ecx
  00091	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _kPPosCur$3[ebp+4]
  00096	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0009b	51		 push	 ecx
  0009c	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _kPPosCur$3[ebp]
  000a1	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000a6	e8 00 00 00 00	 call	 ?__GetBackgroundHeight@CInstanceBase@@KAMMM@Z ; CInstanceBase::__GetBackgroundHeight
  000ab	59		 pop	 ecx
  000ac	59		 pop	 ecx
  000ad	d9 5d f8	 fstp	 DWORD PTR _kPPosCur$3[ebp+8]

; 1886 : 			NEW_SetPixelPosition(kPPosCur);

  000b0	8d 45 f0	 lea	 eax, DWORD PTR _kPPosCur$3[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?NEW_SetPixelPosition@CInstanceBase@@QAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetPixelPosition

; 1887 : 		}
; 1888 : 
; 1889 : 		// SetMaterialColor
; 1890 : 		{
; 1891 : 			DWORD dwMtrlColor=__GetShadowMapColor(kPPosCur.x, kPPosCur.y);

  000bc	51		 push	 ecx
  000bd	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR _kPPosCur$3[ebp+4]
  000c2	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000c7	51		 push	 ecx
  000c8	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _kPPosCur$3[ebp]
  000cd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000d2	e8 00 00 00 00	 call	 ?__GetShadowMapColor@CInstanceBase@@KAKMM@Z ; CInstanceBase::__GetShadowMapColor
  000d7	59		 pop	 ecx
  000d8	59		 pop	 ecx
  000d9	89 45 e4	 mov	 DWORD PTR _dwMtrlColor$1[ebp], eax

; 1892 : 			m_GraphicThingInstance.SetMaterialColor(dwMtrlColor);

  000dc	ff 75 e4	 push	 DWORD PTR _dwMtrlColor$1[ebp]
  000df	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  000e8	e8 00 00 00 00	 call	 ?SetMaterialColor@CActorInstance@@QAEXK@Z ; CActorInstance::SetMaterialColor
$LN2@Update:

; 1893 : 		}
; 1894 : 	}
; 1895 : 
; 1896 : 	m_GraphicThingInstance.UpdateAdvancingPointInstance();

  000ed	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f0	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  000f6	e8 00 00 00 00	 call	 ?UpdateAdvancingPointInstance@CActorInstance@@QAEXXZ ; CActorInstance::UpdateAdvancingPointInstance

; 1897 : 
; 1898 : 	AttackProcess();

  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ?AttackProcess@CInstanceBase@@IAEXXZ ; CInstanceBase::AttackProcess

; 1899 : 	MovementProcess();

  00103	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	e8 00 00 00 00	 call	 ?MovementProcess@CInstanceBase@@IAEXXZ ; CInstanceBase::MovementProcess

; 1900 : 
; 1901 : 	m_GraphicThingInstance.MotionProcess(IsPC());

  0010b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  00113	50		 push	 eax
  00114	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0011d	e8 00 00 00 00	 call	 ?MotionProcess@CActorInstance@@QAEXH@Z ; CActorInstance::MotionProcess

; 1902 : 	if (IsMountingHorse())

  00122	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00125	e8 00 00 00 00	 call	 ?IsMountingHorse@CInstanceBase@@QAEHXZ ; CInstanceBase::IsMountingHorse
  0012a	85 c0		 test	 eax, eax
  0012c	74 0d		 je	 SHORT $LN3@Update

; 1903 : 	{
; 1904 : 		m_kHorse.m_pkActor->HORSE_MotionProcess(FALSE);

  0012e	6a 00		 push	 0
  00130	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00133	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00136	e8 00 00 00 00	 call	 ?HORSE_MotionProcess@CActorInstance@@QAEXH@Z ; CActorInstance::HORSE_MotionProcess
$LN3@Update:

; 1905 : 	}
; 1906 : 
; 1907 : 	__ComboProcess();	

  0013b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0013e	e8 00 00 00 00	 call	 ?__ComboProcess@CInstanceBase@@IAEXXZ ; CInstanceBase::__ComboProcess

; 1908 : 	
; 1909 : 	ProcessDamage();

  00143	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00146	e8 00 00 00 00	 call	 ?ProcessDamage@CInstanceBase@@IAEXXZ ; CInstanceBase::ProcessDamage

; 1910 : 
; 1911 : }

  0014b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0014e	33 cd		 xor	 ecx, ebp
  00150	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00155	c9		 leave
  00156	c3		 ret	 0
?Update@CInstanceBase@@QAEXXZ ENDP			; CInstanceBase::Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Destroy@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Destroy@CInstanceBase@@QAEXXZ PROC			; CInstanceBase::Destroy, COMDAT
; _this$ = ecx

; 2999 : {	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3000 : 	DetachTextTail();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?DetachTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::DetachTextTail

; 3001 : 	
; 3002 : 	DismountHorse();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?DismountHorse@CInstanceBase@@QAEXXZ ; CInstanceBase::DismountHorse

; 3003 : 
; 3004 : 	m_kQue_kCmdNew.clear();

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  00020	e8 00 00 00 00	 call	 ?clear@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAEXXZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::clear

; 3005 : 	
; 3006 : 	__EffectContainer_Destroy();

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?__EffectContainer_Destroy@CInstanceBase@@IAEXXZ ; CInstanceBase::__EffectContainer_Destroy

; 3007 : 	__StoneSmoke_Destroy();

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?__StoneSmoke_Destroy@CInstanceBase@@IAEXXZ ; CInstanceBase::__StoneSmoke_Destroy

; 3008 : 
; 3009 : 	if (__IsMainInstance())

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  0003d	0f b6 c0	 movzx	 eax, al
  00040	85 c0		 test	 eax, eax
  00042	74 08		 je	 SHORT $LN2@Destroy

; 3010 : 		__ClearMainInstance();	

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?__ClearMainInstance@CInstanceBase@@IAEXXZ ; CInstanceBase::__ClearMainInstance
$LN2@Destroy:

; 3011 : 	
; 3012 : 	m_GraphicThingInstance.Destroy();

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00055	e8 00 00 00 00	 call	 ?Destroy@CActorInstance@@QAEXXZ ; CActorInstance::Destroy

; 3013 : 	
; 3014 : 	__Initialize();

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ?__Initialize@CInstanceBase@@IAEXXZ ; CInstanceBase::__Initialize

; 3015 : }

  00062	c9		 leave
  00063	c3		 ret	 0
?Destroy@CInstanceBase@@QAEXXZ ENDP			; CInstanceBase::Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?DestroyDeviceObjects@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DestroyDeviceObjects@CInstanceBase@@QAEXXZ PROC	; CInstanceBase::DestroyDeviceObjects, COMDAT
; _this$ = ecx

; 2994 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2995 : 	m_GraphicThingInstance.DestroyDeviceObjects();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?DestroyDeviceObjects@CGraphicThingInstance@@QAEXXZ ; CGraphicThingInstance::DestroyDeviceObjects

; 2996 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?DestroyDeviceObjects@CInstanceBase@@QAEXXZ ENDP	; CInstanceBase::DestroyDeviceObjects
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CreateDeviceObjects@CInstanceBase@@QAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?CreateDeviceObjects@CInstanceBase@@QAE_NXZ PROC	; CInstanceBase::CreateDeviceObjects, COMDAT
; _this$ = ecx

; 2989 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2990 : 	return m_GraphicThingInstance.CreateDeviceObjects();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00010	e8 00 00 00 00	 call	 ?CreateDeviceObjects@CGraphicThingInstance@@QAE_NXZ ; CGraphicThingInstance::CreateDeviceObjects

; 2991 : }

  00015	c9		 leave
  00016	c3		 ret	 0
?CreateDeviceObjects@CInstanceBase@@QAE_NXZ ENDP	; CInstanceBase::CreateDeviceObjects
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z
_TEXT	SEGMENT
tv367 = -136						; size = 8
tv358 = -128						; size = 8
_c_iGuildSymbolRace$ = -120				; size = 4
_f$2 = -116						; size = 4
$T3 = -112						; size = 16
$T4 = -96						; size = 4
_center_z$5 = -92					; size = 4
_fy$ = -88						; size = 4
_fx$ = -84						; size = 4
_center_x$6 = -80					; size = 4
_center_y$7 = -76					; size = 4
tv363 = -72						; size = 4
tv338 = -68						; size = 4
tv66 = -64						; size = 4
_dwBodyColor$8 = -60					; size = 4
_this$ = -56						; size = 4
_strFileName$9 = -52					; size = 24
$T10 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_c_rkCreateData$ = 8					; size = 4
?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z PROC	; CInstanceBase::Create, COMDAT
; _this$ = ecx

; 719  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 7c	 sub	 esp, 124		; 0000007cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx

; 720  : 	IAbstractApplication::GetSingleton().SkipRenderBuffering(300);

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractApplication@@@@0PAVIAbstractApplication@@A ; TAbstractSingleton<IAbstractApplication>::ms_singleton
  00030	89 45 c0	 mov	 DWORD PTR tv66[ebp], eax
  00033	68 2c 01 00 00	 push	 300			; 0000012cH
  00038	8b 45 c0	 mov	 eax, DWORD PTR tv66[ebp]
  0003b	8b 00		 mov	 eax, DWORD PTR [eax]
  0003d	8b 4d c0	 mov	 ecx, DWORD PTR tv66[ebp]
  00040	ff 50 10	 call	 DWORD PTR [eax+16]

; 721  : 
; 722  : 	SetInstanceType(c_rkCreateData.m_bType);

  00043	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00046	0f b6 00	 movzx	 eax, BYTE PTR [eax]
  00049	50		 push	 eax
  0004a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?SetInstanceType@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetInstanceType

; 723  : 
; 724  : 
; 725  : 	if (!SetRace(c_rkCreateData.m_dwRace))

  00052	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00055	ff 70 18	 push	 DWORD PTR [eax+24]
  00058	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?SetRace@CInstanceBase@@QAE_NK@Z ; CInstanceBase::SetRace
  00060	0f b6 c0	 movzx	 eax, al
  00063	85 c0		 test	 eax, eax
  00065	75 07		 jne	 SHORT $LN2@Create

; 726  : 		return false;

  00067	32 c0		 xor	 al, al
  00069	e9 3f 04 00 00	 jmp	 $LN1@Create
$LN2@Create:

; 727  : 
; 728  : 	SetVirtualID(c_rkCreateData.m_dwVID);

  0006e	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00071	ff 70 14	 push	 DWORD PTR [eax+20]
  00074	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ?SetVirtualID@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetVirtualID

; 729  : 
; 730  : 	if (c_rkCreateData.m_isMain)

  0007c	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  0007f	0f b6 40 64	 movzx	 eax, BYTE PTR [eax+100]
  00083	85 c0		 test	 eax, eax
  00085	74 08		 je	 SHORT $LN3@Create

; 731  : 		SetMainInstance();

  00087	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?SetMainInstance@CInstanceBase@@QAEXXZ ; CInstanceBase::SetMainInstance
$LN3@Create:

; 732  : 
; 733  : 	if (IsGuildWall())

  0008f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?IsGuildWall@CInstanceBase@@QAEHXZ ; CInstanceBase::IsGuildWall
  00097	85 c0		 test	 eax, eax
  00099	0f 84 bd 00 00
	00		 je	 $LN4@Create

; 734  : 	{
; 735  : 		unsigned center_x;
; 736  : 		unsigned center_y;
; 737  : 
; 738  : 		c_rkCreateData.m_kAffectFlags.ConvertToPosition(&center_x, &center_y);

  0009f	8d 45 b4	 lea	 eax, DWORD PTR _center_y$7[ebp]
  000a2	50		 push	 eax
  000a3	8d 45 b0	 lea	 eax, DWORD PTR _center_x$6[ebp]
  000a6	50		 push	 eax
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _c_rkCreateData$[ebp]
  000aa	83 c1 43	 add	 ecx, 67			; 00000043H
  000ad	e8 00 00 00 00	 call	 ?ConvertToPosition@CAffectFlagContainer@@QBEXPAI0@Z ; CAffectFlagContainer::ConvertToPosition

; 739  : 		
; 740  : 		float center_z = __GetBackgroundHeight(center_x, center_y);

  000b2	8b 45 b4	 mov	 eax, DWORD PTR _center_y$7[ebp]
  000b5	89 45 bc	 mov	 DWORD PTR tv338[ebp], eax
  000b8	f2 0f 2a 45 bc	 cvtsi2sd xmm0, DWORD PTR tv338[ebp]
  000bd	8b 45 bc	 mov	 eax, DWORD PTR tv338[ebp]
  000c0	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000c3	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000cc	f2 0f 11 45 80	 movsd	 QWORD PTR tv358[ebp], xmm0
  000d1	f2 0f 5a 45 80	 cvtsd2ss xmm0, QWORD PTR tv358[ebp]
  000d6	51		 push	 ecx
  000d7	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  000dc	8b 45 b0	 mov	 eax, DWORD PTR _center_x$6[ebp]
  000df	89 45 b8	 mov	 DWORD PTR tv363[ebp], eax
  000e2	f2 0f 2a 45 b8	 cvtsi2sd xmm0, DWORD PTR tv363[ebp]
  000e7	8b 45 b8	 mov	 eax, DWORD PTR tv363[ebp]
  000ea	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  000ed	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  000f6	f2 0f 11 85 78
	ff ff ff	 movsd	 QWORD PTR tv367[ebp], xmm0
  000fe	f2 0f 5a 85 78
	ff ff ff	 cvtsd2ss xmm0, QWORD PTR tv367[ebp]
  00106	51		 push	 ecx
  00107	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0010c	e8 00 00 00 00	 call	 ?__GetBackgroundHeight@CInstanceBase@@KAMMM@Z ; CInstanceBase::__GetBackgroundHeight
  00111	59		 pop	 ecx
  00112	59		 pop	 ecx
  00113	d9 5d a4	 fstp	 DWORD PTR _center_z$5[ebp]

; 741  : 		NEW_SetPixelPosition(TPixelPosition(float(c_rkCreateData.m_lPosX), float(c_rkCreateData.m_lPosY), center_z));

  00116	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00119	f3 0f 2a 40 24	 cvtsi2ss xmm0, DWORD PTR [eax+36]
  0011e	f3 0f 11 45 ac	 movss	 DWORD PTR _fx$[ebp], xmm0
  00123	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00126	f3 0f 2a 40 28	 cvtsi2ss xmm0, DWORD PTR [eax+40]
  0012b	f3 0f 11 45 a8	 movss	 DWORD PTR _fy$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 180  :     x = fx;

  00130	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00135	f3 0f 11 45 e4	 movss	 DWORD PTR $T10[ebp], xmm0

; 181  :     y = fy;

  0013a	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0013f	f3 0f 11 45 e8	 movss	 DWORD PTR $T10[ebp+4], xmm0

; 182  :     z = fz;

  00144	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _center_z$5[ebp]
  00149	f3 0f 11 45 ec	 movss	 DWORD PTR $T10[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 741  : 		NEW_SetPixelPosition(TPixelPosition(float(c_rkCreateData.m_lPosX), float(c_rkCreateData.m_lPosY), center_z));

  0014e	8d 45 e4	 lea	 eax, DWORD PTR $T10[ebp]
  00151	50		 push	 eax
  00152	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00155	e8 00 00 00 00	 call	 ?NEW_SetPixelPosition@CInstanceBase@@QAEXABUD3DXVECTOR3@@@Z ; CInstanceBase::NEW_SetPixelPosition

; 742  : 	}

  0015a	eb 24		 jmp	 SHORT $LN5@Create
$LN4@Create:

; 743  : 	else
; 744  : 	{
; 745  : 		SCRIPT_SetPixelPosition(float(c_rkCreateData.m_lPosX), float(c_rkCreateData.m_lPosY));

  0015c	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  0015f	f3 0f 2a 40 28	 cvtsi2ss xmm0, DWORD PTR [eax+40]
  00164	51		 push	 ecx
  00165	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0016a	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  0016d	f3 0f 2a 40 24	 cvtsi2ss xmm0, DWORD PTR [eax+36]
  00172	51		 push	 ecx
  00173	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00178	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017b	e8 00 00 00 00	 call	 ?SCRIPT_SetPixelPosition@CInstanceBase@@QAEXMM@Z ; CInstanceBase::SCRIPT_SetPixelPosition
$LN5@Create:

; 746  : 	}	
; 747  : 
; 748  : 	if (0 != c_rkCreateData.m_dwMountVnum)

  00180	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00183	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00187	74 0e		 je	 SHORT $LN6@Create

; 749  : 		MountHorse(c_rkCreateData.m_dwMountVnum);

  00189	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  0018c	ff 70 3c	 push	 DWORD PTR [eax+60]
  0018f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00192	e8 00 00 00 00	 call	 ?MountHorse@CInstanceBase@@QAEXI@Z ; CInstanceBase::MountHorse
$LN6@Create:

; 750  : 
; 751  : 	SetArmor(c_rkCreateData.m_dwArmor);

  00197	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  0019a	ff 70 30	 push	 DWORD PTR [eax+48]
  0019d	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a0	e8 00 00 00 00	 call	 ?SetArmor@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetArmor

; 752  : 
; 753  : 	if (IsPC())

  001a5	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001a8	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  001ad	85 c0		 test	 eax, eax
  001af	74 1c		 je	 SHORT $LN7@Create

; 754  : 	{
; 755  : 		SetHair(c_rkCreateData.m_dwHair);

  001b1	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  001b4	ff 70 38	 push	 DWORD PTR [eax+56]
  001b7	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001ba	e8 00 00 00 00	 call	 ?SetHair@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetHair

; 756  : 		SetWeapon(c_rkCreateData.m_dwWeapon);

  001bf	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  001c2	ff 70 34	 push	 DWORD PTR [eax+52]
  001c5	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	e8 00 00 00 00	 call	 ?SetWeapon@CInstanceBase@@QAE_NK@Z ; CInstanceBase::SetWeapon
$LN7@Create:

; 757  : 	}
; 758  : 
; 759  : 	__Create_SetName(c_rkCreateData);

  001cd	ff 75 08	 push	 DWORD PTR _c_rkCreateData$[ebp]
  001d0	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	e8 00 00 00 00	 call	 ?__Create_SetName@CInstanceBase@@IAEXABUSCreateData@1@@Z ; CInstanceBase::__Create_SetName

; 760  : 
; 761  : 	m_dwLevel = c_rkCreateData.m_dwLevel;

  001d8	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001db	8b 4d 08	 mov	 ecx, DWORD PTR _c_rkCreateData$[ebp]
  001de	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  001e1	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 762  : 	m_dwGuildID = c_rkCreateData.m_dwGuildID;

  001e4	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001e7	8b 4d 08	 mov	 ecx, DWORD PTR _c_rkCreateData$[ebp]
  001ea	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  001ed	89 48 44	 mov	 DWORD PTR [eax+68], ecx

; 763  : 	m_dwEmpireID = c_rkCreateData.m_dwEmpireID;

  001f0	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  001f3	8b 4d 08	 mov	 ecx, DWORD PTR _c_rkCreateData$[ebp]
  001f6	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  001f9	89 48 40	 mov	 DWORD PTR [eax+64], ecx

; 764  : 
; 765  : 	SetVirtualNumber(c_rkCreateData.m_dwRace);

  001fc	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  001ff	ff 70 18	 push	 DWORD PTR [eax+24]
  00202	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00205	e8 00 00 00 00	 call	 ?SetVirtualNumber@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetVirtualNumber

; 766  : 	SetRotation(c_rkCreateData.m_fRot);

  0020a	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  0020d	51		 push	 ecx
  0020e	f3 0f 10 40 2c	 movss	 xmm0, DWORD PTR [eax+44]
  00213	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00218	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0021b	e8 00 00 00 00	 call	 ?SetRotation@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetRotation

; 767  : 
; 768  : 	SetAlignment(c_rkCreateData.m_sAlignment);

  00220	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00223	0f b7 40 40	 movzx	 eax, WORD PTR [eax+64]
  00227	50		 push	 eax
  00228	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0022b	e8 00 00 00 00	 call	 ?SetAlignment@CInstanceBase@@QAEXF@Z ; CInstanceBase::SetAlignment

; 769  : 	SetPKMode(c_rkCreateData.m_byPKMode);

  00230	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00233	0f b6 40 42	 movzx	 eax, BYTE PTR [eax+66]
  00237	50		 push	 eax
  00238	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	e8 00 00 00 00	 call	 ?SetPKMode@CInstanceBase@@QAEXE@Z ; CInstanceBase::SetPKMode

; 770  : 
; 771  : 	SetMoveSpeed(c_rkCreateData.m_dwMovSpd);

  00240	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00243	ff 70 1c	 push	 DWORD PTR [eax+28]
  00246	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00249	e8 00 00 00 00	 call	 ?SetMoveSpeed@CInstanceBase@@QAEXI@Z ; CInstanceBase::SetMoveSpeed

; 772  : 	SetAttackSpeed(c_rkCreateData.m_dwAtkSpd);

  0024e	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00251	ff 70 20	 push	 DWORD PTR [eax+32]
  00254	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00257	e8 00 00 00 00	 call	 ?SetAttackSpeed@CInstanceBase@@QAEXI@Z ; CInstanceBase::SetAttackSpeed

; 773  : 	
; 774  : 	// NOTE : Dress    Alpha   .
; 775  : 	if (!IsWearingDress())

  0025c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0025f	e8 00 00 00 00	 call	 ?IsWearingDress@CInstanceBase@@QAEHXZ ; CInstanceBase::IsWearingDress
  00264	85 c0		 test	 eax, eax
  00266	75 41		 jne	 SHORT $LN8@Create

; 776  : 	{
; 777  : 		// NOTE :  Affect    
; 778  : 		m_GraphicThingInstance.SetAlphaValue(0.0f);

  00268	51		 push	 ecx
  00269	0f 57 c0	 xorps	 xmm0, xmm0
  0026c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00271	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00274	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0027a	e8 00 00 00 00	 call	 ?SetAlphaValue@CActorInstance@@QAEXM@Z ; CActorInstance::SetAlphaValue

; 779  : 		m_GraphicThingInstance.BlendAlphaValue(1.0f, 0.5f);

  0027f	51		 push	 ecx
  00280	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f000000
  00288	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0028d	51		 push	 ecx
  0028e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00296	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0029b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0029e	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  002a4	e8 00 00 00 00	 call	 ?BlendAlphaValue@CActorInstance@@QAEXMM@Z ; CActorInstance::BlendAlphaValue
$LN8@Create:

; 780  : 	}
; 781  : 
; 782  : 	if (!IsGuildWall())

  002a9	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002ac	e8 00 00 00 00	 call	 ?IsGuildWall@CInstanceBase@@QAEHXZ ; CInstanceBase::IsGuildWall
  002b1	85 c0		 test	 eax, eax
  002b3	75 0f		 jne	 SHORT $LN9@Create

; 783  : 	{
; 784  : 		SetAffectFlagContainer(c_rkCreateData.m_kAffectFlags);

  002b5	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  002b8	83 c0 43	 add	 eax, 67			; 00000043H
  002bb	50		 push	 eax
  002bc	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002bf	e8 00 00 00 00	 call	 ?SetAffectFlagContainer@CInstanceBase@@QAEXABVCAffectFlagContainer@@@Z ; CInstanceBase::SetAffectFlagContainer
$LN9@Create:

; 785  : 	}	
; 786  : 
; 787  : 	// NOTE :  Affect    
; 788  : 	AttachTextTail();

  002c4	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c7	e8 00 00 00 00	 call	 ?AttachTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::AttachTextTail

; 789  : 	RefreshTextTail();

  002cc	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002cf	e8 00 00 00 00	 call	 ?RefreshTextTail@CInstanceBase@@QAEXXZ ; CInstanceBase::RefreshTextTail

; 790  : 
; 791  : 	if (c_rkCreateData.m_dwStateFlags & ADD_CHARACTER_STATE_SPAWN) 

  002d4	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  002d7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002da	83 e0 02	 and	 eax, 2
  002dd	74 43		 je	 SHORT $LN10@Create

; 792  : 	{
; 793  : 		if (IsAffect(AFFECT_SPAWN))

  002df	6a 02		 push	 2
  002e1	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002e4	e8 00 00 00 00	 call	 ?IsAffect@CInstanceBase@@QAE_NI@Z ; CInstanceBase::IsAffect
  002e9	0f b6 c0	 movzx	 eax, al
  002ec	85 c0		 test	 eax, eax
  002ee	74 0a		 je	 SHORT $LN12@Create

; 794  : 			__AttachEffect(EFFECT_SPAWN_APPEAR);

  002f0	6a 09		 push	 9
  002f2	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002f5	e8 00 00 00 00	 call	 ?__AttachEffect@CInstanceBase@@IAEKI@Z ; CInstanceBase::__AttachEffect
$LN12@Create:

; 795  : 
; 796  : 		if (IsPC())

  002fa	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  002fd	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  00302	85 c0		 test	 eax, eax
  00304	74 0e		 je	 SHORT $LN13@Create

; 797  : 		{
; 798  : 			Refresh(CRaceMotionData::NAME_WAIT, true);

  00306	6a 01		 push	 1
  00308	6a 01		 push	 1
  0030a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0030d	e8 00 00 00 00	 call	 ?Refresh@CInstanceBase@@QAEXK_N@Z ; CInstanceBase::Refresh

; 799  : 		}

  00312	eb 0c		 jmp	 SHORT $LN14@Create
$LN13@Create:

; 800  : 		else
; 801  : 		{
; 802  : 			Refresh(CRaceMotionData::NAME_SPAWN, false);

  00314	6a 00		 push	 0
  00316	6a 19		 push	 25			; 00000019H
  00318	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0031b	e8 00 00 00 00	 call	 ?Refresh@CInstanceBase@@QAEXK_N@Z ; CInstanceBase::Refresh
$LN14@Create:

; 803  : 		}
; 804  : 	}

  00320	eb 0c		 jmp	 SHORT $LN11@Create
$LN10@Create:

; 805  : 	else
; 806  : 	{
; 807  : 		Refresh(CRaceMotionData::NAME_WAIT, true);

  00322	6a 01		 push	 1
  00324	6a 01		 push	 1
  00326	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00329	e8 00 00 00 00	 call	 ?Refresh@CInstanceBase@@QAEXK_N@Z ; CInstanceBase::Refresh
$LN11@Create:

; 808  : 	}
; 809  : 
; 810  : 	__AttachEmpireEffect(c_rkCreateData.m_dwEmpireID);

  0032e	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00331	ff 70 08	 push	 DWORD PTR [eax+8]
  00334	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00337	e8 00 00 00 00	 call	 ?__AttachEmpireEffect@CInstanceBase@@IAEXK@Z ; CInstanceBase::__AttachEmpireEffect

; 811  : 
; 812  : 	RegisterBoundingSphere();

  0033c	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0033f	e8 00 00 00 00	 call	 ?RegisterBoundingSphere@CInstanceBase@@QAEXXZ ; CInstanceBase::RegisterBoundingSphere

; 813  : 
; 814  : 	if (c_rkCreateData.m_dwStateFlags & ADD_CHARACTER_STATE_DEAD)

  00344	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00347	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0034a	83 e0 01	 and	 eax, 1
  0034d	74 0e		 je	 SHORT $LN15@Create

; 815  : 		m_GraphicThingInstance.DieEnd();

  0034f	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00352	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00358	e8 00 00 00 00	 call	 ?DieEnd@CActorInstance@@QAEXXZ ; CActorInstance::DieEnd
$LN15@Create:

; 816  : 
; 817  : 	SetStateFlags(c_rkCreateData.m_dwStateFlags);

  0035d	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  00360	ff 70 04	 push	 DWORD PTR [eax+4]
  00363	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00366	e8 00 00 00 00	 call	 ?SetStateFlags@CInstanceBase@@QAEXK@Z ; CInstanceBase::SetStateFlags

; 818  : 
; 819  : 	m_GraphicThingInstance.SetBattleHitEffect(ms_adwCRCAffectEffect[EFFECT_HIT]);

  0036b	6a 04		 push	 4
  0036d	58		 pop	 eax
  0036e	d1 e0		 shl	 eax, 1
  00370	ff b0 00 00 00
	00		 push	 DWORD PTR ?ms_adwCRCAffectEffect@CInstanceBase@@1PAKA[eax]
  00376	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00379	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0037f	e8 00 00 00 00	 call	 ?SetBattleHitEffect@CActorInstance@@QAEXK@Z ; CActorInstance::SetBattleHitEffect

; 820  : 
; 821  : 	if (!IsPC())

  00384	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00387	e8 00 00 00 00	 call	 ?IsPC@CInstanceBase@@QAEHXZ ; CInstanceBase::IsPC
  0038c	85 c0		 test	 eax, eax
  0038e	0f 85 a7 00 00
	00		 jne	 $LN17@Create
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 27   : 		return (*ms_singleton);

  00394	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNonPlayer@@@@0PAVCPythonNonPlayer@@A ; CSingleton<CPythonNonPlayer>::ms_singleton
  00399	89 45 a0	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 823  : 		DWORD dwBodyColor = CPythonNonPlayer::Instance().GetMonsterColor(c_rkCreateData.m_dwRace);

  0039c	8b 45 08	 mov	 eax, DWORD PTR _c_rkCreateData$[ebp]
  0039f	ff 70 18	 push	 DWORD PTR [eax+24]
  003a2	8b 4d a0	 mov	 ecx, DWORD PTR $T4[ebp]
  003a5	e8 00 00 00 00	 call	 ?GetMonsterColor@CPythonNonPlayer@@QAEKK@Z ; CPythonNonPlayer::GetMonsterColor
  003aa	89 45 c4	 mov	 DWORD PTR _dwBodyColor$8[ebp], eax

; 824  : 		if (0 != dwBodyColor)

  003ad	83 7d c4 00	 cmp	 DWORD PTR _dwBodyColor$8[ebp], 0
  003b1	0f 84 84 00 00
	00		 je	 $LN17@Create

; 825  : 		{
; 826  : 			SetModulateRenderMode();

  003b7	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  003ba	e8 00 00 00 00	 call	 ?SetModulateRenderMode@CInstanceBase@@QAEXXZ ; CInstanceBase::SetModulateRenderMode
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 887  :     CONST FLOAT f = 1.0f / 255.0f;

  003bf	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3b808081
  003c7	f3 0f 11 45 8c	 movss	 DWORD PTR _f$2[ebp], xmm0

; 888  :     r = f * (FLOAT) (unsigned char) (dw >> 16);

  003cc	8b 45 c4	 mov	 eax, DWORD PTR _dwBodyColor$8[ebp]
  003cf	c1 e8 10	 shr	 eax, 16			; 00000010H
  003d2	0f b6 c0	 movzx	 eax, al
  003d5	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003d9	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3b808081
  003e1	f3 0f 11 45 90	 movss	 DWORD PTR $T3[ebp], xmm0

; 889  :     g = f * (FLOAT) (unsigned char) (dw >>  8);

  003e6	8b 45 c4	 mov	 eax, DWORD PTR _dwBodyColor$8[ebp]
  003e9	c1 e8 08	 shr	 eax, 8
  003ec	0f b6 c0	 movzx	 eax, al
  003ef	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  003f3	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3b808081
  003fb	f3 0f 11 45 94	 movss	 DWORD PTR $T3[ebp+4], xmm0

; 890  :     b = f * (FLOAT) (unsigned char) (dw >>  0);

  00400	0f b6 45 c4	 movzx	 eax, BYTE PTR _dwBodyColor$8[ebp]
  00404	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00408	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3b808081
  00410	f3 0f 11 45 98	 movss	 DWORD PTR $T3[ebp+8], xmm0

; 891  :     a = f * (FLOAT) (unsigned char) (dw >> 24);

  00415	8b 45 c4	 mov	 eax, DWORD PTR _dwBodyColor$8[ebp]
  00418	c1 e8 18	 shr	 eax, 24			; 00000018H
  0041b	0f b6 c0	 movzx	 eax, al
  0041e	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  00422	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3b808081
  0042a	f3 0f 11 45 9c	 movss	 DWORD PTR $T3[ebp+12], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 827  : 			SetAddColor(dwBodyColor);

  0042f	8d 45 90	 lea	 eax, DWORD PTR $T3[ebp]
  00432	50		 push	 eax
  00433	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00436	e8 00 00 00 00	 call	 ?SetAddColor@CInstanceBase@@QAEXABUD3DXCOLOR@@@Z ; CInstanceBase::SetAddColor
$LN17@Create:

; 828  : 		}
; 829  : 	}
; 830  : 
; 831  : 	__AttachHorseSaddle();

  0043b	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0043e	e8 00 00 00 00	 call	 ?__AttachHorseSaddle@CInstanceBase@@IAEXXZ ; CInstanceBase::__AttachHorseSaddle

; 832  : 
; 833  : 	//     ,    
; 834  : 	const int c_iGuildSymbolRace = 14200;

  00443	c7 45 88 78 37
	00 00		 mov	 DWORD PTR _c_iGuildSymbolRace$[ebp], 14200 ; 00003778H

; 835  : 	if (c_iGuildSymbolRace == GetRace())

  0044a	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  0044d	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  00452	3d 78 37 00 00	 cmp	 eax, 14200		; 00003778H
  00457	75 52		 jne	 SHORT $LN98@Create

; 836  : 	{
; 837  : 		std::string strFileName = GetGuildSymbolFileName(m_dwGuildID);

  00459	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  0045c	ff 70 44	 push	 DWORD PTR [eax+68]
  0045f	e8 00 00 00 00	 call	 ?GetGuildSymbolFileName@@YAPBDK@Z ; GetGuildSymbolFileName
  00464	59		 pop	 ecx
  00465	50		 push	 eax
  00466	8d 4d cc	 lea	 ecx, DWORD PTR _strFileName$9[ebp]
  00469	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0046e	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 838  : 		if (IsFile(strFileName.c_str()))

  00472	8d 4d cc	 lea	 ecx, DWORD PTR _strFileName$9[ebp]
  00475	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0047a	50		 push	 eax
  0047b	e8 00 00 00 00	 call	 ?IsFile@@YA_NPBD@Z	; IsFile
  00480	59		 pop	 ecx
  00481	0f b6 c0	 movzx	 eax, al
  00484	85 c0		 test	 eax, eax
  00486	74 17		 je	 SHORT $LN19@Create

; 839  : 			m_GraphicThingInstance.ChangeMaterial(strFileName.c_str());

  00488	8d 4d cc	 lea	 ecx, DWORD PTR _strFileName$9[ebp]
  0048b	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00490	50		 push	 eax
  00491	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  00494	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0049a	e8 00 00 00 00	 call	 ?ChangeMaterial@CActorInstance@@QAEXPBD@Z ; CActorInstance::ChangeMaterial
$LN19@Create:

; 840  : 	}

  0049f	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  004a3	8d 4d cc	 lea	 ecx, DWORD PTR _strFileName$9[ebp]
  004a6	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
$LN98@Create:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 842  : 	return true;

  004ab	b0 01		 mov	 al, 1
$LN1@Create:

; 843  : }

  004ad	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004b0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004b7	59		 pop	 ecx
  004b8	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004bb	33 cd		 xor	 ecx, ebp
  004bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004c2	c9		 leave
  004c3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR _strFileName$9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?Create@CInstanceBase@@QAE_NABUSCreateData@1@@Z ENDP	; CInstanceBase::Create
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CalculateDistanceSq3d@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
_c_rkPPosSrc$ = -8					; size = 4
_this$ = -4						; size = 4
_c_rkPPosDst$ = 8					; size = 4
?CalculateDistanceSq3d@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z PROC ; CInstanceBase::CalculateDistanceSq3d, COMDAT
; _this$ = ecx

; 574  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 575  : 	const TPixelPosition& c_rkPPosSrc=m_GraphicThingInstance.NEW_GetCurPixelPositionRef();

  00008	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00011	e8 00 00 00 00	 call	 ?NEW_GetCurPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetCurPixelPositionRef
  00016	89 45 f8	 mov	 DWORD PTR _c_rkPPosSrc$[ebp], eax

; 576  : 	return SPixelPosition_CalculateDistanceSq3d(c_rkPPosSrc, c_rkPPosDst);

  00019	ff 75 08	 push	 DWORD PTR _c_rkPPosDst$[ebp]
  0001c	ff 75 f8	 push	 DWORD PTR _c_rkPPosSrc$[ebp]
  0001f	e8 00 00 00 00	 call	 ?SPixelPosition_CalculateDistanceSq3d@@YAMABUD3DXVECTOR3@@0@Z ; SPixelPosition_CalculateDistanceSq3d
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx

; 577  : }

  00026	c9		 leave
  00027	c2 04 00	 ret	 4
?CalculateDistanceSq3d@CInstanceBase@@QAEMABUD3DXVECTOR3@@@Z ENDP ; CInstanceBase::CalculateDistanceSq3d
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?DismountHorse@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?DismountHorse@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::DismountHorse, COMDAT
; _this$ = ecx

; 961  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 962  : 	m_kHorse.Destroy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ?Destroy@SHORSE@CInstanceBase@@QAEXXZ ; CInstanceBase::SHORSE::Destroy

; 963  : }

  00012	c9		 leave
  00013	c3		 ret	 0
?DismountHorse@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::DismountHorse
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?MountHorse@CInstanceBase@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_eRace$ = 8						; size = 4
?MountHorse@CInstanceBase@@QAEXI@Z PROC			; CInstanceBase::MountHorse, COMDAT
; _this$ = ecx

; 948  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 949  : 	m_kHorse.Destroy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ?Destroy@SHORSE@CInstanceBase@@QAEXXZ ; CInstanceBase::SHORSE::Destroy

; 950  : 	m_kHorse.Create(m_GraphicThingInstance.NEW_GetCurPixelPositionRef(), eRace, ms_adwCRCAffectEffect[EFFECT_HIT]);

  00012	6a 04		 push	 4
  00014	58		 pop	 eax
  00015	d1 e0		 shl	 eax, 1
  00017	ff b0 00 00 00
	00		 push	 DWORD PTR ?ms_adwCRCAffectEffect@CInstanceBase@@1PAKA[eax]
  0001d	ff 75 08	 push	 DWORD PTR _eRace$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00029	e8 00 00 00 00	 call	 ?NEW_GetCurPixelPositionRef@CActorInstance@@QAEABUD3DXVECTOR3@@XZ ; CActorInstance::NEW_GetCurPixelPositionRef
  0002e	50		 push	 eax
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 04	 add	 ecx, 4
  00035	e8 00 00 00 00	 call	 ?Create@SHORSE@CInstanceBase@@QAEXABUD3DXVECTOR3@@II@Z ; CInstanceBase::SHORSE::Create

; 951  : 
; 952  : 	SetMotionMode(CRaceMotionData::MODE_HORSE);	

  0003a	6a 09		 push	 9
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?SetMotionMode@CInstanceBase@@QAEXH@Z ; CInstanceBase::SetMotionMode

; 953  : 	SetRotationSpeed(c_fDefaultHorseRotationSpeed);

  00044	51		 push	 ecx
  00045	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43960000
  0004d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?SetRotationSpeed@CInstanceBase@@QAEXM@Z ; CInstanceBase::SetRotationSpeed

; 954  : 
; 955  : 	m_GraphicThingInstance.MountHorse(m_kHorse.GetActorPtr());

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	83 c1 04	 add	 ecx, 4
  00060	e8 00 00 00 00	 call	 ?GetActorPtr@SHORSE@CInstanceBase@@QAEPAVCActorInstance@@XZ ; CInstanceBase::SHORSE::GetActorPtr
  00065	50		 push	 eax
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0006f	e8 00 00 00 00	 call	 ?MountHorse@CActorInstance@@QAEXPAV1@@Z ; CActorInstance::MountHorse

; 956  : 	m_GraphicThingInstance.Stop();

  00074	51		 push	 ecx
  00075	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3e19999a
  0007d	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00082	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0008b	e8 00 00 00 00	 call	 ?Stop@CActorInstance@@QAEXM@Z ; CActorInstance::Stop

; 957  : 	m_GraphicThingInstance.RefreshActorInstance();

  00090	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00099	e8 00 00 00 00	 call	 ?RefreshActorInstance@CActorInstance@@QAEXXZ ; CActorInstance::RefreshActorInstance

; 958  : }

  0009e	c9		 leave
  0009f	c2 04 00	 ret	 4
?MountHorse@CInstanceBase@@QAEXI@Z ENDP			; CInstanceBase::MountHorse
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?LessRenderOrder@CInstanceBase@@QAE_NPAV1@@Z
_TEXT	SEGMENT
tv149 = -36						; size = 4
tv143 = -32						; size = 4
_uRightLODLevel$ = -28					; size = 4
_uLeftLODLevel$ = -24					; size = 4
_nTestAlpha$ = -20					; size = 4
_nMainAlpha$ = -16					; size = 4
tv71 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
_pkInst$ = 8						; size = 4
?LessRenderOrder@CInstanceBase@@QAE_NPAV1@@Z PROC	; CInstanceBase::LessRenderOrder, COMDAT
; _this$ = ecx

; 322  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 323  : 	int nMainAlpha=(__GetAlphaValue() < 1.0f) ? 1 : 0;

  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ?__GetAlphaValue@CInstanceBase@@IAEMXZ ; CInstanceBase::__GetAlphaValue
  00012	d9 5d e0	 fstp	 DWORD PTR tv143[ebp]
  00015	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  0001d	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR tv143[ebp]
  00021	76 09		 jbe	 SHORT $LN12@LessRender
  00023	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0002a	eb 04		 jmp	 SHORT $LN13@LessRender
$LN12@LessRender:
  0002c	83 65 f8 00	 and	 DWORD PTR tv67[ebp], 0
$LN13@LessRender:
  00030	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]
  00033	89 45 f0	 mov	 DWORD PTR _nMainAlpha$[ebp], eax

; 324  : 	int nTestAlpha=(pkInst->__GetAlphaValue() < 1.0f) ? 1 : 0;

  00036	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  00039	e8 00 00 00 00	 call	 ?__GetAlphaValue@CInstanceBase@@IAEMXZ ; CInstanceBase::__GetAlphaValue
  0003e	d9 5d dc	 fstp	 DWORD PTR tv149[ebp]
  00041	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00049	0f 2f 45 dc	 comiss	 xmm0, DWORD PTR tv149[ebp]
  0004d	76 09		 jbe	 SHORT $LN14@LessRender
  0004f	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00056	eb 04		 jmp	 SHORT $LN15@LessRender
$LN14@LessRender:
  00058	83 65 f4 00	 and	 DWORD PTR tv71[ebp], 0
$LN15@LessRender:
  0005c	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR _nTestAlpha$[ebp], eax

; 325  : 	if (nMainAlpha < nTestAlpha)

  00062	8b 45 f0	 mov	 eax, DWORD PTR _nMainAlpha$[ebp]
  00065	3b 45 ec	 cmp	 eax, DWORD PTR _nTestAlpha$[ebp]
  00068	7d 07		 jge	 SHORT $LN2@LessRender

; 326  : 		return true;

  0006a	b0 01		 mov	 al, 1
  0006c	e9 cd 00 00 00	 jmp	 $LN1@LessRender
$LN2@LessRender:

; 327  : 	if (nMainAlpha > nTestAlpha)

  00071	8b 45 f0	 mov	 eax, DWORD PTR _nMainAlpha$[ebp]
  00074	3b 45 ec	 cmp	 eax, DWORD PTR _nTestAlpha$[ebp]
  00077	7e 07		 jle	 SHORT $LN3@LessRender

; 328  : 		return false;

  00079	32 c0		 xor	 al, al
  0007b	e9 be 00 00 00	 jmp	 $LN1@LessRender
$LN3@LessRender:

; 329  : 
; 330  : 	if (GetRace()<pkInst->GetRace())

  00080	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  00088	8b f0		 mov	 esi, eax
  0008a	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  0008d	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  00092	3b f0		 cmp	 esi, eax
  00094	73 07		 jae	 SHORT $LN4@LessRender

; 331  : 		return true;

  00096	b0 01		 mov	 al, 1
  00098	e9 a1 00 00 00	 jmp	 $LN1@LessRender
$LN4@LessRender:

; 332  : 	if (GetRace()>pkInst->GetRace())

  0009d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a0	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  000a5	8b f0		 mov	 esi, eax
  000a7	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  000aa	e8 00 00 00 00	 call	 ?GetRace@CInstanceBase@@QAEKXZ ; CInstanceBase::GetRace
  000af	3b f0		 cmp	 esi, eax
  000b1	76 07		 jbe	 SHORT $LN5@LessRender

; 333  : 		return false;

  000b3	32 c0		 xor	 al, al
  000b5	e9 84 00 00 00	 jmp	 $LN1@LessRender
$LN5@LessRender:

; 334  : 
; 335  : 	if (GetShape()<pkInst->GetShape())

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  000c2	8b f0		 mov	 esi, eax
  000c4	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  000c7	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  000cc	3b f0		 cmp	 esi, eax
  000ce	73 04		 jae	 SHORT $LN6@LessRender

; 336  : 		return true;

  000d0	b0 01		 mov	 al, 1
  000d2	eb 6a		 jmp	 SHORT $LN1@LessRender
$LN6@LessRender:

; 337  : 
; 338  : 	if (GetShape()>pkInst->GetShape())

  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d7	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  000dc	8b f0		 mov	 esi, eax
  000de	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  000e1	e8 00 00 00 00	 call	 ?GetShape@CInstanceBase@@QAEKXZ ; CInstanceBase::GetShape
  000e6	3b f0		 cmp	 esi, eax
  000e8	76 04		 jbe	 SHORT $LN7@LessRender

; 339  : 		return false;

  000ea	32 c0		 xor	 al, al
  000ec	eb 50		 jmp	 SHORT $LN1@LessRender
$LN7@LessRender:

; 340  : 
; 341  : 	UINT uLeftLODLevel=__LessRenderOrder_GetLODLevel();

  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f1	e8 00 00 00 00	 call	 ?__LessRenderOrder_GetLODLevel@CInstanceBase@@IAEIXZ ; CInstanceBase::__LessRenderOrder_GetLODLevel
  000f6	89 45 e8	 mov	 DWORD PTR _uLeftLODLevel$[ebp], eax

; 342  : 	UINT uRightLODLevel=pkInst->__LessRenderOrder_GetLODLevel();

  000f9	8b 4d 08	 mov	 ecx, DWORD PTR _pkInst$[ebp]
  000fc	e8 00 00 00 00	 call	 ?__LessRenderOrder_GetLODLevel@CInstanceBase@@IAEIXZ ; CInstanceBase::__LessRenderOrder_GetLODLevel
  00101	89 45 e4	 mov	 DWORD PTR _uRightLODLevel$[ebp], eax

; 343  : 	if (uLeftLODLevel<uRightLODLevel)

  00104	8b 45 e8	 mov	 eax, DWORD PTR _uLeftLODLevel$[ebp]
  00107	3b 45 e4	 cmp	 eax, DWORD PTR _uRightLODLevel$[ebp]
  0010a	73 04		 jae	 SHORT $LN8@LessRender

; 344  : 		return true;

  0010c	b0 01		 mov	 al, 1
  0010e	eb 2e		 jmp	 SHORT $LN1@LessRender
$LN8@LessRender:

; 345  : 	if (uLeftLODLevel>uRightLODLevel)

  00110	8b 45 e8	 mov	 eax, DWORD PTR _uLeftLODLevel$[ebp]
  00113	3b 45 e4	 cmp	 eax, DWORD PTR _uRightLODLevel$[ebp]
  00116	76 04		 jbe	 SHORT $LN9@LessRender

; 346  : 		return false;

  00118	32 c0		 xor	 al, al
  0011a	eb 22		 jmp	 SHORT $LN1@LessRender
$LN9@LessRender:

; 347  : 
; 348  : 	if (m_awPart[CRaceData::PART_WEAPON]<pkInst->m_awPart[CRaceData::PART_WEAPON])

  0011c	6a 04		 push	 4
  0011e	58		 pop	 eax
  0011f	c1 e0 00	 shl	 eax, 0
  00122	6a 04		 push	 4
  00124	59		 pop	 ecx
  00125	c1 e1 00	 shl	 ecx, 0
  00128	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0012b	8b 75 08	 mov	 esi, DWORD PTR _pkInst$[ebp]
  0012e	8b 44 02 28	 mov	 eax, DWORD PTR [edx+eax+40]
  00132	3b 44 0e 28	 cmp	 eax, DWORD PTR [esi+ecx+40]
  00136	73 04		 jae	 SHORT $LN10@LessRender

; 349  : 		return true;

  00138	b0 01		 mov	 al, 1
  0013a	eb 02		 jmp	 SHORT $LN1@LessRender
$LN10@LessRender:

; 350  : 
; 351  : 	return false;

  0013c	32 c0		 xor	 al, al
$LN1@LessRender:

; 352  : }

  0013e	5e		 pop	 esi
  0013f	c9		 leave
  00140	c2 04 00	 ret	 4
?LessRenderOrder@CInstanceBase@@QAE_NPAV1@@Z ENDP	; CInstanceBase::LessRenderOrder
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ??1CInstanceBase@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CInstanceBase@@UAE@XZ PROC				; CInstanceBase::~CInstanceBase, COMDAT
; _this$ = ecx

; 3105 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CInstanceBase@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CInstanceBase@@6B@

; 3106 : 	Destroy();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Destroy@CInstanceBase@@QAEXXZ ; CInstanceBase::Destroy

; 3107 : }

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	81 c1 9c 06 00
	00		 add	 ecx, 1692		; 0000069cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  00040	e8 00 00 00 00	 call	 ?_Tidy@?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3107 : }

  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0004e	e8 00 00 00 00	 call	 ?_Tidy@?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@AAEXXZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3107 : }

  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0005c	e8 00 00 00 00	 call	 ??1CActorInstance@@UAE@XZ ; CActorInstance::~CActorInstance
  00061	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  0006a	e8 00 00 00 00	 call	 ??1?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	83 c1 48	 add	 ecx, 72			; 00000048H
  00075	e8 00 00 00 00	 call	 ??1CAffectFlagContainer@@QAE@XZ ; CAffectFlagContainer::~CAffectFlagContainer
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	83 c1 10	 add	 ecx, 16			; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00080	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3107 : }

  00085	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	83 c1 04	 add	 ecx, 4
  0008b	e8 00 00 00 00	 call	 ??1SHORSE@CInstanceBase@@QAE@XZ ; CInstanceBase::SHORSE::~SHORSE
  00090	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009a	59		 pop	 ecx
  0009b	c9		 leave
  0009c	c3		 ret	 0
  0009d	cc		 int	 3
  0009e	cc		 int	 3
  0009f	cc		 int	 3
  000a0	cc		 int	 3
  000a1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CInstanceBase@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CInstanceBase@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CInstanceBase@@UAE@XZ ENDP				; CInstanceBase::~CInstanceBase
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ??0CInstanceBase@@QAE@XZ
_TEXT	SEGMENT
_this$ = -36						; size = 4
_this$ = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0CInstanceBase@@QAE@XZ PROC				; CInstanceBase::CInstanceBase, COMDAT
; _this$ = ecx

; 3100 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CInstanceBase@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CInstanceBase@@6B@
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 04	 add	 ecx, 4
  00037	e8 00 00 00 00	 call	 ??0SHORSE@CInstanceBase@@QAE@XZ ; CInstanceBase::SHORSE::SHORSE
  0003c	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00040	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00043	83 c0 10	 add	 eax, 16			; 00000010H
  00046	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00049	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0004f	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2367 :         _Tidy_init();

  00057	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3100 : {

  0005f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	83 c1 48	 add	 ecx, 72			; 00000048H
  00069	e8 00 00 00 00	 call	 ??0CAffectFlagContainer@@QAE@XZ ; CAffectFlagContainer::CAffectFlagContainer
  0006e	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00072	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00075	05 50 01 00 00	 add	 eax, 336		; 00000150H
  0007a	89 45 e0	 mov	 DWORD PTR _this$[ebp], eax
  0007d	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	89 45 dc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\map

; 107  :     map() : _Mybase(key_compare()) {}

  00083	8d 45 f3	 lea	 eax, DWORD PTR $T2[ebp]
  00086	50		 push	 eax
  00087	8b 4d dc	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ??0?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 3100 : {

  0008f	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00093	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  0009c	e8 00 00 00 00	 call	 ??0CActorInstance@@QAE@XZ ; CActorInstance::CActorInstance
  000a1	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  000a5	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  000ae	e8 00 00 00 00	 call	 ??0?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >
  000b3	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  000b7	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ba	81 c1 9c 06 00
	00		 add	 ecx, 1692		; 0000069cH
  000c0	e8 00 00 00 00	 call	 ??0?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >
  000c5	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 3101 : 	__Initialize();

  000c9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cc	e8 00 00 00 00	 call	 ?__Initialize@CInstanceBase@@IAEXXZ ; CInstanceBase::__Initialize

; 3102 : }

  000d1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  000d5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000db	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e2	59		 pop	 ecx
  000e3	c9		 leave
  000e4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CInstanceBase@@QAE@XZ$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1SHORSE@CInstanceBase@@QAE@XZ ; CInstanceBase::SHORSE::~SHORSE
__unwindfunclet$??0CInstanceBase@@QAE@XZ$1:
  0000b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	83 c1 10	 add	 ecx, 16			; 00000010H
  00011	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CInstanceBase@@QAE@XZ$2:
  00016	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	83 c1 48	 add	 ecx, 72			; 00000048H
  0001c	e9 00 00 00 00	 jmp	 ??1CAffectFlagContainer@@QAE@XZ ; CAffectFlagContainer::~CAffectFlagContainer
__unwindfunclet$??0CInstanceBase@@QAE@XZ$3:
  00021	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 50 01 00
	00		 add	 ecx, 336		; 00000150H
  0002a	e9 00 00 00 00	 jmp	 ??1SEffectContainer@CInstanceBase@@QAE@XZ
__unwindfunclet$??0CInstanceBase@@QAE@XZ$4:
  0002f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00038	e9 00 00 00 00	 jmp	 ??1CActorInstance@@UAE@XZ ; CActorInstance::~CActorInstance
__unwindfunclet$??0CInstanceBase@@QAE@XZ$5:
  0003d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	81 c1 90 06 00
	00		 add	 ecx, 1680		; 00000690H
  00046	e9 00 00 00 00	 jmp	 ??1?$list@USCommand@CInstanceBase@@V?$allocator@USCommand@CInstanceBase@@@std@@@std@@QAE@XZ ; std::list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >::~list<CInstanceBase::SCommand,std::allocator<CInstanceBase::SCommand> >
__unwindfunclet$??0CInstanceBase@@QAE@XZ$6:
  0004b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	81 c1 9c 06 00
	00		 add	 ecx, 1692		; 0000069cH
  00054	e9 00 00 00 00	 jmp	 ??1?$list@USEffectDamage@CInstanceBase@@V?$allocator@USEffectDamage@CInstanceBase@@@std@@@std@@QAE@XZ ; std::list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >::~list<CInstanceBase::SEffectDamage,std::allocator<CInstanceBase::SEffectDamage> >
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
__ehhandler$??0CInstanceBase@@QAE@XZ:
  0005e	90		 npad	 1
  0005f	90		 npad	 1
  00060	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00064	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00067	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0006a	33 c8		 xor	 ecx, eax
  0006c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00071	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CInstanceBase@@QAE@XZ
  00076	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CInstanceBase@@QAE@XZ ENDP				; CInstanceBase::CInstanceBase
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__GetBowRange@CInstanceBase@@IAEMXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_rPlayer$1 = -8						; size = 4
_fRange$ = -4						; size = 4
?__GetBowRange@CInstanceBase@@IAEMXZ PROC		; CInstanceBase::__GetBowRange, COMDAT
; _this$ = ecx

; 694  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 695  : 	float fRange = 2500.0f - 100.0f;

  00009	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@45160000
  00011	f3 0f 11 45 fc	 movss	 DWORD PTR _fRange$[ebp], xmm0

; 696  : 
; 697  : 	if (__IsMainInstance())

  00016	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?__IsMainInstance@CInstanceBase@@IAE_NXZ ; CInstanceBase::__IsMainInstance
  0001e	0f b6 c0	 movzx	 eax, al
  00021	85 c0		 test	 eax, eax
  00023	74 23		 je	 SHORT $LN2@GetBowRang

; 698  : 	{
; 699  : 		IAbstractPlayer& rPlayer=IAbstractPlayer::GetSingleton();

  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$TAbstractSingleton@VIAbstractPlayer@@@@0PAVIAbstractPlayer@@A ; TAbstractSingleton<IAbstractPlayer>::ms_singleton
  0002a	89 45 f8	 mov	 DWORD PTR _rPlayer$1[ebp], eax

; 700  : 		fRange += float(rPlayer.GetStatus(POINT_BOW_DISTANCE));

  0002d	6a 22		 push	 34			; 00000022H
  0002f	8b 45 f8	 mov	 eax, DWORD PTR _rPlayer$1[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	8b 4d f8	 mov	 ecx, DWORD PTR _rPlayer$1[ebp]
  00037	ff 50 10	 call	 DWORD PTR [eax+16]
  0003a	f3 0f 2a c0	 cvtsi2ss xmm0, eax
  0003e	f3 0f 58 45 fc	 addss	 xmm0, DWORD PTR _fRange$[ebp]
  00043	f3 0f 11 45 fc	 movss	 DWORD PTR _fRange$[ebp], xmm0
$LN2@GetBowRang:

; 701  : 	}
; 702  : 
; 703  : 	return fRange;

  00048	d9 45 fc	 fld	 DWORD PTR _fRange$[ebp]

; 704  : }

  0004b	c9		 leave
  0004c	c3		 ret	 0
?__GetBowRange@CInstanceBase@@IAEMXZ ENDP		; CInstanceBase::__GetBowRange
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__MainCanSeeHiddenThing@CInstanceBase@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__MainCanSeeHiddenThing@CInstanceBase@@IAE_NXZ PROC	; CInstanceBase::__MainCanSeeHiddenThing, COMDAT
; _this$ = ecx

; 687  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 688  : 	return false;

  00007	32 c0		 xor	 al, al

; 689  : //	CInstanceBase * pInstance = __GetMainInstancePtr();
; 690  : //	return pInstance->IsAffect(AFFECT_GAMJI);
; 691  : }

  00009	c9		 leave
  0000a	c3		 ret	 0
?__MainCanSeeHiddenThing@CInstanceBase@@IAE_NXZ ENDP	; CInstanceBase::__MainCanSeeHiddenThing
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__IsMainInstance@CInstanceBase@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__IsMainInstance@CInstanceBase@@IAE_NXZ PROC		; CInstanceBase::__IsMainInstance, COMDAT
; _this$ = ecx

; 671  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 672  : 	if (this==__GetMainInstancePtr())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__GetMainInstancePtr@CInstanceBase@@IAEPAV1@XZ ; CInstanceBase::__GetMainInstancePtr
  0000f	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  00012	75 04		 jne	 SHORT $LN2@IsMainInst

; 673  : 		return true;

  00014	b0 01		 mov	 al, 1
  00016	eb 02		 jmp	 SHORT $LN1@IsMainInst
$LN2@IsMainInst:

; 674  : 
; 675  : 	return false;

  00018	32 c0		 xor	 al, al
$LN1@IsMainInst:

; 676  : }

  0001a	c9		 leave
  0001b	c3		 ret	 0
?__IsMainInstance@CInstanceBase@@IAE_NXZ ENDP		; CInstanceBase::__IsMainInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__IsExistMainInstance@CInstanceBase@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__IsExistMainInstance@CInstanceBase@@IAE_NXZ PROC	; CInstanceBase::__IsExistMainInstance, COMDAT
; _this$ = ecx

; 679  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 680  : 	if(__GetMainInstancePtr())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__GetMainInstancePtr@CInstanceBase@@IAEPAV1@XZ ; CInstanceBase::__GetMainInstancePtr
  0000f	85 c0		 test	 eax, eax
  00011	74 06		 je	 SHORT $LN2@IsExistMai

; 681  : 		return true;

  00013	b0 01		 mov	 al, 1
  00015	eb 04		 jmp	 SHORT $LN1@IsExistMai
  00017	eb 02		 jmp	 SHORT $LN1@IsExistMai
$LN2@IsExistMai:

; 682  : 	else
; 683  : 		return false;

  00019	32 c0		 xor	 al, al
$LN1@IsExistMai:

; 684  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?__IsExistMainInstance@CInstanceBase@@IAE_NXZ ENDP	; CInstanceBase::__IsExistMainInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?OnUntargeted@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnUntargeted@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::OnUntargeted, COMDAT
; _this$ = ecx

; 617  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 618  : 	__DetachTargetEffect();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__DetachTargetEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__DetachTargetEffect

; 619  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?OnUntargeted@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::OnUntargeted
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?OnTargeted@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnTargeted@CInstanceBase@@QAEXXZ PROC			; CInstanceBase::OnTargeted, COMDAT
; _this$ = ecx

; 601  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 602  : #ifdef __MOVIE_MODE__
; 603  : 	if (!__IsExistMainInstance())
; 604  : 		return;
; 605  : #endif
; 606  : 
; 607  : 	if (IsStoneDoor())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsStoneDoor@CInstanceBase@@QAEHXZ ; CInstanceBase::IsStoneDoor
  0000f	85 c0		 test	 eax, eax
  00011	74 02		 je	 SHORT $LN2@OnTargeted

; 608  : 		return;

  00013	eb 16		 jmp	 SHORT $LN1@OnTargeted
$LN2@OnTargeted:

; 609  : 
; 610  : 	if (IsDead())

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?IsDead@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDead
  0001d	85 c0		 test	 eax, eax
  0001f	74 02		 je	 SHORT $LN3@OnTargeted

; 611  : 		return;

  00021	eb 08		 jmp	 SHORT $LN1@OnTargeted
$LN3@OnTargeted:

; 612  : 
; 613  : 	__AttachTargetEffect();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?__AttachTargetEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__AttachTargetEffect
$LN1@OnTargeted:

; 614  : }

  0002b	c9		 leave
  0002c	c3		 ret	 0
?OnTargeted@CInstanceBase@@QAEXXZ ENDP			; CInstanceBase::OnTargeted
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?OnUnselected@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnUnselected@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::OnUnselected, COMDAT
; _this$ = ecx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 597  : 	__DetachSelectEffect();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__DetachSelectEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__DetachSelectEffect

; 598  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?OnUnselected@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::OnUnselected
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?OnSelected@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnSelected@CInstanceBase@@QAEXXZ PROC			; CInstanceBase::OnSelected, COMDAT
; _this$ = ecx

; 580  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 581  : #ifdef __MOVIE_MODE__
; 582  : 	if (!__IsExistMainInstance())
; 583  : 		return;
; 584  : #endif
; 585  : 
; 586  : 	if (IsStoneDoor())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?IsStoneDoor@CInstanceBase@@QAEHXZ ; CInstanceBase::IsStoneDoor
  0000f	85 c0		 test	 eax, eax
  00011	74 02		 je	 SHORT $LN2@OnSelected

; 587  : 		return;

  00013	eb 16		 jmp	 SHORT $LN1@OnSelected
$LN2@OnSelected:

; 588  : 
; 589  : 	if (IsDead())

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?IsDead@CInstanceBase@@QAEHXZ ; CInstanceBase::IsDead
  0001d	85 c0		 test	 eax, eax
  0001f	74 02		 je	 SHORT $LN3@OnSelected

; 590  : 		return;

  00021	eb 08		 jmp	 SHORT $LN1@OnSelected
$LN3@OnSelected:

; 591  : 
; 592  : 	__AttachSelectEffect();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?__AttachSelectEffect@CInstanceBase@@IAEXXZ ; CInstanceBase::__AttachSelectEffect
$LN1@OnSelected:

; 593  : }

  0002b	c9		 leave
  0002c	c3		 ret	 0
?OnSelected@CInstanceBase@@QAEXXZ ENDP			; CInstanceBase::OnSelected
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?SetMainInstance@CInstanceBase@@QAEXXZ
_TEXT	SEGMENT
_rkChrMgr$ = -12					; size = 4
_dwVID$ = -8						; size = 4
_this$ = -4						; size = 4
?SetMainInstance@CInstanceBase@@QAEXXZ PROC		; CInstanceBase::SetMainInstance, COMDAT
; _this$ = ecx

; 648  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 649  : 	CPythonCharacterManager& rkChrMgr=CPythonCharacterManager::Instance();

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonCharacterManager@@@@0PAVCPythonCharacterManager@@A ; CSingleton<CPythonCharacterManager>::ms_singleton
  0000e	89 45 f4	 mov	 DWORD PTR _rkChrMgr$[ebp], eax

; 650  : 
; 651  : 	DWORD dwVID=GetVirtualID();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?GetVirtualID@CInstanceBase@@QAEKXZ ; CInstanceBase::GetVirtualID
  00019	89 45 f8	 mov	 DWORD PTR _dwVID$[ebp], eax

; 652  : 	rkChrMgr.SetMainInstance(dwVID);

  0001c	ff 75 f8	 push	 DWORD PTR _dwVID$[ebp]
  0001f	8b 4d f4	 mov	 ecx, DWORD PTR _rkChrMgr$[ebp]
  00022	e8 00 00 00 00	 call	 ?SetMainInstance@CPythonCharacterManager@@QAE_NK@Z ; CPythonCharacterManager::SetMainInstance

; 653  : 
; 654  : 	m_GraphicThingInstance.SetMainInstance();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	81 c1 d4 01 00
	00		 add	 ecx, 468		; 000001d4H
  00030	e8 00 00 00 00	 call	 ?SetMainInstance@CActorInstance@@QAEXXZ ; CActorInstance::SetMainInstance

; 655  : }

  00035	c9		 leave
  00036	c3		 ret	 0
?SetMainInstance@CInstanceBase@@QAEXXZ ENDP		; CInstanceBase::SetMainInstance
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?CreateSystem@CInstanceBase@@SAXI@Z
_TEXT	SEGMENT
_uCapacity$ = 8						; size = 4
?CreateSystem@CInstanceBase@@SAXI@Z PROC		; CInstanceBase::CreateSystem, COMDAT

; 627  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 57   : 			m_uInitCapacity=uCapacity;

  00003	8b 45 08	 mov	 eax, DWORD PTR _uCapacity$[ebp]
  00006	a3 1c 00 00 00	 mov	 DWORD PTR ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A+28, eax

; 58   : 			m_kVct_pkData.reserve(uCapacity);

  0000b	ff 75 08	 push	 DWORD PTR _uCapacity$[ebp]
  0000e	b9 04 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A+4
  00013	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXI@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::reserve

; 59   : 			m_kVct_pkFree.reserve(uCapacity);

  00018	ff 75 08	 push	 DWORD PTR _uCapacity$[ebp]
  0001b	b9 10 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A+16
  00020	e8 00 00 00 00	 call	 ?reserve@?$vector@PAVCInstanceBase@@V?$allocator@PAVCInstanceBase@@@std@@@std@@QAEXI@Z ; std::vector<CInstanceBase *,std::allocator<CInstanceBase *> >::reserve
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 630  : 	memset(ms_adwCRCAffectEffect, 0, sizeof(ms_adwCRCAffectEffect));

  00025	68 48 04 00 00	 push	 1096			; 00000448H
  0002a	6a 00		 push	 0
  0002c	68 00 00 00 00	 push	 OFFSET ?ms_adwCRCAffectEffect@CInstanceBase@@1PAKA ; CInstanceBase::ms_adwCRCAffectEffect
  00031	e8 00 00 00 00	 call	 _memset
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 631  : 
; 632  : 	ms_fDustGap=250.0f;

  00039	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@437a0000
  00041	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?ms_fDustGap@CInstanceBase@@1MA, xmm0

; 633  : 	ms_fHorseDustGap=500.0f;

  00049	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@43fa0000
  00051	f3 0f 11 05 00
	00 00 00	 movss	 DWORD PTR ?ms_fHorseDustGap@CInstanceBase@@1MA, xmm0

; 634  : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?CreateSystem@CInstanceBase@@SAXI@Z ENDP		; CInstanceBase::CreateSystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?DestroySystem@CInstanceBase@@SAXXZ
_TEXT	SEGMENT
?DestroySystem@CInstanceBase@@SAXXZ PROC		; CInstanceBase::DestroySystem, COMDAT

; 622  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\Pool.h

; 34   : 			Destroy();

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?ms_kPool@CInstanceBase@@2V?$CDynamicPool@VCInstanceBase@@@@A ; CInstanceBase::ms_kPool
  00008	e8 00 00 00 00	 call	 ?Destroy@?$CDynamicPool@VCInstanceBase@@@@QAEXXZ ; CDynamicPool<CInstanceBase>::Destroy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp

; 624  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?DestroySystem@CInstanceBase@@SAXXZ ENDP		; CInstanceBase::DestroySystem
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -28					; size = 4
__Scary$ = -24						; size = 4
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
_$S15$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 2017 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f4	 mov	 eax, DWORD PTR $T3[ebp]
  00012	89 45 e8	 mov	 DWORD PTR __Scary$[ebp], eax

; 2018 :         const auto _Scary = _Get_scary();
; 2019 :         auto&& _Alproxy   = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00015	8d 45 ff	 lea	 eax, DWORD PTR _$S15$[ebp]
  00018	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0001e	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  00021	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00024	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax

; 2020 :         _Container_proxy_ptr<_Alnode> _Proxy(_Alproxy, *_Scary);
; 2021 :         _Scary->_Myhead = _Node::_Buyheadnode(_Getal());

  00027	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  0002a	e8 00 00 00 00	 call	 ??$_Buyheadnode@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAPAU01@AAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@@Z ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Buyheadnode<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
  0002f	59		 pop	 ecx
  00030	8b 4d e8	 mov	 ecx, DWORD PTR __Scary$[ebp]
  00033	89 01		 mov	 DWORD PTR [ecx], eax

; 2022 :         _Proxy._Release();
; 2023 :     }

  00035	c9		 leave
  00036	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Scary$ = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >, COMDAT
; _this$ = ecx

; 1189 :     ~_Tree() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0000c	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2047 :         return _STD addressof(_Mypair._Myval2._Myval2);

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Scary$[ebp], eax

; 2039 :         return _Mypair._Myval2._Get_first();

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00018	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 2039 :         return _Mypair._Myval2._Get_first();

  0001b	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  0001e	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 752  :         _Erase_tree(_Al, _Myhead->_Parent);

  00021	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	ff 70 04	 push	 DWORD PTR [eax+4]
  00029	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR __Scary$[ebp]
  0002f	e8 00 00 00 00	 call	 ??$_Erase_tree@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBKK@std@@@std@@@std@@QAEXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU?$_Tree_node@U?$pair@$$CBKK@std@@PAX@1@@Z ; std::_Tree_val<std::_Tree_simple_types<std::pair<unsigned long const ,unsigned long> > >::_Erase_tree<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >

; 753  :         _Alnode::value_type::_Freenode0(_Al, _Myhead);

  00034	8b 45 fc	 mov	 eax, DWORD PTR __Scary$[ebp]
  00037	ff 30		 push	 DWORD PTR [eax]
  00039	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@std@@@?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@SAXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBKK@std@@PAX@std@@@1@PAU01@@Z ; std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *>::_Freenode0<std::allocator<std::_Tree_node<std::pair<unsigned long const ,unsigned long>,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 1190 :         const auto _Scary = _Get_scary();
; 1191 :         _Scary->_Erase_head(_Getal());
; 1192 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1193 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1194 :         _Delete_plain_internal(_Alproxy, _Scary->_Myproxy);
; 1195 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1196 :     }

  00043	c9		 leave
  00044	c3		 ret	 0
??1?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::~_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z
_TEXT	SEGMENT
_this$ = -28						; size = 4
_this$ = -24						; size = 4
$T1 = -20						; size = 4
_this$2 = -16						; size = 4
_this$ = -12						; size = 4
___formal$ = -8						; size = 1
$T3 = -1						; size = 1
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z PROC ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >, COMDAT
; _this$ = ecx

; 885  :     _Tree(const key_compare& _Parg) : _Mypair(_One_then_variadic_args_t{}, _Parg, _Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0000f	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00012	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1344 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00015	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00018	8a 00		 mov	 al, BYTE PTR [eax]
  0001a	88 45 f8	 mov	 BYTE PTR ___formal$[ebp], al
  0001d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00020	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00023	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00026	89 45 f0	 mov	 DWORD PTR _this$2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xtree

; 435  :     _Tree_val() noexcept : _Myhead(), _Mysize(0) {}

  00029	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  0002c	83 20 00	 and	 DWORD PTR [eax], 0
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$2[ebp]
  00032	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 886  :         _Alloc_sentinel_and_proxy();

  00036	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Alloc_sentinel_and_proxy

; 887  :     }

  0003e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c9		 leave
  00042	c2 04 00	 ret	 4
??0?$_Tree@V?$_Tmap_traits@KKU?$less@K@std@@V?$allocator@U?$pair@$$CBKK@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@K@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >::_Tree<std::_Tmap_traits<unsigned long,unsigned long,std::less<unsigned long>,std::allocator<std::pair<unsigned long const ,unsigned long> >,0> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Al$ = -64						; size = 4
__First1$ = -60						; size = 4
__First1$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 65		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000bd	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c0	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  000c3	89 45 c8	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c6	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  000c9	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000cc	ff 75 c8	 push	 DWORD PTR __First1$[ebp]
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d7	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000db	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000de	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e4	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e7	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000ea	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ed	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000ee	50		 push	 eax
  000ef	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000f2	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f7	59		 pop	 ecx
  000f8	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f9	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000fc	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ff	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  00101	eb 4c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00103	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00106	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00109	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  0010c	e8 00 00 00 00	 call	 _memcpy
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00114	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  00117	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]
  0011a	89 45 c4	 mov	 DWORD PTR __First1$[ebp], eax

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0011d	ff 75 14	 push	 DWORD PTR _<_Args_1>$[ebp]
  00120	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00123	ff 75 c4	 push	 DWORD PTR __First1$[ebp]
  00126	e8 00 00 00 00	 call	 _memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0012e	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  00132	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00135	03 45 14	 add	 eax, DWORD PTR _<_Args_1>$[ebp]

; 428  :         _Left = _Right;

  00138	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  0013b	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  0013e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00141	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00144	50		 push	 eax
  00145	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00148	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0014d	59		 pop	 ecx
  0014e	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  0014f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  00152	c9		 leave
  00153	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
__Al$ = -56						; size = 4
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
$T2 = -44						; size = 4
__Old_ptr$3 = -40					; size = 4
__Old_capacity$ = -36					; size = 4
__New_capacity$ = -32					; size = 4
__New_size$ = -28					; size = 4
__New_ptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Raw_new$ = -16					; size = 4
__My_data$ = -12					; size = 4
__Old_size$ = -8					; size = 4
__Overflow_is_possible$4 = -3				; size = 1
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 4328 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4329 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4330 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4331 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 4332 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00015	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4333 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4334 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4335 :         }
; 4336 : 
; 4337 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 e4	 mov	 DWORD PTR __New_size$[ebp], eax

; 4338 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0003c	89 45 dc	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  0003f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	50		 push	 eax
  00048	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	ff 70 14	 push	 DWORD PTR [eax+20]
  0004e	ff 75 e4	 push	 DWORD PTR __New_size$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 e0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  0005c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00062	8b 45 d4	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 c8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00068	c6 45 fd 00	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006c	8b 45 e0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0006f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00070	50		 push	 eax
  00071	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00076	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4341 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00077	89 45 e8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4342 :         _My_data._Orphan_all();
; 4343 :         _My_data._Mysize      = _New_size;

  0007a	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	8b 4d e4	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00080	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4344 :         _My_data._Myres       = _New_capacity;

  00083	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00086	8b 4d e0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00089	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4345 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  0008c	8b 45 e8	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0008f	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00092	8b 45 d0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR __Raw_new$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4346 :         if (_BUF_SIZE <= _Old_capacity) {

  00098	83 7d dc 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  0009c	72 62		 jb	 SHORT $LN3@Reallocate

; 4347 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009e	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a1	8b 00		 mov	 eax, DWORD PTR [eax]
  000a3	89 45 d8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  000a6	8b 45 d8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  000a9	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000ac	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  000af	ff 75 cc	 push	 DWORD PTR $T1[ebp]
  000b2	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 424  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000bd	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  000c0	0f be 45 14	 movsx	 eax, BYTE PTR _<_Args_1>$[ebp]
  000c4	50		 push	 eax

; 2976 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  000c5	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c8	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]

; 424  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 _memset
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2977 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  000d4	c6 45 ff 00	 mov	 BYTE PTR $T6[ebp], 0
  000d8	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000db	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]

; 428  :         _Left = _Right;

  000de	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000e1	8a 55 ff	 mov	 dl, BYTE PTR $T6[ebp]
  000e4	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4348 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 4349 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000e7	8b 45 dc	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000ea	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000eb	50		 push	 eax
  000ec	ff 75 d8	 push	 DWORD PTR __Old_ptr$3[ebp]
  000ef	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000f4	59		 pop	 ecx
  000f5	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4350 :             _My_data._Bx._Ptr = _New_ptr;

  000f6	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f9	8b 4d e8	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000fc	89 08		 mov	 DWORD PTR [eax], ecx

; 4351 :         } else {

  000fe	eb 49		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00100	ff 75 f8	 push	 DWORD PTR __Old_size$[ebp]
  00103	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00106	ff 75 f0	 push	 DWORD PTR __Raw_new$[ebp]
  00109	e8 00 00 00 00	 call	 _memcpy
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 424  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00111	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00114	0f be 45 14	 movsx	 eax, BYTE PTR _<_Args_1>$[ebp]
  00118	50		 push	 eax

; 2976 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  00119	8b 45 f0	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  0011c	03 45 f8	 add	 eax, DWORD PTR __Old_size$[ebp]

; 424  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 _memset
  00125	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2977 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00128	c6 45 fe 00	 mov	 BYTE PTR $T5[ebp], 0
  0012c	8b 45 f8	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0012f	03 45 10	 add	 eax, DWORD PTR _<_Args_0>$[ebp]

; 428  :         _Left = _Right;

  00132	8b 4d f0	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  00135	8a 55 fe	 mov	 dl, BYTE PTR $T5[ebp]
  00138	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4352 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 4353 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0013b	8d 45 e8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  0013e	50		 push	 eax
  0013f	ff 75 f4	 push	 DWORD PTR __My_data$[ebp]
  00142	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00147	59		 pop	 ecx
  00148	59		 pop	 ecx
$LN4@Reallocate:

; 4354 :         }
; 4355 : 
; 4356 :         return *this;

  00149	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4357 :     }

  0014c	c9		 leave
  0014d	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gameLib\Interface.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??_GIBackground@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GIBackground@@UAEPAXI@Z PROC				; IBackground::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\gameLib\Interface.h

; 8    : 		virtual ~IBackground() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7IBackground@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 19   : 	{ 

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VIBackground@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00019	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VIBackground@@@@0PAVIBackground@@A, 0 ; CSingleton<IBackground>::ms_singleton
  00020	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00023	83 e0 01	 and	 eax, 1
  00026	74 0c		 je	 SHORT $LN2@scalar
  00028	6a 04		 push	 4
  0002a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN2@scalar:
  00034	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00037	c9		 leave
  00038	c2 04 00	 ret	 4
??_GIBackground@@UAEPAXI@Z ENDP				; IBackground::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VIBackground@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CSingleton@VIBackground@@@@UAEPAXI@Z PROC		; CSingleton<IBackground>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	{ 

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VIBackground@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VIBackground@@@@0PAVIBackground@@A, 0 ; CSingleton<IBackground>::ms_singleton
  00017	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	74 0c		 je	 SHORT $LN2@scalar
  0001f	6a 04		 push	 4
  00021	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
$LN2@scalar:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
??_G?$CSingleton@VIBackground@@@@UAEPAXI@Z ENDP		; CSingleton<IBackground>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
__Left$ = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 4372 :     void _Eos(const size_type _Newsize) { // set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4373 :         _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());

  00009	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0000d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR __Newsize$[ebp]
  00013	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001e	03 45 08	 add	 eax, DWORD PTR __Newsize$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR __Left$[ebp], eax

; 428  :         _Left = _Right;

  00024	8b 45 f4	 mov	 eax, DWORD PTR __Left$[ebp]
  00027	8a 4d ff	 mov	 cl, BYTE PTR $T1[ebp]
  0002a	88 08		 mov	 BYTE PTR [eax], cl

; 4374 :     }

  0002c	c9		 leave
  0002d	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
tv75 = -12						; size = 4
$T3 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4284 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  00012	3b 45 10	 cmp	 eax, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4287 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 46		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  0001f	d1 e8		 shr	 eax, 1
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Max$[ebp]
  00024	2b c8		 sub	 ecx, eax
  00026	39 4d 0c	 cmp	 DWORD PTR __Old$[ebp], ecx
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4291 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 32		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 45 0c	 mov	 eax, DWORD PTR __Old$[ebp]
  00033	d1 e8		 shr	 eax, 1
  00035	03 45 0c	 add	 eax, DWORD PTR __Old$[ebp]
  00038	89 45 f8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Masked$[ebp]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR $T3[ebp]
  00041	73 08		 jae	 SHORT $LN7@Calculate_
  00043	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00046	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00049	eb 06		 jmp	 SHORT $LN8@Calculate_
$LN7@Calculate_:
  0004b	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  0004e	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
$LN8@Calculate_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00054	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
  00057	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0005a	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0005d	8b 45 ec	 mov	 eax, DWORD PTR $T1[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4295 :     }

  00062	c9		 leave
  00063	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z
_TEXT	SEGMENT
$T1 = -36						; size = 1
$T2 = -32						; size = 4
$T3 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$4 = -16					; size = 4
tv129 = -12						; size = 4
_this$ = -8						; size = 4
$T5 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_of, COMDAT
; _this$ = ecx

; 4036 :     /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 4037 :         // look for one of [_Ptr, <null>) at or after _Off
; 4038 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __Result$4[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00028	72 09		 jb	 SHORT $LN12@find_first
  0002a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv129[ebp], 1
  00031	eb 04		 jmp	 SHORT $LN13@find_first
$LN12@find_first:
  00033	83 65 f4 00	 and	 DWORD PTR tv129[ebp], 0
$LN13@find_first:
  00037	8a 45 f4	 mov	 al, BYTE PTR tv129[ebp]
  0003a	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0003d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00041	85 c0		 test	 eax, eax
  00043	74 0e		 je	 SHORT $LN7@find_first

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004d	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR __Result$4[ebp], eax
$LN7@find_first:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Result$4[ebp]
  00056	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax

; 4037 :         // look for one of [_Ptr, <null>) at or after _Off
; 4038 :         return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,

  00059	ff 75 dc	 push	 DWORD PTR $T1[ebp]
  0005c	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0005f	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00062	ff 75 0c	 push	 DWORD PTR __Off$[ebp]
  00065	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00068	ff 70 10	 push	 DWORD PTR [eax+16]
  0006b	ff 75 e0	 push	 DWORD PTR $T2[ebp]
  0006e	e8 00 00 00 00	 call	 ??$_Traits_find_first_of@U?$char_traits@D@std@@@std@@YAIQBDII0IU?$integral_constant@_N$00@0@@Z ; std::_Traits_find_first_of<std::char_traits<char> >
  00073	83 c4 18	 add	 esp, 24			; 00000018H

; 4039 :             _Off, _Ptr, _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
; 4040 :     }

  00076	c9		 leave
  00077	c2 08 00	 ret	 8
?find_first_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_first_of
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__Newsize$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 3782 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3770 :         return _Mypair._Myval2._Mysize;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000e	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 3783 :         // determine new length, padding with _Ch elements as needed
; 3784 :         const size_type _Old_size = size();
; 3785 :         if (_Newsize <= _Old_size) {

  00011	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00014	3b 45 f8	 cmp	 eax, DWORD PTR __Old_size$[ebp]
  00017	77 0d		 ja	 SHORT $LN2@resize

; 3786 :             _Eos(_Newsize);

  00019	ff 75 08	 push	 DWORD PTR __Newsize$[ebp]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 3787 :         } else {

  00024	eb 12		 jmp	 SHORT $LN1@resize
$LN2@resize:

; 3788 :             append(_Newsize - _Old_size, _Ch);

  00026	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  00029	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0002c	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0002f	50		 push	 eax
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN1@resize:

; 3789 :         }
; 3790 :     }

  00038	c9		 leave
  00039	c2 08 00	 ret	 8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
$T1 = -20						; size = 1
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2961 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2962 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2963 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 08	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 46		 ja	 SHORT $LN2@append

; 2964 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2965 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 424  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00037	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  0003a	0f be 45 0c	 movsx	 eax, BYTE PTR __Ch$[ebp]
  0003e	50		 push	 eax

; 2966 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  0003f	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00042	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]

; 424  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 _memset
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2967 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0004e	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00052	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00055	03 45 08	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  00058	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005b	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  0005e	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2968 :             return *this;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2969 :         }
; 2970 : 
; 2971 :         return _Reallocate_grow_by(

  00066	33 c0		 xor	 eax, eax
  00068	88 45 ec	 mov	 BYTE PTR $T1[ebp], al
  0006b	ff 75 0c	 push	 DWORD PTR __Ch$[ebp]
  0006e	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00074	ff 75 08	 push	 DWORD PTR __Count$[ebp]
  00077	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN1@append:

; 2972 :             _Count,
; 2973 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2974 :                 const _Elem _Ch) {
; 2975 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2976 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2977 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2978 :             },
; 2979 :             _Count, _Ch);
; 2980 :     }

  0007f	c9		 leave
  00080	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -24						; size = 1
__First1$ = -20						; size = 4
__Old_ptr$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 2935 :     basic_string& append(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2936 :         // append [_Ptr, _Ptr + _Count)
; 2937 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0000f	89 45 f4	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2938 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 49		 ja	 SHORT $LN2@append

; 2939 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00023	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 2940 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 2941 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  0003a	03 45 f4	 add	 eax, DWORD PTR __Old_size$[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR __First1$[ebp], eax

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00040	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00043	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00046	ff 75 ec	 push	 DWORD PTR __First1$[ebp]
  00049	e8 00 00 00 00	 call	 _memmove
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2942 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00055	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00058	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]

; 428  :         _Left = _Right;

  0005b	8b 4d f0	 mov	 ecx, DWORD PTR __Old_ptr$2[ebp]
  0005e	8a 55 ff	 mov	 dl, BYTE PTR $T3[ebp]
  00061	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 2943 :             return *this;

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	eb 19		 jmp	 SHORT $LN1@append
$LN2@append:

; 2944 :         }
; 2945 : 
; 2946 :         return _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 e8	 mov	 BYTE PTR $T1[ebp], al
  0006e	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  00071	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00074	ff 75 e8	 push	 DWORD PTR $T1[ebp]
  00077	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 2947 :             _Count,
; 2948 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 2949 :                 const size_type _Count) {
; 2950 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2951 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2952 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2953 :             },
; 2954 :             _Ptr, _Count);
; 2955 :     }

  00082	c9		 leave
  00083	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__Alproxy$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_this$ = -20						; size = 4
_$S6$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0002e	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00031	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00034	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0003b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2413 :     basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00042	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 2414 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00046	8d 45 f3	 lea	 eax, DWORD PTR _$S6$[ebp]
  00049	89 45 d8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2415 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
; 2416 :         _Tidy_init();

  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00054	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00057	e8 00 00 00 00	 call	 _strlen
  0005c	59		 pop	 ecx
  0005d	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00060	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00063	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00066	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  00069	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2417 :         assign(_Ptr);
; 2418 :         _Proxy._Release();
; 2419 :     }

  00074	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00085	59		 pop	 ecx
  00086	c9		 leave
  00087	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0000e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 60 14 00	 and	 DWORD PTR [eax+20], 0
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	c9		 leave
  00019	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -20						; size = 4
__Format$ = -16						; size = 4
__ArgList$ = -12					; size = 4
tv86 = -8						; size = 4
__Result$1 = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1781 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1782 :         int _Result;
; 1783 :         va_list _ArgList;
; 1784 :         __crt_va_start(_ArgList, _Format);

  00006	8d 45 10	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 f4	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Format$[ebp]
  0000f	89 45 f0	 mov	 DWORD PTR __Format$[ebp], eax

; 1390 :         int const _Result = __stdio_common_vsprintf(

  00012	ff 75 f4	 push	 DWORD PTR __ArgList$[ebp]
  00015	6a 00		 push	 0
  00017	ff 75 f0	 push	 DWORD PTR __Format$[ebp]
  0001a	6a ff		 push	 -1
  0001c	ff 75 08	 push	 DWORD PTR __Buffer$[ebp]
  0001f	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00024	8b 08		 mov	 ecx, DWORD PTR [eax]
  00026	83 c9 01	 or	 ecx, 1
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	50		 push	 eax
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ___stdio_common_vsprintf
  00033	83 c4 1c	 add	 esp, 28			; 0000001cH
  00036	89 45 fc	 mov	 DWORD PTR __Result$1[ebp], eax

; 1391 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1392 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1393 : 
; 1394 :         return _Result < 0 ? -1 : _Result;

  00039	83 7d fc 00	 cmp	 DWORD PTR __Result$1[ebp], 0
  0003d	7d 06		 jge	 SHORT $LN7@sprintf
  0003f	83 4d f8 ff	 or	 DWORD PTR tv86[ebp], -1
  00043	eb 06		 jmp	 SHORT $LN3@sprintf
$LN7@sprintf:
  00045	8b 45 fc	 mov	 eax, DWORD PTR __Result$1[ebp]
  00048	89 45 f8	 mov	 DWORD PTR tv86[ebp], eax
$LN3@sprintf:

; 1785 : 
; 1786 :         #pragma warning(push)
; 1787 :         #pragma warning(disable: 4996) // Deprecation
; 1788 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv86[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 1789 :         #pragma warning(pop)
; 1790 : 
; 1791 :         __crt_va_end(_ArgList);

  00051	83 65 f4 00	 and	 DWORD PTR __ArgList$[ebp], 0

; 1792 :         return _Result;

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 1793 :     }

  00058	c9		 leave
  00059	c3		 ret	 0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 86   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\InstanceBase.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
