; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?CAMERA_MIN_DISTANCE@CCamera@@0MA		; CCamera::CAMERA_MIN_DISTANCE
PUBLIC	?CAMERA_MAX_DISTANCE@CCamera@@0MA		; CCamera::CAMERA_MAX_DISTANCE
_DATA	SEGMENT
?CAMERA_MIN_DISTANCE@CCamera@@0MA DD 043480000r	; 200	; CCamera::CAMERA_MIN_DISTANCE
?CAMERA_MAX_DISTANCE@CCamera@@0MA DD 0451c4000r	; 2500	; CCamera::CAMERA_MAX_DISTANCE
_DATA	ENDS
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::VisibilityCallback
PUBLIC	?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; SpherePackCallback::RayTraceCallback
PUBLIC	?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::RangeTestCallback
PUBLIC	?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; SpherePackCallback::PointTest2dCallback
PUBLIC	??_GSpherePackCallback@@UAEPAXI@Z		; SpherePackCallback::`scalar deleting destructor'
PUBLIC	?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::deallocate
PUBLIC	??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
PUBLIC	?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array
PUBLIC	?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
PUBLIC	?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?Update@CCamera@@QAEXXZ				; CCamera::Update
PUBLIC	?ProcessTerrainCollision@CCamera@@AAEXXZ	; CCamera::ProcessTerrainCollision
PUBLIC	?ProcessBuildingCollision@CCamera@@AAEXXZ	; CCamera::ProcessBuildingCollision
PUBLIC	??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
PUBLIC	??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z ; CCullingManager::ForInRange<CameraCollisionChecker>
PUBLIC	??$emplace_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::emplace_back<D3DXVECTOR3 const &>
PUBLIC	??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>
PUBLIC	??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
PUBLIC	??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z ; RangeTester<CameraCollisionChecker>::RangeTester<CameraCollisionChecker>
PUBLIC	??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
PUBLIC	?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ; RangeTester<CameraCollisionChecker>::RayTraceCallback
PUBLIC	?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::VisibilityCallback
PUBLIC	?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::RangeTestCallback
PUBLIC	?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ; RangeTester<CameraCollisionChecker>::PointTest2dCallback
PUBLIC	??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor'
PUBLIC	??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_7SpherePackCallback@@6B@			; SpherePackCallback::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4SpherePackCallback@@6B@			; SpherePackCallback::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSpherePackCallback@@@8			; SpherePackCallback `RTTI Type Descriptor'
PUBLIC	??_R3SpherePackCallback@@8			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2SpherePackCallback@@8			; SpherePackCallback::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@SpherePackCallback@@8		; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
PUBLIC	??_7?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`vftable'
PUBLIC	??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 ; RangeTester<CameraCollisionChecker> `RTTI Type Descriptor'
PUBLIC	??_R3?$RangeTester@UCameraCollisionChecker@@@@8	; RangeTester<CameraCollisionChecker>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$RangeTester@UCameraCollisionChecker@@@@8	; RangeTester<CameraCollisionChecker>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@3f000000
PUBLIC	__real@3f800000
PUBLIC	__real@40000000
PUBLIC	__real@40400000
PUBLIC	__real@40800000
PUBLIC	__real@42480000
PUBLIC	__real@42c80000
PUBLIC	__real@bf800000
PUBLIC	__xmm@80000000800000008000000080000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_fabs:PROC
EXTRN	_sqrt:PROC
EXTRN	_floor:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?fMIN@@YAMMM@Z:PROC				; fMIN
EXTRN	?fMAX@@YAMMM@Z:PROC				; fMAX
EXTRN	??_ESpherePackCallback@@UAEPAXI@Z:PROC		; SpherePackCallback::`vector deleting destructor'
EXTRN	?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z:PROC ; SpherePackFactory::RangeTest
EXTRN	?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ:PROC ; CGraphicObjectInstance::GetPosition
EXTRN	?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z:PROC ; CGraphicObjectInstance::CollisionDynamicSphere
EXTRN	?GetHeight@CMapManager@@QAEMMM@Z:PROC		; CMapManager::GetHeight
EXTRN	?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z:PROC ; CPythonBackground::GetPickingPointWithRayOnlyTerrain
EXTRN	?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z:PROC ; CCamera::SetCameraState
EXTRN	?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z:PROC	; CCamera::SetEye
EXTRN	?SetDistance@CCamera@@QAEXM@Z:PROC		; CCamera::SetDistance
EXTRN	?RotateEyeAroundTarget@CCamera@@QAEXMM@Z:PROC	; CCamera::RotateEyeAroundTarget
EXTRN	?SetTargetHeight@CCamera@@QAEXM@Z:PROC		; CCamera::SetTargetHeight
EXTRN	??_E?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z:PROC ; RangeTester<CameraCollisionChecker>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A DD 01H DUP (?) ; CSingleton<CCullingManager>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A DD 01H DUP (?) ; CSingleton<CPythonBackground>::ms_singleton
_BSS	ENDS
;	COMDAT __xmm@80000000800000008000000080000000
CONST	SEGMENT
__xmm@80000000800000008000000080000000 DB 00H, 00H, 00H, 080H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 080H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@42c80000
CONST	SEGMENT
__real@42c80000 DD 042c80000r			; 100
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@40800000
CONST	SEGMENT
__real@40800000 DD 040800000r			; 4
CONST	ENDS
;	COMDAT __real@40400000
CONST	SEGMENT
__real@40400000 DD 040400000r			; 3
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f000000
CONST	SEGMENT
__real@3f000000 DD 03f000000r			; 0.5
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 DD FLAT:??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R2?$RangeTester@UCameraCollisionChecker@@@@8 DD FLAT:??_R1A@?0A@EA@?$RangeTester@UCameraCollisionChecker@@@@8 ; RangeTester<CameraCollisionChecker>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	SEGMENT
??_R3?$RangeTester@UCameraCollisionChecker@@@@8 DD 00H	; RangeTester<CameraCollisionChecker>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8
data$rs	SEGMENT
??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8 DD FLAT:??_7type_info@@6B@ ; RangeTester<CameraCollisionChecker> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU?$RangeTester@UCameraCollisionChecker@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@
rdata$r	SEGMENT
??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ DD 00H ; RangeTester<CameraCollisionChecker>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AU?$RangeTester@UCameraCollisionChecker@@@@@8
	DD	FLAT:??_R3?$RangeTester@UCameraCollisionChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
CONST	SEGMENT
??_7?$RangeTester@UCameraCollisionChecker@@@@6B@ DD FLAT:??_R4?$RangeTester@UCameraCollisionChecker@@@@6B@ ; RangeTester<CameraCollisionChecker>::`vftable'
	DD	FLAT:??_E?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@SpherePackCallback@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@SpherePackCallback@@8 DD FLAT:??_R0?AVSpherePackCallback@@@8 ; SpherePackCallback::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R2SpherePackCallback@@8
rdata$r	SEGMENT
??_R2SpherePackCallback@@8 DD FLAT:??_R1A@?0A@EA@SpherePackCallback@@8 ; SpherePackCallback::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3SpherePackCallback@@8
rdata$r	SEGMENT
??_R3SpherePackCallback@@8 DD 00H			; SpherePackCallback::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSpherePackCallback@@@8
data$rs	SEGMENT
??_R0?AVSpherePackCallback@@@8 DD FLAT:??_7type_info@@6B@ ; SpherePackCallback `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSpherePackCallback@@', 00H
data$rs	ENDS
;	COMDAT ??_R4SpherePackCallback@@6B@
rdata$r	SEGMENT
??_R4SpherePackCallback@@6B@ DD 00H			; SpherePackCallback::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSpherePackCallback@@@8
	DD	FLAT:??_R3SpherePackCallback@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7SpherePackCallback@@6B@
CONST	SEGMENT
??_7SpherePackCallback@@6B@ DD FLAT:??_R4SpherePackCallback@@6B@ ; SpherePackCallback::`vftable'
	DD	FLAT:??_ESpherePackCallback@@UAEPAXI@Z
	DD	FLAT:?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
	DD	FLAT:?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
	DD	FLAT:?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z$32 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z$0
__unwindtable$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z$32
__ehfuncinfo$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z$0
__ehfuncinfo$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?ProcessBuildingCollision@CCamera@@AAEXXZ DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?ProcessBuildingCollision@CCamera@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?ProcessBuildingCollision@CCamera@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$20
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__Backout$1 = -52					; size = 12
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
$T6 = -20						; size = 4
__Ptr$ = -16						; size = 4
$T7 = -12						; size = 4
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >, COMDAT

; 1685 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 1686 :     // move [_First, _Last) to raw _Dest, using _Al
; 1687 :     // note: only called internally from elsewhere in the STL
; 1688 :     using _Ptrval     = typename _Alloc::value_type*;
; 1689 :     auto _UFirst      = _Get_unwrapped(_First);

  00008	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0000b	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1690 :     const auto _ULast = _Get_unwrapped(_Last);

  0000e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00011	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1535 :     _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00014	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00017	89 45 cc	 mov	 DWORD PTR __Backout$1[ebp], eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	89 45 d0	 mov	 DWORD PTR __Backout$1[ebp+4], eax
  00020	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00023	89 45 d4	 mov	 DWORD PTR __Backout$1[ebp+8], eax

; 1691 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1692 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1693 :         _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1694 :         return _Dest + (_ULast - _UFirst);
; 1695 :     } else {
; 1696 :         _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};
; 1697 :         for (; _UFirst != _ULast; ++_UFirst) {

  00026	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00028	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0002b	83 c0 0c	 add	 eax, 12			; 0000000cH
  0002e	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00031	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00034	3b 45 f8	 cmp	 eax, DWORD PTR __ULast$[ebp]
  00037	74 3e		 je	 SHORT $LN3@Uninitiali
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1455 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00039	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0003c	89 45 f4	 mov	 DWORD PTR $T7[ebp], eax

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003f	8b 45 f4	 mov	 eax, DWORD PTR $T7[ebp]
  00042	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00045	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00048	89 45 f0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004b	8b 45 f0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004e	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1546 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00051	8b 45 d4	 mov	 eax, DWORD PTR __Backout$1[ebp+8]
  00054	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00057	8b 45 ec	 mov	 eax, DWORD PTR $T6[ebp]
  0005a	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0005d	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00060	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00063	8b 75 e4	 mov	 esi, DWORD PTR $T4[ebp]
  00066	8b 7d e0	 mov	 edi, DWORD PTR $T3[ebp]
  00069	a5		 movsd
  0006a	a5		 movsd
  0006b	a5		 movsd

; 1547 :         ++_Last;

  0006c	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0006f	83 c0 0c	 add	 eax, 12			; 0000000cH
  00072	89 45 d0	 mov	 DWORD PTR __Backout$1[ebp+4], eax

; 1698 :             _Backout._Emplace_back(_STD move(*_UFirst));
; 1699 :         }

  00075	eb b1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1551 :         _First = _Last;

  00077	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  0007a	89 45 cc	 mov	 DWORD PTR __Backout$1[ebp], eax

; 1552 :         return _Last;

  0007d	8b 45 d0	 mov	 eax, DWORD PTR __Backout$1[ebp+4]
  00080	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax

; 1541 :         _Destroy_range(_First, _Last, _Al);

  00083	ff 75 d4	 push	 DWORD PTR __Backout$1[ebp+8]
  00086	ff 75 d0	 push	 DWORD PTR __Backout$1[ebp+4]
  00089	ff 75 cc	 push	 DWORD PTR __Backout$1[ebp]
  0008c	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1700 : 
; 1701 :         return _Backout._Release();

  00094	8b 45 dc	 mov	 eax, DWORD PTR $T2[ebp]

; 1702 :     }
; 1703 : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	c9		 leave
  0009a	c3		 ret	 0
??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z PROC ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 19   : 	{}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
  00019	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001c	83 e0 01	 and	 eax, 1
  0001f	74 0c		 je	 SHORT $LN2@scalar
  00021	6a 0c		 push	 12			; 0000000cH
  00023	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002b	59		 pop	 ecx
  0002c	59		 pop	 ecx
$LN2@scalar:
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	c9		 leave
  00031	c2 04 00	 ret	 4
??_G?$RangeTester@UCameraCollisionChecker@@@@UAEPAXI@Z ENDP ; RangeTester<CameraCollisionChecker>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_p$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::PointTest2dCallback, COMDAT
; _this$ = ecx

; 50   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 51   : #ifdef SPHERELIB_STRICT
; 52   : 		if (sphere->IS_SPHERE)
; 53   : 			puts("RangeTester::PointTest2dCallback");	
; 54   : #endif
; 55   : 		if (state!=VS_OUTSIDE)

  00008	83 7d 10 02	 cmp	 DWORD PTR _state$[ebp], 2
  0000c	74 17		 je	 SHORT $LN1@PointTest2
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  0000e	8b 45 0c	 mov	 eax, DWORD PTR _sphere$[ebp]
  00011	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00014	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 60   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00017	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	e8 00 00 00 00	 call	 ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
$LN1@PointTest2:

; 61   : 		}
; 62   : 	}

  00025	c9		 leave
  00026	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
_p$ = 8							; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::RangeTestCallback, COMDAT
; _this$ = ecx

; 40   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : #ifdef SPHERELIB_STRICT
; 42   : 		if (sphere->IS_SPHERE)
; 43   : 			puts("RangeTester::RangeTestCallback");
; 44   : #endif	
; 45   : 		if (state!=VS_OUTSIDE)

  00008	83 7d 14 02	 cmp	 DWORD PTR _state$[ebp], 2
  0000c	74 17		 je	 SHORT $LN1@RangeTestC
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  0000e	8b 45 10	 mov	 eax, DWORD PTR _sphere$[ebp]
  00011	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00014	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 46   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  00017	ff 75 fc	 push	 DWORD PTR $T1[ebp]
  0001a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	e8 00 00 00 00	 call	 ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
$LN1@RangeTestC:

; 47   : 	}

  00025	c9		 leave
  00026	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; RangeTester<CameraCollisionChecker>::VisibilityCallback, COMDAT
; _this$ = ecx

; 37   : 	virtual void VisibilityCallback(const Frustum &f,SpherePack *sphere,ViewState state){};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; RangeTester<CameraCollisionChecker>::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; RangeTester<CameraCollisionChecker>::RayTraceCallback, COMDAT
; _this$ = ecx

; 27   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 28   : #ifdef SPHERELIB_STRICT
; 29   : 		if (sphere->IS_SPHERE)
; 30   : 			puts("RangeTester::RayTraceCallback");
; 31   : #endif	
; 32   : 		if (dist<=0.0f || dist>=distance)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	0f 57 c0	 xorps	 xmm0, xmm0
  0000e	0f 2f 40 08	 comiss	 xmm0, DWORD PTR [eax+8]
  00012	73 0e		 jae	 SHORT $LN3@RayTraceCa
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  0001c	0f 2f 45 10	 comiss	 xmm0, DWORD PTR _distance$[ebp]
  00020	72 17		 jb	 SHORT $LN2@RayTraceCa
$LN3@RayTraceCa:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 209  : 	void * GetUserData(void) const { return mUserData; };

  00022	8b 45 18	 mov	 eax, DWORD PTR _sphere$[ebp]
  00025	8b 40 44	 mov	 eax, DWORD PTR [eax+68]
  00028	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 33   : 			(*f)((CGraphicObjectInstance *)sphere->GetUserData());

  0002b	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00034	e8 00 00 00 00	 call	 ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ; CameraCollisionChecker::operator()
$LN2@RayTraceCa:

; 34   : 	};

  00039	c9		 leave
  0003a	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@?$RangeTester@UCameraCollisionChecker@@@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; RangeTester<CameraCollisionChecker>::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ PROC	; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>, COMDAT
; _this$ = ecx

; 19   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 19   : 	{}

  00019	c9		 leave
  0001a	c3		 ret	 0
??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ENDP	; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_fn$ = 8						; size = 4
_distance$ = 12						; size = 4
??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z PROC ; RangeTester<CameraCollisionChecker>::RangeTester<CameraCollisionChecker>, COMDAT
; _this$ = ecx

; 16   : 	{}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 55   : 	SpherePackCallback() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 16   : 	{}

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@

; 15   : 		: f(fn), dist(distance)

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _fn$[ebp]
  0001f	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _distance$[ebp]
  0002a	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0

; 16   : 	{}

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c9		 leave
  00033	c2 08 00	 ret	 8
??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z ENDP ; RangeTester<CameraCollisionChecker>::RangeTester<CameraCollisionChecker>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z PROC ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >, COMDAT

; 962  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 963  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 964  :     using _Ty = typename _Alloc::value_type;
; 965  :     if _CONSTEXPR_IF (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 966  :         for (; _First != _Last; ++_First) {
; 967  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 968  :         }
; 969  :     }
; 970  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z
_TEXT	SEGMENT
__Max_possible$2 = -68					; size = 4
$T3 = -64						; size = 4
__Al$ = -60						; size = 4
__Last$ = -56						; size = 4
$T4 = -52						; size = 4
$T5 = -48						; size = 4
__First$ = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
__First$ = -32						; size = 4
__Last$ = -28						; size = 4
$T8 = -24						; size = 4
$T9 = -20						; size = 4
__$EHRec$ = -16						; size = 16
$T10 = 0						; size = 4
$T11 = 4						; size = 4
$T12 = 8						; size = 4
$T13 = 12						; size = 4
$T14 = 16						; size = 4
$T15 = 20						; size = 4
$T16 = 24						; size = 4
$T17 = 28						; size = 4
$T18 = 32						; size = 4
$T19 = 36						; size = 4
$T20 = 40						; size = 4
__Newsize$ = 44						; size = 4
__Constructed_last$ = 48				; size = 4
__Oldsize$ = 52						; size = 4
tv172 = 56						; size = 4
$T21 = 60						; size = 4
$T22 = 64						; size = 4
__My_data$ = 68						; size = 4
__Constructed_first$ = 72				; size = 4
___formal$ = 76						; size = 1
__Overflow_is_possible$23 = 83				; size = 1
__Newcapacity$ = 84					; size = 4
__Mylast$ = 88						; size = 4
__Myfirst$ = 92						; size = 4
__Whereoff$ = 96					; size = 4
$T24 = 103						; size = 1
_this$ = 104						; size = 4
__Newvec$ = 108						; size = 4
__Whereptr$ = 120					; size = 4
_<_Val_0>$ = 124					; size = 4
??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>, COMDAT
; _this$ = ecx

; 725  :     pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8d 6c 24 90	 lea	 ebp, DWORD PTR [esp-112]
  00005	83 ec 70	 sub	 esp, 112		; 00000070H
  00008	6a ff		 push	 -1
  0000a	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z
  0000f	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00015	50		 push	 eax
  00016	51		 push	 ecx
  00017	83 ec 34	 sub	 esp, 52			; 00000034H
  0001a	53		 push	 ebx
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	50		 push	 eax
  00025	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00028	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002e	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00031	89 4d 68	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00034	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00037	89 45 28	 mov	 DWORD PTR $T20[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0003a	8b 45 28	 mov	 eax, DWORD PTR $T20[ebp]
  0003d	89 45 c4	 mov	 DWORD PTR __Al$[ebp], eax

; 726  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 727  :         _Alty& _Al        = _Getal();
; 728  :         auto& _My_data    = _Mypair._Myval2;

  00040	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
  00043	89 45 44	 mov	 DWORD PTR __My_data$[ebp], eax

; 729  :         pointer& _Myfirst = _My_data._Myfirst;

  00046	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  00049	89 45 5c	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 730  :         pointer& _Mylast  = _My_data._Mylast;

  0004c	8b 45 44	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004f	83 c0 04	 add	 eax, 4
  00052	89 45 58	 mov	 DWORD PTR __Mylast$[ebp], eax

; 731  : 
; 732  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 733  : 
; 734  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  00055	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00058	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0005b	2b 08		 sub	 ecx, DWORD PTR [eax]
  0005d	8b c1		 mov	 eax, ecx
  0005f	99		 cdq
  00060	6a 0c		 push	 12			; 0000000cH
  00062	59		 pop	 ecx
  00063	f7 f9		 idiv	 ecx
  00065	89 45 60	 mov	 DWORD PTR __Whereoff$[ebp], eax

; 735  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  00068	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0006b	8b 4d 5c	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 34	 mov	 DWORD PTR __Oldsize$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  0007b	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0007e	89 45 24	 mov	 DWORD PTR $T19[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00081	8b 45 24	 mov	 eax, DWORD PTR $T19[ebp]
  00084	89 45 c0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00087	c7 45 40 55 55
	55 15		 mov	 DWORD PTR $T22[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  0008e	c7 45 20 ff ff
	ff 7f		 mov	 DWORD PTR $T18[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00095	8b 45 20	 mov	 eax, DWORD PTR $T18[ebp]
  00098	89 45 3c	 mov	 DWORD PTR $T21[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0009b	8b 45 40	 mov	 eax, DWORD PTR $T22[ebp]
  0009e	3b 45 3c	 cmp	 eax, DWORD PTR $T21[ebp]
  000a1	73 08		 jae	 SHORT $LN34@Emplace_re
  000a3	8d 45 40	 lea	 eax, DWORD PTR $T22[ebp]
  000a6	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
  000a9	eb 06		 jmp	 SHORT $LN35@Emplace_re
$LN34@Emplace_re:
  000ab	8d 45 3c	 lea	 eax, DWORD PTR $T21[ebp]
  000ae	89 45 38	 mov	 DWORD PTR tv172[ebp], eax
$LN35@Emplace_re:
  000b1	8b 45 38	 mov	 eax, DWORD PTR tv172[ebp]
  000b4	89 45 1c	 mov	 DWORD PTR $T17[ebp], eax
  000b7	8b 45 1c	 mov	 eax, DWORD PTR $T17[ebp]
  000ba	89 45 18	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  000bd	8b 45 18	 mov	 eax, DWORD PTR $T16[ebp]
  000c0	8b 00		 mov	 eax, DWORD PTR [eax]
  000c2	89 45 14	 mov	 DWORD PTR $T15[ebp], eax

; 736  : 
; 737  :         if (_Oldsize == max_size()) {

  000c5	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000c8	3b 45 14	 cmp	 eax, DWORD PTR $T15[ebp]
  000cb	75 05		 jne	 SHORT $LN2@Emplace_re

; 738  :             _Xlength();

  000cd	e8 00 00 00 00	 call	 ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
$LN2@Emplace_re:

; 739  :         }
; 740  : 
; 741  :         const size_type _Newsize     = _Oldsize + 1;

  000d2	8b 45 34	 mov	 eax, DWORD PTR __Oldsize$[ebp]
  000d5	40		 inc	 eax
  000d6	89 45 2c	 mov	 DWORD PTR __Newsize$[ebp], eax

; 742  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  000d9	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  000dc	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  000df	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth
  000e4	89 45 54	 mov	 DWORD PTR __Newcapacity$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  000e7	c6 45 53 01	 mov	 BYTE PTR __Overflow_is_possible$23[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  000eb	c7 45 bc 55 55
	55 15		 mov	 DWORD PTR __Max_possible$2[ebp], 357913941 ; 15555555H

; 60   :         if (_Count > _Max_possible) {

  000f2	81 7d 54 55 55
	55 15		 cmp	 DWORD PTR __Newcapacity$[ebp], 357913941 ; 15555555H
  000f9	76 05		 jbe	 SHORT $LN67@Emplace_re

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  000fb	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN67@Emplace_re:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00100	6b 45 54 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  00104	89 45 10	 mov	 DWORD PTR $T14[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00107	ff 75 10	 push	 DWORD PTR $T14[ebp]
  0010a	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0010f	59		 pop	 ecx
  00110	89 45 6c	 mov	 DWORD PTR __Newvec$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 745  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00113	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00117	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0011a	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]
  0011e	89 45 30	 mov	 DWORD PTR __Constructed_last$[ebp], eax

; 746  :         pointer _Constructed_first      = _Constructed_last;

  00121	8b 45 30	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  00124	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 747  : 
; 748  :         _TRY_BEGIN

  00127	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+12], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0012b	8b 45 7c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0012e	89 45 08	 mov	 DWORD PTR $T12[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 749  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  00131	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00135	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00138	89 45 0c	 mov	 DWORD PTR $T13[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0013b	8b 45 0c	 mov	 eax, DWORD PTR $T13[ebp]
  0013e	89 45 00	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00141	8b 45 08	 mov	 eax, DWORD PTR $T12[ebp]
  00144	89 45 04	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00147	8b 75 04	 mov	 esi, DWORD PTR $T11[ebp]
  0014a	8b 7d 00	 mov	 edi, DWORD PTR $T10[ebp]
  0014d	a5		 movsd
  0014e	a5		 movsd
  0014f	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 750  :         _Constructed_first = _Newvec + _Whereoff;

  00150	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  00154	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
  00157	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 751  : 
; 752  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  0015a	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0015d	8b 4d 78	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00160	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00162	75 3d		 jne	 SHORT $LN4@Emplace_re

; 753  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00164	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00167	8b 00		 mov	 eax, DWORD PTR [eax]
  00169	89 45 e4	 mov	 DWORD PTR __Last$[ebp], eax
  0016c	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0016f	8b 00		 mov	 eax, DWORD PTR [eax]
  00171	89 45 e0	 mov	 DWORD PTR __First$[ebp], eax

; 1607 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00174	33 c0		 xor	 eax, eax
  00176	88 45 67	 mov	 BYTE PTR $T24[ebp], al
  00179	8a 45 67	 mov	 al, BYTE PTR $T24[ebp]
  0017c	88 45 4c	 mov	 BYTE PTR ___formal$[ebp], al

; 1733 :         return _Mypair._Get_first();

  0017f	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00182	89 45 ec	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00185	8b 45 ec	 mov	 eax, DWORD PTR $T9[ebp]
  00188	89 45 e8	 mov	 DWORD PTR $T8[ebp], eax

; 1597 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  0018b	ff 75 e8	 push	 DWORD PTR $T8[ebp]
  0018e	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00191	ff 75 e4	 push	 DWORD PTR __Last$[ebp]
  00194	ff 75 e0	 push	 DWORD PTR __First$[ebp]
  00197	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
  0019c	83 c4 10	 add	 esp, 16			; 00000010H

; 754  :         } else { // provide basic guarantee

  0019f	eb 5f		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 755  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  001a1	8b 45 5c	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  001a4	8b 00		 mov	 eax, DWORD PTR [eax]
  001a6	89 45 d4	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001a9	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001ac	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001af	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  001b2	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001b5	ff 75 d8	 push	 DWORD PTR $T6[ebp]
  001b8	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  001bb	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001be	ff 75 d4	 push	 DWORD PTR __First$[ebp]
  001c1	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
  001c6	83 c4 10	 add	 esp, 16			; 00000010H

; 756  :             _Constructed_first = _Newvec;

  001c9	8b 45 6c	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001cc	89 45 48	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001cf	8b 45 58	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001d2	8b 00		 mov	 eax, DWORD PTR [eax]
  001d4	89 45 c8	 mov	 DWORD PTR __Last$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  001d7	8b 45 68	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  001da	89 45 d0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  001dd	8b 45 d0	 mov	 eax, DWORD PTR $T5[ebp]
  001e0	89 45 cc	 mov	 DWORD PTR $T4[ebp], eax

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001e3	ff 75 cc	 push	 DWORD PTR $T4[ebp]

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  001e6	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  001ea	8b 4d 6c	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001ed	8d 44 01 0c	 lea	 eax, DWORD PTR [ecx+eax+12]

; 1592 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  001f1	50		 push	 eax
  001f2	ff 75 c8	 push	 DWORD PTR __Last$[ebp]
  001f5	ff 75 78	 push	 DWORD PTR __Whereptr$[ebp]
  001f8	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAUD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAPAUD3DXVECTOR3@@QAU1@0PAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Uninitialized_move<D3DXVECTOR3 *,std::allocator<D3DXVECTOR3> >
  001fd	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:

; 757  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00200	eb 2b		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z$0:

; 758  :         }
; 759  :         _CATCH_ALL
; 760  :         _Destroy(_Constructed_first, _Constructed_last);

  00202	ff 75 30	 push	 DWORD PTR __Constructed_last$[ebp]
  00205	ff 75 48	 push	 DWORD PTR __Constructed_first$[ebp]
  00208	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  0020b	e8 00 00 00 00	 call	 ?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy

; 761  :         _Al.deallocate(_Newvec, _Newcapacity);

  00210	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  00213	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00216	8b 4d c4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00219	e8 00 00 00 00	 call	 ?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z ; std::allocator<D3DXVECTOR3>::deallocate

; 762  :         _RERAISE;

  0021e	6a 00		 push	 0
  00220	6a 00		 push	 0
  00222	e8 00 00 00 00	 call	 __CxxThrowException@8

; 763  :         _CATCH_END

  00227	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0022c	c3		 ret	 0
$LN7@Emplace_re:
  0022d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
  00231	eb 04		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z$1
$LN10@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
  00233	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z$1:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 764  : 
; 765  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00237	ff 75 54	 push	 DWORD PTR __Newcapacity$[ebp]
  0023a	ff 75 2c	 push	 DWORD PTR __Newsize$[ebp]
  0023d	ff 75 6c	 push	 DWORD PTR __Newvec$[ebp]
  00240	8b 4d 68	 mov	 ecx, DWORD PTR _this$[ebp]
  00243	e8 00 00 00 00	 call	 ?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array

; 766  :         return _Newvec + _Whereoff;

  00248	6b 45 60 0c	 imul	 eax, DWORD PTR __Whereoff$[ebp], 12
  0024c	03 45 6c	 add	 eax, DWORD PTR __Newvec$[ebp]
$LN70@Emplace_re:

; 767  :     }

  0024f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00252	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00259	59		 pop	 ecx
  0025a	5f		 pop	 edi
  0025b	5e		 pop	 esi
  0025c	5b		 pop	 ebx
  0025d	83 c5 70	 add	 ebp, 112		; 00000070H
  00260	c9		 leave
  00261	c2 08 00	 ret	 8
  00264	cc		 int	 3
  00265	cc		 int	 3
  00266	cc		 int	 3
  00267	cc		 int	 3
  00268	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a b8	 mov	 ecx, DWORD PTR [edx-72]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??$emplace_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z
_TEXT	SEGMENT
__Result$ = -64						; size = 4
__Result$1 = -60					; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
$T5 = -44						; size = 4
$T6 = -40						; size = 4
$T7 = -36						; size = 4
$T8 = -32						; size = 4
__Ptr$ = -28						; size = 4
$T9 = -24						; size = 4
__My_data$10 = -20					; size = 4
__Mylast$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$11 = -4					; size = 4
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::emplace_back<D3DXVECTOR3 const &>, COMDAT
; _this$ = ecx

; 700  :     decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 701  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 702  :         auto& _My_data   = _Mypair._Myval2;

  0000b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000e	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 703  :         pointer& _Mylast = _My_data._Mylast;

  00011	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00014	83 c0 04	 add	 eax, 4
  00017	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 704  :         if (_Mylast != _My_data._Myend) {

  0001a	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00020	8b 00		 mov	 eax, DWORD PTR [eax]
  00022	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00025	74 61		 je	 SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00027	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0002a	89 45 e8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 684  :         auto& _My_data   = _Mypair._Myval2;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 ec	 mov	 DWORD PTR __My_data$10[ebp], eax

; 685  :         pointer& _Mylast = _My_data._Mylast;

  00033	8b 45 ec	 mov	 eax, DWORD PTR __My_data$10[ebp]
  00036	83 c0 04	 add	 eax, 4
  00039	89 45 fc	 mov	 DWORD PTR __Mylast$11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0003c	8b 45 e8	 mov	 eax, DWORD PTR $T9[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 687  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00042	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 e4	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00053	89 45 e0	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00056	8b 45 e0	 mov	 eax, DWORD PTR $T8[ebp]
  00059	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0005c	8b 45 dc	 mov	 eax, DWORD PTR $T7[ebp]
  0005f	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T6[ebp]
  00065	89 45 d4	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00068	8b 75 d4	 mov	 esi, DWORD PTR $T5[ebp]
  0006b	8b 7d d0	 mov	 edi, DWORD PTR $T4[ebp]
  0006e	a5		 movsd
  0006f	a5		 movsd
  00070	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 689  :         _Ty& _Result = *_Mylast;

  00071	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  00074	8b 00		 mov	 eax, DWORD PTR [eax]
  00076	89 45 c4	 mov	 DWORD PTR __Result$1[ebp], eax

; 690  :         ++_Mylast;

  00079	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$11[ebp]
  0007c	8b 00		 mov	 eax, DWORD PTR [eax]
  0007e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00081	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$11[ebp]
  00084	89 01		 mov	 DWORD PTR [ecx], eax

; 705  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00086	eb 19		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 708  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0008e	ff 75 cc	 push	 DWORD PTR $T3[ebp]
  00091	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00094	ff 30		 push	 DWORD PTR [eax]
  00096	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEPAUD3DXVECTOR3@@QAU2@ABU2@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Emplace_reallocate<D3DXVECTOR3 const &>
  0009e	89 45 c0	 mov	 DWORD PTR __Result$[ebp], eax
$LN1@emplace_ba:

; 709  : #if _HAS_CXX17
; 710  :         return _Result;
; 711  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 712  :         (void) _Result;
; 713  : #endif // _HAS_CXX17
; 714  :     }

  000a1	5f		 pop	 edi
  000a2	5e		 pop	 esi
  000a3	c9		 leave
  000a4	c2 04 00	 ret	 4
??$emplace_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::emplace_back<D3DXVECTOR3 const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
;	COMDAT ??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z
_TEXT	SEGMENT
_r$ = -28						; size = 12
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_p$ = 8							; size = 4
_radius$ = 12						; size = 4
_pFunc$ = 16						; size = 4
??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z PROC ; CCullingManager::ForInRange<CameraCollisionChecker>, COMDAT
; _this$ = ecx

; 112  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 55   : 	SpherePackCallback() {}

  00028	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 16   : 	{}

  0002f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@

; 15   : 		: f(fn), dist(distance)

  00036	8b 45 10	 mov	 eax, DWORD PTR _pFunc$[ebp]
  00039	89 45 e8	 mov	 DWORD PTR _r$[ebp+4], eax
  0003c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00044	f3 0f 11 45 ec	 movss	 DWORD PTR _r$[ebp+8], xmm0

; 113  : 		RangeTester<T> r(pFunc);

  00049	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  0004d	8d 45 e4	 lea	 eax, DWORD PTR _r$[ebp]
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _radius$[ebp]
  00057	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0005c	ff 75 08	 push	 DWORD PTR _p$[ebp]
  0005f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00062	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00065	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest

; 115  : 	}

  0006a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1

; 19   : 	{}

  0006e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  00075	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _r$[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 115  : 	}

  0007c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00086	59		 pop	 ecx
  00087	c9		 leave
  00088	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR _r$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z ENDP ; CCullingManager::ForInRange<CameraCollisionChecker>
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
;	COMDAT ??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
_pOpponent$ = 8						; size = 4
??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z PROC ; CameraCollisionChecker::operator(), COMDAT
; _this$ = ecx

; 115  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 		if (pOpponent->CollisionDynamicSphere(*m_pdsi))

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	ff 70 08	 push	 DWORD PTR [eax+8]
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR _pOpponent$[ebp]
  00012	e8 00 00 00 00	 call	 ?CollisionDynamicSphere@CGraphicObjectInstance@@QBE_NABUCDynamicSphereInstance@@@Z ; CGraphicObjectInstance::CollisionDynamicSphere
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	74 25		 je	 SHORT $LN1@operator

; 117  :  		{
; 118  : 			m_pkVct_v3Position->push_back(pOpponent->GetPosition());

  0001e	8b 4d 08	 mov	 ecx, DWORD PTR _pOpponent$[ebp]
  00021	e8 00 00 00 00	 call	 ?GetPosition@CGraphicObjectInstance@@QBEABUD3DXVECTOR3@@XZ ; CGraphicObjectInstance::GetPosition
  00026	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002f	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 717  :         emplace_back(_Val);

  00032	ff 75 f8	 push	 DWORD PTR __Val$[ebp]
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ??$emplace_back@ABUD3DXVECTOR3@@@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAEXABUD3DXVECTOR3@@@Z ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::emplace_back<D3DXVECTOR3 const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 119  : 			m_isBlocked = true;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c6 00 01	 mov	 BYTE PTR [eax], 1
$LN1@operator:

; 120  :  		}
; 121  : 	}

  00043	c9		 leave
  00044	c2 04 00	 ret	 4
??RCameraCollisionChecker@@QAEXPAVCGraphicObjectInstance@@@Z ENDP ; CameraCollisionChecker::operator()
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
;	COMDAT ?ProcessBuildingCollision@CCamera@@AAEXXZ
_TEXT	SEGMENT
_kVct_kPosition$2 = -812				; size = 12
_kVct_kPosition$3 = -800				; size = 12
_kVct_kPosition$4 = -788				; size = 12
_kVct_kPosition$5 = -776				; size = 12
_r$6 = -764						; size = 12
_r$7 = -752						; size = 12
_kCameraCollisionChecker$8 = -740			; size = 12
_kCameraCollisionChecker$9 = -728			; size = 12
_kVct_kPosition$10 = -716				; size = 12
_kVct_kPosition$11 = -704				; size = 12
_kCameraCollisionChecker$12 = -692			; size = 12
_kCameraCollisionChecker$13 = -680			; size = 12
_kCameraCollisionChecker$14 = -668			; size = 12
_kCameraCollisionChecker$15 = -656			; size = 12
_fz$ = -644						; size = 4
_fx$ = -640						; size = 4
_fy$ = -636						; size = 4
_fz$ = -632						; size = 4
_radius$ = -628						; size = 4
$T16 = -624						; size = 4
__My_data$17 = -620					; size = 4
_radius$ = -616						; size = 4
_this$ = -612						; size = 4
_fx$ = -608						; size = 4
_fy$ = -604						; size = 4
_fz$ = -600						; size = 4
_fx$ = -596						; size = 4
_fy$ = -592						; size = 4
_fz$ = -588						; size = 4
_fx$ = -584						; size = 4
_fy$ = -580						; size = 4
_fz$ = -576						; size = 4
_this$ = -572						; size = 4
_fz$ = -568						; size = 4
_fy$ = -564						; size = 4
_fx$ = -560						; size = 4
__My_data$18 = -556					; size = 4
$T19 = -552						; size = 4
_this$ = -548						; size = 4
_fz$ = -544						; size = 4
_fy$ = -540						; size = 4
_fx$ = -536						; size = 4
_fz$ = -532						; size = 4
_fy$ = -528						; size = 4
_fx$ = -524						; size = 4
_this$ = -520						; size = 4
_fz$ = -516						; size = 4
_fy$ = -512						; size = 4
_fx$ = -508						; size = 4
_fz$ = -504						; size = 4
_fy$ = -500						; size = 4
_fx$ = -496						; size = 4
_this$ = -492						; size = 4
_fz$ = -488						; size = 4
_fy$ = -484						; size = 4
_fx$ = -480						; size = 4
_fz$ = -476						; size = 4
_fy$ = -472						; size = 4
_fx$ = -468						; size = 4
_this$ = -464						; size = 4
_fz$ = -460						; size = 4
_fy$ = -456						; size = 4
_fx$ = -452						; size = 4
_fz$ = -448						; size = 4
_fy$ = -444						; size = 4
_fx$ = -440						; size = 4
_fy$ = -436						; size = 4
_fx$ = -432						; size = 4
_c$ = -428						; size = 4
_b$ = -424						; size = 4
_a$ = -420						; size = 4
_fDot$20 = -416						; size = 4
__My_data$21 = -412					; size = 4
_fDot$22 = -408						; size = 4
__My_data$23 = -404					; size = 4
_v$ = -400						; size = 4
_pV2$ = -396						; size = 4
_v$ = -392						; size = 4
$T24 = -388						; size = 4
_this$25 = -384						; size = 4
_this$ = -380						; size = 4
_f$ = -376						; size = 4
_v$ = -372						; size = 4
_this$26 = -368						; size = 4
_this$ = -364						; size = 4
_f$ = -360						; size = 4
_v$ = -356						; size = 4
_this$27 = -352						; size = 4
_this$ = -348						; size = 4
_f$ = -344						; size = 4
_v$ = -340						; size = 4
_this$ = -336						; size = 4
_f$ = -332						; size = 4
_v$ = -328						; size = 4
_this$ = -324						; size = 4
_f$ = -320						; size = 4
_v$ = -316						; size = 4
_pV2$ = -312						; size = 4
$T28 = -308						; size = 4
_this$ = -304						; size = 4
_f$ = -300						; size = 4
_v$ = -296						; size = 4
_pV2$ = -292						; size = 4
_fMoveAmountLarge$ = -288				; size = 4
_rkCullingMgr$ = -284					; size = 4
_pV2$ = -280						; size = 4
_bCollide$29 = -274					; size = 1
_bCollide$30 = -273					; size = 1
_bCollide$31 = -272					; size = 1
_bCollide$32 = -271					; size = 1
_bCollide$33 = -270					; size = 1
_bCollide$34 = -269					; size = 1
_fMoveAmountSmall$ = -268				; size = 4
_this$ = -264						; size = 4
_v$35 = -260						; size = 12
$T36 = -248						; size = 12
_v$37 = -236						; size = 12
$T38 = -224						; size = 12
$T39 = -212						; size = 12
$T40 = -200						; size = 12
$T41 = -188						; size = 12
$T42 = -176						; size = 12
$T43 = -164						; size = 12
$T44 = -152						; size = 12
$T45 = -140						; size = 12
$T46 = -128						; size = 12
$T47 = -116						; size = 12
$T48 = -104						; size = 12
_s$ = -92						; size = 28
$T49 = -64						; size = 12
_aVector3d$ = -52					; size = 12
$T50 = -40						; size = 12
_v3CheckVector$ = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?ProcessBuildingCollision@CCamera@@AAEXXZ PROC		; CCamera::ProcessBuildingCollision, COMDAT
; _this$ = ecx

; 125  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?ProcessBuildingCollision@CCamera@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 20 03 00
	00		 sub	 esp, 800		; 00000320H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00027	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002d	89 8d f8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx

; 126  : 	float fMoveAmountSmall = 2.0f;

  00033	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0003b	f3 0f 11 85 f4
	fe ff ff	 movss	 DWORD PTR _fMoveAmountSmall$[ebp], xmm0

; 127  : 	float fMoveAmountLarge = 4.0f;

  00043	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  0004b	f3 0f 11 85 e0
	fe ff ff	 movss	 DWORD PTR _fMoveAmountLarge$[ebp], xmm0

; 128  : 
; 129  : 	D3DXVECTOR3 v3CheckVector;
; 130  : 
; 131  : 	CDynamicSphereInstance s;
; 132  : 	s.fRadius = m_fObjectCollisionRadius;

  00053	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00059	f3 0f 10 80 f4
	02 00 00	 movss	 xmm0, DWORD PTR [eax+756]
  00061	f3 0f 11 45 bc	 movss	 DWORD PTR _s$[ebp+24], xmm0

; 133  : 	s.v3LastPosition = m_v3Eye;

  00066	8b b5 f8 fe ff
	ff		 mov	 esi, DWORD PTR _this$[ebp]
  0006c	83 c6 30	 add	 esi, 48			; 00000030H
  0006f	8d 7d b0	 lea	 edi, DWORD PTR _s$[ebp+12]
  00072	a5		 movsd
  00073	a5		 movsd
  00074	a5		 movsd

; 134  : 
; 135  : 	Vector3d aVector3d;
; 136  : 	aVector3d.Set(m_v3Eye.x, m_v3Eye.y, m_v3Eye.z);

  00075	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0007b	f3 0f 10 40 30	 movss	 xmm0, DWORD PTR [eax+48]
  00080	f3 0f 11 85 5c
	fe ff ff	 movss	 DWORD PTR _a$[ebp], xmm0
  00088	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0008e	f3 0f 10 40 34	 movss	 xmm0, DWORD PTR [eax+52]
  00093	f3 0f 11 85 58
	fe ff ff	 movss	 DWORD PTR _b$[ebp], xmm0
  0009b	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000a1	f3 0f 10 40 38	 movss	 xmm0, DWORD PTR [eax+56]
  000a6	f3 0f 11 85 54
	fe ff ff	 movss	 DWORD PTR _c$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\vector.h

; 107  : 		x = a;

  000ae	f3 0f 10 85 5c
	fe ff ff	 movss	 xmm0, DWORD PTR _a$[ebp]
  000b6	f3 0f 11 45 cc	 movss	 DWORD PTR _aVector3d$[ebp], xmm0

; 108  : 		y = b;

  000bb	f3 0f 10 85 58
	fe ff ff	 movss	 xmm0, DWORD PTR _b$[ebp]
  000c3	f3 0f 11 45 d0	 movss	 DWORD PTR _aVector3d$[ebp+4], xmm0

; 109  : 		z = c;

  000c8	f3 0f 10 85 54
	fe ff ff	 movss	 xmm0, DWORD PTR _c$[ebp]
  000d0	f3 0f 11 45 d4	 movss	 DWORD PTR _aVector3d$[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 140  : 	CCullingManager & rkCullingMgr = CCullingManager::Instance();

  000d5	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCCullingManager@@@@0PAVCCullingManager@@A ; CSingleton<CCullingManager>::ms_singleton
  000da	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _rkCullingMgr$[ebp], eax

; 143  : 		v3CheckVector = m_v3Eye - m_fObjectCollisionRadius * m_v3View;

  000e0	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e6	83 c0 54	 add	 eax, 84			; 00000054H
  000e9	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  000ef	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000f5	f3 0f 10 80 f4
	02 00 00	 movss	 xmm0, DWORD PTR [eax+756]
  000fd	f3 0f 11 85 d4
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00105	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  0010b	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00113	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00117	f3 0f 11 85 50
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0011f	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00125	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  0012d	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00132	f3 0f 11 85 4c
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0013a	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00140	f3 0f 10 85 d4
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00148	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  0014d	f3 0f 11 85 7c
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00155	f3 0f 10 85 50
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0015d	f3 0f 11 85 5c
	ff ff ff	 movss	 DWORD PTR $T43[ebp], xmm0

; 181  :     y = fy;

  00165	f3 0f 10 85 4c
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0016d	f3 0f 11 85 60
	ff ff ff	 movss	 DWORD PTR $T43[ebp+4], xmm0

; 182  :     z = fz;

  00175	f3 0f 10 85 7c
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0017d	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR $T43[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 143  : 		v3CheckVector = m_v3Eye - m_fObjectCollisionRadius * m_v3View;

  00185	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0018b	83 c0 30	 add	 eax, 48			; 00000030H
  0018e	89 85 d0 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00194	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0019a	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0019e	f3 0f 5c 85 5c
	ff ff ff	 subss	 xmm0, DWORD PTR $T43[ebp]
  001a6	f3 0f 11 85 80
	fd ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  001ae	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001b4	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  001b9	f3 0f 5c 85 60
	ff ff ff	 subss	 xmm0, DWORD PTR $T43[ebp+4]
  001c1	f3 0f 11 85 84
	fd ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  001c9	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001cf	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  001d4	f3 0f 5c 85 64
	ff ff ff	 subss	 xmm0, DWORD PTR $T43[ebp+8]
  001dc	f3 0f 11 85 88
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  001e4	f3 0f 10 85 80
	fd ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001ec	f3 0f 11 85 08
	ff ff ff	 movss	 DWORD PTR $T36[ebp], xmm0

; 181  :     y = fy;

  001f4	f3 0f 10 85 84
	fd ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001fc	f3 0f 11 85 0c
	ff ff ff	 movss	 DWORD PTR $T36[ebp+4], xmm0

; 182  :     z = fz;

  00204	f3 0f 10 85 88
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  0020c	f3 0f 11 85 10
	ff ff ff	 movss	 DWORD PTR $T36[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 143  : 		v3CheckVector = m_v3Eye - m_fObjectCollisionRadius * m_v3View;

  00214	8d b5 08 ff ff
	ff		 lea	 esi, DWORD PTR $T36[ebp]
  0021a	8d 7d e4	 lea	 edi, DWORD PTR _v3CheckVector$[ebp]
  0021d	a5		 movsd
  0021e	a5		 movsd
  0021f	a5		 movsd

; 144  : 		s.v3Position = v3CheckVector;

  00220	8d 75 e4	 lea	 esi, DWORD PTR _v3CheckVector$[ebp]
  00223	8d 7d a4	 lea	 edi, DWORD PTR _s$[ebp]
  00226	a5		 movsd
  00227	a5		 movsd
  00228	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00229	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$11[ebp]
  0022f	89 85 9c fd ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00235	8b 8d 9c fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 146  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  00240	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 111  : 	CameraCollisionChecker(CDynamicSphereInstance * pdsi, std::vector<D3DXVECTOR3>* pkVct_v3Position) : m_pdsi(pdsi), m_pkVct_v3Position(pkVct_v3Position), m_isBlocked(false) 

  00244	c6 85 64 fd ff
	ff 00		 mov	 BYTE PTR _kCameraCollisionChecker$14[ebp], 0
  0024b	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$11[ebp]
  00251	89 85 68 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$14[ebp+4], eax
  00257	8d 45 a4	 lea	 eax, DWORD PTR _s$[ebp]
  0025a	89 85 6c fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$14[ebp+8], eax

; 147  : 		CameraCollisionChecker kCameraCollisionChecker(&s, &kVct_kPosition);
; 148  : 		rkCullingMgr.ForInRange(aVector3d, m_fObjectCollisionRadius, &kCameraCollisionChecker);

  00260	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00266	f3 0f 10 80 f4
	02 00 00	 movss	 xmm0, DWORD PTR [eax+756]
  0026e	f3 0f 11 85 8c
	fd ff ff	 movss	 DWORD PTR _radius$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 113  : 		RangeTester<T> r(pFunc);

  00276	51		 push	 ecx
  00277	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  0027f	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00284	8d 85 64 fd ff
	ff		 lea	 eax, DWORD PTR _kCameraCollisionChecker$14[ebp]
  0028a	50		 push	 eax
  0028b	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR _r$7[ebp]
  00291	e8 00 00 00 00	 call	 ??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z ; RangeTester<CameraCollisionChecker>::RangeTester<CameraCollisionChecker>
  00296	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  0029a	8d 85 10 fd ff
	ff		 lea	 eax, DWORD PTR _r$7[ebp]
  002a0	50		 push	 eax
  002a1	51		 push	 ecx
  002a2	f3 0f 10 85 8c
	fd ff ff	 movss	 xmm0, DWORD PTR _radius$[ebp]
  002aa	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  002af	8d 45 cc	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  002b2	50		 push	 eax
  002b3	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _rkCullingMgr$[ebp]
  002b9	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  002bc	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest

; 115  : 	}

  002c1	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0

; 19   : 	{}

  002c5	c7 85 10 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _r$7[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  002cf	c7 85 10 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _r$7[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 149  : 		bool bCollide = kCameraCollisionChecker.m_isBlocked;

  002d9	8a 85 64 fd ff
	ff		 mov	 al, BYTE PTR _kCameraCollisionChecker$14[ebp]
  002df	88 85 f3 fe ff
	ff		 mov	 BYTE PTR _bCollide$34[ebp], al

; 150  : 
; 151  : 		if (bCollide)

  002e5	0f b6 85 f3 fe
	ff ff		 movzx	 eax, BYTE PTR _bCollide$34[ebp]
  002ec	85 c0		 test	 eax, eax
  002ee	0f 84 cc 02 00
	00		 je	 $LN9@ProcessBui

; 152  : 		{
; 153  : 			if (m_v3AngularVelocity.y > 0.0f)

  002f4	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002fa	f3 0f 10 80 28
	03 00 00	 movss	 xmm0, DWORD PTR [eax+808]
  00302	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00309	76 35		 jbe	 SHORT $LN3@ProcessBui

; 154  : 			{
; 155  : 				m_v3AngularVelocity.y = 0.0f;

  0030b	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00311	0f 57 c0	 xorps	 xmm0, xmm0
  00314	f3 0f 11 80 28
	03 00 00	 movss	 DWORD PTR [eax+808], xmm0

; 156  : 				m_v3AngularVelocity.z += fMoveAmountLarge;

  0031c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00322	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  0032a	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountLarge$[ebp]
  00332	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00338	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0
$LN3@ProcessBui:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  00340	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$11[ebp]
  00346	89 85 6c fe ff
	ff		 mov	 DWORD PTR __My_data$23[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  0034c	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR __My_data$23[ebp]
  00352	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$23[ebp]
  00358	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0035b	2b 01		 sub	 eax, DWORD PTR [ecx]
  0035d	99		 cdq
  0035e	6a 0c		 push	 12			; 0000000cH
  00360	59		 pop	 ecx
  00361	f7 f9		 idiv	 ecx
  00363	89 85 90 fd ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 161  : 			if (kVct_kPosition.size() > 1)

  00369	83 bd 90 fd ff
	ff 01		 cmp	 DWORD PTR $T16[ebp], 1
  00370	76 29		 jbe	 SHORT $LN4@ProcessBui

; 162  : 			{
; 163  : 	//			m_v3AngularVelocity.z = fMAX(fMoveAmountSmall, m_v3AngularVelocity.z);
; 164  :  				m_v3AngularVelocity.z += fMoveAmountSmall;

  00372	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00378	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  00380	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountSmall$[ebp]
  00388	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0038e	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0

; 165  : 			}

  00396	e9 25 02 00 00	 jmp	 $LN9@ProcessBui
$LN4@ProcessBui:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  0039b	8d 85 40 fd ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$11[ebp]
  003a1	89 85 94 fd ff
	ff		 mov	 DWORD PTR __My_data$17[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  003a7	33 c0		 xor	 eax, eax
  003a9	6b c0 0c	 imul	 eax, eax, 12
  003ac	8b 8d 94 fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$17[ebp]
  003b2	03 01		 add	 eax, DWORD PTR [ecx]
  003b4	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T28[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 168  : 				D3DXVec3Cross(&v3CheckVector, &(kVct_kPosition[0] - m_v3Eye), &m_v3View);

  003ba	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003c0	83 c0 30	 add	 eax, 48			; 00000030H
  003c3	89 85 70 fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  003c9	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T28[ebp]
  003cf	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  003d5	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  003d9	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  003dd	f3 0f 11 85 a0
	fd ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  003e5	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T28[ebp]
  003eb	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  003f1	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  003f6	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  003fb	f3 0f 11 85 a4
	fd ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00403	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T28[ebp]
  00409	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0040f	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00414	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  00419	f3 0f 11 85 a8
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00421	f3 0f 10 85 a0
	fd ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00429	f3 0f 11 45 c0	 movss	 DWORD PTR $T49[ebp], xmm0

; 181  :     y = fy;

  0042e	f3 0f 10 85 a4
	fd ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00436	f3 0f 11 45 c4	 movss	 DWORD PTR $T49[ebp+4], xmm0

; 182  :     z = fz;

  0043b	f3 0f 10 85 a8
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00443	f3 0f 11 45 c8	 movss	 DWORD PTR $T49[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 168  : 				D3DXVec3Cross(&v3CheckVector, &(kVct_kPosition[0] - m_v3Eye), &m_v3View);

  00448	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0044e	83 c0 54	 add	 eax, 84			; 00000054H
  00451	89 85 e8 fe ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  00457	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0045d	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR $T49[ebp+4]
  00462	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00467	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0046d	f3 0f 10 4d c8	 movss	 xmm1, DWORD PTR $T49[ebp+8]
  00472	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  00477	f3 0f 5c c1	 subss	 xmm0, xmm1
  0047b	f3 0f 11 85 14
	ff ff ff	 movss	 DWORD PTR _v$37[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  00483	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00489	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR $T49[ebp+8]
  0048e	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00492	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  00498	f3 0f 10 4d c0	 movss	 xmm1, DWORD PTR $T49[ebp]
  0049d	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  004a2	f3 0f 5c c1	 subss	 xmm0, xmm1
  004a6	f3 0f 11 85 18
	ff ff ff	 movss	 DWORD PTR _v$37[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  004ae	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  004b4	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR $T49[ebp]
  004b9	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  004be	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  004c4	f3 0f 10 4d c4	 movss	 xmm1, DWORD PTR $T49[ebp+4]
  004c9	f3 0f 59 08	 mulss	 xmm1, DWORD PTR [eax]
  004cd	f3 0f 5c c1	 subss	 xmm0, xmm1
  004d1	f3 0f 11 85 1c
	ff ff ff	 movss	 DWORD PTR _v$37[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  004d9	8d b5 14 ff ff
	ff		 lea	 esi, DWORD PTR _v$37[ebp]
  004df	8d 7d e4	 lea	 edi, DWORD PTR _v3CheckVector$[ebp]
  004e2	a5		 movsd
  004e3	a5		 movsd
  004e4	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 169  : 				float fDot = D3DXVec3Dot(&v3CheckVector, &m_v3Up);

  004e5	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  004eb	83 c0 48	 add	 eax, 72			; 00000048H
  004ee	89 85 c8 fe ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  004f4	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  004fa	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v3CheckVector$[ebp+8]
  004ff	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00504	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0050a	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _v3CheckVector$[ebp+4]
  0050f	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  00514	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0051a	f3 0f 10 55 e4	 movss	 xmm2, DWORD PTR _v3CheckVector$[ebp]
  0051f	f3 0f 59 10	 mulss	 xmm2, DWORD PTR [eax]
  00523	f3 0f 58 d1	 addss	 xmm2, xmm1
  00527	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 169  : 				float fDot = D3DXVec3Dot(&v3CheckVector, &m_v3Up);

  0052b	f3 0f 11 95 68
	fe ff ff	 movss	 DWORD PTR _fDot$22[ebp], xmm2

; 170  : 				if (fDot < 0)

  00533	0f 57 c0	 xorps	 xmm0, xmm0
  00536	0f 2f 85 68 fe
	ff ff		 comiss	 xmm0, DWORD PTR _fDot$22[ebp]
  0053d	76 26		 jbe	 SHORT $LN6@ProcessBui

; 171  : 				{
; 172  : 	//				m_v3AngularVelocity.x = fMIN(-fMoveAmountSmall, m_v3AngularVelocity.x);
; 173  :  					m_v3AngularVelocity.x -= fMoveAmountSmall;

  0053f	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00545	f3 0f 10 80 24
	03 00 00	 movss	 xmm0, DWORD PTR [eax+804]
  0054d	f3 0f 5c 85 f4
	fe ff ff	 subss	 xmm0, DWORD PTR _fMoveAmountSmall$[ebp]
  00555	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0055b	f3 0f 11 80 24
	03 00 00	 movss	 DWORD PTR [eax+804], xmm0

; 174  : 				}

  00563	eb 5b		 jmp	 SHORT $LN9@ProcessBui
$LN6@ProcessBui:

; 175  : 				else if(fDot > 0)

  00565	f3 0f 10 85 68
	fe ff ff	 movss	 xmm0, DWORD PTR _fDot$22[ebp]
  0056d	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00574	76 26		 jbe	 SHORT $LN8@ProcessBui

; 176  : 				{
; 177  : 	//				m_v3AngularVelocity.x = fMAX(fMoveAmountSmall, m_v3AngularVelocity.x);
; 178  :  					m_v3AngularVelocity.x += fMoveAmountSmall;

  00576	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0057c	f3 0f 10 80 24
	03 00 00	 movss	 xmm0, DWORD PTR [eax+804]
  00584	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountSmall$[ebp]
  0058c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00592	f3 0f 11 80 24
	03 00 00	 movss	 DWORD PTR [eax+804], xmm0

; 179  : 				}

  0059a	eb 24		 jmp	 SHORT $LN9@ProcessBui
$LN8@ProcessBui:

; 180  : 				else
; 181  : 				{
; 182  : 	//				m_v3AngularVelocity.z = fMAX(fMoveAmountSmall, m_v3AngularVelocity.z);
; 183  :  					m_v3AngularVelocity.z += fMoveAmountSmall;

  0059c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005a2	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  005aa	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountSmall$[ebp]
  005b2	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005b8	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0
$LN9@ProcessBui:

; 184  : 				}
; 185  : 			}
; 186  : 		}
; 187  : 	}

  005c0	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  005c4	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$11[ebp]
  005ca	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 191  : 		v3CheckVector = m_v3Eye + 2.0f * m_fObjectCollisionRadius * m_v3Up;

  005cf	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005d5	83 c0 48	 add	 eax, 72			; 00000048H
  005d8	89 85 c4 fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  005de	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005e4	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  005ec	f3 0f 59 80 f4
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+756]
  005f4	f3 0f 11 85 c0
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  005fc	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00602	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  0060a	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0060e	f3 0f 11 85 ac
	fd ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00616	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  0061c	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00624	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00629	f3 0f 11 85 b0
	fd ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00631	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00637	f3 0f 10 85 c0
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  0063f	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00644	f3 0f 11 85 b4
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0064c	f3 0f 10 85 ac
	fd ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00654	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR $T44[ebp], xmm0

; 181  :     y = fy;

  0065c	f3 0f 10 85 b0
	fd ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00664	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR $T44[ebp+4], xmm0

; 182  :     z = fz;

  0066c	f3 0f 10 85 b4
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00674	f3 0f 11 85 70
	ff ff ff	 movss	 DWORD PTR $T44[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 191  : 		v3CheckVector = m_v3Eye + 2.0f * m_fObjectCollisionRadius * m_v3Up;

  0067c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00682	83 c0 30	 add	 eax, 48			; 00000030H
  00685	89 85 bc fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  0068b	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00691	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00695	f3 0f 58 85 68
	ff ff ff	 addss	 xmm0, DWORD PTR $T44[ebp]
  0069d	f3 0f 11 85 b8
	fd ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  006a5	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006ab	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  006b0	f3 0f 58 85 6c
	ff ff ff	 addss	 xmm0, DWORD PTR $T44[ebp+4]
  006b8	f3 0f 11 85 bc
	fd ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  006c0	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006c6	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  006cb	f3 0f 58 85 70
	ff ff ff	 addss	 xmm0, DWORD PTR $T44[ebp+8]
  006d3	f3 0f 11 85 c0
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  006db	f3 0f 10 85 b8
	fd ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  006e3	f3 0f 11 85 20
	ff ff ff	 movss	 DWORD PTR $T38[ebp], xmm0

; 181  :     y = fy;

  006eb	f3 0f 10 85 bc
	fd ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  006f3	f3 0f 11 85 24
	ff ff ff	 movss	 DWORD PTR $T38[ebp+4], xmm0

; 182  :     z = fz;

  006fb	f3 0f 10 85 c0
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00703	f3 0f 11 85 28
	ff ff ff	 movss	 DWORD PTR $T38[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 191  : 		v3CheckVector = m_v3Eye + 2.0f * m_fObjectCollisionRadius * m_v3Up;

  0070b	8d b5 20 ff ff
	ff		 lea	 esi, DWORD PTR $T38[ebp]
  00711	8d 7d e4	 lea	 edi, DWORD PTR _v3CheckVector$[ebp]
  00714	a5		 movsd
  00715	a5		 movsd
  00716	a5		 movsd

; 192  : 		s.v3Position = v3CheckVector;

  00717	8d 75 e4	 lea	 esi, DWORD PTR _v3CheckVector$[ebp]
  0071a	8d 7d a4	 lea	 edi, DWORD PTR _s$[ebp]
  0071d	a5		 movsd
  0071e	a5		 movsd
  0071f	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00720	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$5[ebp]
  00726	89 85 c4 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0072c	8b 8d c4 fd ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00732	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 194  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  00737	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2

; 111  : 	CameraCollisionChecker(CDynamicSphereInstance * pdsi, std::vector<D3DXVECTOR3>* pkVct_v3Position) : m_pdsi(pdsi), m_pkVct_v3Position(pkVct_v3Position), m_isBlocked(false) 

  0073e	c6 85 28 fd ff
	ff 00		 mov	 BYTE PTR _kCameraCollisionChecker$9[ebp], 0
  00745	8d 85 f8 fc ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$5[ebp]
  0074b	89 85 2c fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$9[ebp+4], eax
  00751	8d 45 a4	 lea	 eax, DWORD PTR _s$[ebp]
  00754	89 85 30 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$9[ebp+8], eax

; 195  : 		CameraCollisionChecker kCameraCollisionChecker(&s, &kVct_kPosition);
; 196  : 		rkCullingMgr.ForInRange(aVector3d, m_fObjectCollisionRadius, &kCameraCollisionChecker);

  0075a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00760	f3 0f 10 80 f4
	02 00 00	 movss	 xmm0, DWORD PTR [eax+756]
  00768	f3 0f 11 85 98
	fd ff ff	 movss	 DWORD PTR _radius$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\CullingManager.h

; 113  : 		RangeTester<T> r(pFunc);

  00770	51		 push	 ecx
  00771	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@bf800000
  00779	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0077e	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR _kCameraCollisionChecker$9[ebp]
  00784	50		 push	 eax
  00785	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR _r$6[ebp]
  0078b	e8 00 00 00 00	 call	 ??0?$RangeTester@UCameraCollisionChecker@@@@QAE@PAUCameraCollisionChecker@@M@Z ; RangeTester<CameraCollisionChecker>::RangeTester<CameraCollisionChecker>
  00790	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 114  : 		m_Factory->RangeTest(p, radius, &r/*this*/);	

  00794	8d 85 04 fd ff
	ff		 lea	 eax, DWORD PTR _r$6[ebp]
  0079a	50		 push	 eax
  0079b	51		 push	 ecx
  0079c	f3 0f 10 85 98
	fd ff ff	 movss	 xmm0, DWORD PTR _radius$[ebp]
  007a4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007a9	8d 45 cc	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  007ac	50		 push	 eax
  007ad	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _rkCullingMgr$[ebp]
  007b3	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  007b6	e8 00 00 00 00	 call	 ?RangeTest@SpherePackFactory@@QAEXABVVector3d@@MPAVSpherePackCallback@@@Z ; SpherePackFactory::RangeTest

; 115  : 	}

  007bb	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 19   : 	{}

  007bf	c7 85 04 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _r$6[ebp], OFFSET ??_7?$RangeTester@UCameraCollisionChecker@@@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h

; 56   : 	virtual ~SpherePackCallback() {}

  007c9	c7 85 04 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR _r$6[ebp], OFFSET ??_7SpherePackCallback@@6B@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 197  : 		bool bCollide = kCameraCollisionChecker.m_isBlocked;

  007d3	8a 85 28 fd ff
	ff		 mov	 al, BYTE PTR _kCameraCollisionChecker$9[ebp]
  007d9	88 85 f2 fe ff
	ff		 mov	 BYTE PTR _bCollide$33[ebp], al

; 198  : 
; 199  : 		if (bCollide)

  007df	0f b6 85 f2 fe
	ff ff		 movzx	 eax, BYTE PTR _bCollide$33[ebp]
  007e6	85 c0		 test	 eax, eax
  007e8	74 3c		 je	 SHORT $LN10@ProcessBui

; 200  : 		{
; 201  : 			m_v3AngularVelocity.z = fMIN(-fMoveAmountSmall, m_v3AngularVelocity.y);

  007ea	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  007f0	51		 push	 ecx
  007f1	f3 0f 10 80 28
	03 00 00	 movss	 xmm0, DWORD PTR [eax+808]
  007f9	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  007fe	f3 0f 10 85 f4
	fe ff ff	 movss	 xmm0, DWORD PTR _fMoveAmountSmall$[ebp]
  00806	0f 57 05 00 00
	00 00		 xorps	 xmm0, DWORD PTR __xmm@80000000800000008000000080000000
  0080d	51		 push	 ecx
  0080e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00813	e8 00 00 00 00	 call	 ?fMIN@@YAMMM@Z		; fMIN
  00818	59		 pop	 ecx
  00819	59		 pop	 ecx
  0081a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00820	d9 98 2c 03 00
	00		 fstp	 DWORD PTR [eax+812]
$LN10@ProcessBui:

; 202  : 	// 		m_v3AngularVelocity.z -= 1.0f;
; 203  : 		}
; 204  : 	}

  00826	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0082a	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$5[ebp]
  00830	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 208  : 		v3CheckVector = m_v3Eye + 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  00835	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0083b	83 c0 60	 add	 eax, 96			; 00000060H
  0083e	89 85 b8 fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  00844	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0084a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  00852	f3 0f 59 80 f4
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+756]
  0085a	f3 0f 11 85 b4
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00862	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00868	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00870	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00874	f3 0f 11 85 48
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0087c	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00882	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  0088a	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  0088f	f3 0f 11 85 44
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00897	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  0089d	f3 0f 10 85 b4
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  008a5	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  008aa	f3 0f 11 85 40
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  008b2	f3 0f 10 85 48
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  008ba	f3 0f 11 85 74
	ff ff ff	 movss	 DWORD PTR $T45[ebp], xmm0

; 181  :     y = fy;

  008c2	f3 0f 10 85 44
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  008ca	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR $T45[ebp+4], xmm0

; 182  :     z = fz;

  008d2	f3 0f 10 85 40
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  008da	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR $T45[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 208  : 		v3CheckVector = m_v3Eye + 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  008e2	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008e8	83 c0 30	 add	 eax, 48			; 00000030H
  008eb	89 85 b0 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  008f1	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008f7	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  008fb	f3 0f 58 85 74
	ff ff ff	 addss	 xmm0, DWORD PTR $T45[ebp]
  00903	f3 0f 11 85 3c
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  0090b	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00911	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00916	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR $T45[ebp+4]
  0091e	f3 0f 11 85 38
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00926	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0092c	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00931	f3 0f 58 85 7c
	ff ff ff	 addss	 xmm0, DWORD PTR $T45[ebp+8]
  00939	f3 0f 11 85 34
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00941	f3 0f 10 85 3c
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00949	f3 0f 11 85 2c
	ff ff ff	 movss	 DWORD PTR $T39[ebp], xmm0

; 181  :     y = fy;

  00951	f3 0f 10 85 38
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00959	f3 0f 11 85 30
	ff ff ff	 movss	 DWORD PTR $T39[ebp+4], xmm0

; 182  :     z = fz;

  00961	f3 0f 10 85 34
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00969	f3 0f 11 85 34
	ff ff ff	 movss	 DWORD PTR $T39[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 208  : 		v3CheckVector = m_v3Eye + 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  00971	8d b5 2c ff ff
	ff		 lea	 esi, DWORD PTR $T39[ebp]
  00977	8d 7d e4	 lea	 edi, DWORD PTR _v3CheckVector$[ebp]
  0097a	a5		 movsd
  0097b	a5		 movsd
  0097c	a5		 movsd

; 209  : 		s.v3Position = v3CheckVector;

  0097d	8d 75 e4	 lea	 esi, DWORD PTR _v3CheckVector$[ebp]
  00980	8d 7d a4	 lea	 edi, DWORD PTR _s$[ebp]
  00983	a5		 movsd
  00984	a5		 movsd
  00985	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00986	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$4[ebp]
  0098c	89 85 30 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00992	8b 8d 30 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00998	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 211  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  0099d	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4

; 111  : 	CameraCollisionChecker(CDynamicSphereInstance * pdsi, std::vector<D3DXVECTOR3>* pkVct_v3Position) : m_pdsi(pdsi), m_pkVct_v3Position(pkVct_v3Position), m_isBlocked(false) 

  009a4	c6 85 70 fd ff
	ff 00		 mov	 BYTE PTR _kCameraCollisionChecker$15[ebp], 0
  009ab	8d 85 ec fc ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$4[ebp]
  009b1	89 85 74 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$15[ebp+4], eax
  009b7	8d 45 a4	 lea	 eax, DWORD PTR _s$[ebp]
  009ba	89 85 78 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$15[ebp+8], eax

; 212  : 		CameraCollisionChecker kCameraCollisionChecker(&s, &kVct_kPosition);
; 213  : 		rkCullingMgr.ForInRange(aVector3d, m_fObjectCollisionRadius, &kCameraCollisionChecker);

  009c0	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR _kCameraCollisionChecker$15[ebp]
  009c6	50		 push	 eax
  009c7	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009cd	51		 push	 ecx
  009ce	f3 0f 10 80 f4
	02 00 00	 movss	 xmm0, DWORD PTR [eax+756]
  009d6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  009db	8d 45 cc	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  009de	50		 push	 eax
  009df	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkCullingMgr$[ebp]
  009e5	e8 00 00 00 00	 call	 ??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z ; CCullingManager::ForInRange<CameraCollisionChecker>

; 214  : 		bool bCollide = kCameraCollisionChecker.m_isBlocked;

  009ea	8a 85 70 fd ff
	ff		 mov	 al, BYTE PTR _kCameraCollisionChecker$15[ebp]
  009f0	88 85 f1 fe ff
	ff		 mov	 BYTE PTR _bCollide$32[ebp], al

; 215  : 
; 216  : 		if (bCollide)

  009f6	0f b6 85 f1 fe
	ff ff		 movzx	 eax, BYTE PTR _bCollide$32[ebp]
  009fd	85 c0		 test	 eax, eax
  009ff	74 4c		 je	 SHORT $LN12@ProcessBui

; 217  : 		{
; 218  : 			if (m_v3AngularVelocity.x > 0.0f)

  00a01	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a07	f3 0f 10 80 24
	03 00 00	 movss	 xmm0, DWORD PTR [eax+804]
  00a0f	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00a16	76 35		 jbe	 SHORT $LN12@ProcessBui

; 219  : 			{
; 220  : 				m_v3AngularVelocity.x = 0.0f;

  00a18	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a1e	0f 57 c0	 xorps	 xmm0, xmm0
  00a21	f3 0f 11 80 24
	03 00 00	 movss	 DWORD PTR [eax+804], xmm0

; 221  : 				m_v3AngularVelocity.y += fMoveAmountLarge;

  00a29	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a2f	f3 0f 10 80 28
	03 00 00	 movss	 xmm0, DWORD PTR [eax+808]
  00a37	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountLarge$[ebp]
  00a3f	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a45	f3 0f 11 80 28
	03 00 00	 movss	 DWORD PTR [eax+808], xmm0
$LN12@ProcessBui:

; 222  : 			}
; 223  : 		}
; 224  : 	}

  00a4d	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00a51	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$4[ebp]
  00a57	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 228  : 		v3CheckVector = m_v3Eye - 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  00a5c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a62	83 c0 60	 add	 eax, 96			; 00000060H
  00a65	89 85 ac fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  00a6b	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a71	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40400000
  00a79	f3 0f 59 80 f4
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+756]
  00a81	f3 0f 11 85 a8
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00a89	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00a8f	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00a97	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00a9b	f3 0f 11 85 2c
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00aa3	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00aa9	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00ab1	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00ab6	f3 0f 11 85 28
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00abe	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00ac4	f3 0f 10 85 a8
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00acc	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00ad1	f3 0f 11 85 24
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00ad9	f3 0f 10 85 2c
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00ae1	f3 0f 11 45 80	 movss	 DWORD PTR $T46[ebp], xmm0

; 181  :     y = fy;

  00ae6	f3 0f 10 85 28
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00aee	f3 0f 11 45 84	 movss	 DWORD PTR $T46[ebp+4], xmm0

; 182  :     z = fz;

  00af3	f3 0f 10 85 24
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00afb	f3 0f 11 45 88	 movss	 DWORD PTR $T46[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 228  : 		v3CheckVector = m_v3Eye - 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  00b00	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b06	83 c0 30	 add	 eax, 48			; 00000030H
  00b09	89 85 a4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00b0f	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b15	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00b19	f3 0f 5c 45 80	 subss	 xmm0, DWORD PTR $T46[ebp]
  00b1e	f3 0f 11 85 20
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00b26	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b2c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00b31	f3 0f 5c 45 84	 subss	 xmm0, DWORD PTR $T46[ebp+4]
  00b36	f3 0f 11 85 1c
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00b3e	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b44	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00b49	f3 0f 5c 45 88	 subss	 xmm0, DWORD PTR $T46[ebp+8]
  00b4e	f3 0f 11 85 18
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00b56	f3 0f 10 85 20
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00b5e	f3 0f 11 85 38
	ff ff ff	 movss	 DWORD PTR $T40[ebp], xmm0

; 181  :     y = fy;

  00b66	f3 0f 10 85 1c
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00b6e	f3 0f 11 85 3c
	ff ff ff	 movss	 DWORD PTR $T40[ebp+4], xmm0

; 182  :     z = fz;

  00b76	f3 0f 10 85 18
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00b7e	f3 0f 11 85 40
	ff ff ff	 movss	 DWORD PTR $T40[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 228  : 		v3CheckVector = m_v3Eye - 3.0f * m_fObjectCollisionRadius * m_v3Cross;

  00b86	8d b5 38 ff ff
	ff		 lea	 esi, DWORD PTR $T40[ebp]
  00b8c	8d 7d e4	 lea	 edi, DWORD PTR _v3CheckVector$[ebp]
  00b8f	a5		 movsd
  00b90	a5		 movsd
  00b91	a5		 movsd

; 229  : 		s.v3Position = v3CheckVector;

  00b92	8d 75 e4	 lea	 esi, DWORD PTR _v3CheckVector$[ebp]
  00b95	8d 7d a4	 lea	 edi, DWORD PTR _s$[ebp]
  00b98	a5		 movsd
  00b99	a5		 movsd
  00b9a	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00b9b	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$3[ebp]
  00ba1	89 85 14 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00ba7	8b 85 14 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00bad	89 85 a0 fe ff
	ff		 mov	 DWORD PTR _this$27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00bb3	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _this$27[ebp]
  00bb9	83 20 00	 and	 DWORD PTR [eax], 0
  00bbc	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _this$27[ebp]
  00bc2	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00bc6	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR _this$27[ebp]
  00bcc	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 231  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  00bd0	c7 45 fc 05 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 5

; 111  : 	CameraCollisionChecker(CDynamicSphereInstance * pdsi, std::vector<D3DXVECTOR3>* pkVct_v3Position) : m_pdsi(pdsi), m_pkVct_v3Position(pkVct_v3Position), m_isBlocked(false) 

  00bd7	c6 85 58 fd ff
	ff 00		 mov	 BYTE PTR _kCameraCollisionChecker$13[ebp], 0
  00bde	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$3[ebp]
  00be4	89 85 5c fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$13[ebp+4], eax
  00bea	8d 45 a4	 lea	 eax, DWORD PTR _s$[ebp]
  00bed	89 85 60 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$13[ebp+8], eax

; 232  : 		CameraCollisionChecker kCameraCollisionChecker(&s, &kVct_kPosition);
; 233  : 		rkCullingMgr.ForInRange(aVector3d, m_fObjectCollisionRadius, &kCameraCollisionChecker);

  00bf3	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR _kCameraCollisionChecker$13[ebp]
  00bf9	50		 push	 eax
  00bfa	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c00	51		 push	 ecx
  00c01	f3 0f 10 80 f4
	02 00 00	 movss	 xmm0, DWORD PTR [eax+756]
  00c09	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00c0e	8d 45 cc	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  00c11	50		 push	 eax
  00c12	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkCullingMgr$[ebp]
  00c18	e8 00 00 00 00	 call	 ??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z ; CCullingManager::ForInRange<CameraCollisionChecker>

; 234  : 		bool bCollide = kCameraCollisionChecker.m_isBlocked;

  00c1d	8a 85 58 fd ff
	ff		 mov	 al, BYTE PTR _kCameraCollisionChecker$13[ebp]
  00c23	88 85 f0 fe ff
	ff		 mov	 BYTE PTR _bCollide$31[ebp], al

; 235  : 
; 236  : 		if (bCollide)

  00c29	0f b6 85 f0 fe
	ff ff		 movzx	 eax, BYTE PTR _bCollide$31[ebp]
  00c30	85 c0		 test	 eax, eax
  00c32	74 47		 je	 SHORT $LN14@ProcessBui

; 237  : 		{
; 238  : 			if (m_v3AngularVelocity.x < 0.0f)

  00c34	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c3a	0f 57 c0	 xorps	 xmm0, xmm0
  00c3d	0f 2f 80 24 03
	00 00		 comiss	 xmm0, DWORD PTR [eax+804]
  00c44	76 35		 jbe	 SHORT $LN14@ProcessBui

; 239  : 			{
; 240  : 				m_v3AngularVelocity.x = 0.0f;

  00c46	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c4c	0f 57 c0	 xorps	 xmm0, xmm0
  00c4f	f3 0f 11 80 24
	03 00 00	 movss	 DWORD PTR [eax+804], xmm0

; 241  : 				m_v3AngularVelocity.y += fMoveAmountLarge;

  00c57	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c5d	f3 0f 10 80 28
	03 00 00	 movss	 xmm0, DWORD PTR [eax+808]
  00c65	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountLarge$[ebp]
  00c6d	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c73	f3 0f 11 80 28
	03 00 00	 movss	 DWORD PTR [eax+808], xmm0
$LN14@ProcessBui:

; 242  : 			}
; 243  : 		}
; 244  : 	}

  00c7b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00c7f	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$3[ebp]
  00c85	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 248  : 		v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  00c8a	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c90	83 c0 48	 add	 eax, 72			; 00000048H
  00c93	89 85 9c fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  00c99	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00c9f	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00ca7	f3 0f 59 80 f0
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+752]
  00caf	f3 0f 11 85 98
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00cb7	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00cbd	f3 0f 10 85 98
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00cc5	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00cc9	f3 0f 11 85 10
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00cd1	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00cd7	f3 0f 10 85 98
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00cdf	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00ce4	f3 0f 11 85 0c
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00cec	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00cf2	f3 0f 10 85 98
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00cfa	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00cff	f3 0f 11 85 08
	fe ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00d07	f3 0f 10 85 10
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00d0f	f3 0f 11 45 8c	 movss	 DWORD PTR $T47[ebp], xmm0

; 181  :     y = fy;

  00d14	f3 0f 10 85 0c
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00d1c	f3 0f 11 45 90	 movss	 DWORD PTR $T47[ebp+4], xmm0

; 182  :     z = fz;

  00d21	f3 0f 10 85 08
	fe ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00d29	f3 0f 11 45 94	 movss	 DWORD PTR $T47[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 248  : 		v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  00d2e	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d34	83 c0 30	 add	 eax, 48			; 00000030H
  00d37	89 85 94 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00d3d	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d43	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00d47	f3 0f 5c 45 8c	 subss	 xmm0, DWORD PTR $T47[ebp]
  00d4c	f3 0f 11 85 04
	fe ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00d54	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d5a	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00d5f	f3 0f 5c 45 90	 subss	 xmm0, DWORD PTR $T47[ebp+4]
  00d64	f3 0f 11 85 00
	fe ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00d6c	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00d72	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00d77	f3 0f 5c 45 94	 subss	 xmm0, DWORD PTR $T47[ebp+8]
  00d7c	f3 0f 11 85 fc
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00d84	f3 0f 10 85 04
	fe ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00d8c	f3 0f 11 85 44
	ff ff ff	 movss	 DWORD PTR $T41[ebp], xmm0

; 181  :     y = fy;

  00d94	f3 0f 10 85 00
	fe ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00d9c	f3 0f 11 85 48
	ff ff ff	 movss	 DWORD PTR $T41[ebp+4], xmm0

; 182  :     z = fz;

  00da4	f3 0f 10 85 fc
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00dac	f3 0f 11 85 4c
	ff ff ff	 movss	 DWORD PTR $T41[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 248  : 		v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  00db4	8d b5 44 ff ff
	ff		 lea	 esi, DWORD PTR $T41[ebp]
  00dba	8d 7d e4	 lea	 edi, DWORD PTR _v3CheckVector$[ebp]
  00dbd	a5		 movsd
  00dbe	a5		 movsd
  00dbf	a5		 movsd

; 249  : 		s.v3Position = v3CheckVector;

  00dc0	8d 75 e4	 lea	 esi, DWORD PTR _v3CheckVector$[ebp]
  00dc3	8d 7d a4	 lea	 edi, DWORD PTR _s$[ebp]
  00dc6	a5		 movsd
  00dc7	a5		 movsd
  00dc8	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00dc9	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$2[ebp]
  00dcf	89 85 f8 fd ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00dd5	8b 85 f8 fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ddb	89 85 90 fe ff
	ff		 mov	 DWORD PTR _this$26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00de1	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _this$26[ebp]
  00de7	83 20 00	 and	 DWORD PTR [eax], 0
  00dea	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _this$26[ebp]
  00df0	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00df4	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR _this$26[ebp]
  00dfa	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 251  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  00dfe	c7 45 fc 06 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 6

; 111  : 	CameraCollisionChecker(CDynamicSphereInstance * pdsi, std::vector<D3DXVECTOR3>* pkVct_v3Position) : m_pdsi(pdsi), m_pkVct_v3Position(pkVct_v3Position), m_isBlocked(false) 

  00e05	c6 85 4c fd ff
	ff 00		 mov	 BYTE PTR _kCameraCollisionChecker$12[ebp], 0
  00e0c	8d 85 d4 fc ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$2[ebp]
  00e12	89 85 50 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$12[ebp+4], eax
  00e18	8d 45 a4	 lea	 eax, DWORD PTR _s$[ebp]
  00e1b	89 85 54 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$12[ebp+8], eax

; 252  : 		CameraCollisionChecker kCameraCollisionChecker(&s, &kVct_kPosition);
; 253  : 		rkCullingMgr.ForInRange(aVector3d, m_fObjectCollisionRadius, &kCameraCollisionChecker);

  00e21	8d 85 4c fd ff
	ff		 lea	 eax, DWORD PTR _kCameraCollisionChecker$12[ebp]
  00e27	50		 push	 eax
  00e28	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e2e	51		 push	 ecx
  00e2f	f3 0f 10 80 f4
	02 00 00	 movss	 xmm0, DWORD PTR [eax+756]
  00e37	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e3c	8d 45 cc	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  00e3f	50		 push	 eax
  00e40	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkCullingMgr$[ebp]
  00e46	e8 00 00 00 00	 call	 ??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z ; CCullingManager::ForInRange<CameraCollisionChecker>

; 254  : 		bool bCollide = kCameraCollisionChecker.m_isBlocked;

  00e4b	8a 85 4c fd ff
	ff		 mov	 al, BYTE PTR _kCameraCollisionChecker$12[ebp]
  00e51	88 85 ef fe ff
	ff		 mov	 BYTE PTR _bCollide$30[ebp], al

; 255  : 
; 256  : 		if (bCollide)

  00e57	0f b6 85 ef fe
	ff ff		 movzx	 eax, BYTE PTR _bCollide$30[ebp]
  00e5e	85 c0		 test	 eax, eax
  00e60	74 47		 je	 SHORT $LN16@ProcessBui

; 257  : 		{
; 258  : 			if (m_v3AngularVelocity.z < 0.0f)

  00e62	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e68	0f 57 c0	 xorps	 xmm0, xmm0
  00e6b	0f 2f 80 2c 03
	00 00		 comiss	 xmm0, DWORD PTR [eax+812]
  00e72	76 35		 jbe	 SHORT $LN16@ProcessBui

; 259  : 			{
; 260  : 				m_v3AngularVelocity.z = 0.0f;

  00e74	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e7a	0f 57 c0	 xorps	 xmm0, xmm0
  00e7d	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0

; 261  : 				m_v3AngularVelocity.y += fMoveAmountLarge;

  00e85	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00e8b	f3 0f 10 80 28
	03 00 00	 movss	 xmm0, DWORD PTR [eax+808]
  00e93	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountLarge$[ebp]
  00e9b	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ea1	f3 0f 11 80 28
	03 00 00	 movss	 DWORD PTR [eax+808], xmm0
$LN16@ProcessBui:

; 262  : 			}
; 263  : 		}
; 264  : 	}

  00ea9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  00ead	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$2[ebp]
  00eb3	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 268  : 		v3CheckVector = m_v3Eye + 4.0f * m_fObjectCollisionRadius * m_v3View;

  00eb8	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ebe	83 c0 54	 add	 eax, 84			; 00000054H
  00ec1	89 85 8c fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
  00ec7	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ecd	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40800000
  00ed5	f3 0f 59 80 f4
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+756]
  00edd	f3 0f 11 85 88
	fe ff ff	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00ee5	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00eeb	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00ef3	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00ef7	f3 0f 11 85 f4
	fd ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00eff	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00f05	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00f0d	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00f12	f3 0f 11 85 f0
	fd ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00f1a	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR _v$[ebp]
  00f20	f3 0f 10 85 88
	fe ff ff	 movss	 xmm0, DWORD PTR _f$[ebp]
  00f28	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00f2d	f3 0f 11 85 ec
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00f35	f3 0f 10 85 f4
	fd ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00f3d	f3 0f 11 45 98	 movss	 DWORD PTR $T48[ebp], xmm0

; 181  :     y = fy;

  00f42	f3 0f 10 85 f0
	fd ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00f4a	f3 0f 11 45 9c	 movss	 DWORD PTR $T48[ebp+4], xmm0

; 182  :     z = fz;

  00f4f	f3 0f 10 85 ec
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00f57	f3 0f 11 45 a0	 movss	 DWORD PTR $T48[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 268  : 		v3CheckVector = m_v3Eye + 4.0f * m_fObjectCollisionRadius * m_v3View;

  00f5c	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00f62	83 c0 30	 add	 eax, 48			; 00000030H
  00f65	89 85 84 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  00f6b	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00f71	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00f75	f3 0f 58 45 98	 addss	 xmm0, DWORD PTR $T48[ebp]
  00f7a	f3 0f 11 85 e8
	fd ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  00f82	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00f88	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  00f8d	f3 0f 58 45 9c	 addss	 xmm0, DWORD PTR $T48[ebp+4]
  00f92	f3 0f 11 85 e4
	fd ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  00f9a	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00fa0	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  00fa5	f3 0f 58 45 a0	 addss	 xmm0, DWORD PTR $T48[ebp+8]
  00faa	f3 0f 11 85 e0
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  00fb2	f3 0f 10 85 e8
	fd ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00fba	f3 0f 11 85 50
	ff ff ff	 movss	 DWORD PTR $T42[ebp], xmm0

; 181  :     y = fy;

  00fc2	f3 0f 10 85 e4
	fd ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  00fca	f3 0f 11 85 54
	ff ff ff	 movss	 DWORD PTR $T42[ebp+4], xmm0

; 182  :     z = fz;

  00fd2	f3 0f 10 85 e0
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00fda	f3 0f 11 85 58
	ff ff ff	 movss	 DWORD PTR $T42[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 268  : 		v3CheckVector = m_v3Eye + 4.0f * m_fObjectCollisionRadius * m_v3View;

  00fe2	8d b5 50 ff ff
	ff		 lea	 esi, DWORD PTR $T42[ebp]
  00fe8	8d 7d e4	 lea	 edi, DWORD PTR _v3CheckVector$[ebp]
  00feb	a5		 movsd
  00fec	a5		 movsd
  00fed	a5		 movsd

; 269  : 		s.v3Position = v3CheckVector;

  00fee	8d 75 e4	 lea	 esi, DWORD PTR _v3CheckVector$[ebp]
  00ff1	8d 7d a4	 lea	 edi, DWORD PTR _s$[ebp]
  00ff4	a5		 movsd
  00ff5	a5		 movsd
  00ff6	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 445  :     vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00ff7	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$10[ebp]
  00ffd	89 85 dc fd ff
	ff		 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  01003	8b 85 dc fd ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01009	89 85 80 fe ff
	ff		 mov	 DWORD PTR _this$25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  0100f	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$25[ebp]
  01015	83 20 00	 and	 DWORD PTR [eax], 0
  01018	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$25[ebp]
  0101e	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  01022	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR _this$25[ebp]
  01028	83 60 08 00	 and	 DWORD PTR [eax+8], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 271  : 		std::vector<D3DXVECTOR3> kVct_kPosition;

  0102c	c7 45 fc 07 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 7

; 111  : 	CameraCollisionChecker(CDynamicSphereInstance * pdsi, std::vector<D3DXVECTOR3>* pkVct_v3Position) : m_pdsi(pdsi), m_pkVct_v3Position(pkVct_v3Position), m_isBlocked(false) 

  01033	c6 85 1c fd ff
	ff 00		 mov	 BYTE PTR _kCameraCollisionChecker$8[ebp], 0
  0103a	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$10[ebp]
  01040	89 85 20 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$8[ebp+4], eax
  01046	8d 45 a4	 lea	 eax, DWORD PTR _s$[ebp]
  01049	89 85 24 fd ff
	ff		 mov	 DWORD PTR _kCameraCollisionChecker$8[ebp+8], eax

; 272  : 		CameraCollisionChecker kCameraCollisionChecker(&s, &kVct_kPosition);
; 273  : 		rkCullingMgr.ForInRange(aVector3d, m_fObjectCollisionRadius, &kCameraCollisionChecker);

  0104f	8d 85 1c fd ff
	ff		 lea	 eax, DWORD PTR _kCameraCollisionChecker$8[ebp]
  01055	50		 push	 eax
  01056	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0105c	51		 push	 ecx
  0105d	f3 0f 10 80 f4
	02 00 00	 movss	 xmm0, DWORD PTR [eax+756]
  01065	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0106a	8d 45 cc	 lea	 eax, DWORD PTR _aVector3d$[ebp]
  0106d	50		 push	 eax
  0106e	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _rkCullingMgr$[ebp]
  01074	e8 00 00 00 00	 call	 ??$ForInRange@UCameraCollisionChecker@@@CCullingManager@@QAEXABVVector3d@@MPAUCameraCollisionChecker@@@Z ; CCullingManager::ForInRange<CameraCollisionChecker>

; 274  : 		bool bCollide = kCameraCollisionChecker.m_isBlocked;

  01079	8a 85 1c fd ff
	ff		 mov	 al, BYTE PTR _kCameraCollisionChecker$8[ebp]
  0107f	88 85 ee fe ff
	ff		 mov	 BYTE PTR _bCollide$29[ebp], al

; 275  : 
; 276  : 		if (bCollide)

  01085	0f b6 85 ee fe
	ff ff		 movzx	 eax, BYTE PTR _bCollide$29[ebp]
  0108c	85 c0		 test	 eax, eax
  0108e	0f 84 c7 02 00
	00		 je	 $LN24@ProcessBui

; 277  : 		{
; 278  : 			if (m_v3AngularVelocity.y < 0.0f)

  01094	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0109a	0f 57 c0	 xorps	 xmm0, xmm0
  0109d	0f 2f 80 28 03
	00 00		 comiss	 xmm0, DWORD PTR [eax+808]
  010a4	76 35		 jbe	 SHORT $LN18@ProcessBui

; 279  : 			{
; 280  : 				m_v3AngularVelocity.y = 0.0f;

  010a6	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  010ac	0f 57 c0	 xorps	 xmm0, xmm0
  010af	f3 0f 11 80 28
	03 00 00	 movss	 DWORD PTR [eax+808], xmm0

; 281  : 				m_v3AngularVelocity.z += fMoveAmountLarge;

  010b7	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  010bd	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  010c5	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountLarge$[ebp]
  010cd	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  010d3	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0
$LN18@ProcessBui:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1483 :         auto& _My_data = _Mypair._Myval2;

  010db	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$10[ebp]
  010e1	89 85 64 fe ff
	ff		 mov	 DWORD PTR __My_data$21[ebp], eax

; 1484 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  010e7	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR __My_data$21[ebp]
  010ed	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR __My_data$21[ebp]
  010f3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  010f6	2b 01		 sub	 eax, DWORD PTR [ecx]
  010f8	99		 cdq
  010f9	6a 0c		 push	 12			; 0000000cH
  010fb	59		 pop	 ecx
  010fc	f7 f9		 idiv	 ecx
  010fe	89 85 d8 fd ff
	ff		 mov	 DWORD PTR $T19[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 284  : 			if (kVct_kPosition.size() > 1)

  01104	83 bd d8 fd ff
	ff 01		 cmp	 DWORD PTR $T19[ebp], 1
  0110b	76 29		 jbe	 SHORT $LN19@ProcessBui

; 285  : 			{
; 286  : 	//			m_v3AngularVelocity.z = fMAX(fMoveAmountLarge, m_v3AngularVelocity.z);
; 287  :  				m_v3AngularVelocity.z += fMoveAmountLarge;

  0110d	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01113	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  0111b	f3 0f 58 85 e0
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountLarge$[ebp]
  01123	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01129	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0

; 288  : 			}

  01131	e9 25 02 00 00	 jmp	 $LN24@ProcessBui
$LN19@ProcessBui:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1498 :         auto& _My_data = _Mypair._Myval2;

  01136	8d 85 34 fd ff
	ff		 lea	 eax, DWORD PTR _kVct_kPosition$10[ebp]
  0113c	89 85 d4 fd ff
	ff		 mov	 DWORD PTR __My_data$18[ebp], eax

; 1499 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1500 :         _STL_VERIFY(
; 1501 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1502 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1503 : 
; 1504 :         return _My_data._Myfirst[_Pos];

  01142	33 c0		 xor	 eax, eax
  01144	6b c0 0c	 imul	 eax, eax, 12
  01147	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR __My_data$18[ebp]
  0114d	03 01		 add	 eax, DWORD PTR [ecx]
  0114f	89 85 7c fe ff
	ff		 mov	 DWORD PTR $T24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 291  : 				D3DXVec3Cross(&v3CheckVector, &(kVct_kPosition[0] - m_v3Eye), &m_v3View);

  01155	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0115b	83 c0 30	 add	 eax, 48			; 00000030H
  0115e	89 85 78 fe ff
	ff		 mov	 DWORD PTR _v$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  01164	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  0116a	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  01170	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  01174	f3 0f 5c 01	 subss	 xmm0, DWORD PTR [ecx]
  01178	f3 0f 11 85 d0
	fd ff ff	 movss	 DWORD PTR _fx$[ebp], xmm0
  01180	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  01186	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  0118c	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  01191	f3 0f 5c 41 04	 subss	 xmm0, DWORD PTR [ecx+4]
  01196	f3 0f 11 85 cc
	fd ff ff	 movss	 DWORD PTR _fy$[ebp], xmm0
  0119e	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  011a4	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR _v$[ebp]
  011aa	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  011af	f3 0f 5c 41 08	 subss	 xmm0, DWORD PTR [ecx+8]
  011b4	f3 0f 11 85 c8
	fd ff ff	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  011bc	f3 0f 10 85 d0
	fd ff ff	 movss	 xmm0, DWORD PTR _fx$[ebp]
  011c4	f3 0f 11 45 d8	 movss	 DWORD PTR $T50[ebp], xmm0

; 181  :     y = fy;

  011c9	f3 0f 10 85 cc
	fd ff ff	 movss	 xmm0, DWORD PTR _fy$[ebp]
  011d1	f3 0f 11 45 dc	 movss	 DWORD PTR $T50[ebp+4], xmm0

; 182  :     z = fz;

  011d6	f3 0f 10 85 c8
	fd ff ff	 movss	 xmm0, DWORD PTR _fz$[ebp]
  011de	f3 0f 11 45 e0	 movss	 DWORD PTR $T50[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 291  : 				D3DXVec3Cross(&v3CheckVector, &(kVct_kPosition[0] - m_v3Eye), &m_v3View);

  011e3	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  011e9	83 c0 54	 add	 eax, 84			; 00000054H
  011ec	89 85 dc fe ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1277 :     v.x = pV1->y * pV2->z - pV1->z * pV2->y;

  011f2	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  011f8	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR $T50[ebp+4]
  011fd	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  01202	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  01208	f3 0f 10 4d e0	 movss	 xmm1, DWORD PTR $T50[ebp+8]
  0120d	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  01212	f3 0f 5c c1	 subss	 xmm0, xmm1
  01216	f3 0f 11 85 fc
	fe ff ff	 movss	 DWORD PTR _v$35[ebp], xmm0

; 1278 :     v.y = pV1->z * pV2->x - pV1->x * pV2->z;

  0121e	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  01224	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR $T50[ebp+8]
  01229	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  0122d	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  01233	f3 0f 10 4d d8	 movss	 xmm1, DWORD PTR $T50[ebp]
  01238	f3 0f 59 48 08	 mulss	 xmm1, DWORD PTR [eax+8]
  0123d	f3 0f 5c c1	 subss	 xmm0, xmm1
  01241	f3 0f 11 85 00
	ff ff ff	 movss	 DWORD PTR _v$35[ebp+4], xmm0

; 1279 :     v.z = pV1->x * pV2->y - pV1->y * pV2->x;

  01249	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0124f	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR $T50[ebp]
  01254	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  01259	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  0125f	f3 0f 10 4d dc	 movss	 xmm1, DWORD PTR $T50[ebp+4]
  01264	f3 0f 59 08	 mulss	 xmm1, DWORD PTR [eax]
  01268	f3 0f 5c c1	 subss	 xmm0, xmm1
  0126c	f3 0f 11 85 04
	ff ff ff	 movss	 DWORD PTR _v$35[ebp+8], xmm0

; 1280 : 
; 1281 :     *pOut = v;

  01274	8d b5 fc fe ff
	ff		 lea	 esi, DWORD PTR _v$35[ebp]
  0127a	8d 7d e4	 lea	 edi, DWORD PTR _v3CheckVector$[ebp]
  0127d	a5		 movsd
  0127e	a5		 movsd
  0127f	a5		 movsd
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 292  : 				float fDot = D3DXVec3Dot(&v3CheckVector, &m_v3Up);

  01280	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01286	83 c0 48	 add	 eax, 72			; 00000048H
  01289	89 85 74 fe ff
	ff		 mov	 DWORD PTR _pV2$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1264 :     return pV1->x * pV2->x + pV1->y * pV2->y + pV1->z * pV2->z;

  0128f	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  01295	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _v3CheckVector$[ebp+8]
  0129a	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  0129f	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  012a5	f3 0f 10 4d e8	 movss	 xmm1, DWORD PTR _v3CheckVector$[ebp+4]
  012aa	f3 0f 59 48 04	 mulss	 xmm1, DWORD PTR [eax+4]
  012af	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR _pV2$[ebp]
  012b5	f3 0f 10 55 e4	 movss	 xmm2, DWORD PTR _v3CheckVector$[ebp]
  012ba	f3 0f 59 10	 mulss	 xmm2, DWORD PTR [eax]
  012be	f3 0f 58 d1	 addss	 xmm2, xmm1
  012c2	f3 0f 58 d0	 addss	 xmm2, xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 292  : 				float fDot = D3DXVec3Dot(&v3CheckVector, &m_v3Up);

  012c6	f3 0f 11 95 60
	fe ff ff	 movss	 DWORD PTR _fDot$20[ebp], xmm2

; 293  : 				if (fDot < 0)

  012ce	0f 57 c0	 xorps	 xmm0, xmm0
  012d1	0f 2f 85 60 fe
	ff ff		 comiss	 xmm0, DWORD PTR _fDot$20[ebp]
  012d8	76 26		 jbe	 SHORT $LN21@ProcessBui

; 294  : 				{
; 295  : 	// 				m_v3AngularVelocity.x = fMIN(-fMoveAmountSmall, m_v3AngularVelocity.x);
; 296  : 					m_v3AngularVelocity.x -= fMoveAmountSmall;

  012da	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  012e0	f3 0f 10 80 24
	03 00 00	 movss	 xmm0, DWORD PTR [eax+804]
  012e8	f3 0f 5c 85 f4
	fe ff ff	 subss	 xmm0, DWORD PTR _fMoveAmountSmall$[ebp]
  012f0	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  012f6	f3 0f 11 80 24
	03 00 00	 movss	 DWORD PTR [eax+804], xmm0

; 297  : 				}

  012fe	eb 5b		 jmp	 SHORT $LN24@ProcessBui
$LN21@ProcessBui:

; 298  : 				else if(fDot > 0)

  01300	f3 0f 10 85 60
	fe ff ff	 movss	 xmm0, DWORD PTR _fDot$20[ebp]
  01308	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  0130f	76 26		 jbe	 SHORT $LN23@ProcessBui

; 299  : 				{
; 300  : 	// 				m_v3AngularVelocity.x = fMAX(fMoveAmountSmall, m_v3AngularVelocity.x);
; 301  : 					m_v3AngularVelocity.x += fMoveAmountSmall;

  01311	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01317	f3 0f 10 80 24
	03 00 00	 movss	 xmm0, DWORD PTR [eax+804]
  0131f	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountSmall$[ebp]
  01327	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0132d	f3 0f 11 80 24
	03 00 00	 movss	 DWORD PTR [eax+804], xmm0

; 302  : 				}

  01335	eb 24		 jmp	 SHORT $LN24@ProcessBui
$LN23@ProcessBui:

; 303  : 				else
; 304  : 				{
; 305  : 	//				m_v3AngularVelocity.z = fMAX(fMoveAmountSmall, m_v3AngularVelocity.z);
; 306  : 					m_v3AngularVelocity.z += fMoveAmountSmall;

  01337	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0133d	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  01345	f3 0f 58 85 f4
	fe ff ff	 addss	 xmm0, DWORD PTR _fMoveAmountSmall$[ebp]
  0134d	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  01353	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0
$LN24@ProcessBui:

; 307  : 				}
; 308  : 			}
; 309  : 		}
; 310  : 	}

  0135b	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 673  :         _Tidy();

  0135f	8d 8d 34 fd ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$10[ebp]
  01365	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 311  : }

  0136a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0136d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01374	59		 pop	 ecx
  01375	5f		 pop	 edi
  01376	5e		 pop	 esi
  01377	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0137a	33 cd		 xor	 ecx, ebp
  0137c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  01381	c9		 leave
  01382	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$0:
  00000	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$11[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$10:
  0000b	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR _r$7[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$1:
  00016	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$5[ebp]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$20:
  00021	8d 8d 04 fd ff
	ff		 lea	 ecx, DWORD PTR _r$6[ebp]
  00027	e9 00 00 00 00	 jmp	 ??1?$RangeTester@UCameraCollisionChecker@@@@UAE@XZ ; RangeTester<CameraCollisionChecker>::~RangeTester<CameraCollisionChecker>
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$2:
  0002c	8d 8d ec fc ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$4[ebp]
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$3:
  00037	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$3[ebp]
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$4:
  00042	8d 8d d4 fc ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$2[ebp]
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
__unwindfunclet$?ProcessBuildingCollision@CCamera@@AAEXXZ$5:
  0004d	8d 8d 34 fd ff
	ff		 lea	 ecx, DWORD PTR _kVct_kPosition$10[ebp]
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
  00058	cc		 int	 3
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
__ehhandler$?ProcessBuildingCollision@CCamera@@AAEXXZ:
  0005d	90		 npad	 1
  0005e	90		 npad	 1
  0005f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00063	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00066	8b 8a d4 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-812]
  0006c	33 c8		 xor	 ecx, eax
  0006e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00073	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00076	33 c8		 xor	 ecx, eax
  00078	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?ProcessBuildingCollision@CCamera@@AAEXXZ
  00082	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?ProcessBuildingCollision@CCamera@@AAEXXZ ENDP		; CCamera::ProcessBuildingCollision
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
;	COMDAT ?ProcessTerrainCollision@CCamera@@AAEXXZ
_TEXT	SEGMENT
_fx$ = -128						; size = 4
_fz$ = -124						; size = 4
__X$ = -120						; size = 4
__X$ = -116						; size = 4
$T1 = -112						; size = 4
_fz$ = -108						; size = 4
$T2 = -104						; size = 4
_fx$ = -100						; size = 4
_fz$ = -96						; size = 4
_fy$ = -92						; size = 4
_fy$ = -88						; size = 4
_fz$ = -84						; size = 4
_fy$ = -80						; size = 4
_fx$ = -76						; size = 4
$T3 = -72						; size = 4
__X$ = -68						; size = 4
_fz$ = -64						; size = 4
_fy$ = -60						; size = 4
_fx$ = -56						; size = 4
_fz$ = -52						; size = 4
_fy$ = -48						; size = 4
_fx$ = -44						; size = 4
_fy$ = -40						; size = 4
_fx$ = -36						; size = 4
_fz$ = -32						; size = 4
_fy$ = -28						; size = 4
_fx$ = -24						; size = 4
_f$ = -20						; size = 4
_f$ = -16						; size = 4
_v$ = -12						; size = 4
_this$ = -8						; size = 4
_rPythonBackground$ = -4				; size = 4
_v$ = 0							; size = 4
_this$ = 4						; size = 4
_f$ = 8							; size = 4
_v$ = 12						; size = 4
_this$ = 16						; size = 4
_v3NewEye$4 = 20					; size = 12
_v3NewEye$5 = 32					; size = 12
$T6 = 44						; size = 12
$T7 = 56						; size = 12
$T8 = 68						; size = 12
_v3CollisionPoint$ = 80					; size = 12
_v3CheckVector$9 = 92					; size = 12
$T10 = 104						; size = 12
__$ArrayPad$ = 116					; size = 4
?ProcessTerrainCollision@CCamera@@AAEXXZ PROC		; CCamera::ProcessTerrainCollision, COMDAT
; _this$ = ecx

; 14   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec f8 00 00
	00		 sub	 esp, 248		; 000000f8H
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 74	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d 10	 mov	 DWORD PTR _this$[ebp], ecx

; 15   : 	CPythonBackground & rPythonBackground = CPythonBackground::Instance();

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonBackground@@@@0PAVCPythonBackground@@A ; CSingleton<CPythonBackground>::ms_singleton
  0001d	89 45 fc	 mov	 DWORD PTR _rPythonBackground$[ebp], eax

; 16   : 	D3DXVECTOR3 v3CollisionPoint;
; 17   : 
; 18   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kTargetToCameraBottomRay, &v3CollisionPoint))

  00020	8d 45 50	 lea	 eax, DWORD PTR _v3CollisionPoint$[ebp]
  00023	50		 push	 eax
  00024	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  00027	05 00 02 00 00	 add	 eax, 512		; 00000200H
  0002c	50		 push	 eax
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _rPythonBackground$[ebp]
  00030	e8 00 00 00 00	 call	 ?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPointWithRayOnlyTerrain
  00035	0f b6 c0	 movzx	 eax, al
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 16 02 00
	00		 je	 $LN2@ProcessTer

; 19   : 	{
; 20   : 		SetCameraState(CAMERA_STATE_CANTGODOWN);

  00040	6a 01		 push	 1
  00042	8b 4d 10	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState

; 21   : 		D3DXVECTOR3 v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  0004a	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	83 c0 48	 add	 eax, 72			; 00000048H
  00050	89 45 0c	 mov	 DWORD PTR _v$[ebp], eax
  00053	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  00056	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0005e	f3 0f 59 80 f0
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+752]
  00066	f3 0f 11 45 08	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0006b	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0006e	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _f$[ebp]
  00073	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00077	f3 0f 11 45 e8	 movss	 DWORD PTR _fx$[ebp], xmm0
  0007c	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  0007f	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _f$[ebp]
  00084	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00089	f3 0f 11 45 e4	 movss	 DWORD PTR _fy$[ebp], xmm0
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _v$[ebp]
  00091	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _f$[ebp]
  00096	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  0009b	f3 0f 11 45 e0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000a0	f3 0f 10 45 e8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  000a5	f3 0f 11 45 2c	 movss	 DWORD PTR $T6[ebp], xmm0

; 181  :     y = fy;

  000aa	f3 0f 10 45 e4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  000af	f3 0f 11 45 30	 movss	 DWORD PTR $T6[ebp+4], xmm0

; 182  :     z = fz;

  000b4	f3 0f 10 45 e0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  000b9	f3 0f 11 45 34	 movss	 DWORD PTR $T6[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 21   : 		D3DXVECTOR3 v3CheckVector = m_v3Eye - 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  000be	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	83 c0 30	 add	 eax, 48			; 00000030H
  000c4	89 45 04	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  000c7	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp]
  000ca	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000ce	f3 0f 5c 45 2c	 subss	 xmm0, DWORD PTR $T6[ebp]
  000d3	f3 0f 11 45 dc	 movss	 DWORD PTR _fx$[ebp], xmm0
  000d8	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp]
  000db	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000e0	f3 0f 5c 45 30	 subss	 xmm0, DWORD PTR $T6[ebp+4]
  000e5	f3 0f 11 45 d8	 movss	 DWORD PTR _fy$[ebp], xmm0
  000ea	8b 45 04	 mov	 eax, DWORD PTR _this$[ebp]
  000ed	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000f2	f3 0f 5c 45 34	 subss	 xmm0, DWORD PTR $T6[ebp+8]
  000f7	f3 0f 11 45 84	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  000fc	f3 0f 10 45 dc	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00101	f3 0f 11 45 5c	 movss	 DWORD PTR _v3CheckVector$9[ebp], xmm0

; 181  :     y = fy;

  00106	f3 0f 10 45 d8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0010b	f3 0f 11 45 60	 movss	 DWORD PTR _v3CheckVector$9[ebp+4], xmm0

; 182  :     z = fz;

  00110	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00115	f3 0f 11 45 64	 movss	 DWORD PTR _v3CheckVector$9[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  0011a	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _v3CheckVector$9[ebp+4]
  0011f	f3 0f 11 45 88	 movss	 DWORD PTR __X$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 686  :             return (float)floor(_X);

  00124	f3 0f 5a 45 88	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00129	51		 push	 ecx
  0012a	51		 push	 ecx
  0012b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00130	e8 00 00 00 00	 call	 _floor
  00135	59		 pop	 ecx
  00136	59		 pop	 ecx
  00137	d9 5d 90	 fstp	 DWORD PTR $T1[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  0013a	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _v3CheckVector$9[ebp]
  0013f	f3 0f 11 45 8c	 movss	 DWORD PTR __X$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 686  :             return (float)floor(_X);

  00144	f3 0f 5a 45 8c	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00149	51		 push	 ecx
  0014a	51		 push	 ecx
  0014b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00150	e8 00 00 00 00	 call	 _floor
  00155	59		 pop	 ecx
  00156	59		 pop	 ecx
  00157	d9 5d 98	 fstp	 DWORD PTR $T2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 22   : 		v3CheckVector.z = rPythonBackground.GetHeight(floorf(v3CheckVector.x), floorf(v3CheckVector.y));

  0015a	51		 push	 ecx
  0015b	f3 0f 10 45 90	 movss	 xmm0, DWORD PTR $T1[ebp]
  00160	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00165	51		 push	 ecx
  00166	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR $T2[ebp]
  0016b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00170	8b 4d fc	 mov	 ecx, DWORD PTR _rPythonBackground$[ebp]
  00173	e8 00 00 00 00	 call	 ?GetHeight@CMapManager@@QAEMMM@Z ; CMapManager::GetHeight
  00178	d9 5d 64	 fstp	 DWORD PTR _v3CheckVector$9[ebp+8]

; 23   : 		D3DXVECTOR3 v3NewEye = v3CheckVector + 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  0017b	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  0017e	83 c0 48	 add	 eax, 72			; 00000048H
  00181	89 45 00	 mov	 DWORD PTR _v$[ebp], eax
  00184	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  00187	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  0018f	f3 0f 59 80 f0
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+752]
  00197	f3 0f 11 45 ec	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  0019c	8b 45 00	 mov	 eax, DWORD PTR _v$[ebp]
  0019f	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _f$[ebp]
  001a4	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  001a8	f3 0f 11 45 9c	 movss	 DWORD PTR _fx$[ebp], xmm0
  001ad	8b 45 00	 mov	 eax, DWORD PTR _v$[ebp]
  001b0	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _f$[ebp]
  001b5	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  001ba	f3 0f 11 45 a8	 movss	 DWORD PTR _fy$[ebp], xmm0
  001bf	8b 45 00	 mov	 eax, DWORD PTR _v$[ebp]
  001c2	f3 0f 10 45 ec	 movss	 xmm0, DWORD PTR _f$[ebp]
  001c7	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  001cc	f3 0f 11 45 94	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  001d1	f3 0f 10 45 9c	 movss	 xmm0, DWORD PTR _fx$[ebp]
  001d6	f3 0f 11 45 38	 movss	 DWORD PTR $T7[ebp], xmm0

; 181  :     y = fy;

  001db	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR _fy$[ebp]
  001e0	f3 0f 11 45 3c	 movss	 DWORD PTR $T7[ebp+4], xmm0

; 182  :     z = fz;

  001e5	f3 0f 10 45 94	 movss	 xmm0, DWORD PTR _fz$[ebp]
  001ea	f3 0f 11 45 40	 movss	 DWORD PTR $T7[ebp+8], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  001ef	f3 0f 10 45 5c	 movss	 xmm0, DWORD PTR _v3CheckVector$9[ebp]
  001f4	f3 0f 58 45 38	 addss	 xmm0, DWORD PTR $T7[ebp]
  001f9	f3 0f 11 45 d4	 movss	 DWORD PTR _fx$[ebp], xmm0
  001fe	f3 0f 10 45 60	 movss	 xmm0, DWORD PTR _v3CheckVector$9[ebp+4]
  00203	f3 0f 58 45 3c	 addss	 xmm0, DWORD PTR $T7[ebp+4]
  00208	f3 0f 11 45 d0	 movss	 DWORD PTR _fy$[ebp], xmm0
  0020d	f3 0f 10 45 64	 movss	 xmm0, DWORD PTR _v3CheckVector$9[ebp+8]
  00212	f3 0f 58 45 40	 addss	 xmm0, DWORD PTR $T7[ebp+8]
  00217	f3 0f 11 45 cc	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0021c	f3 0f 10 45 d4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  00221	f3 0f 11 45 20	 movss	 DWORD PTR _v3NewEye$5[ebp], xmm0

; 181  :     y = fy;

  00226	f3 0f 10 45 d0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  0022b	f3 0f 11 45 24	 movss	 DWORD PTR _v3NewEye$5[ebp+4], xmm0

; 182  :     z = fz;

  00230	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR _fz$[ebp]
  00235	f3 0f 11 45 28	 movss	 DWORD PTR _v3NewEye$5[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 24   : 		if (v3NewEye.z > m_v3Eye.z)

  0023a	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  0023d	f3 0f 10 45 28	 movss	 xmm0, DWORD PTR _v3NewEye$5[ebp+8]
  00242	0f 2f 40 38	 comiss	 xmm0, DWORD PTR [eax+56]
  00246	76 0c		 jbe	 SHORT $LN4@ProcessTer

; 25   : 		{
; 26   : 			//printf("ToCameraBottom(%f, %f, %f) TCR %f, UP(%f, %f, %f), new %f > old %f", 
; 27   : 			//	v3CheckVector.x, v3CheckVector.y, v3CheckVector.z, 
; 28   : 			//	m_fTerrainCollisionRadius,
; 29   : 			//	m_v3Up.x, m_v3Up.y, m_v3Up.z,
; 30   : 			//	v3NewEye.z, m_v3Eye.z);
; 31   : 			SetEye(v3NewEye);

  00248	8d 45 20	 lea	 eax, DWORD PTR _v3NewEye$5[ebp]
  0024b	50		 push	 eax
  0024c	8b 4d 10	 mov	 ecx, DWORD PTR _this$[ebp]
  0024f	e8 00 00 00 00	 call	 ?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z ; CCamera::SetEye
$LN4@ProcessTer:

; 32   : 		}
; 33   : 		/*
; 34   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 35   : 		D3DXVECTOR3 v3NewEye = v3CollisionPoint;
; 36   : 		SetEye(v3NewEye);
; 37   : 		*/
; 38   : 	}

  00254	eb 0a		 jmp	 SHORT $LN3@ProcessTer
$LN2@ProcessTer:

; 39   : 	else
; 40   : 		SetCameraState(CAMERA_STATE_NORMAL);

  00256	6a 00		 push	 0
  00258	8b 4d 10	 mov	 ecx, DWORD PTR _this$[ebp]
  0025b	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
$LN3@ProcessTer:

; 41   : 
; 42   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBottomToTerrainRay, &v3CollisionPoint))

  00260	8d 45 50	 lea	 eax, DWORD PTR _v3CollisionPoint$[ebp]
  00263	50		 push	 eax
  00264	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  00267	05 38 01 00 00	 add	 eax, 312		; 00000138H
  0026c	50		 push	 eax
  0026d	8b 4d fc	 mov	 ecx, DWORD PTR _rPythonBackground$[ebp]
  00270	e8 00 00 00 00	 call	 ?GetPickingPointWithRayOnlyTerrain@CPythonBackground@@QAE_NABVCRay@@PAUD3DXVECTOR3@@@Z ; CPythonBackground::GetPickingPointWithRayOnlyTerrain
  00275	0f b6 c0	 movzx	 eax, al
  00278	85 c0		 test	 eax, eax
  0027a	0f 84 91 01 00
	00		 je	 $LN5@ProcessTer

; 43   : 	{
; 44   : 		SetCameraState(CAMERA_STATE_CANTGODOWN);

  00280	6a 01		 push	 1
  00282	8b 4d 10	 mov	 ecx, DWORD PTR _this$[ebp]
  00285	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  0028a	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  0028d	83 c0 30	 add	 eax, 48			; 00000030H
  00290	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 263  :     return D3DXVECTOR3(x - v.x, y - v.y, z - v.z);

  00293	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00296	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  0029a	f3 0f 5c 45 50	 subss	 xmm0, DWORD PTR _v3CollisionPoint$[ebp]
  0029f	f3 0f 11 45 c8	 movss	 DWORD PTR _fx$[ebp], xmm0
  002a4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002a7	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  002ac	f3 0f 5c 45 54	 subss	 xmm0, DWORD PTR _v3CollisionPoint$[ebp+4]
  002b1	f3 0f 11 45 c4	 movss	 DWORD PTR _fy$[ebp], xmm0
  002b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002b9	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  002be	f3 0f 5c 45 58	 subss	 xmm0, DWORD PTR _v3CollisionPoint$[ebp+8]
  002c3	f3 0f 11 45 c0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  002c8	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fx$[ebp]
  002cd	f3 0f 11 45 68	 movss	 DWORD PTR $T10[ebp], xmm0

; 181  :     y = fy;

  002d2	f3 0f 10 45 c4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  002d7	f3 0f 11 45 6c	 movss	 DWORD PTR $T10[ebp+4], xmm0

; 182  :     z = fz;

  002dc	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  002e1	f3 0f 11 45 70	 movss	 DWORD PTR $T10[ebp+8], xmm0

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  002e6	f3 0f 10 45 70	 movss	 xmm0, DWORD PTR $T10[ebp+8]
  002eb	f3 0f 59 45 70	 mulss	 xmm0, DWORD PTR $T10[ebp+8]
  002f0	f3 0f 10 4d 6c	 movss	 xmm1, DWORD PTR $T10[ebp+4]
  002f5	f3 0f 59 4d 6c	 mulss	 xmm1, DWORD PTR $T10[ebp+4]
  002fa	f3 0f 10 55 68	 movss	 xmm2, DWORD PTR $T10[ebp]
  002ff	f3 0f 59 55 68	 mulss	 xmm2, DWORD PTR $T10[ebp]
  00304	f3 0f 58 d1	 addss	 xmm2, xmm1
  00308	f3 0f 58 d0	 addss	 xmm2, xmm0
  0030c	f3 0f 11 55 bc	 movss	 DWORD PTR __X$[ebp], xmm2
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 760  :             return (float)sqrt(_X);

  00311	f3 0f 5a 45 bc	 cvtss2sd xmm0, DWORD PTR __X$[ebp]
  00316	51		 push	 ecx
  00317	51		 push	 ecx
  00318	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0031d	e8 00 00 00 00	 call	 _sqrt
  00322	59		 pop	 ecx
  00323	59		 pop	 ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 1239 :     return sqrtf(pV->x * pV->x + pV->y * pV->y + pV->z * pV->z);

  00324	d9 5d b8	 fstp	 DWORD PTR $T3[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 45   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 2.0f * m_fTerrainCollisionRadius)

  00327	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  0032a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00332	f3 0f 59 80 f0
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+752]
  0033a	0f 2f 45 b8	 comiss	 xmm0, DWORD PTR $T3[ebp]
  0033e	0f 86 cb 00 00
	00		 jbe	 $LN7@ProcessTer

; 46   : 		{
; 47   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + 2.0f * m_fTerrainCollisionRadius * m_v3Up;

  00344	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  00347	83 c0 48	 add	 eax, 72			; 00000048H
  0034a	89 45 f4	 mov	 DWORD PTR _v$[ebp], eax
  0034d	8b 45 10	 mov	 eax, DWORD PTR _this$[ebp]
  00350	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@40000000
  00358	f3 0f 59 80 f0
	02 00 00	 mulss	 xmm0, DWORD PTR [eax+752]
  00360	f3 0f 11 45 f0	 movss	 DWORD PTR _f$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 283  :     return D3DXVECTOR3(f * v.x, f * v.y, f * v.z);

  00365	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  00368	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _f$[ebp]
  0036d	f3 0f 59 00	 mulss	 xmm0, DWORD PTR [eax]
  00371	f3 0f 11 45 b4	 movss	 DWORD PTR _fx$[ebp], xmm0
  00376	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  00379	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _f$[ebp]
  0037e	f3 0f 59 40 04	 mulss	 xmm0, DWORD PTR [eax+4]
  00383	f3 0f 11 45 b0	 movss	 DWORD PTR _fy$[ebp], xmm0
  00388	8b 45 f4	 mov	 eax, DWORD PTR _v$[ebp]
  0038b	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _f$[ebp]
  00390	f3 0f 59 40 08	 mulss	 xmm0, DWORD PTR [eax+8]
  00395	f3 0f 11 45 ac	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  0039a	f3 0f 10 45 b4	 movss	 xmm0, DWORD PTR _fx$[ebp]
  0039f	f3 0f 11 45 44	 movss	 DWORD PTR $T8[ebp], xmm0

; 181  :     y = fy;

  003a4	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR _fy$[ebp]
  003a9	f3 0f 11 45 48	 movss	 DWORD PTR $T8[ebp+4], xmm0

; 182  :     z = fz;

  003ae	f3 0f 10 45 ac	 movss	 xmm0, DWORD PTR _fz$[ebp]
  003b3	f3 0f 11 45 4c	 movss	 DWORD PTR $T8[ebp+8], xmm0

; 257  :     return D3DXVECTOR3(x + v.x, y + v.y, z + v.z);

  003b8	f3 0f 10 45 50	 movss	 xmm0, DWORD PTR _v3CollisionPoint$[ebp]
  003bd	f3 0f 58 45 44	 addss	 xmm0, DWORD PTR $T8[ebp]
  003c2	f3 0f 11 45 80	 movss	 DWORD PTR _fx$[ebp], xmm0
  003c7	f3 0f 10 45 54	 movss	 xmm0, DWORD PTR _v3CollisionPoint$[ebp+4]
  003cc	f3 0f 58 45 48	 addss	 xmm0, DWORD PTR $T8[ebp+4]
  003d1	f3 0f 11 45 a4	 movss	 DWORD PTR _fy$[ebp], xmm0
  003d6	f3 0f 10 45 58	 movss	 xmm0, DWORD PTR _v3CollisionPoint$[ebp+8]
  003db	f3 0f 58 45 4c	 addss	 xmm0, DWORD PTR $T8[ebp+8]
  003e0	f3 0f 11 45 a0	 movss	 DWORD PTR _fz$[ebp], xmm0

; 180  :     x = fx;

  003e5	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR _fx$[ebp]
  003ea	f3 0f 11 45 14	 movss	 DWORD PTR _v3NewEye$4[ebp], xmm0

; 181  :     y = fy;

  003ef	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR _fy$[ebp]
  003f4	f3 0f 11 45 18	 movss	 DWORD PTR _v3NewEye$4[ebp+4], xmm0

; 182  :     z = fz;

  003f9	f3 0f 10 45 a0	 movss	 xmm0, DWORD PTR _fz$[ebp]
  003fe	f3 0f 11 45 1c	 movss	 DWORD PTR _v3NewEye$4[ebp+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 49   : 			SetEye(v3NewEye);

  00403	8d 45 14	 lea	 eax, DWORD PTR _v3NewEye$4[ebp]
  00406	50		 push	 eax
  00407	8b 4d 10	 mov	 ecx, DWORD PTR _this$[ebp]
  0040a	e8 00 00 00 00	 call	 ?SetEye@CCamera@@QAEXABUD3DXVECTOR3@@@Z ; CCamera::SetEye
$LN7@ProcessTer:

; 50   : 		}
; 51   : 	}

  0040f	eb 0a		 jmp	 SHORT $LN6@ProcessTer
$LN5@ProcessTer:

; 52   : 	else
; 53   : 		SetCameraState(CAMERA_STATE_NORMAL);

  00411	6a 00		 push	 0
  00413	8b 4d 10	 mov	 ecx, DWORD PTR _this$[ebp]
  00416	e8 00 00 00 00	 call	 ?SetCameraState@CCamera@@QAEXW4_eCameraState_@@@Z ; CCamera::SetCameraState
$LN6@ProcessTer:

; 54   : /*
; 55   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraFrontToTerrainRay, &v3CollisionPoint))
; 56   : 	{
; 57   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 4.0f * m_fTerrainCollisionRadius)
; 58   : 		{
; 59   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 4.0f * m_fTerrainCollisionRadius * m_v3View;
; 60   : 			//printf("CameraFrontToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 61   : 			SetEye(v3NewEye);
; 62   : 		}
; 63   : 	}
; 64   : 
; 65   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraBackToTerrainRay, &v3CollisionPoint))
; 66   : 	{
; 67   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < m_fTerrainCollisionRadius)
; 68   : 		{
; 69   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + m_fTerrainCollisionRadius * m_v3View;
; 70   : 			//printf("CameraBackToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 71   : 			SetEye(v3NewEye);
; 72   : 		}
; 73   : 	}
; 74   : 
; 75   : 	// Left
; 76   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraLeftToTerrainRay, &v3CollisionPoint))
; 77   : 	{
; 78   : 		SetCameraState(CAMERA_STATE_CANTGOLEFT);
; 79   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 80   : 		{
; 81   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint + 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 82   : 			//printf("CameraLeftToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 83   : 			SetEye(v3NewEye);
; 84   : 		}
; 85   : 	}
; 86   : 	else
; 87   : 		SetCameraState(CAMERA_STATE_NORMAL);
; 88   : 
; 89   : 	// Right
; 90   : 	if (rPythonBackground.GetPickingPointWithRayOnlyTerrain(m_kCameraRightToTerrainRay, &v3CollisionPoint))
; 91   : 	{
; 92   : 		SetCameraState(CAMERA_STATE_CANTGORIGHT);
; 93   : 		if (D3DXVec3Length(&(m_v3Eye - v3CollisionPoint)) < 3.0f * m_fTerrainCollisionRadius)
; 94   : 		{
; 95   : 			D3DXVECTOR3 v3NewEye = v3CollisionPoint - 3.0f * m_fTerrainCollisionRadius * m_v3Cross;
; 96   : 			//printf("CameraRightToTerrain new %f > old %f", v3NewEye.z, m_v3Eye.z);
; 97   : 			SetEye(v3NewEye);
; 98   : 		}
; 99   : 	}
; 100  : 	else
; 101  : 		SetCameraState(CAMERA_STATE_NORMAL);
; 102  : 	*/
; 103  : }

  0041b	8b 4d 74	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0041e	33 cd		 xor	 ecx, ebp
  00420	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00425	83 c5 78	 add	 ebp, 120		; 00000078H
  00428	c9		 leave
  00429	c3		 ret	 0
?ProcessTerrainCollision@CCamera@@AAEXXZ ENDP		; CCamera::ProcessTerrainCollision
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Camera.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Camera.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp
;	COMDAT ?Update@CCamera@@QAEXXZ
_TEXT	SEGMENT
_CAMERA_TARGET_DELTA$ = -60				; size = 4
_fNewTargetHeight$ = -56				; size = 4
_CAMERA_MOVABLE_DISTANCE$ = -52				; size = 4
_fCameraCurMovableDistance$ = -48			; size = 4
$T1 = -44						; size = 4
$T2 = -40						; size = 4
__Xx$ = -36						; size = 4
$T3 = -32						; size = 4
__Xx$ = -28						; size = 4
$T4 = -24						; size = 4
__Xx$ = -20						; size = 4
_fNewDistance$ = -16					; size = 4
$T5 = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
?Update@CCamera@@QAEXXZ PROC				; CCamera::Update, COMDAT
; _this$ = ecx

; 314  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 315  : // 	ProcessBuildingCollision();
; 316  : 
; 317  : 	RotateEyeAroundTarget(m_v3AngularVelocity.z, m_v3AngularVelocity.x);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	51		 push	 ecx
  0000d	f3 0f 10 80 24
	03 00 00	 movss	 xmm0, DWORD PTR [eax+804]
  00015	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	51		 push	 ecx
  0001e	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  00026	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?RotateEyeAroundTarget@CCamera@@QAEXMM@Z ; CCamera::RotateEyeAroundTarget
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Camera.h

; 186  : 		float GetDistance() const { return m_fDistance; }

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [eax+308]
  0003e	f3 0f 11 45 f4	 movss	 DWORD PTR $T5[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 319  : 	float fNewDistance=fMAX(CAMERA_MIN_DISTANCE, fMIN( CAMERA_MAX_DISTANCE, GetDistance() - m_v3AngularVelocity.y ) );

  00043	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00046	f3 0f 10 45 f4	 movss	 xmm0, DWORD PTR $T5[ebp]
  0004b	f3 0f 5c 80 28
	03 00 00	 subss	 xmm0, DWORD PTR [eax+808]
  00053	51		 push	 ecx
  00054	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00059	51		 push	 ecx
  0005a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  00062	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00067	e8 00 00 00 00	 call	 ?fMIN@@YAMMM@Z		; fMIN
  0006c	59		 pop	 ecx
  0006d	59		 pop	 ecx
  0006e	51		 push	 ecx
  0006f	d9 1c 24	 fstp	 DWORD PTR [esp]
  00072	51		 push	 ecx
  00073	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MIN_DISTANCE@CCamera@@0MA
  0007b	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00080	e8 00 00 00 00	 call	 ?fMAX@@YAMMM@Z		; fMAX
  00085	59		 pop	 ecx
  00086	59		 pop	 ecx
  00087	d9 5d f0	 fstp	 DWORD PTR _fNewDistance$[ebp]

; 320  : 	SetDistance(fNewDistance);

  0008a	51		 push	 ecx
  0008b	f3 0f 10 45 f0	 movss	 xmm0, DWORD PTR _fNewDistance$[ebp]
  00090	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00095	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?SetDistance@CCamera@@QAEXM@Z ; CCamera::SetDistance

; 321  : 	
; 322  : 	if (m_bProcessTerrainCollision)

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	0f b6 80 34 03
	00 00		 movzx	 eax, BYTE PTR [eax+820]
  000a7	85 c0		 test	 eax, eax
  000a9	74 08		 je	 SHORT $LN2@Update

; 323  :  		ProcessTerrainCollision();

  000ab	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?ProcessTerrainCollision@CCamera@@AAEXXZ ; CCamera::ProcessTerrainCollision
$LN2@Update:

; 324  : 
; 325  : 	m_v3AngularVelocity *= 0.5f;

  000b3	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b6	05 24 03 00 00	 add	 eax, 804		; 00000324H
  000bb	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\M2Data\include\d3dx8math.inl

; 222  :     x *= f;

  000be	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  000c5	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  000cd	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 223  :     y *= f;

  000d4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000d7	f3 0f 10 40 04	 movss	 xmm0, DWORD PTR [eax+4]
  000dc	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  000e4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	f3 0f 11 40 04	 movss	 DWORD PTR [eax+4], xmm0

; 224  :     z *= f;

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	f3 0f 10 40 08	 movss	 xmm0, DWORD PTR [eax+8]
  000f4	f3 0f 59 05 00
	00 00 00	 mulss	 xmm0, DWORD PTR __real@3f000000
  000fc	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ff	f3 0f 11 40 08	 movss	 DWORD PTR [eax+8], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 326  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  00104	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00107	f3 0f 10 80 24
	03 00 00	 movss	 xmm0, DWORD PTR [eax+804]
  0010f	f3 0f 11 45 ec	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00114	f3 0f 5a 45 ec	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  00119	51		 push	 ecx
  0011a	51		 push	 ecx
  0011b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00120	e8 00 00 00 00	 call	 _fabs
  00125	59		 pop	 ecx
  00126	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  00127	d9 5d e8	 fstp	 DWORD PTR $T4[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 326  : 	if (fabs(m_v3AngularVelocity.x) < 1.0f)

  0012a	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00132	0f 2f 45 e8	 comiss	 xmm0, DWORD PTR $T4[ebp]
  00136	76 0e		 jbe	 SHORT $LN3@Update

; 327  : 		m_v3AngularVelocity.x = 0.0f;

  00138	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0013b	0f 57 c0	 xorps	 xmm0, xmm0
  0013e	f3 0f 11 80 24
	03 00 00	 movss	 DWORD PTR [eax+804], xmm0
$LN3@Update:

; 328  : 	if (fabs(m_v3AngularVelocity.y) < 1.0f)

  00146	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00149	f3 0f 10 80 28
	03 00 00	 movss	 xmm0, DWORD PTR [eax+808]
  00151	f3 0f 11 45 e4	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00156	f3 0f 5a 45 e4	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  0015b	51		 push	 ecx
  0015c	51		 push	 ecx
  0015d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00162	e8 00 00 00 00	 call	 _fabs
  00167	59		 pop	 ecx
  00168	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  00169	d9 5d e0	 fstp	 DWORD PTR $T3[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 328  : 	if (fabs(m_v3AngularVelocity.y) < 1.0f)

  0016c	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  00174	0f 2f 45 e0	 comiss	 xmm0, DWORD PTR $T3[ebp]
  00178	76 0e		 jbe	 SHORT $LN4@Update

; 329  : 		m_v3AngularVelocity.y = 0.0f;

  0017a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0017d	0f 57 c0	 xorps	 xmm0, xmm0
  00180	f3 0f 11 80 28
	03 00 00	 movss	 DWORD PTR [eax+808], xmm0
$LN4@Update:

; 330  : 	if (fabs(m_v3AngularVelocity.z) < 1.0f)

  00188	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0018b	f3 0f 10 80 2c
	03 00 00	 movss	 xmm0, DWORD PTR [eax+812]
  00193	f3 0f 11 45 dc	 movss	 DWORD PTR __Xx$[ebp], xmm0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.18362.0\ucrt\corecrt_math.h

; 672  :             return (float)fabs(_X);

  00198	f3 0f 5a 45 dc	 cvtss2sd xmm0, DWORD PTR __Xx$[ebp]
  0019d	51		 push	 ecx
  0019e	51		 push	 ecx
  0019f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  001a4	e8 00 00 00 00	 call	 _fabs
  001a9	59		 pop	 ecx
  001aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\cmath

; 95   :     return _CSTD fabsf(_Xx);

  001ab	d9 5d d8	 fstp	 DWORD PTR $T2[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 330  : 	if (fabs(m_v3AngularVelocity.z) < 1.0f)

  001ae	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@3f800000
  001b6	0f 2f 45 d8	 comiss	 xmm0, DWORD PTR $T2[ebp]
  001ba	76 0e		 jbe	 SHORT $LN5@Update

; 331  : 		m_v3AngularVelocity.z = 0.0f;

  001bc	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001bf	0f 57 c0	 xorps	 xmm0, xmm0
  001c2	f3 0f 11 80 2c
	03 00 00	 movss	 DWORD PTR [eax+812], xmm0
$LN5@Update:

; 332  : 
; 333  : 	const float CAMERA_MOVABLE_DISTANCE = CAMERA_MAX_DISTANCE - CAMERA_MIN_DISTANCE;

  001ca	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  001d2	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR ?CAMERA_MIN_DISTANCE@CCamera@@0MA
  001da	f3 0f 11 45 cc	 movss	 DWORD PTR _CAMERA_MOVABLE_DISTANCE$[ebp], xmm0

; 334  : 	const float CAMERA_TARGET_DELTA = CAMERA_TARGET_FACE - CAMERA_TARGET_STANDARD;

  001df	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  001e7	f3 0f 11 45 c4	 movss	 DWORD PTR _CAMERA_TARGET_DELTA$[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterlib\Camera.h

; 186  : 		float GetDistance() const { return m_fDistance; }

  001ec	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  001ef	f3 0f 10 80 34
	01 00 00	 movss	 xmm0, DWORD PTR [eax+308]
  001f7	f3 0f 11 45 d4	 movss	 DWORD PTR $T1[ebp], xmm0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\CameraProcedure.cpp

; 335  : 	float fCameraCurMovableDistance=CAMERA_MAX_DISTANCE - GetDistance();

  001fc	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR ?CAMERA_MAX_DISTANCE@CCamera@@0MA
  00204	f3 0f 5c 45 d4	 subss	 xmm0, DWORD PTR $T1[ebp]
  00209	f3 0f 11 45 d0	 movss	 DWORD PTR _fCameraCurMovableDistance$[ebp], xmm0

; 336  : 	float fNewTargetHeight = CAMERA_TARGET_STANDARD + CAMERA_TARGET_DELTA * fCameraCurMovableDistance / CAMERA_MOVABLE_DISTANCE;

  0020e	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@42480000
  00216	f3 0f 59 45 d0	 mulss	 xmm0, DWORD PTR _fCameraCurMovableDistance$[ebp]
  0021b	f3 0f 5e 45 cc	 divss	 xmm0, DWORD PTR _CAMERA_MOVABLE_DISTANCE$[ebp]
  00220	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@42c80000
  00228	f3 0f 11 45 c8	 movss	 DWORD PTR _fNewTargetHeight$[ebp], xmm0

; 337  : 
; 338  : 	SetTargetHeight(fNewTargetHeight);

  0022d	51		 push	 ecx
  0022e	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR _fNewTargetHeight$[ebp]
  00233	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00238	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023b	e8 00 00 00 00	 call	 ?SetTargetHeight@CCamera@@QAEXM@Z ; CCamera::SetTargetHeight

; 339  : 
; 340  : 	// Cinematic
; 341  : #ifdef __20040725_CAMERA_WORK__
; 342  : 	m_MovementPosition += m_MovementSpeed;
; 343  : 	
; 344  : 	if (0.0f != m_MovementPosition.m_fViewDir)
; 345  : 		MoveFront(m_MovementPosition.m_fViewDir);
; 346  : 	if (0.0f != m_MovementPosition.m_fCrossDir)
; 347  : 		MoveAlongCross(m_MovementPosition.m_fCrossDir);
; 348  : 	if (0.0f != m_MovementPosition.m_fUpDir)
; 349  : 		MoveVertical(m_MovementPosition.m_fUpDir);
; 350  : #endif
; 351  : }

  00240	c9		 leave
  00241	c3		 ret	 0
?Update@CCamera@@QAEXXZ ENDP				; CCamera::Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 375  :     _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 20 00	 and	 DWORD PTR [eax], 0
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	83 60 04 00	 and	 DWORD PTR [eax+4], 0
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	83 60 08 00	 and	 DWORD PTR [eax+8], 0
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<D3DXVECTOR3> >::_Vector_val<std::_Simple_types<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength, COMDAT

; 1704 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1705 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1706 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlength@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@CAXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy, COMDAT
; _this$ = ecx

; 1686 :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1687 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1688 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1689 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1690 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1691 : 
; 1692 :         _My_data._Orphan_all();
; 1693 : 
; 1694 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 75		 je	 SHORT $LN3@Tidy

; 1695 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1696 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1698 :             _Myfirst = pointer();

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	83 20 00	 and	 DWORD PTR [eax], 0

; 1699 :             _Mylast  = pointer();

  00098	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0009b	83 20 00	 and	 DWORD PTR [eax], 0

; 1700 :             _Myend   = pointer();

  0009e	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a1	83 20 00	 and	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1701 :         }
; 1702 :     }

  000a4	c9		 leave
  000a5	c3		 ret	 0
?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
__Ptr$ = -48						; size = 4
__Count$ = -44						; size = 4
$T2 = -40						; size = 4
__First$ = -36						; size = 4
__Last$ = -32						; size = 4
$T3 = -28						; size = 4
$T4 = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array, COMDAT
; _this$ = ecx

; 1667 :     void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1668 :         // orphan all iterators, discard old array, acquire new array
; 1669 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1670 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00012	89 45 fc	 mov	 DWORD PTR __Myfirst$[ebp], eax

; 1671 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00018	83 c0 04	 add	 eax, 4
  0001b	89 45 f0	 mov	 DWORD PTR __Mylast$[ebp], eax

; 1672 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1673 : 
; 1674 :         _My_data._Orphan_all();
; 1675 : 
; 1676 :         if (_Myfirst) { // destroy and deallocate old array

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0002a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002d	74 63		 je	 SHORT $LN2@Change_arr

; 1677 :             _Destroy(_Myfirst, _Mylast);

  0002f	8b 45 f0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00032	8b 00		 mov	 eax, DWORD PTR [eax]
  00034	89 45 e0	 mov	 DWORD PTR __Last$[ebp], eax
  00037	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0003a	8b 00		 mov	 eax, DWORD PTR [eax]
  0003c	89 45 dc	 mov	 DWORD PTR __First$[ebp], eax

; 1733 :         return _Mypair._Get_first();

  0003f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00042	89 45 e8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00045	8b 45 e8	 mov	 eax, DWORD PTR $T4[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  0004b	ff 75 e4	 push	 DWORD PTR $T3[ebp]
  0004e	ff 75 e0	 push	 DWORD PTR __Last$[ebp]
  00051	ff 75 dc	 push	 DWORD PTR __First$[ebp]
  00054	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1733 :         return _Mypair._Get_first();

  0005c	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0005f	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  00062	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
  00065	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax

; 1678 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00068	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006e	8b 00		 mov	 eax, DWORD PTR [eax]
  00070	2b 01		 sub	 eax, DWORD PTR [ecx]
  00072	99		 cdq
  00073	6a 0c		 push	 12			; 0000000cH
  00075	59		 pop	 ecx
  00076	f7 f9		 idiv	 ecx
  00078	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007e	8b 00		 mov	 eax, DWORD PTR [eax]
  00080	89 45 d0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00083	6b 45 d4 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  00087	50		 push	 eax
  00088	ff 75 d0	 push	 DWORD PTR __Ptr$[ebp]
  0008b	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
$LN2@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1681 :         _Myfirst = _Newvec;

  00092	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00095	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00098	89 08		 mov	 DWORD PTR [eax], ecx

; 1682 :         _Mylast  = _Newvec + _Newsize;

  0009a	6b 45 0c 0c	 imul	 eax, DWORD PTR __Newsize$[ebp], 12
  0009e	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000a1	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a4	89 01		 mov	 DWORD PTR [ecx], eax

; 1683 :         _Myend   = _Newvec + _Newcapacity;

  000a6	6b 45 10 0c	 imul	 eax, DWORD PTR __Newcapacity$[ebp], 12
  000aa	03 45 08	 add	 eax, DWORD PTR __Newvec$[ebp]
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  000b0	89 01		 mov	 DWORD PTR [ecx], eax

; 1684 :     }

  000b2	c9		 leave
  000b3	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXQAUD3DXVECTOR3@@II@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -52						; size = 4
$T2 = -48						; size = 4
$T3 = -44						; size = 4
$T4 = -40						; size = 4
$T5 = -36						; size = 4
__Geometric$ = -32					; size = 4
__Max$ = -28						; size = 4
tv82 = -24						; size = 4
$T6 = -20						; size = 4
$T7 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$8 = -8					; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1615 :     size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1493 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$8[ebp], eax

; 1494 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __My_data$8[ebp]
  00012	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$8[ebp]
  00015	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00018	2b 01		 sub	 eax, DWORD PTR [ecx]
  0001a	99		 cdq
  0001b	6a 0c		 push	 12			; 0000000cH
  0001d	59		 pop	 ecx
  0001e	f7 f9		 idiv	 ecx
  00020	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1737 :         return _Mypair._Get_first();

  00023	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00026	89 45 dc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1737 :         return _Mypair._Get_first();

  00029	8b 45 dc	 mov	 eax, DWORD PTR $T5[ebp]
  0002c	89 45 cc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0002f	c7 45 f0 55 55
	55 15		 mov	 DWORD PTR $T7[ebp], 357913941 ; 15555555H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00036	c7 45 d8 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  0003d	8b 45 d8	 mov	 eax, DWORD PTR $T4[ebp]
  00040	89 45 ec	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00043	8b 45 f0	 mov	 eax, DWORD PTR $T7[ebp]
  00046	3b 45 ec	 cmp	 eax, DWORD PTR $T6[ebp]
  00049	73 08		 jae	 SHORT $LN25@Calculate_
  0004b	8d 45 f0	 lea	 eax, DWORD PTR $T7[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
  00051	eb 06		 jmp	 SHORT $LN26@Calculate_
$LN25@Calculate_:
  00053	8d 45 ec	 lea	 eax, DWORD PTR $T6[ebp]
  00056	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
$LN26@Calculate_:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv82[ebp]
  0005c	89 45 d4	 mov	 DWORD PTR $T3[ebp], eax
  0005f	8b 45 d4	 mov	 eax, DWORD PTR $T3[ebp]
  00062	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1488 :         return (_STD min)(

  00065	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
  00068	8b 00		 mov	 eax, DWORD PTR [eax]
  0006a	89 45 e4	 mov	 DWORD PTR __Max$[ebp], eax

; 1616 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1617 :         const size_type _Oldcapacity = capacity();
; 1618 :         const auto _Max              = max_size();
; 1619 : 
; 1620 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0006d	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00070	d1 e8		 shr	 eax, 1
  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00075	2b c8		 sub	 ecx, eax
  00077	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0007a	76 05		 jbe	 SHORT $LN2@Calculate_

; 1621 :             return _Max; // geometric growth would overflow

  0007c	8b 45 e4	 mov	 eax, DWORD PTR __Max$[ebp]
  0007f	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1622 :         }
; 1623 : 
; 1624 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00081	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00084	d1 e8		 shr	 eax, 1
  00086	03 45 fc	 add	 eax, DWORD PTR __Oldcapacity$[ebp]
  00089	89 45 e0	 mov	 DWORD PTR __Geometric$[ebp], eax

; 1625 : 
; 1626 :         if (_Geometric < _Newsize) {

  0008c	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0008f	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00092	73 05		 jae	 SHORT $LN3@Calculate_

; 1627 :             return _Newsize; // geometric growth would be insufficient

  00094	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00097	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1628 :         }
; 1629 : 
; 1630 :         return _Geometric; // geometric growth is sufficient

  00099	8b 45 e0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1631 :     }

  0009c	c9		 leave
  0009d	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@ABEII@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy, COMDAT
; _this$ = ecx

; 1611 :     void _Destroy(pointer _First, pointer _Last) { // destroy [_First, _Last) using allocator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector

; 1733 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00012	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax

; 1612 :         _Destroy_range(_First, _Last, _Getal());

  00015	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  00018	ff 75 0c	 push	 DWORD PTR __Last$[ebp]
  0001b	ff 75 08	 push	 DWORD PTR __First$[ebp]
  0001e	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@QAU1@AAV?$allocator@UD3DXVECTOR3@@@0@@Z ; std::_Destroy_range<std::allocator<D3DXVECTOR3> >
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1613 :     }

  00026	c9		 leave
  00027	c2 08 00	 ret	 8
?_Destroy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXPAUD3DXVECTOR3@@0@Z ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vector
;	COMDAT ??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ PROC ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >, COMDAT
; _this$ = ecx

; 672  :     ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 673  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@AAEXXZ ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::_Tidy

; 674  : #if _ITERATOR_DEBUG_LEVEL != 0
; 675  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 676  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 677  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 678  :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$vector@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@QAE@XZ ENDP ; std::vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >::~vector<D3DXVECTOR3,std::allocator<D3DXVECTOR3> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z PROC ; std::allocator<D3DXVECTOR3>::deallocate, COMDAT
; _this$ = ecx

; 808  :     void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 809  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	6b 45 0c 0c	 imul	 eax, DWORD PTR __Count$[ebp], 12
  0000b	50		 push	 eax
  0000c	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	59		 pop	 ecx
  00015	59		 pop	 ecx

; 811  :     }

  00016	c9		 leave
  00017	c2 08 00	 ret	 8
?deallocate@?$allocator@UD3DXVECTOR3@@@std@@QAEXQAUD3DXVECTOR3@@I@Z ENDP ; std::allocator<D3DXVECTOR3>::deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ??_GSpherePackCallback@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSpherePackCallback@@UAEPAXI@Z PROC			; SpherePackCallback::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 56   : 	virtual ~SpherePackCallback() {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7SpherePackCallback@@6B@
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 0c		 je	 SHORT $LN2@scalar
  00018	6a 04		 push	 4
  0001a	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
$LN2@scalar:
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??_GSpherePackCallback@@UAEPAXI@Z ENDP			; SpherePackCallback::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_searchpos$ = 8						; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::PointTest2dCallback, COMDAT
; _this$ = ecx

; 79   : 	{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 0c 00	 ret	 12			; 0000000cH
?PointTest2dCallback@SpherePackCallback@@UAEXABVVector3d@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::PointTest2dCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_searchpos$ = 8						; size = 4
_distance$ = 12						; size = 4
_sphere$ = 16						; size = 4
_state$ = 20						; size = 4
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::RangeTestCallback, COMDAT
; _this$ = ecx

; 74   : 	{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 10 00	 ret	 16			; 00000010H
?RangeTestCallback@SpherePackCallback@@UAEXABVVector3d@@MPAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::RangeTestCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_p1$ = 8						; size = 4
_dir$ = 12						; size = 4
_distance$ = 16						; size = 4
_sect$ = 20						; size = 4
_sphere$ = 24						; size = 4
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z PROC ; SpherePackCallback::RayTraceCallback, COMDAT
; _this$ = ecx

; 68   : 	{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 14 00	 ret	 20			; 00000014H
?RayTraceCallback@SpherePackCallback@@UAEXABVVector3d@@0M0PAVSpherePack@@@Z ENDP ; SpherePackCallback::RayTraceCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\SphereLib\spherepack.h
;	COMDAT ?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_f$ = 8							; size = 4
_sphere$ = 12						; size = 4
_state$ = 16						; size = 4
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z PROC ; SpherePackCallback::VisibilityCallback, COMDAT
; _this$ = ecx

; 61   : 	{};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c2 0c 00	 ret	 12			; 0000000cH
?VisibilityCallback@SpherePackCallback@@UAEXABVFrustum@@PAVSpherePack@@W4ViewState@@@Z ENDP ; SpherePackCallback::VisibilityCallback
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
END
