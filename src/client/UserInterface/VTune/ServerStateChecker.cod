; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ	; CSingleton<CServerStateChecker>::~CSingleton<CServerStateChecker>
PUBLIC	??_G?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z ; CSingleton<CServerStateChecker>::`scalar deleting destructor'
PUBLIC	??0CServerStateChecker@@QAE@XZ			; CServerStateChecker::CServerStateChecker
PUBLIC	??1CServerStateChecker@@UAE@XZ			; CServerStateChecker::~CServerStateChecker
PUBLIC	?Create@CServerStateChecker@@QAEXPAU_object@@@Z	; CServerStateChecker::Create
PUBLIC	?AddChannel@CServerStateChecker@@QAEXIPBDI@Z	; CServerStateChecker::AddChannel
PUBLIC	?Request@CServerStateChecker@@QAEXXZ		; CServerStateChecker::Request
PUBLIC	?Update@CServerStateChecker@@QAEXXZ		; CServerStateChecker::Update
PUBLIC	?Initialize@CServerStateChecker@@QAEXXZ		; CServerStateChecker::Initialize
PUBLIC	??0?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
PUBLIC	??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::~list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
PUBLIC	?clear@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXXZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::clear
PUBLIC	?_Tidy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Tidy
PUBLIC	?_Alloc_sentinel_and_proxy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Alloc_sentinel_and_proxy
PUBLIC	??_GCServerStateChecker@@UAEPAXI@Z		; CServerStateChecker::`scalar deleting destructor'
PUBLIC	??$_Free_non_head@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CServerStateChecker::SChannel,void *>::_Free_non_head<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
PUBLIC	??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Emplace<CServerStateChecker::SChannel const &>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>
PUBLIC	??$_Freenode0@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CServerStateChecker::SChannel,void *>::_Freenode0<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
PUBLIC	?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_Allocate
PUBLIC	??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
PUBLIC	??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
PUBLIC	?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_Transfer_before
PUBLIC	??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > ><CServerStateChecker::SChannel const &>
PUBLIC	??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *>
PUBLIC	??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A ; CSingleton<CServerStateChecker>::ms_singleton
PUBLIC	??_7?$CSingleton@VCServerStateChecker@@@@6B@	; CSingleton<CServerStateChecker>::`vftable'
PUBLIC	??_7CServerStateChecker@@6B@			; CServerStateChecker::`vftable'
PUBLIC	??_C@_04INACLLOK@?$CIii?$CJ@			; `string'
PUBLIC	??_C@_0BD@EEDMKMGJ@NotifyChannelState@		; `string'
PUBLIC	??_C@_0O@NKNMEGII@list?5too?5long@		; `string'
PUBLIC	??_R4CServerStateChecker@@6B@			; CServerStateChecker::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCServerStateChecker@@@8			; CServerStateChecker `RTTI Type Descriptor'
PUBLIC	??_R3CServerStateChecker@@8			; CServerStateChecker::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CServerStateChecker@@8			; CServerStateChecker::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CServerStateChecker@@8		; CServerStateChecker::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8 ; CSingleton<CServerStateChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8	; CSingleton<CServerStateChecker> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCServerStateChecker@@@@8	; CSingleton<CServerStateChecker>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VCServerStateChecker@@@@8	; CSingleton<CServerStateChecker>::`RTTI Base Class Array'
PUBLIC	??_R4?$CSingleton@VCServerStateChecker@@@@6B@	; CSingleton<CServerStateChecker>::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	__imp__Py_BuildValue:PROC
EXTRN	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z:PROC ; PyCallClassMemberFunc
EXTRN	??0CNetworkStream@@QAE@XZ:PROC			; CNetworkStream::CNetworkStream
EXTRN	??1CNetworkStream@@UAE@XZ:PROC			; CNetworkStream::~CNetworkStream
EXTRN	?SetRecvBufferSize@CNetworkStream@@QAEXH@Z:PROC	; CNetworkStream::SetRecvBufferSize
EXTRN	?SetSendBufferSize@CNetworkStream@@QAEXH@Z:PROC	; CNetworkStream::SetSendBufferSize
EXTRN	?ClearRecvBuffer@CNetworkStream@@QAEXXZ:PROC	; CNetworkStream::ClearRecvBuffer
EXTRN	?Process@CNetworkStream@@QAEXXZ:PROC		; CNetworkStream::Process
EXTRN	?Connect@CNetworkStream@@QAE_NPBDHH@Z:PROC	; CNetworkStream::Connect
EXTRN	?Disconnect@CNetworkStream@@QAEXXZ:PROC		; CNetworkStream::Disconnect
EXTRN	?Recv@CNetworkStream@@QAE_NHPAX@Z:PROC		; CNetworkStream::Recv
EXTRN	?Send@CNetworkStream@@QAE_NHPBX@Z:PROC		; CNetworkStream::Send
EXTRN	??_E?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z:PROC ; CSingleton<CServerStateChecker>::`vector deleting destructor'
EXTRN	??_ECServerStateChecker@@UAEPAXI@Z:PROC		; CServerStateChecker::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A DD 01H DUP (?) ; CSingleton<CServerStateChecker>::ms_singleton
_BSS	ENDS
;	COMDAT ??_R4?$CSingleton@VCServerStateChecker@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCServerStateChecker@@@@6B@ DD 00H	; CSingleton<CServerStateChecker>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCServerStateChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCServerStateChecker@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCServerStateChecker@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8 ; CSingleton<CServerStateChecker>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCServerStateChecker@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCServerStateChecker@@@@8 DD 00H	; CSingleton<CServerStateChecker>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCServerStateChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CServerStateChecker> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCServerStateChecker@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCServerStateChecker@@@@@8 ; CSingleton<CServerStateChecker>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCServerStateChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CServerStateChecker@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CServerStateChecker@@8 DD FLAT:??_R0?AVCServerStateChecker@@@8 ; CServerStateChecker::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CServerStateChecker@@8
rdata$r	ENDS
;	COMDAT ??_R2CServerStateChecker@@8
rdata$r	SEGMENT
??_R2CServerStateChecker@@8 DD FLAT:??_R1A@?0A@EA@CServerStateChecker@@8 ; CServerStateChecker::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$CSingleton@VCServerStateChecker@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CServerStateChecker@@8
rdata$r	SEGMENT
??_R3CServerStateChecker@@8 DD 00H			; CServerStateChecker::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2CServerStateChecker@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCServerStateChecker@@@8
data$rs	SEGMENT
??_R0?AVCServerStateChecker@@@8 DD FLAT:??_7type_info@@6B@ ; CServerStateChecker `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCServerStateChecker@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CServerStateChecker@@6B@
rdata$r	SEGMENT
??_R4CServerStateChecker@@6B@ DD 00H			; CServerStateChecker::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCServerStateChecker@@@8
	DD	FLAT:??_R3CServerStateChecker@@8
rdata$r	ENDS
;	COMDAT ??_C@_0O@NKNMEGII@list?5too?5long@
CONST	SEGMENT
??_C@_0O@NKNMEGII@list?5too?5long@ DB 'list too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@EEDMKMGJ@NotifyChannelState@
CONST	SEGMENT
??_C@_0BD@EEDMKMGJ@NotifyChannelState@ DB 'NotifyChannelState', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04INACLLOK@?$CIii?$CJ@
CONST	SEGMENT
??_C@_04INACLLOK@?$CIii?$CJ@ DB '(ii)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7CServerStateChecker@@6B@
CONST	SEGMENT
??_7CServerStateChecker@@6B@ DD FLAT:??_R4CServerStateChecker@@6B@ ; CServerStateChecker::`vftable'
	DD	FLAT:??_ECServerStateChecker@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCServerStateChecker@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCServerStateChecker@@@@6B@ DD FLAT:??_R4?$CSingleton@VCServerStateChecker@@@@6B@ ; CSingleton<CServerStateChecker>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z$0
__ehfuncinfo$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CServerStateChecker@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0CServerStateChecker@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CServerStateChecker@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CServerStateChecker@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CServerStateChecker@@QAE@XZ$2
__ehfuncinfo$??0CServerStateChecker@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0CServerStateChecker@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z PROC ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z ENDP ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z PROC ; std::_Destroy_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z ENDP ; std::_Destroy_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z
_TEXT	SEGMENT
___formal$ = -40					; size = 4
$T2 = -36						; size = 4
$T3 = -32						; size = 4
$T4 = -28						; size = 4
$T5 = -24						; size = 4
__Val$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > ><CServerStateChecker::SChannel const &>, COMDAT
; _this$ = ecx

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001b	33 c5		 xor	 eax, ebp
  0001d	50		 push	 eax
  0001e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00021	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00027	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1045 :     explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr) {}

  0002a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx
  00032	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 60 04 00	 and	 DWORD PTR [eax+4], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 585  :     explicit _List_node_emplace_op2(_Alnode& _Al_, _Valtys&&... _Vals) : _Alloc_construct_ptr<_Alnode>(_Al_) {

  00039	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 586  :         this->_Allocate();

  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEXXZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_Allocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00045	8b 45 0c	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00048	89 45 e4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0004b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00051	83 c0 08	 add	 eax, 8
  00054	89 45 ec	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00057	8b 45 ec	 mov	 eax, DWORD PTR __Val$[ebp]
  0005a	89 45 e8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 587  :         _Alnode_traits::construct(this->_Al, _STD addressof(this->_Ptr->_Myval), _STD forward<_Valtys>(_Vals)...);

  0005d	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b 00		 mov	 eax, DWORD PTR [eax]
  00062	89 45 d8	 mov	 DWORD PTR ___formal$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  00065	8b 45 e8	 mov	 eax, DWORD PTR $T5[ebp]
  00068	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  0006b	8b 45 e4	 mov	 eax, DWORD PTR $T4[ebp]
  0006e	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 701  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00071	8b 75 e0	 mov	 esi, DWORD PTR $T3[ebp]
  00074	8b 7d dc	 mov	 edi, DWORD PTR $T2[ebp]
  00077	a5		 movsd
  00078	a5		 movsd
  00079	a5		 movsd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 588  :     }

  0007a	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  0007e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00081	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00084	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008b	59		 pop	 ecx
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	c9		 leave
  0008f	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > ><CServerStateChecker::SChannel const &>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@2@QAU32@@Z
_TEXT	SEGMENT
__Insert_after$ = -12					; size = 4
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
__Insert_before$ = 8					; size = 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@2@QAU32@@Z PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_Transfer_before, COMDAT
; _this$ = ecx

; 599  :     pointer _Transfer_before(const pointer _Insert_before) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 600  :         const pointer _Insert_after = _Insert_before->_Prev;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0000c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000f	89 45 f4	 mov	 DWORD PTR __Insert_after$[ebp], eax

; 601  :         _Construct_in_place(this->_Ptr->_Next, _Insert_before);

  00012	8d 45 08	 lea	 eax, DWORD PTR __Insert_before$[ebp]
  00015	50		 push	 eax
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	ff 70 04	 push	 DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 602  :         _Construct_in_place(this->_Ptr->_Prev, _Insert_after);

  00023	8d 45 f4	 lea	 eax, DWORD PTR __Insert_after$[ebp]
  00026	50		 push	 eax
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002d	83 c0 04	 add	 eax, 4
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@ABQAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@ABQAU10@@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * const &>
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx

; 603  :         const auto _Result    = this->_Ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0003e	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 604  :         this->_Ptr            = pointer{};

  00041	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00044	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 605  :         _Insert_before->_Prev = _Result;

  00048	8b 45 08	 mov	 eax, DWORD PTR __Insert_before$[ebp]
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  0004e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 606  :         _Insert_after->_Next  = _Result;

  00051	8b 45 f4	 mov	 eax, DWORD PTR __Insert_after$[ebp]
  00054	8b 4d f8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 607  :         return _Result;

  00059	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 608  :     }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@2@QAU32@@Z ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_Transfer_before
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Val$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >, COMDAT
; _this$ = ecx

; 590  :     ~_List_node_emplace_op2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 591  :         if (this->_Ptr != pointer{}) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 12		 je	 SHORT $LN1@List_node_

; 592  :             _Alnode_traits::destroy(this->_Al, _STD addressof(this->_Ptr->_Myval));

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	83 c0 08	 add	 eax, 8
  0001b	89 45 f8	 mov	 DWORD PTR __Val$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0001e	8b 45 f8	 mov	 eax, DWORD PTR __Val$[ebp]
  00021	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
$LN1@List_node_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 594  :     }

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
  0002c	c9		 leave
  0002d	c3		 ret	 0
??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$ = -8						; size = 4
_this$ = -4						; size = 4
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >, COMDAT
; _this$ = ecx

; 1056 :     ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1057 :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 22		 je	 SHORT $LN3@Alloc_cons

; 1058 :             _Al.deallocate(_Ptr, 1);

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00018	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 00		 mov	 eax, DWORD PTR [eax]
  00020	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	6b c0 14	 imul	 eax, eax, 20
  00029	50		 push	 eax
  0002a	ff 75 f8	 push	 DWORD PTR __Ptr$[ebp]
  0002d	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00032	59		 pop	 ecx
  00033	59		 pop	 ecx
$LN3@Alloc_cons:

; 1059 :         }
; 1060 :     }

  00034	c9		 leave
  00035	c3		 ret	 0
??1?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -24					; size = 4
_this$ = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$4 = -1				; size = 1
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEXXZ PROC ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_Allocate, COMDAT
; _this$ = ecx

; 1051 :     void _Allocate() { // disengage *this, then allocate a new memory block

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1052 :         _Ptr = nullptr; // if allocate throws, prevents double-free

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1053 :         _Ptr = _Al.allocate(1);

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 00		 mov	 eax, DWORD PTR [eax]
  00015	89 45 ec	 mov	 DWORD PTR _this$[ebp], eax

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00018	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$4[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001c	c7 45 e8 cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax
  00026	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  0002b	76 05		 jbe	 SHORT $LN6@Allocate

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  0002d	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN6@Allocate:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00032	33 c0		 xor	 eax, eax
  00034	40		 inc	 eax
  00035	6b c0 14	 imul	 eax, eax, 20
  00038	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0003e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00043	59		 pop	 ecx
  00044	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax

; 1053 :         _Ptr = _Al.allocate(1);

  00047	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR $T2[ebp]
  0004d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN9@Allocate:

; 1054 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?_Allocate@?$_Alloc_construct_ptr@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEXXZ ENDP ; std::_Alloc_construct_ptr<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_Allocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Freenode0@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Freenode0@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<CServerStateChecker::SChannel,void *>::_Freenode0<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >, COMDAT

; 307  :     static void _Freenode0(_Alnode& _Al, _Nodeptr _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :         // destroy pointer members in _Ptr and deallocate with _Al
; 309  :         static_assert(is_same_v<typename _Alnode::value_type, _List_node>, "Bad _Freenode0 call");
; 310  :         _Destroy_in_place(_Ptr->_Next);

  00003	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00006	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *>
  0000b	59		 pop	 ecx

; 311  :         _Destroy_in_place(_Ptr->_Prev);

  0000c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000f	83 c0 04	 add	 eax, 4
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@@Z ; std::_Destroy_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *>
  00018	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 696  :         _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00019	33 c0		 xor	 eax, eax
  0001b	40		 inc	 eax
  0001c	6b c0 14	 imul	 eax, eax, 20
  0001f	50		 push	 eax
  00020	ff 75 0c	 push	 DWORD PTR __Ptr$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 313  :     }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Freenode0@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<CServerStateChecker::SChannel,void *>::_Freenode0<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z PROC ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z ENDP ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z
_TEXT	SEGMENT
__Op$ = -76						; size = 8
$T1 = -68						; size = 4
$T2 = -64						; size = 4
$T3 = -60						; size = 4
$T4 = -56						; size = 4
$T5 = -52						; size = 4
$T6 = -48						; size = 4
$T7 = -44						; size = 4
$T8 = -40						; size = 4
$T9 = -36						; size = 4
$T10 = -32						; size = 4
tv80 = -28						; size = 4
tv82 = -24						; size = 4
tv94 = -20						; size = 4
$T11 = -16						; size = 4
$T12 = -12						; size = 4
__Mysize$ = -8						; size = 4
_this$ = -4						; size = 4
__Where$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z PROC ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Emplace<CServerStateChecker::SChannel const &>, COMDAT
; _this$ = ecx

; 1012 :     _Nodeptr _Emplace(const _Nodeptr _Where, _Valty&&... _Val) { // insert element at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1013 :         size_type& _Mysize = _Mypair._Myval2._Mysize;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 c0 04	 add	 eax, 4
  0000f	89 45 f8	 mov	 DWORD PTR __Mysize$[ebp], eax

; 1791 :         return _Mypair._Get_first();

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  00015	89 45 e0	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1791 :         return _Mypair._Get_first();

  00018	8b 45 e0	 mov	 eax, DWORD PTR $T10[ebp]
  0001b	89 45 c4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0001e	c7 45 f4 cc cc
	cc 0c		 mov	 DWORD PTR $T12[ebp], 214748364 ; 0cccccccH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00025	c7 45 dc ff ff
	ff 7f		 mov	 DWORD PTR $T9[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  0002c	8b 45 dc	 mov	 eax, DWORD PTR $T9[ebp]
  0002f	89 45 f0	 mov	 DWORD PTR $T11[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  00032	8b 45 f4	 mov	 eax, DWORD PTR $T12[ebp]
  00035	3b 45 f0	 cmp	 eax, DWORD PTR $T11[ebp]
  00038	73 08		 jae	 SHORT $LN22@Emplace
  0003a	8d 45 f4	 lea	 eax, DWORD PTR $T12[ebp]
  0003d	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00040	eb 06		 jmp	 SHORT $LN23@Emplace
$LN22@Emplace:
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T11[ebp]
  00045	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
$LN23@Emplace:
  00048	8b 45 ec	 mov	 eax, DWORD PTR tv94[ebp]
  0004b	89 45 d8	 mov	 DWORD PTR $T8[ebp], eax
  0004e	8b 45 d8	 mov	 eax, DWORD PTR $T8[ebp]
  00051	89 45 d4	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1195 :         return (_STD min)(

  00054	8b 45 d4	 mov	 eax, DWORD PTR $T7[ebp]
  00057	8b 00		 mov	 eax, DWORD PTR [eax]
  00059	89 45 d0	 mov	 DWORD PTR $T6[ebp], eax

; 1014 :         if (_Mysize == max_size()) {

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	3b 45 d0	 cmp	 eax, DWORD PTR $T6[ebp]
  00064	75 0a		 jne	 SHORT $LN2@Emplace

; 1015 :             _Xlength_error("list too long");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0O@NKNMEGII@list?5too?5long@
  0006b	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Emplace:

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00070	8b 45 c0	 mov	 eax, DWORD PTR $T2[ebp]
  00073	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1787 :         return _Mypair._Get_first();

  00076	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00079	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0007c	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]
  0007f	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  00082	8b 45 bc	 mov	 eax, DWORD PTR $T1[ebp]
  00085	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00088	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0008b	89 45 e8	 mov	 DWORD PTR tv82[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1018 :         _List_node_emplace_op2<_Alnode> _Op{_Getal(), _STD forward<_Valty>(_Val)...};

  0008e	ff 75 e8	 push	 DWORD PTR tv82[ebp]
  00091	ff 75 e4	 push	 DWORD PTR tv80[ebp]
  00094	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  00097	e8 00 00 00 00	 call	 ??$?0ABUSChannel@CServerStateChecker@@@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@AAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@ABUSChannel@CServerStateChecker@@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > ><CServerStateChecker::SChannel const &>

; 1019 :         ++_Mysize;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR __Mysize$[ebp]
  0009f	8b 00		 mov	 eax, DWORD PTR [eax]
  000a1	40		 inc	 eax
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR __Mysize$[ebp]
  000a5	89 01		 mov	 DWORD PTR [ecx], eax

; 1020 :         return _Op._Transfer_before(_Where);

  000a7	ff 75 08	 push	 DWORD PTR __Where$[ebp]
  000aa	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000ad	e8 00 00 00 00	 call	 ?_Transfer_before@?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@2@QAU32@@Z ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::_Transfer_before
  000b2	89 45 c8	 mov	 DWORD PTR $T4[ebp], eax
  000b5	8d 4d b4	 lea	 ecx, DWORD PTR __Op$[ebp]
  000b8	e8 00 00 00 00	 call	 ??1?$_List_node_emplace_op2@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@std@@QAE@XZ ; std::_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >::~_List_node_emplace_op2<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
  000bd	8b 45 c8	 mov	 eax, DWORD PTR $T4[ebp]
$LN3@Emplace:

; 1021 :     }

  000c0	c9		 leave
  000c1	c2 08 00	 ret	 8
??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z ENDP ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Emplace<CServerStateChecker::SChannel const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??$_Free_non_head@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__Pnext$2 = -8						; size = 4
__Pnode$ = -4						; size = 4
__Al$ = 8						; size = 4
__Head$ = 12						; size = 4
??$_Free_non_head@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z PROC ; std::_List_node<CServerStateChecker::SChannel,void *>::_Free_non_head<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >, COMDAT

; 323  :         _Alnode& _Al, _Nodeptr _Head) noexcept { // free a list starting at _First and terminated at nullptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 324  :         _Head->_Prev->_Next = nullptr;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00009	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000c	83 20 00	 and	 DWORD PTR [eax], 0

; 325  : 
; 326  :         auto _Pnode = _Head->_Next;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR __Head$[ebp]
  00012	8b 00		 mov	 eax, DWORD PTR [eax]
  00014	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax

; 327  :         for (_Nodeptr _Pnext; _Pnode; _Pnode = _Pnext) {

  00017	eb 06		 jmp	 SHORT $LN4@Free_non_h
$LN2@Free_non_h:
  00019	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0001c	89 45 fc	 mov	 DWORD PTR __Pnode$[ebp], eax
$LN4@Free_non_h:
  0001f	83 7d fc 00	 cmp	 DWORD PTR __Pnode$[ebp], 0
  00023	74 20		 je	 SHORT $LN5@Free_non_h

; 328  :             _Pnext = _Pnode->_Next;

  00025	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00028	8b 00		 mov	 eax, DWORD PTR [eax]
  0002a	89 45 f8	 mov	 DWORD PTR __Pnext$2[ebp], eax

; 317  :         allocator_traits<_Alnode>::destroy(_Al, _STD addressof(_Ptr->_Myval));

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Pnode$[ebp]
  00030	83 c0 08	 add	 eax, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00033	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 318  :         _Freenode0(_Al, _Ptr);

  00036	ff 75 fc	 push	 DWORD PTR __Pnode$[ebp]
  00039	ff 75 08	 push	 DWORD PTR __Al$[ebp]
  0003c	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CServerStateChecker::SChannel,void *>::_Freenode0<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
  00041	59		 pop	 ecx
  00042	59		 pop	 ecx

; 329  :             _Freenode(_Al, _Pnode);
; 330  :         }

  00043	eb d4		 jmp	 SHORT $LN2@Free_non_h
$LN5@Free_non_h:

; 331  :     }

  00045	c9		 leave
  00046	c3		 ret	 0
??$_Free_non_head@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z ENDP ; std::_List_node<CServerStateChecker::SChannel,void *>::_Free_non_head<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCServerStateChecker@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCServerStateChecker@@UAEPAXI@Z PROC			; CServerStateChecker::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CServerStateChecker@@UAE@XZ ; CServerStateChecker::~CServerStateChecker
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 8c 00 00 00	 push	 140			; 0000008cH
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCServerStateChecker@@UAEPAXI@Z ENDP			; CServerStateChecker::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Alloc_sentinel_and_proxy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Max_possible$1 = -36					; size = 4
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
$T2 = -24						; size = 4
$T3 = -20						; size = 4
$T4 = -16						; size = 4
_this$ = -12						; size = 4
__Newhead$ = -8						; size = 4
__Overflow_is_possible$5 = -2				; size = 1
_$S12$ = -1						; size = 1
?_Alloc_sentinel_and_proxy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ PROC ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Alloc_sentinel_and_proxy, COMDAT
; _this$ = ecx

; 1771 :     void _Alloc_sentinel_and_proxy() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());

  00009	8d 45 ff	 lea	 eax, DWORD PTR _$S12$[ebp]
  0000c	89 45 e4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001b	c6 45 fe 01	 mov	 BYTE PTR __Overflow_is_possible$5[ebp], 1

; 57   : 
; 58   :     if _CONSTEXPR_IF (_Overflow_is_possible) {
; 59   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0001f	c7 45 dc cc cc
	cc 0c		 mov	 DWORD PTR __Max_possible$1[ebp], 214748364 ; 0cccccccH

; 60   :         if (_Count > _Max_possible) {

  00026	33 c0		 xor	 eax, eax
  00028	40		 inc	 eax
  00029	3d cc cc cc 0c	 cmp	 eax, 214748364		; 0cccccccH
  0002e	76 05		 jbe	 SHORT $LN15@Alloc_sent

; 61   :             _Throw_bad_array_new_length(); // multiply overflow

  00030	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN15@Alloc_sent:

; 62   :         }
; 63   :     }
; 64   : 
; 65   :     return _Count * _Ty_size;

  00035	33 c0		 xor	 eax, eax
  00037	40		 inc	 eax
  00038	6b c0 14	 imul	 eax, eax, 20
  0003b	89 45 ec	 mov	 DWORD PTR $T3[ebp], eax

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  0003e	ff 75 ec	 push	 DWORD PTR $T3[ebp]
  00041	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00046	59		 pop	 ecx
  00047	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1775 :         auto _Newhead = _Al.allocate(1);

  0004a	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
  0004d	89 45 f8	 mov	 DWORD PTR __Newhead$[ebp], eax

; 1776 :         _Construct_in_place(_Newhead->_Next, _Newhead);

  00050	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00053	50		 push	 eax
  00054	ff 75 f8	 push	 DWORD PTR __Newhead$[ebp]
  00057	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>
  0005c	59		 pop	 ecx
  0005d	59		 pop	 ecx

; 1777 :         _Construct_in_place(_Newhead->_Prev, _Newhead);

  0005e	8d 45 f8	 lea	 eax, DWORD PTR __Newhead$[ebp]
  00061	50		 push	 eax
  00062	8b 45 f8	 mov	 eax, DWORD PTR __Newhead$[ebp]
  00065	83 c0 04	 add	 eax, 4
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ??$_Construct_in_place@PAU?$_List_node@USChannel@CServerStateChecker@@PAX@std@@AAPAU12@@std@@YAXAAPAU?$_List_node@USChannel@CServerStateChecker@@PAX@0@0@Z ; std::_Construct_in_place<std::_List_node<CServerStateChecker::SChannel,void *> *,std::_List_node<CServerStateChecker::SChannel,void *> * &>
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 1778 :         _Mypair._Myval2._Myhead = _Newhead;

  00070	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00073	8b 4d f8	 mov	 ecx, DWORD PTR __Newhead$[ebp]
  00076	89 08		 mov	 DWORD PTR [eax], ecx
$LN18@Alloc_sent:

; 1779 :         _Proxy._Release();
; 1780 :     }

  00078	c9		 leave
  00079	c3		 ret	 0
?_Alloc_sentinel_and_proxy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ ENDP ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Alloc_sentinel_and_proxy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?_Tidy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
__Al$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ PROC ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Tidy, COMDAT
; _this$ = ecx

; 1436 :     void _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :         return _Mypair._Get_first();

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  0000c	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  00012	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1437 :         auto& _Al      = _Getal();
; 1438 :         auto& _My_data = _Mypair._Myval2;

  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1439 :         _My_data._Orphan_all();
; 1440 :         _Node::_Free_non_head(_Al, _My_data._Myhead);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CServerStateChecker::SChannel,void *>::_Free_non_head<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1441 :         _Node::_Freenode0(_Al, _My_data._Myhead);

  0002a	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	ff 30		 push	 DWORD PTR [eax]
  0002f	ff 75 f4	 push	 DWORD PTR __Al$[ebp]
  00032	e8 00 00 00 00	 call	 ??$_Freenode0@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CServerStateChecker::SChannel,void *>::_Freenode0<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
  00037	59		 pop	 ecx
  00038	59		 pop	 ecx

; 1442 :     }

  00039	c9		 leave
  0003a	c3		 ret	 0
?_Tidy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ ENDP ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ?clear@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?clear@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXXZ PROC ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::clear, COMDAT
; _this$ = ecx

; 1426 :     void clear() noexcept { // erase all

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1427 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1787 :         return _Mypair._Get_first();

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00012	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1787 :         return _Mypair._Get_first();

  00015	8b 45 f4	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax

; 1428 :         _My_data._Orphan_non_end();
; 1429 :         _Node::_Free_non_head(_Getal(), _My_data._Myhead);

  0001b	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	ff 30		 push	 DWORD PTR [eax]
  00020	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00023	e8 00 00 00 00	 call	 ??$_Free_non_head@V?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@std@@@?$_List_node@USChannel@CServerStateChecker@@PAX@std@@SAXAAV?$allocator@U?$_List_node@USChannel@CServerStateChecker@@PAX@std@@@1@PAU01@@Z ; std::_List_node<CServerStateChecker::SChannel,void *>::_Free_non_head<std::allocator<std::_List_node<CServerStateChecker::SChannel,void *> > >
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 1430 :         _My_data._Myhead->_Next = _My_data._Myhead;

  0002a	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00032	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00034	89 08		 mov	 DWORD PTR [eax], ecx

; 1431 :         _My_data._Myhead->_Prev = _My_data._Myhead;

  00036	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00040	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1432 :         _My_data._Mysize        = 0;

  00043	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00046	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 1433 :     }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?clear@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXXZ ENDP ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::clear
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ PROC ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::~list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >, COMDAT
; _this$ = ecx

; 1045 :     ~list() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1046 :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Tidy

; 1047 : #if _ITERATOR_DEBUG_LEVEL != 0 // TRANSITION, ABI
; 1048 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alnode, _Getal());
; 1049 :         _Delete_plain_internal(_Alproxy, _Mypair._Myval2._Myproxy);
; 1050 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1051 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ENDP ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::~list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
;	COMDAT ??0?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ PROC ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >, COMDAT
; _this$ = ecx

; 804  :     list() : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 354  :     _List_val() noexcept : _Myhead(), _Mysize(0) {} // initialize data

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 20 00	 and	 DWORD PTR [eax], 0
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 805  :         _Alloc_sentinel_and_proxy();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Alloc_sentinel_and_proxy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Alloc_sentinel_and_proxy

; 806  :     }

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	c9		 leave
  0002e	c3		 ret	 0
??0?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ENDP ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?Initialize@CServerStateChecker@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Initialize@CServerStateChecker@@QAEXXZ PROC		; CServerStateChecker::Initialize, COMDAT
; _this$ = ecx

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 103  : 	m_lstChannel.clear();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 08	 add	 ecx, 8
  0000d	e8 00 00 00 00	 call	 ?clear@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEXXZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::clear

; 104  : 	m_kStream.Disconnect();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 10	 add	 ecx, 16			; 00000010H
  00018	e8 00 00 00 00	 call	 ?Disconnect@CNetworkStream@@QAEXXZ ; CNetworkStream::Disconnect

; 105  : }

  0001d	c9		 leave
  0001e	c3		 ret	 0
?Initialize@CServerStateChecker@@QAEXXZ ENDP		; CServerStateChecker::Initialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?Update@CServerStateChecker@@QAEXXZ
_TEXT	SEGMENT
$T1 = -104						; size = 4
$T2 = -100						; size = 4
$T3 = -96						; size = 4
$T4 = -92						; size = 4
$T5 = -88						; size = 4
$T6 = -84						; size = 4
$T7 = -80						; size = 4
$T8 = -76						; size = 4
$T9 = -72						; size = 4
$T10 = -68						; size = 4
$T11 = -64						; size = 4
$T12 = -60						; size = 4
___param0$ = -56					; size = 4
$T13 = -52						; size = 4
$T14 = -48						; size = 4
___param0$ = -44					; size = 4
_nSize$ = -40						; size = 4
tv211 = -36						; size = 4
tv235 = -32						; size = 4
_this$ = -28						; size = 4
_this$ = -24						; size = 4
_i$15 = -20						; size = 4
_it$16 = -16						; size = 4
_this$ = -12						; size = 4
_channelStatus$17 = -8					; size = 3
$T18 = -3						; size = 1
$T19 = -2						; size = 1
_bHeader$ = -1						; size = 1
?Update@CServerStateChecker@@QAEXXZ PROC		; CServerStateChecker::Update, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 73   : 	m_kStream.Process();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	83 c1 10	 add	 ecx, 16			; 00000010H
  0000f	e8 00 00 00 00	 call	 ?Process@CNetworkStream@@QAEXXZ ; CNetworkStream::Process

; 74   : 
; 75   : 	BYTE bHeader;
; 76   : 	if (!m_kStream.Recv(sizeof(bHeader), &bHeader)) {

  00014	8d 45 ff	 lea	 eax, DWORD PTR _bHeader$[ebp]
  00017	50		 push	 eax
  00018	6a 01		 push	 1
  0001a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 10	 add	 ecx, 16			; 00000010H
  00020	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	75 05		 jne	 SHORT $LN8@Update

; 77   : 		return;

  0002c	e9 7f 01 00 00	 jmp	 $LN1@Update
$LN8@Update:

; 78   : 	}
; 79   : 	if (HEADER_GC_RESPOND_CHANNELSTATUS != bHeader) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR _bHeader$[ebp]
  00035	3d d2 00 00 00	 cmp	 eax, 210		; 000000d2H
  0003a	74 05		 je	 SHORT $LN9@Update

; 80   : 		return;

  0003c	e9 6f 01 00 00	 jmp	 $LN1@Update
$LN9@Update:

; 81   : 	}
; 82   : 	int nSize;
; 83   : 	if (!m_kStream.Recv(sizeof(nSize), &nSize)) {

  00041	8d 45 d8	 lea	 eax, DWORD PTR _nSize$[ebp]
  00044	50		 push	 eax
  00045	6a 04		 push	 4
  00047	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	83 c1 10	 add	 ecx, 16			; 00000010H
  0004d	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00052	0f b6 c0	 movzx	 eax, al
  00055	85 c0		 test	 eax, eax
  00057	75 05		 jne	 SHORT $LN10@Update

; 84   : 		return;

  00059	e9 52 01 00 00	 jmp	 $LN1@Update
$LN10@Update:

; 85   : 	}
; 86   : 	for (int i = 0; i < nSize; i++) {

  0005e	83 65 ec 00	 and	 DWORD PTR _i$15[ebp], 0
  00062	eb 07		 jmp	 SHORT $LN4@Update
$LN2@Update:
  00064	8b 45 ec	 mov	 eax, DWORD PTR _i$15[ebp]
  00067	40		 inc	 eax
  00068	89 45 ec	 mov	 DWORD PTR _i$15[ebp], eax
$LN4@Update:
  0006b	8b 45 ec	 mov	 eax, DWORD PTR _i$15[ebp]
  0006e	3b 45 d8	 cmp	 eax, DWORD PTR _nSize$[ebp]
  00071	0f 8d 31 01 00
	00		 jge	 $LN3@Update

; 87   : 		TChannelStatus channelStatus;
; 88   : 		if (!m_kStream.Recv(sizeof(channelStatus), &channelStatus)) {

  00077	8d 45 f8	 lea	 eax, DWORD PTR _channelStatus$17[ebp]
  0007a	50		 push	 eax
  0007b	6a 03		 push	 3
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00080	83 c1 10	 add	 ecx, 16			; 00000010H
  00083	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00088	0f b6 c0	 movzx	 eax, al
  0008b	85 c0		 test	 eax, eax
  0008d	75 05		 jne	 SHORT $LN11@Update

; 89   : 			return;

  0008f	e9 1c 01 00 00	 jmp	 $LN1@Update
$LN11@Update:

; 91   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  00094	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00097	83 c0 08	 add	 eax, 8
  0009a	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0009d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000a0	89 45 9c	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000a3	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b 00		 mov	 eax, DWORD PTR [eax]
  000a8	8b 00		 mov	 eax, DWORD PTR [eax]
  000aa	89 45 d4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000ad	8b 45 d4	 mov	 eax, DWORD PTR ___param0$[ebp]
  000b0	89 45 d0	 mov	 DWORD PTR $T14[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000b3	8d 45 d0	 lea	 eax, DWORD PTR $T14[ebp]
  000b6	89 45 cc	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 91   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  000b9	8b 45 cc	 mov	 eax, DWORD PTR $T13[ebp]
  000bc	8b 00		 mov	 eax, DWORD PTR [eax]
  000be	89 45 f0	 mov	 DWORD PTR _it$16[ebp], eax
  000c1	eb 08		 jmp	 SHORT $LN7@Update
$LN5@Update:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  000c3	8b 45 f0	 mov	 eax, DWORD PTR _it$16[ebp]
  000c6	8b 00		 mov	 eax, DWORD PTR [eax]
  000c8	89 45 f0	 mov	 DWORD PTR _it$16[ebp], eax
$LN7@Update:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 91   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  000cb	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	83 c0 08	 add	 eax, 8
  000d1	89 45 e4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000d4	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000d7	89 45 98	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000da	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  000dd	8b 00		 mov	 eax, DWORD PTR [eax]
  000df	89 45 c8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  000e2	8b 45 c8	 mov	 eax, DWORD PTR ___param0$[ebp]
  000e5	89 45 c4	 mov	 DWORD PTR $T12[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  000e8	8d 45 c4	 lea	 eax, DWORD PTR $T12[ebp]
  000eb	89 45 c0	 mov	 DWORD PTR $T11[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  000ee	8b 45 c0	 mov	 eax, DWORD PTR $T11[ebp]
  000f1	8b 4d f0	 mov	 ecx, DWORD PTR _it$16[ebp]
  000f4	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000f6	75 09		 jne	 SHORT $LN60@Update
  000f8	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR tv235[ebp], 1
  000ff	eb 04		 jmp	 SHORT $LN61@Update
$LN60@Update:
  00101	83 65 e0 00	 and	 DWORD PTR tv235[ebp], 0
$LN61@Update:
  00105	8a 45 e0	 mov	 al, BYTE PTR tv235[ebp]
  00108	88 45 fe	 mov	 BYTE PTR $T19[ebp], al

; 203  :         return !(*this == _Right);

  0010b	0f b6 45 fe	 movzx	 eax, BYTE PTR $T19[ebp]
  0010f	85 c0		 test	 eax, eax
  00111	75 09		 jne	 SHORT $LN55@Update
  00113	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR tv211[ebp], 1
  0011a	eb 04		 jmp	 SHORT $LN56@Update
$LN55@Update:
  0011c	83 65 dc 00	 and	 DWORD PTR tv211[ebp], 0
$LN56@Update:
  00120	8a 45 dc	 mov	 al, BYTE PTR tv211[ebp]
  00123	88 45 fd	 mov	 BYTE PTR $T18[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 91   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  00126	0f b6 45 fd	 movzx	 eax, BYTE PTR $T18[ebp]
  0012a	85 c0		 test	 eax, eax
  0012c	74 75		 je	 SHORT $LN6@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  0012e	8b 45 f0	 mov	 eax, DWORD PTR _it$16[ebp]
  00131	83 c0 08	 add	 eax, 8
  00134	89 45 bc	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00137	8b 45 bc	 mov	 eax, DWORD PTR $T10[ebp]
  0013a	89 45 b8	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  0013d	8b 45 b8	 mov	 eax, DWORD PTR $T9[ebp]
  00140	89 45 b4	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 156  :         return pointer_traits<pointer>::pointer_to(**this);

  00143	8b 45 b4	 mov	 eax, DWORD PTR $T8[ebp]
  00146	89 45 b0	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 92   : 			if (channelStatus.nPort == it->uPort) {

  00149	0f bf 45 f8	 movsx	 eax, WORD PTR _channelStatus$17[ebp]
  0014d	8b 4d b0	 mov	 ecx, DWORD PTR $T7[ebp]
  00150	3b 41 08	 cmp	 eax, DWORD PTR [ecx+8]
  00153	75 49		 jne	 SHORT $LN12@Update
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00155	8b 45 f0	 mov	 eax, DWORD PTR _it$16[ebp]
  00158	83 c0 08	 add	 eax, 8
  0015b	89 45 ac	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0015e	8b 45 ac	 mov	 eax, DWORD PTR $T6[ebp]
  00161	89 45 a8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00164	8b 45 a8	 mov	 eax, DWORD PTR $T5[ebp]
  00167	89 45 a4	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 156  :         return pointer_traits<pointer>::pointer_to(**this);

  0016a	8b 45 a4	 mov	 eax, DWORD PTR $T4[ebp]
  0016d	89 45 a0	 mov	 DWORD PTR $T3[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 93   : 				PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, channelStatus.bStatus));

  00170	0f b6 45 fa	 movzx	 eax, BYTE PTR _channelStatus$17[ebp+2]
  00174	50		 push	 eax
  00175	8b 45 a0	 mov	 eax, DWORD PTR $T3[ebp]
  00178	ff 30		 push	 DWORD PTR [eax]
  0017a	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ@
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00185	83 c4 0c	 add	 esp, 12			; 0000000cH
  00188	50		 push	 eax
  00189	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEDMKMGJ@NotifyChannelState@
  0018e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00191	ff 70 04	 push	 DWORD PTR [eax+4]
  00194	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00199	83 c4 0c	 add	 esp, 12			; 0000000cH

; 94   : 				break;

  0019c	eb 05		 jmp	 SHORT $LN6@Update
$LN12@Update:

; 95   : 			}
; 96   : 		}

  0019e	e9 20 ff ff ff	 jmp	 $LN5@Update
$LN6@Update:

; 97   : 	}

  001a3	e9 bc fe ff ff	 jmp	 $LN2@Update
$LN3@Update:

; 98   : 	Initialize();

  001a8	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001ab	e8 00 00 00 00	 call	 ?Initialize@CServerStateChecker@@QAEXXZ ; CServerStateChecker::Initialize
$LN1@Update:

; 99   : }

  001b0	c9		 leave
  001b1	c3		 ret	 0
?Update@CServerStateChecker@@QAEXXZ ENDP		; CServerStateChecker::Update
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?Request@CServerStateChecker@@QAEXXZ
_TEXT	SEGMENT
$T1 = -112						; size = 4
$T2 = -108						; size = 4
$T3 = -104						; size = 4
$T4 = -100						; size = 4
$T5 = -96						; size = 4
$T6 = -92						; size = 4
$T7 = -88						; size = 4
$T8 = -84						; size = 4
$T9 = -80						; size = 4
$T10 = -76						; size = 4
$T11 = -72						; size = 4
$T12 = -68						; size = 4
___param0$ = -64					; size = 4
$T13 = -60						; size = 4
$T14 = -56						; size = 4
___param0$ = -52					; size = 4
$T15 = -48						; size = 4
$T16 = -44						; size = 4
$T17 = -40						; size = 4
$T18 = -36						; size = 4
$T19 = -32						; size = 4
$T20 = -28						; size = 4
___param0$ = -24					; size = 4
$T21 = -20						; size = 4
$T22 = -16						; size = 4
___param0$ = -12					; size = 4
$T23 = -8						; size = 4
$T24 = -4						; size = 4
$T25 = 0						; size = 4
$T26 = 4						; size = 4
$T27 = 8						; size = 4
$T28 = 12						; size = 4
$T29 = 16						; size = 4
$T30 = 20						; size = 4
___param0$ = 24						; size = 4
$T31 = 28						; size = 4
$T32 = 32						; size = 4
$T33 = 36						; size = 4
$T34 = 40						; size = 4
$T35 = 44						; size = 4
$T36 = 48						; size = 4
___param0$ = 52						; size = 4
tv438 = 56						; size = 4
tv462 = 60						; size = 4
_this$ = 64						; size = 4
_this$ = 68						; size = 4
tv361 = 72						; size = 4
tv385 = 76						; size = 4
_this$ = 80						; size = 4
_this$ = 84						; size = 4
_this$ = 88						; size = 4
_this$ = 92						; size = 4
tv211 = 96						; size = 4
_it$37 = 100						; size = 4
_it$38 = 104						; size = 4
$T39 = 110						; size = 1
$T40 = 111						; size = 1
_bHeader$ = 112						; size = 1
$T41 = 113						; size = 1
$T42 = 114						; size = 1
$T43 = 115						; size = 1
_this$ = 116						; size = 4
?Request@CServerStateChecker@@QAEXXZ PROC		; CServerStateChecker::Request, COMDAT
; _this$ = ecx

; 44   : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  0000b	89 4d 74	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1200 :         return _Mypair._Myval2._Mysize == 0;

  0000e	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00011	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00015	75 09		 jne	 SHORT $LN14@Request
  00017	c7 45 60 01 00
	00 00		 mov	 DWORD PTR tv211[ebp], 1
  0001e	eb 04		 jmp	 SHORT $LN15@Request
$LN14@Request:
  00020	83 65 60 00	 and	 DWORD PTR tv211[ebp], 0
$LN15@Request:
  00024	8a 45 60	 mov	 al, BYTE PTR tv211[ebp]
  00027	88 45 73	 mov	 BYTE PTR $T43[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 45   : 	if (m_lstChannel.empty()) { 

  0002a	0f b6 45 73	 movzx	 eax, BYTE PTR $T43[ebp]
  0002e	85 c0		 test	 eax, eax
  00030	74 05		 je	 SHORT $LN8@Request

; 46   : 		return; 

  00032	e9 d2 02 00 00	 jmp	 $LN1@Request
$LN8@Request:

; 49   : 	if (!m_kStream.Connect(m_lstChannel.begin()->c_szAddr, m_lstChannel.begin()->uPort))

  00037	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 c0 08	 add	 eax, 8
  0003d	89 45 5c	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00040	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00043	89 45 a4	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00046	8b 45 5c	 mov	 eax, DWORD PTR _this$[ebp]
  00049	8b 00		 mov	 eax, DWORD PTR [eax]
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
  0004d	89 45 34	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00050	8b 45 34	 mov	 eax, DWORD PTR ___param0$[ebp]
  00053	89 45 30	 mov	 DWORD PTR $T36[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00056	8d 45 30	 lea	 eax, DWORD PTR $T36[ebp]
  00059	89 45 2c	 mov	 DWORD PTR $T35[ebp], eax

; 152  :         return this->_Ptr->_Myval;

  0005c	8b 45 2c	 mov	 eax, DWORD PTR $T35[ebp]
  0005f	8b 00		 mov	 eax, DWORD PTR [eax]
  00061	83 c0 08	 add	 eax, 8
  00064	89 45 28	 mov	 DWORD PTR $T34[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  00067	8b 45 28	 mov	 eax, DWORD PTR $T34[ebp]
  0006a	89 45 24	 mov	 DWORD PTR $T33[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0006d	8b 45 24	 mov	 eax, DWORD PTR $T33[ebp]
  00070	89 45 20	 mov	 DWORD PTR $T32[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00073	8b 45 20	 mov	 eax, DWORD PTR $T32[ebp]
  00076	89 45 1c	 mov	 DWORD PTR $T31[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 243  :         return pointer_traits<pointer>::pointer_to(**this);

  00079	8b 45 1c	 mov	 eax, DWORD PTR $T31[ebp]
  0007c	89 45 fc	 mov	 DWORD PTR $T24[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 49   : 	if (!m_kStream.Connect(m_lstChannel.begin()->c_szAddr, m_lstChannel.begin()->uPort))

  0007f	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00082	83 c0 08	 add	 eax, 8
  00085	89 45 58	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00088	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0008b	89 45 a0	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0008e	8b 45 58	 mov	 eax, DWORD PTR _this$[ebp]
  00091	8b 00		 mov	 eax, DWORD PTR [eax]
  00093	8b 00		 mov	 eax, DWORD PTR [eax]
  00095	89 45 18	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00098	8b 45 18	 mov	 eax, DWORD PTR ___param0$[ebp]
  0009b	89 45 14	 mov	 DWORD PTR $T30[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0009e	8d 45 14	 lea	 eax, DWORD PTR $T30[ebp]
  000a1	89 45 10	 mov	 DWORD PTR $T29[ebp], eax

; 152  :         return this->_Ptr->_Myval;

  000a4	8b 45 10	 mov	 eax, DWORD PTR $T29[ebp]
  000a7	8b 00		 mov	 eax, DWORD PTR [eax]
  000a9	83 c0 08	 add	 eax, 8
  000ac	89 45 0c	 mov	 DWORD PTR $T28[ebp], eax

; 239  :         return const_cast<reference>(_Mybase::operator*());

  000af	8b 45 0c	 mov	 eax, DWORD PTR $T28[ebp]
  000b2	89 45 08	 mov	 DWORD PTR $T27[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000b5	8b 45 08	 mov	 eax, DWORD PTR $T27[ebp]
  000b8	89 45 04	 mov	 DWORD PTR $T26[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  000bb	8b 45 04	 mov	 eax, DWORD PTR $T26[ebp]
  000be	89 45 00	 mov	 DWORD PTR $T25[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 243  :         return pointer_traits<pointer>::pointer_to(**this);

  000c1	8b 45 00	 mov	 eax, DWORD PTR $T25[ebp]
  000c4	89 45 f8	 mov	 DWORD PTR $T23[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 49   : 	if (!m_kStream.Connect(m_lstChannel.begin()->c_szAddr, m_lstChannel.begin()->uPort))

  000c7	6a 03		 push	 3
  000c9	8b 45 fc	 mov	 eax, DWORD PTR $T24[ebp]
  000cc	ff 70 08	 push	 DWORD PTR [eax+8]
  000cf	8b 45 f8	 mov	 eax, DWORD PTR $T23[ebp]
  000d2	ff 70 04	 push	 DWORD PTR [eax+4]
  000d5	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	83 c1 10	 add	 ecx, 16			; 00000010H
  000db	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NPBDHH@Z ; CNetworkStream::Connect
  000e0	0f b6 c0	 movzx	 eax, al
  000e3	85 c0		 test	 eax, eax
  000e5	0f 85 e8 00 00
	00		 jne	 $LN9@Request

; 51   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  000eb	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  000ee	83 c0 08	 add	 eax, 8
  000f1	89 45 54	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000f4	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  000f7	89 45 9c	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  000fa	8b 45 54	 mov	 eax, DWORD PTR _this$[ebp]
  000fd	8b 00		 mov	 eax, DWORD PTR [eax]
  000ff	8b 00		 mov	 eax, DWORD PTR [eax]
  00101	89 45 f4	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00104	8b 45 f4	 mov	 eax, DWORD PTR ___param0$[ebp]
  00107	89 45 f0	 mov	 DWORD PTR $T22[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0010a	8d 45 f0	 lea	 eax, DWORD PTR $T22[ebp]
  0010d	89 45 ec	 mov	 DWORD PTR $T21[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 51   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  00110	8b 45 ec	 mov	 eax, DWORD PTR $T21[ebp]
  00113	8b 00		 mov	 eax, DWORD PTR [eax]
  00115	89 45 68	 mov	 DWORD PTR _it$38[ebp], eax
  00118	eb 08		 jmp	 SHORT $LN4@Request
$LN2@Request:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0011a	8b 45 68	 mov	 eax, DWORD PTR _it$38[ebp]
  0011d	8b 00		 mov	 eax, DWORD PTR [eax]
  0011f	89 45 68	 mov	 DWORD PTR _it$38[ebp], eax
$LN4@Request:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 51   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  00122	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00125	83 c0 08	 add	 eax, 8
  00128	89 45 50	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0012b	8b 45 50	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0012e	89 45 98	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00131	8b 45 50	 mov	 eax, DWORD PTR _this$[ebp]
  00134	8b 00		 mov	 eax, DWORD PTR [eax]
  00136	89 45 e8	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00139	8b 45 e8	 mov	 eax, DWORD PTR ___param0$[ebp]
  0013c	89 45 e4	 mov	 DWORD PTR $T20[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0013f	8d 45 e4	 lea	 eax, DWORD PTR $T20[ebp]
  00142	89 45 e0	 mov	 DWORD PTR $T19[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00145	8b 45 e0	 mov	 eax, DWORD PTR $T19[ebp]
  00148	8b 4d 68	 mov	 ecx, DWORD PTR _it$38[ebp]
  0014b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0014d	75 09		 jne	 SHORT $LN129@Request
  0014f	c7 45 4c 01 00
	00 00		 mov	 DWORD PTR tv385[ebp], 1
  00156	eb 04		 jmp	 SHORT $LN130@Request
$LN129@Request:
  00158	83 65 4c 00	 and	 DWORD PTR tv385[ebp], 0
$LN130@Request:
  0015c	8a 45 4c	 mov	 al, BYTE PTR tv385[ebp]
  0015f	88 45 72	 mov	 BYTE PTR $T42[ebp], al

; 203  :         return !(*this == _Right);

  00162	0f b6 45 72	 movzx	 eax, BYTE PTR $T42[ebp]
  00166	85 c0		 test	 eax, eax
  00168	75 09		 jne	 SHORT $LN124@Request
  0016a	c7 45 48 01 00
	00 00		 mov	 DWORD PTR tv361[ebp], 1
  00171	eb 04		 jmp	 SHORT $LN125@Request
$LN124@Request:
  00173	83 65 48 00	 and	 DWORD PTR tv361[ebp], 0
$LN125@Request:
  00177	8a 45 48	 mov	 al, BYTE PTR tv361[ebp]
  0017a	88 45 71	 mov	 BYTE PTR $T41[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 51   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  0017d	0f b6 45 71	 movzx	 eax, BYTE PTR $T41[ebp]
  00181	85 c0		 test	 eax, eax
  00183	74 49		 je	 SHORT $LN3@Request
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  00185	8b 45 68	 mov	 eax, DWORD PTR _it$38[ebp]
  00188	83 c0 08	 add	 eax, 8
  0018b	89 45 dc	 mov	 DWORD PTR $T18[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0018e	8b 45 dc	 mov	 eax, DWORD PTR $T18[ebp]
  00191	89 45 d8	 mov	 DWORD PTR $T17[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  00194	8b 45 d8	 mov	 eax, DWORD PTR $T17[ebp]
  00197	89 45 d4	 mov	 DWORD PTR $T16[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 156  :         return pointer_traits<pointer>::pointer_to(**this);

  0019a	8b 45 d4	 mov	 eax, DWORD PTR $T16[ebp]
  0019d	89 45 d0	 mov	 DWORD PTR $T15[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 52   : 			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));

  001a0	6a 00		 push	 0
  001a2	8b 45 d0	 mov	 eax, DWORD PTR $T15[ebp]
  001a5	ff 30		 push	 DWORD PTR [eax]
  001a7	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ@
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  001b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  001b5	50		 push	 eax
  001b6	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEDMKMGJ@NotifyChannelState@
  001bb	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  001be	ff 70 04	 push	 DWORD PTR [eax+4]
  001c1	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  001c6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 53   : 		}

  001c9	e9 4c ff ff ff	 jmp	 $LN2@Request
$LN3@Request:

; 54   : 		return;

  001ce	e9 36 01 00 00	 jmp	 $LN1@Request
$LN9@Request:

; 55   : 	}
; 56   : 	m_kStream.ClearRecvBuffer();

  001d3	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  001d6	83 c1 10	 add	 ecx, 16			; 00000010H
  001d9	e8 00 00 00 00	 call	 ?ClearRecvBuffer@CNetworkStream@@QAEXXZ ; CNetworkStream::ClearRecvBuffer

; 57   : 	m_kStream.SetSendBufferSize(1024);

  001de	68 00 04 00 00	 push	 1024			; 00000400H
  001e3	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  001e6	83 c1 10	 add	 ecx, 16			; 00000010H
  001e9	e8 00 00 00 00	 call	 ?SetSendBufferSize@CNetworkStream@@QAEXH@Z ; CNetworkStream::SetSendBufferSize

; 58   : 	m_kStream.SetRecvBufferSize(1024);

  001ee	68 00 04 00 00	 push	 1024			; 00000400H
  001f3	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  001f6	83 c1 10	 add	 ecx, 16			; 00000010H
  001f9	e8 00 00 00 00	 call	 ?SetRecvBufferSize@CNetworkStream@@QAEXH@Z ; CNetworkStream::SetRecvBufferSize

; 59   : 
; 60   : 	BYTE bHeader = HEADER_CG_STATE_CHECKER;

  001fe	c6 45 70 ce	 mov	 BYTE PTR _bHeader$[ebp], 206 ; 000000ceH

; 61   : 	if (!m_kStream.Send(sizeof(bHeader), &bHeader))

  00202	8d 45 70	 lea	 eax, DWORD PTR _bHeader$[ebp]
  00205	50		 push	 eax
  00206	6a 01		 push	 1
  00208	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  0020b	83 c1 10	 add	 ecx, 16			; 00000010H
  0020e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00213	0f b6 c0	 movzx	 eax, al
  00216	85 c0		 test	 eax, eax
  00218	0f 85 eb 00 00
	00		 jne	 $LN1@Request

; 63   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  0021e	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00221	83 c0 08	 add	 eax, 8
  00224	89 45 44	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  00227	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  0022a	89 45 94	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0022d	8b 45 44	 mov	 eax, DWORD PTR _this$[ebp]
  00230	8b 00		 mov	 eax, DWORD PTR [eax]
  00232	8b 00		 mov	 eax, DWORD PTR [eax]
  00234	89 45 cc	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  00237	8b 45 cc	 mov	 eax, DWORD PTR ___param0$[ebp]
  0023a	89 45 c8	 mov	 DWORD PTR $T14[ebp], eax

; 1092 :         return iterator(_Mypair._Myval2._Myhead->_Next, _STD addressof(_Mypair._Myval2));

  0023d	8d 45 c8	 lea	 eax, DWORD PTR $T14[ebp]
  00240	89 45 c4	 mov	 DWORD PTR $T13[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 63   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  00243	8b 45 c4	 mov	 eax, DWORD PTR $T13[ebp]
  00246	8b 00		 mov	 eax, DWORD PTR [eax]
  00248	89 45 64	 mov	 DWORD PTR _it$37[ebp], eax
  0024b	eb 08		 jmp	 SHORT $LN7@Request
$LN5@Request:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 166  :         this->_Ptr = this->_Ptr->_Next;

  0024d	8b 45 64	 mov	 eax, DWORD PTR _it$37[ebp]
  00250	8b 00		 mov	 eax, DWORD PTR [eax]
  00252	89 45 64	 mov	 DWORD PTR _it$37[ebp], eax
$LN7@Request:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 63   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  00255	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  00258	83 c0 08	 add	 eax, 8
  0025b	89 45 40	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  0025e	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00261	89 45 90	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00264	8b 45 40	 mov	 eax, DWORD PTR _this$[ebp]
  00267	8b 00		 mov	 eax, DWORD PTR [eax]
  00269	89 45 c0	 mov	 DWORD PTR ___param0$[ebp], eax

; 39   :     _List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist* _Plist) noexcept : _Ptr(_Pnode) {

  0026c	8b 45 c0	 mov	 eax, DWORD PTR ___param0$[ebp]
  0026f	89 45 bc	 mov	 DWORD PTR $T12[ebp], eax

; 1100 :         return iterator(_Mypair._Myval2._Myhead, _STD addressof(_Mypair._Myval2));

  00272	8d 45 bc	 lea	 eax, DWORD PTR $T12[ebp]
  00275	89 45 b8	 mov	 DWORD PTR $T11[ebp], eax

; 199  :         return this->_Ptr == _Right._Ptr;

  00278	8b 45 b8	 mov	 eax, DWORD PTR $T11[ebp]
  0027b	8b 4d 64	 mov	 ecx, DWORD PTR _it$37[ebp]
  0027e	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00280	75 09		 jne	 SHORT $LN190@Request
  00282	c7 45 3c 01 00
	00 00		 mov	 DWORD PTR tv462[ebp], 1
  00289	eb 04		 jmp	 SHORT $LN191@Request
$LN190@Request:
  0028b	83 65 3c 00	 and	 DWORD PTR tv462[ebp], 0
$LN191@Request:
  0028f	8a 45 3c	 mov	 al, BYTE PTR tv462[ebp]
  00292	88 45 6f	 mov	 BYTE PTR $T40[ebp], al

; 203  :         return !(*this == _Right);

  00295	0f b6 45 6f	 movzx	 eax, BYTE PTR $T40[ebp]
  00299	85 c0		 test	 eax, eax
  0029b	75 09		 jne	 SHORT $LN185@Request
  0029d	c7 45 38 01 00
	00 00		 mov	 DWORD PTR tv438[ebp], 1
  002a4	eb 04		 jmp	 SHORT $LN186@Request
$LN185@Request:
  002a6	83 65 38 00	 and	 DWORD PTR tv438[ebp], 0
$LN186@Request:
  002aa	8a 45 38	 mov	 al, BYTE PTR tv438[ebp]
  002ad	88 45 6e	 mov	 BYTE PTR $T39[ebp], al
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 63   : 		for (std::list<TChannel>::const_iterator it = m_lstChannel.begin(); it != m_lstChannel.end(); ++it) {

  002b0	0f b6 45 6e	 movzx	 eax, BYTE PTR $T39[ebp]
  002b4	85 c0		 test	 eax, eax
  002b6	74 49		 je	 SHORT $LN6@Request
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 152  :         return this->_Ptr->_Myval;

  002b8	8b 45 64	 mov	 eax, DWORD PTR _it$37[ebp]
  002bb	83 c0 08	 add	 eax, 8
  002be	89 45 b4	 mov	 DWORD PTR $T10[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  002c1	8b 45 b4	 mov	 eax, DWORD PTR $T10[ebp]
  002c4	89 45 b0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xutility

; 151  :         return _STD addressof(_Val);

  002c7	8b 45 b0	 mov	 eax, DWORD PTR $T9[ebp]
  002ca	89 45 ac	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 156  :         return pointer_traits<pointer>::pointer_to(**this);

  002cd	8b 45 ac	 mov	 eax, DWORD PTR $T8[ebp]
  002d0	89 45 a8	 mov	 DWORD PTR $T7[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 64   : 			PyCallClassMemberFunc(m_poWnd, "NotifyChannelState", Py_BuildValue("(ii)", it->uServerIndex, 0));

  002d3	6a 00		 push	 0
  002d5	8b 45 a8	 mov	 eax, DWORD PTR $T7[ebp]
  002d8	ff 30		 push	 DWORD PTR [eax]
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_04INACLLOK@?$CIii?$CJ@
  002df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  002e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  002e8	50		 push	 eax
  002e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@EEDMKMGJ@NotifyChannelState@
  002ee	8b 45 74	 mov	 eax, DWORD PTR _this$[ebp]
  002f1	ff 70 04	 push	 DWORD PTR [eax+4]
  002f4	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  002f9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 65   : 		}

  002fc	e9 4c ff ff ff	 jmp	 $LN5@Request
$LN6@Request:

; 66   : 		Initialize();

  00301	8b 4d 74	 mov	 ecx, DWORD PTR _this$[ebp]
  00304	e8 00 00 00 00	 call	 ?Initialize@CServerStateChecker@@QAEXXZ ; CServerStateChecker::Initialize
$LN1@Request:

; 67   : 		return;
; 68   : 	}
; 69   : }

  00309	83 c5 78	 add	 ebp, 120		; 00000078H
  0030c	c9		 leave
  0030d	c3		 ret	 0
?Request@CServerStateChecker@@QAEXXZ ENDP		; CServerStateChecker::Request
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?AddChannel@CServerStateChecker@@QAEXIPBDI@Z
_TEXT	SEGMENT
_c$ = -20						; size = 12
_this$ = -8						; size = 4
_this$ = -4						; size = 4
_uServerIndex$ = 8					; size = 4
_c_szAddr$ = 12						; size = 4
_uPort$ = 16						; size = 4
?AddChannel@CServerStateChecker@@QAEXIPBDI@Z PROC	; CServerStateChecker::AddChannel, COMDAT
; _this$ = ecx

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 35   : 	TChannel c;
; 36   : 	c.uServerIndex = uServerIndex;

  00009	8b 45 08	 mov	 eax, DWORD PTR _uServerIndex$[ebp]
  0000c	89 45 ec	 mov	 DWORD PTR _c$[ebp], eax

; 37   : 	c.c_szAddr = c_szAddr;

  0000f	8b 45 0c	 mov	 eax, DWORD PTR _c_szAddr$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR _c$[ebp+4], eax

; 38   : 	c.uPort = uPort;

  00015	8b 45 10	 mov	 eax, DWORD PTR _uPort$[ebp]
  00018	89 45 f4	 mov	 DWORD PTR _c$[ebp+8], eax

; 39   : 
; 40   : 	m_lstChannel.push_back(c);

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 08	 add	 eax, 8
  00021	89 45 fc	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1252 :         _Emplace(_Mypair._Myval2._Myhead, _Val);

  00024	8d 45 ec	 lea	 eax, DWORD PTR _c$[ebp]
  00027	50		 push	 eax
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	ff 30		 push	 DWORD PTR [eax]
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??$_Emplace@ABUSChannel@CServerStateChecker@@@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAEPAU?$_List_node@USChannel@CServerStateChecker@@PAX@1@QAU21@ABUSChannel@CServerStateChecker@@@Z ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Emplace<CServerStateChecker::SChannel const &>
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 41   : }

  00035	c9		 leave
  00036	c2 0c 00	 ret	 12			; 0000000cH
?AddChannel@CServerStateChecker@@QAEXIPBDI@Z ENDP	; CServerStateChecker::AddChannel
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ?Create@CServerStateChecker@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_poWnd$ = 8						; size = 4
?Create@CServerStateChecker@@QAEXPAU_object@@@Z PROC	; CServerStateChecker::Create, COMDAT
; _this$ = ecx

; 29   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 30   : 	m_poWnd = poWnd;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _poWnd$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 31   : }

  00010	c9		 leave
  00011	c2 04 00	 ret	 4
?Create@CServerStateChecker@@QAEXPAU_object@@@Z ENDP	; CServerStateChecker::Create
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ??1CServerStateChecker@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CServerStateChecker@@UAE@XZ PROC			; CServerStateChecker::~CServerStateChecker, COMDAT
; _this$ = ecx

; 23   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CServerStateChecker@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CServerStateChecker@@6B@

; 24   : 	Initialize();

  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?Initialize@CServerStateChecker@@QAEXXZ ; CServerStateChecker::Initialize

; 25   : 	m_poWnd = NULL;

  00037	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 60 04 00	 and	 DWORD PTR [eax+4], 0

; 26   : }

  0003e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	83 c1 10	 add	 ecx, 16			; 00000010H
  00044	e8 00 00 00 00	 call	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
  00049	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	83 c1 08	 add	 ecx, 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\list

; 1046 :         _Tidy();

  0004f	e8 00 00 00 00	 call	 ?_Tidy@?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@AAEXXZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::_Tidy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 19   : 	{ 

  00054	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00057	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCServerStateChecker@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  0005d	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A, 0 ; CSingleton<CServerStateChecker>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 26   : }

  00064	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00067	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0006e	59		 pop	 ecx
  0006f	c9		 leave
  00070	c3		 ret	 0
  00071	cc		 int	 3
  00072	cc		 int	 3
  00073	cc		 int	 3
  00074	cc		 int	 3
  00075	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CServerStateChecker@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CServerStateChecker@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CServerStateChecker@@UAE@XZ ENDP			; CServerStateChecker::~CServerStateChecker
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp
;	COMDAT ??0CServerStateChecker@@QAE@XZ
_TEXT	SEGMENT
_offset$2 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CServerStateChecker@@QAE@XZ PROC			; CServerStateChecker::CServerStateChecker, COMDAT
; _this$ = ecx

; 18   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CServerStateChecker@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	51		 push	 ecx
  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00018	33 c5		 xor	 eax, ebp
  0001a	50		 push	 eax
  0001b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00024	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 12   : 	{ 

  00027	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCServerStateChecker@@@@6B@

; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 

  00030	33 c0		 xor	 eax, eax
  00032	89 45 ec	 mov	 DWORD PTR _offset$2[ebp], eax

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00035	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00038	03 45 ec	 add	 eax, DWORD PTR _offset$2[ebp]
  0003b	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A, eax ; CSingleton<CServerStateChecker>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\ServerStateChecker.cpp

; 18   : {

  00040	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00044	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CServerStateChecker@@6B@
  0004d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 08	 add	 ecx, 8
  00053	e8 00 00 00 00	 call	 ??0?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
  00058	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	83 c1 10	 add	 ecx, 16			; 00000010H
  00062	e8 00 00 00 00	 call	 ??0CNetworkStream@@QAE@XZ ; CNetworkStream::CNetworkStream
  00067	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2

; 19   : 	Initialize();

  0006b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?Initialize@CServerStateChecker@@QAEXXZ ; CServerStateChecker::Initialize

; 20   : }

  00073	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00077	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00084	59		 pop	 ecx
  00085	c9		 leave
  00086	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CServerStateChecker@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ ; CSingleton<CServerStateChecker>::~CSingleton<CServerStateChecker>
__unwindfunclet$??0CServerStateChecker@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 08	 add	 ecx, 8
  0000e	e9 00 00 00 00	 jmp	 ??1?$list@USChannel@CServerStateChecker@@V?$allocator@USChannel@CServerStateChecker@@@std@@@std@@QAE@XZ ; std::list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >::~list<CServerStateChecker::SChannel,std::allocator<CServerStateChecker::SChannel> >
__unwindfunclet$??0CServerStateChecker@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 10	 add	 ecx, 16			; 00000010H
  00019	e9 00 00 00 00	 jmp	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
  00022	cc		 int	 3
__ehhandler$??0CServerStateChecker@@QAE@XZ:
  00023	90		 npad	 1
  00024	90		 npad	 1
  00025	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00029	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002c	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0002f	33 c8		 xor	 ecx, eax
  00031	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00036	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CServerStateChecker@@QAE@XZ
  0003b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CServerStateChecker@@QAE@XZ ENDP			; CServerStateChecker::CServerStateChecker
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z PROC	; CSingleton<CServerStateChecker>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	{ 

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCServerStateChecker@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A, 0 ; CSingleton<CServerStateChecker>::ms_singleton
  00017	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	74 0c		 je	 SHORT $LN2@scalar
  0001f	6a 04		 push	 4
  00021	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
$LN2@scalar:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
??_G?$CSingleton@VCServerStateChecker@@@@UAEPAXI@Z ENDP	; CSingleton<CServerStateChecker>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ PROC	; CSingleton<CServerStateChecker>::~CSingleton<CServerStateChecker>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCServerStateChecker@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCServerStateChecker@@@@0PAVCServerStateChecker@@A, 0 ; CSingleton<CServerStateChecker>::ms_singleton

; 22   : 	}

  00017	c9		 leave
  00018	c3		 ret	 0
??1?$CSingleton@VCServerStateChecker@@@@UAE@XZ ENDP	; CSingleton<CServerStateChecker>::~CSingleton<CServerStateChecker>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
