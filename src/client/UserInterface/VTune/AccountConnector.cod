; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??1?$CSingleton@VCAccountConnector@@@@UAE@XZ	; CSingleton<CAccountConnector>::~CSingleton<CAccountConnector>
PUBLIC	??_G?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z ; CSingleton<CAccountConnector>::`scalar deleting destructor'
PUBLIC	??0CAccountConnector@@QAE@XZ			; CAccountConnector::CAccountConnector
PUBLIC	??1CAccountConnector@@UAE@XZ			; CAccountConnector::~CAccountConnector
PUBLIC	?SetHandler@CAccountConnector@@QAEXPAU_object@@@Z ; CAccountConnector::SetHandler
PUBLIC	?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z	; CAccountConnector::SetLoginInfo
PUBLIC	?ClearLoginInfo@CAccountConnector@@QAEXXZ	; CAccountConnector::ClearLoginInfo
PUBLIC	?SendChinaMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z ; CAccountConnector::SendChinaMatrixCardPacket
PUBLIC	?SendRunupMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z ; CAccountConnector::SendRunupMatrixCardPacket
PUBLIC	?SendNEWCIBNPasspodAnswerPacket@CAccountConnector@@QAE_NPBD@Z ; CAccountConnector::SendNEWCIBNPasspodAnswerPacket
PUBLIC	?Connect@CAccountConnector@@QAE_NPBDH0H@Z	; CAccountConnector::Connect
PUBLIC	?Disconnect@CAccountConnector@@QAEXXZ		; CAccountConnector::Disconnect
PUBLIC	?Process@CAccountConnector@@QAEXXZ		; CAccountConnector::Process
PUBLIC	?OnConnectFailure@CAccountConnector@@MAEXXZ	; CAccountConnector::OnConnectFailure
PUBLIC	?OnConnectSuccess@CAccountConnector@@MAEXXZ	; CAccountConnector::OnConnectSuccess
PUBLIC	?OnRemoteDisconnect@CAccountConnector@@MAEXXZ	; CAccountConnector::OnRemoteDisconnect
PUBLIC	?OnDisconnect@CAccountConnector@@MAEXXZ		; CAccountConnector::OnDisconnect
PUBLIC	?__Inialize@CAccountConnector@@IAEXXZ		; CAccountConnector::__Inialize
PUBLIC	?__StateProcess@CAccountConnector@@IAE_NXZ	; CAccountConnector::__StateProcess
PUBLIC	?__OfflineState_Set@CAccountConnector@@IAEXXZ	; CAccountConnector::__OfflineState_Set
PUBLIC	?__HandshakeState_Set@CAccountConnector@@IAEXXZ	; CAccountConnector::__HandshakeState_Set
PUBLIC	?__AuthState_Set@CAccountConnector@@IAEXXZ	; CAccountConnector::__AuthState_Set
PUBLIC	?__HandshakeState_Process@CAccountConnector@@IAE_NXZ ; CAccountConnector::__HandshakeState_Process
PUBLIC	?__AuthState_Process@CAccountConnector@@IAE_NXZ	; CAccountConnector::__AuthState_Process
PUBLIC	?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvEmpty
PUBLIC	?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPhase
PUBLIC	?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvHandshake
PUBLIC	?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPing
PUBLIC	?__AuthState_SendPong@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_SendPong
PUBLIC	?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvAuthSuccess
PUBLIC	?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvAuthFailure
PUBLIC	?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvChinaMatrixCard
PUBLIC	?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvRunupMatrixQuiz
PUBLIC	?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest
PUBLIC	?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPanamaPack
PUBLIC	?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreement
PUBLIC	?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted
PUBLIC	?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptKeys
PUBLIC	?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptSDB
PUBLIC	?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
PUBLIC	?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
PUBLIC	??_GCAccountConnector@@UAEPAXI@Z		; CAccountConnector::`scalar deleting destructor'
PUBLIC	??1SPacketGCHybridCryptKeys@@QAE@XZ		; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys
PUBLIC	??1SPacketGCHybridSDB@@QAE@XZ			; SPacketGCHybridSDB::~SPacketGCHybridSDB
PUBLIC	??_ECAccountConnector@@WHM@AEPAXI@Z		; [thunk]:CAccountConnector::`vector deleting destructor'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_01NBENCBCI@?$CK@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A ; CSingleton<CAccountConnector>::ms_singleton
PUBLIC	??_7?$CSingleton@VCAccountConnector@@@@6B@	; CSingleton<CAccountConnector>::`vftable'
PUBLIC	??_7CAccountConnector@@6BCNetworkStream@@@	; CAccountConnector::`vftable'
PUBLIC	??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ ; CAccountConnector::`vftable'
PUBLIC	?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
PUBLIC	?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
PUBLIC	??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@ ; `string'
PUBLIC	??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@ ; `string'
PUBLIC	??_C@_0BA@HGDBLFFH@SendLogin?5Error@		; `string'
PUBLIC	??_C@_0DN@HEMMJEJK@?5CAccountConnector?3?3__AuthState@ ; `string'
PUBLIC	??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd@ ; `string'
PUBLIC	??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu@	; `string'
PUBLIC	??_C@_0EE@PGOEFGOD@?5CAccountConnector?3?3__AuthState@ ; `string'
PUBLIC	??_C@_09FJACDEDF@BESAMEKEY@			; `string'
PUBLIC	??_C@_03KJMMOONA@?$CIs?$CJ@			; `string'
PUBLIC	??_C@_0P@OOEAIINI@OnLoginFailure@		; `string'
PUBLIC	??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@	; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ@			; `string'
PUBLIC	??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@ ; `string'
PUBLIC	??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@		; `string'
PUBLIC	??_C@_0N@PIKEFLJP@OnMatrixCard@			; `string'
PUBLIC	??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu@	; `string'
PUBLIC	??_C@_0EK@DCNAEAA@?5CAccountConnector?3?3__AuthState@ ; `string'
PUBLIC	??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu@	; `string'
PUBLIC	??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV@ ; `string'
PUBLIC	??_C@_0BB@JEKGEMCL@OnConnectFailure@		; `string'
PUBLIC	??_C@_06NAODFICM@OnExit@			; `string'
PUBLIC	??_R4CAccountConnector@@6BCNetworkStream@@@	; CAccountConnector::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVCAccountConnector@@@8			; CAccountConnector `RTTI Type Descriptor'
PUBLIC	??_R3CAccountConnector@@8			; CAccountConnector::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CAccountConnector@@8			; CAccountConnector::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@CAccountConnector@@8		; CAccountConnector::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@CNetworkStream@@8			; CNetworkStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVCNetworkStream@@@8			; CNetworkStream `RTTI Type Descriptor'
PUBLIC	??_R3CNetworkStream@@8				; CNetworkStream::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2CNetworkStream@@8				; CNetworkStream::`RTTI Base Class Array'
PUBLIC	??_R1HM@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Descriptor at (124,-1,0,64)'
PUBLIC	??_R0?AV?$CSingleton@VCAccountConnector@@@@@8	; CSingleton<CAccountConnector> `RTTI Type Descriptor'
PUBLIC	??_R3?$CSingleton@VCAccountConnector@@@@8	; CSingleton<CAccountConnector>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$CSingleton@VCAccountConnector@@@@8	; CSingleton<CAccountConnector>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ ; CAccountConnector::`RTTI Complete Object Locator'
PUBLIC	??_R4?$CSingleton@VCAccountConnector@@@@6B@	; CSingleton<CAccountConnector>::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Tracen@@YAXPBD@Z:PROC				; Tracen
EXTRN	?Tracenf@@YAXPBDZZ:PROC				; Tracenf
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	__imp__Py_BuildValue:PROC
EXTRN	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z:PROC ; PyCallClassMemberFunc
EXTRN	?ELTimer_SetServerMSec@@YAXK@Z:PROC		; ELTimer_SetServerMSec
EXTRN	?LocaleService_IsYMIR@@YA_NXZ:PROC		; LocaleService_IsYMIR
EXTRN	??0CNetworkStream@@QAE@XZ:PROC			; CNetworkStream::CNetworkStream
EXTRN	??1CNetworkStream@@UAE@XZ:PROC			; CNetworkStream::~CNetworkStream
EXTRN	?SetRecvBufferSize@CNetworkStream@@QAEXH@Z:PROC	; CNetworkStream::SetRecvBufferSize
EXTRN	?SetSendBufferSize@CNetworkStream@@QAEXH@Z:PROC	; CNetworkStream::SetSendBufferSize
EXTRN	?IsSecurityMode@CNetworkStream@@QAE_NXZ:PROC	; CNetworkStream::IsSecurityMode
EXTRN	?Process@CNetworkStream@@QAEXXZ:PROC		; CNetworkStream::Process
EXTRN	?Connect@CNetworkStream@@QAE_NPBDHH@Z:PROC	; CNetworkStream::Connect
EXTRN	?Disconnect@CNetworkStream@@QAEXXZ:PROC		; CNetworkStream::Disconnect
EXTRN	?Peek@CNetworkStream@@QAE_NH@Z:PROC		; CNetworkStream::Peek
EXTRN	?Peek@CNetworkStream@@QAE_NHPAX@Z:PROC		; CNetworkStream::Peek
EXTRN	?Recv@CNetworkStream@@QAE_NHPAX@Z:PROC		; CNetworkStream::Recv
EXTRN	?Send@CNetworkStream@@QAE_NHPBX@Z:PROC		; CNetworkStream::Send
EXTRN	?SendSequence@CNetworkStream@@QAE_NXZ:PROC	; CNetworkStream::SendSequence
EXTRN	?OnProcess@CNetworkStream@@MAE_NXZ:PROC		; CNetworkStream::OnProcess
EXTRN	?Prepare@CNetworkStream@@IAEIPAXPAI@Z:PROC	; CNetworkStream::Prepare
EXTRN	?Activate@CNetworkStream@@IAE_NIPBXI@Z:PROC	; CNetworkStream::Activate
EXTRN	?ActivateCipher@CNetworkStream@@IAEXXZ:PROC	; CNetworkStream::ActivateCipher
EXTRN	??_E?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z:PROC ; CSingleton<CAccountConnector>::`vector deleting destructor'
EXTRN	?__BuildClientKey_20050304Myevan@CAccountConnector@@IAEXXZ:PROC ; CAccountConnector::__BuildClientKey_20050304Myevan
EXTRN	??_ECAccountConnector@@UAEPAXI@Z:PROC		; CAccountConnector::`vector deleting destructor'
EXTRN	?SetWaitFlag@CPythonNetworkStream@@QAEXXZ:PROC	; CPythonNetworkStream::SetWaitFlag
EXTRN	?SetLoginKey@CPythonNetworkStream@@QAEXK@Z:PROC	; CPythonNetworkStream::SetLoginKey
EXTRN	?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ:PROC ; CPythonNetworkStream::ClearLoginInfo
EXTRN	?RegisterPack@CEterPackManager@@QAE_NPBD0PBE@Z:PROC ; CEterPackManager::RegisterPack
EXTRN	?DecryptPackIV@CEterPackManager@@QAE_NK@Z:PROC	; CEterPackManager::DecryptPackIV
EXTRN	?RetrieveHybridCryptPackKeys@CEterPackManager@@QAEXPBE@Z:PROC ; CEterPackManager::RetrieveHybridCryptPackKeys
EXTRN	?RetrieveHybridCryptPackSDB@CEterPackManager@@QAEXPBE@Z:PROC ; CEterPackManager::RetrieveHybridCryptPackSDB
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?g_adwEncryptKey@@3PAKA:BYTE			; g_adwEncryptKey
EXTRN	___security_cookie:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A DD 01H DUP (?) ; CSingleton<CAccountConnector>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A DD 01H DUP (?) ; CSingleton<CPythonNetworkStream>::ms_singleton
_BSS	ENDS
;	COMDAT ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A DD 01H DUP (?) ; CSingleton<CEterPackManager>::ms_singleton
_BSS	ENDS
;	COMDAT ??_R4?$CSingleton@VCAccountConnector@@@@6B@
rdata$r	SEGMENT
??_R4?$CSingleton@VCAccountConnector@@@@6B@ DD 00H	; CSingleton<CAccountConnector>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$CSingleton@VCAccountConnector@@@@@8
	DD	FLAT:??_R3?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R4CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@
rdata$r	SEGMENT
??_R4CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ DD 00H ; CAccountConnector::`RTTI Complete Object Locator'
	DD	07cH
	DD	00H
	DD	FLAT:??_R0?AVCAccountConnector@@@8
	DD	FLAT:??_R3CAccountConnector@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$CSingleton@VCAccountConnector@@@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCAccountConnector@@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R2?$CSingleton@VCAccountConnector@@@@8
rdata$r	SEGMENT
??_R2?$CSingleton@VCAccountConnector@@@@8 DD FLAT:??_R1A@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$CSingleton@VCAccountConnector@@@@8
rdata$r	SEGMENT
??_R3?$CSingleton@VCAccountConnector@@@@8 DD 00H	; CSingleton<CAccountConnector>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$CSingleton@VCAccountConnector@@@@@8
data$rs	SEGMENT
??_R0?AV?$CSingleton@VCAccountConnector@@@@@8 DD FLAT:??_7type_info@@6B@ ; CSingleton<CAccountConnector> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$CSingleton@VCAccountConnector@@@@', 00H
data$rs	ENDS
;	COMDAT ??_R1HM@?0A@EA@?$CSingleton@VCAccountConnector@@@@8
rdata$r	SEGMENT
??_R1HM@?0A@EA@?$CSingleton@VCAccountConnector@@@@8 DD FLAT:??_R0?AV?$CSingleton@VCAccountConnector@@@@@8 ; CSingleton<CAccountConnector>::`RTTI Base Class Descriptor at (124,-1,0,64)'
	DD	00H
	DD	07cH
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R2CNetworkStream@@8
rdata$r	SEGMENT
??_R2CNetworkStream@@8 DD FLAT:??_R1A@?0A@EA@CNetworkStream@@8 ; CNetworkStream::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3CNetworkStream@@8
rdata$r	SEGMENT
??_R3CNetworkStream@@8 DD 00H				; CNetworkStream::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2CNetworkStream@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCNetworkStream@@@8
data$rs	SEGMENT
??_R0?AVCNetworkStream@@@8 DD FLAT:??_7type_info@@6B@	; CNetworkStream `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCNetworkStream@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@CNetworkStream@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CNetworkStream@@8 DD FLAT:??_R0?AVCNetworkStream@@@8 ; CNetworkStream::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CNetworkStream@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@CAccountConnector@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@CAccountConnector@@8 DD FLAT:??_R0?AVCAccountConnector@@@8 ; CAccountConnector::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3CAccountConnector@@8
rdata$r	ENDS
;	COMDAT ??_R2CAccountConnector@@8
rdata$r	SEGMENT
??_R2CAccountConnector@@8 DD FLAT:??_R1A@?0A@EA@CAccountConnector@@8 ; CAccountConnector::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@CNetworkStream@@8
	DD	FLAT:??_R1HM@?0A@EA@?$CSingleton@VCAccountConnector@@@@8
rdata$r	ENDS
;	COMDAT ??_R3CAccountConnector@@8
rdata$r	SEGMENT
??_R3CAccountConnector@@8 DD 00H			; CAccountConnector::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2CAccountConnector@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVCAccountConnector@@@8
data$rs	SEGMENT
??_R0?AVCAccountConnector@@@8 DD FLAT:??_7type_info@@6B@ ; CAccountConnector `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCAccountConnector@@', 00H
data$rs	ENDS
;	COMDAT ??_R4CAccountConnector@@6BCNetworkStream@@@
rdata$r	SEGMENT
??_R4CAccountConnector@@6BCNetworkStream@@@ DD 00H	; CAccountConnector::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVCAccountConnector@@@8
	DD	FLAT:??_R3CAccountConnector@@8
rdata$r	ENDS
;	COMDAT ??_C@_06NAODFICM@OnExit@
CONST	SEGMENT
??_C@_06NAODFICM@OnExit@ DB 'OnExit', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JEKGEMCL@OnConnectFailure@
CONST	SEGMENT
??_C@_0BB@JEKGEMCL@OnConnectFailure@ DB 'OnConnectFailure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV@
CONST	SEGMENT
??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV@ DB 'KEY_AGREEMENT_COMPL'
	DB	'ETED RECV', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu@
CONST	SEGMENT
??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu@ DB 'KEY_AGREEMENT SEND %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@DCNAEAA@?5CAccountConnector?3?3__AuthState@
CONST	SEGMENT
??_C@_0EK@DCNAEAA@?5CAccountConnector?3?3__AuthState@ DB ' CAccountConnec'
	DB	'tor::__AuthState_RecvKeyAgreement - SendKeyAgreement Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu@
CONST	SEGMENT
??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu@ DB 'KEY_AGREEMENT RECV %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@PIKEFLJP@OnMatrixCard@
CONST	SEGMENT
??_C@_0N@PIKEFLJP@OnMatrixCard@ DB 'OnMatrixCard', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@
CONST	SEGMENT
??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@ DB '(iiiiiiii)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@
CONST	SEGMENT
??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@ DB 'BINARY_OnNEWCIBNPa'
	DB	'sspodRequest', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ@ DB '()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@
CONST	SEGMENT
??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@ DB 'BINARY_OnRunupMatrixQuiz'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OOEAIINI@OnLoginFailure@
CONST	SEGMENT
??_C@_0P@OOEAIINI@OnLoginFailure@ DB 'OnLoginFailure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KJMMOONA@?$CIs?$CJ@
CONST	SEGMENT
??_C@_03KJMMOONA@?$CIs?$CJ@ DB '(s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09FJACDEDF@BESAMEKEY@
CONST	SEGMENT
??_C@_09FJACDEDF@BESAMEKEY@ DB 'BESAMEKEY', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@PGOEFGOD@?5CAccountConnector?3?3__AuthState@
CONST	SEGMENT
??_C@_0EE@PGOEFGOD@?5CAccountConnector?3?3__AuthState@ DB ' CAccountConne'
	DB	'ctor::__AuthState_RecvHandshake - SendHandshake Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu@
CONST	SEGMENT
??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu@ DB 'HANDSHAKE SEND %u', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd@
CONST	SEGMENT
??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd@ DB 'HANDSHAKE RECV %u %'
	DB	'd', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@HEMMJEJK@?5CAccountConnector?3?3__AuthState@
CONST	SEGMENT
??_C@_0DN@HEMMJEJK@?5CAccountConnector?3?3__AuthState@ DB ' CAccountConne'
	DB	'ctor::__AuthState_RecvPhase - SendLogin3 Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
CONST	SEGMENT
??_C@_0BA@HGDBLFFH@SendLogin?5Error@ DB 'SendLogin Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@
CONST	SEGMENT
??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@ DB 'SendRunupMatrixCar'
	DB	'dPacketError', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@
CONST	SEGMENT
??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@ DB 'SendNEWCIBNPasspod'
	DB	'AnswerPacket', 00H				; `string'
CONST	ENDS
;	COMDAT ??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@
CONST	SEGMENT
??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ DD FLAT:??_R4CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@ ; CAccountConnector::`vftable'
	DD	FLAT:??_ECAccountConnector@@WHM@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_7CAccountConnector@@6BCNetworkStream@@@
CONST	SEGMENT
??_7CAccountConnector@@6BCNetworkStream@@@ DD FLAT:??_R4CAccountConnector@@6BCNetworkStream@@@ ; CAccountConnector::`vftable'
	DD	FLAT:??_ECAccountConnector@@UAEPAXI@Z
	DD	FLAT:?OnConnectSuccess@CAccountConnector@@MAEXXZ
	DD	FLAT:?OnConnectFailure@CAccountConnector@@MAEXXZ
	DD	FLAT:?OnRemoteDisconnect@CAccountConnector@@MAEXXZ
	DD	FLAT:?OnDisconnect@CAccountConnector@@MAEXXZ
	DD	FLAT:?OnProcess@CNetworkStream@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7?$CSingleton@VCAccountConnector@@@@6B@
CONST	SEGMENT
??_7?$CSingleton@VCAccountConnector@@@@6B@ DD FLAT:??_R4?$CSingleton@VCAccountConnector@@@@6B@ ; CSingleton<CAccountConnector>::`vftable'
	DD	FLAT:??_E?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_01NBENCBCI@?$CK@
CONST	SEGMENT
??_C@_01NBENCBCI@?$CK@ DB '*', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z$0
__ehfuncinfo$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z$0
__ehfuncinfo$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1CAccountConnector@@UAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0CAccountConnector@@QAE@XZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0CAccountConnector@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0CAccountConnector@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0CAccountConnector@@QAE@XZ$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_ECAccountConnector@@WHM@AEPAXI@Z
_TEXT	SEGMENT
??_ECAccountConnector@@WHM@AEPAXI@Z PROC		; [thunk]:CAccountConnector::`vector deleting destructor', COMDAT
  00000	83 e9 7c	 sub	 ecx, 124		; 0000007cH
  00003	e9 00 00 00 00	 jmp	 ??_ECAccountConnector@@UAEPAXI@Z
??_ECAccountConnector@@WHM@AEPAXI@Z ENDP		; [thunk]:CAccountConnector::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
;	COMDAT ??1SPacketGCHybridSDB@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1SPacketGCHybridSDB@@QAE@XZ PROC			; SPacketGCHybridSDB::~SPacketGCHybridSDB, COMDAT
; _this$ = ecx

; 2669 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2670 : 		delete[] m_pStream;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 40 07	 mov	 eax, DWORD PTR [eax+7]
  0000e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00011	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00014	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00019	59		 pop	 ecx

; 2671 : 		m_pStream = NULL;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 60 07 00	 and	 DWORD PTR [eax+7], 0

; 2672 : 	}

  00021	c9		 leave
  00022	c3		 ret	 0
??1SPacketGCHybridSDB@@QAE@XZ ENDP			; SPacketGCHybridSDB::~SPacketGCHybridSDB
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
;	COMDAT ??1SPacketGCHybridCryptKeys@@QAE@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1SPacketGCHybridCryptKeys@@QAE@XZ PROC		; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys, COMDAT
; _this$ = ecx

; 2638 : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2639 : 		if( m_pStream )

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 07 00	 cmp	 DWORD PTR [eax+7], 0
  0000f	74 19		 je	 SHORT $LN3@SPacketGCH

; 2640 : 		{
; 2641 : 			delete[] m_pStream;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 07	 mov	 eax, DWORD PTR [eax+7]
  00017	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0001a	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  0001d	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00022	59		 pop	 ecx

; 2642 : 			m_pStream = NULL;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 60 07 00	 and	 DWORD PTR [eax+7], 0
$LN3@SPacketGCH:

; 2643 : 		}
; 2644 : 	}

  0002a	c9		 leave
  0002b	c3		 ret	 0
??1SPacketGCHybridCryptKeys@@QAE@XZ ENDP		; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_GCAccountConnector@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GCAccountConnector@@UAEPAXI@Z PROC			; CAccountConnector::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1CAccountConnector@@UAE@XZ ; CAccountConnector::~CAccountConnector
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0f		 je	 SHORT $LN2@scalar
  00017	68 d8 00 00 00	 push	 216			; 000000d8H
  0001c	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
$LN2@scalar:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c9		 leave
  0002a	c2 04 00	 ret	 4
??_GCAccountConnector@@UAEPAXI@Z ENDP			; CAccountConnector::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_dynamicHeader$ = -8					; size = 3
_bHeader$ = -1						; size = 1
_uHeader$ = 8						; size = 4
_pfnDispatchPacket$ = 12				; size = 8
?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z PROC ; CAccountConnector::__AnalyzeVarSizePacket, COMDAT
; _this$ = ecx

; 645  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 646  : 	BYTE bHeader;
; 647  : 	if (!Peek(sizeof(bHeader), &bHeader))

  00009	8d 45 ff	 lea	 eax, DWORD PTR _bHeader$[ebp]
  0000c	50		 push	 eax
  0000d	6a 01		 push	 1
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $LN2@AnalyzeVar

; 648  : 		return true;

  0001e	b0 01		 mov	 al, 1
  00020	eb 4c		 jmp	 SHORT $LN1@AnalyzeVar
$LN2@AnalyzeVar:

; 649  : 
; 650  : 	if (bHeader!=uHeader)

  00022	0f b6 45 ff	 movzx	 eax, BYTE PTR _bHeader$[ebp]
  00026	3b 45 08	 cmp	 eax, DWORD PTR _uHeader$[ebp]
  00029	74 04		 je	 SHORT $LN3@AnalyzeVar

; 651  : 		return true;

  0002b	b0 01		 mov	 al, 1
  0002d	eb 3f		 jmp	 SHORT $LN1@AnalyzeVar
$LN3@AnalyzeVar:

; 652  : 
; 653  : 	TDynamicSizePacketHeader dynamicHeader;
; 654  : 
; 655  : 	if (!Peek(sizeof(dynamicHeader), &dynamicHeader))

  0002f	8d 45 f8	 lea	 eax, DWORD PTR _dynamicHeader$[ebp]
  00032	50		 push	 eax
  00033	6a 03		 push	 3
  00035	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  0003d	0f b6 c0	 movzx	 eax, al
  00040	85 c0		 test	 eax, eax
  00042	75 04		 jne	 SHORT $LN4@AnalyzeVar

; 656  : 		return true;

  00044	b0 01		 mov	 al, 1
  00046	eb 26		 jmp	 SHORT $LN1@AnalyzeVar
$LN4@AnalyzeVar:

; 657  : 
; 658  : 	if (!Peek(dynamicHeader.size))

  00048	0f b7 45 f9	 movzx	 eax, WORD PTR _dynamicHeader$[ebp+1]
  0004c	50		 push	 eax
  0004d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NH@Z ; CNetworkStream::Peek
  00055	0f b6 c0	 movzx	 eax, al
  00058	85 c0		 test	 eax, eax
  0005a	75 04		 jne	 SHORT $LN5@AnalyzeVar

; 659  : 		return true;

  0005c	b0 01		 mov	 al, 1
  0005e	eb 0e		 jmp	 SHORT $LN1@AnalyzeVar
$LN5@AnalyzeVar:

; 660  : 
; 661  : 	return (this->*pfnDispatchPacket)(dynamicHeader.size);

  00060	0f b7 45 f9	 movzx	 eax, WORD PTR _dynamicHeader$[ebp+1]
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	03 4d 10	 add	 ecx, DWORD PTR _pfnDispatchPacket$[ebp+4]
  0006b	ff 55 0c	 call	 DWORD PTR _pfnDispatchPacket$[ebp]
$LN1@AnalyzeVar:

; 662  : }

  0006e	c9		 leave
  0006f	c2 0c 00	 ret	 12			; 0000000cH
?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ENDP ; CAccountConnector::__AnalyzeVarSizePacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_bHeader$ = -1						; size = 1
_uHeader$ = 8						; size = 4
_uPacketSize$ = 12					; size = 4
_pfnDispatchPacket$ = 16				; size = 8
?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z PROC ; CAccountConnector::__AnalyzePacket, COMDAT
; _this$ = ecx

; 630  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 631  : 	BYTE bHeader;
; 632  : 	if (!Peek(sizeof(bHeader), &bHeader))

  00008	8d 45 ff	 lea	 eax, DWORD PTR _bHeader$[ebp]
  0000b	50		 push	 eax
  0000c	6a 01		 push	 1
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Peek
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	75 04		 jne	 SHORT $LN2@AnalyzePac

; 633  : 		return true;

  0001d	b0 01		 mov	 al, 1
  0001f	eb 2c		 jmp	 SHORT $LN1@AnalyzePac
$LN2@AnalyzePac:

; 634  : 
; 635  : 	if (bHeader!=uHeader)

  00021	0f b6 45 ff	 movzx	 eax, BYTE PTR _bHeader$[ebp]
  00025	3b 45 08	 cmp	 eax, DWORD PTR _uHeader$[ebp]
  00028	74 04		 je	 SHORT $LN3@AnalyzePac

; 636  : 		return true;

  0002a	b0 01		 mov	 al, 1
  0002c	eb 1f		 jmp	 SHORT $LN1@AnalyzePac
$LN3@AnalyzePac:

; 637  : 
; 638  : 	if (!Peek(uPacketSize))

  0002e	ff 75 0c	 push	 DWORD PTR _uPacketSize$[ebp]
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?Peek@CNetworkStream@@QAE_NH@Z ; CNetworkStream::Peek
  00039	0f b6 c0	 movzx	 eax, al
  0003c	85 c0		 test	 eax, eax
  0003e	75 04		 jne	 SHORT $LN4@AnalyzePac

; 639  : 		return true;

  00040	b0 01		 mov	 al, 1
  00042	eb 09		 jmp	 SHORT $LN1@AnalyzePac
$LN4@AnalyzePac:

; 640  : 
; 641  : 	return (this->*pfnDispatchPacket)();

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	03 4d 14	 add	 ecx, DWORD PTR _pfnDispatchPacket$[ebp+4]
  0004a	ff 55 10	 call	 DWORD PTR _pfnDispatchPacket$[ebp]
$LN1@AnalyzePac:

; 642  : }

  0004d	c9		 leave
  0004e	c2 10 00	 ret	 16			; 00000010H
?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ENDP ; CAccountConnector::__AnalyzePacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z
_TEXT	SEGMENT
_kPacket$ = -56						; size = 11
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
_this$ = -28						; size = 4
_iFixedHeaderSize$ = -24				; size = 4
_iStreamSize$ = -20					; size = 4
$T6 = -15						; size = 1
$T7 = -14						; size = 1
$T8 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_iTotalSize$ = 8					; size = 4
?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z PROC ; CAccountConnector::__AuthState_RecvHybridCryptSDB, COMDAT
; _this$ = ecx

; 411  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 412  : 	int iFixedHeaderSize = TPacketGCHybridSDB::GetFixedHeaderSize();

  00028	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR _iFixedHeaderSize$[ebp], 7

; 414  : 	TPacketGCHybridSDB kPacket(iTotalSize-iFixedHeaderSize);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _iTotalSize$[ebp]
  00032	2b 45 e8	 sub	 eax, DWORD PTR _iFixedHeaderSize$[ebp]
  00035	89 45 ec	 mov	 DWORD PTR _iStreamSize$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h

; 2664 : 	SPacketGCHybridSDB(int iStreamSize) : iSDBStreamLen(iStreamSize)

  00038	8b 45 ec	 mov	 eax, DWORD PTR _iStreamSize$[ebp]
  0003b	89 45 cb	 mov	 DWORD PTR _kPacket$[ebp+3], eax

; 2665 : 	{
; 2666 : 		m_pStream = new BYTE[iStreamSize];

  0003e	ff 75 ec	 push	 DWORD PTR _iStreamSize$[ebp]
  00041	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00046	59		 pop	 ecx
  00047	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
  0004a	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 cf	 mov	 DWORD PTR _kPacket$[ebp+7], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 414  : 	TPacketGCHybridSDB kPacket(iTotalSize-iFixedHeaderSize);

  00050	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 415  : 
; 416  : 	if (!Recv(iFixedHeaderSize, &kPacket))

  00054	8d 45 c8	 lea	 eax, DWORD PTR _kPacket$[ebp]
  00057	50		 push	 eax
  00058	ff 75 e8	 push	 DWORD PTR _iFixedHeaderSize$[ebp]
  0005b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00063	0f b6 c0	 movzx	 eax, al
  00066	85 c0		 test	 eax, eax
  00068	75 20		 jne	 SHORT $LN2@AuthState_

; 417  : 		return false;

  0006a	c6 45 f3 00	 mov	 BYTE PTR $T8[ebp], 0
  0006e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h

; 2670 : 		delete[] m_pStream;

  00072	8b 45 cf	 mov	 eax, DWORD PTR _kPacket$[ebp+7]
  00075	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  00078	ff 75 dc	 push	 DWORD PTR $T4[ebp]
  0007b	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00080	59		 pop	 ecx

; 2671 : 		m_pStream = NULL;

  00081	83 65 cf 00	 and	 DWORD PTR _kPacket$[ebp+7], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 417  : 		return false;

  00085	8a 45 f3	 mov	 al, BYTE PTR $T8[ebp]
  00088	eb 61		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 418  : 
; 419  : 	if (!Recv(kPacket.iSDBStreamLen, kPacket.m_pStream))

  0008a	ff 75 cf	 push	 DWORD PTR _kPacket$[ebp+7]
  0008d	ff 75 cb	 push	 DWORD PTR _kPacket$[ebp+3]
  00090	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00098	0f b6 c0	 movzx	 eax, al
  0009b	85 c0		 test	 eax, eax
  0009d	75 20		 jne	 SHORT $LN16@AuthState_

; 420  : 		return false;

  0009f	c6 45 f2 00	 mov	 BYTE PTR $T7[ebp], 0
  000a3	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h

; 2670 : 		delete[] m_pStream;

  000a7	8b 45 cf	 mov	 eax, DWORD PTR _kPacket$[ebp+7]
  000aa	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
  000ad	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  000b0	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000b5	59		 pop	 ecx

; 2671 : 		m_pStream = NULL;

  000b6	83 65 cf 00	 and	 DWORD PTR _kPacket$[ebp+7], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 420  : 		return false;

  000ba	8a 45 f2	 mov	 al, BYTE PTR $T7[ebp]
  000bd	eb 2c		 jmp	 SHORT $LN1@AuthState_
$LN16@AuthState_:

; 421  : 
; 422  : 	CEterPackManager::Instance().RetrieveHybridCryptPackSDB( kPacket.m_pStream ); 

  000bf	ff 75 cf	 push	 DWORD PTR _kPacket$[ebp+7]
  000c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  000c8	e8 00 00 00 00	 call	 ?RetrieveHybridCryptPackSDB@CEterPackManager@@QAEXPBE@Z ; CEterPackManager::RetrieveHybridCryptPackSDB

; 423  : 	return true;

  000cd	c6 45 f1 01	 mov	 BYTE PTR $T6[ebp], 1
  000d1	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h

; 2670 : 		delete[] m_pStream;

  000d5	8b 45 cf	 mov	 eax, DWORD PTR _kPacket$[ebp+7]
  000d8	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  000db	ff 75 d4	 push	 DWORD PTR $T2[ebp]
  000de	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000e3	59		 pop	 ecx

; 2671 : 		m_pStream = NULL;

  000e4	83 65 cf 00	 and	 DWORD PTR _kPacket$[ebp+7], 0
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 423  : 	return true;

  000e8	8a 45 f1	 mov	 al, BYTE PTR $T6[ebp]
$LN1@AuthState_:

; 424  : }

  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	c9		 leave
  000f7	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SPacketGCHybridSDB@@QAE@XZ ; SPacketGCHybridSDB::~SPacketGCHybridSDB
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z ENDP ; CAccountConnector::__AuthState_RecvHybridCryptSDB
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z
_TEXT	SEGMENT
_kPacket$ = -56						; size = 11
$T2 = -44						; size = 4
$T3 = -40						; size = 4
$T4 = -36						; size = 4
$T5 = -32						; size = 4
_this$ = -28						; size = 4
_iFixedHeaderSize$ = -24				; size = 4
_iStreamSize$ = -20					; size = 4
$T6 = -15						; size = 1
$T7 = -14						; size = 1
$T8 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_iTotalSize$ = 8					; size = 4
?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z PROC ; CAccountConnector::__AuthState_RecvHybridCryptKeys, COMDAT
; _this$ = ecx

; 395  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 396  : 	int iFixedHeaderSize = TPacketGCHybridCryptKeys::GetFixedHeaderSize();

  00028	c7 45 e8 07 00
	00 00		 mov	 DWORD PTR _iFixedHeaderSize$[ebp], 7

; 398  : 	TPacketGCHybridCryptKeys kPacket(iTotalSize-iFixedHeaderSize);

  0002f	8b 45 08	 mov	 eax, DWORD PTR _iTotalSize$[ebp]
  00032	2b 45 e8	 sub	 eax, DWORD PTR _iFixedHeaderSize$[ebp]
  00035	89 45 ec	 mov	 DWORD PTR _iStreamSize$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h

; 2633 : 	SPacketGCHybridCryptKeys(int iStreamSize) : iKeyStreamLen(iStreamSize)

  00038	8b 45 ec	 mov	 eax, DWORD PTR _iStreamSize$[ebp]
  0003b	89 45 cb	 mov	 DWORD PTR _kPacket$[ebp+3], eax

; 2634 : 	{
; 2635 : 		m_pStream = new BYTE[iStreamSize];

  0003e	ff 75 ec	 push	 DWORD PTR _iStreamSize$[ebp]
  00041	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  00046	59		 pop	 ecx
  00047	89 45 e0	 mov	 DWORD PTR $T5[ebp], eax
  0004a	8b 45 e0	 mov	 eax, DWORD PTR $T5[ebp]
  0004d	89 45 cf	 mov	 DWORD PTR _kPacket$[ebp+7], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 398  : 	TPacketGCHybridCryptKeys kPacket(iTotalSize-iFixedHeaderSize);

  00050	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0

; 399  : 
; 400  : 	if (!Recv(iFixedHeaderSize, &kPacket))

  00054	8d 45 c8	 lea	 eax, DWORD PTR _kPacket$[ebp]
  00057	50		 push	 eax
  00058	ff 75 e8	 push	 DWORD PTR _iFixedHeaderSize$[ebp]
  0005b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00063	0f b6 c0	 movzx	 eax, al
  00066	85 c0		 test	 eax, eax
  00068	75 26		 jne	 SHORT $LN2@AuthState_

; 401  : 		return false;

  0006a	c6 45 f3 00	 mov	 BYTE PTR $T8[ebp], 0
  0006e	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h

; 2639 : 		if( m_pStream )

  00072	83 7d cf 00	 cmp	 DWORD PTR _kPacket$[ebp+7], 0
  00076	74 13		 je	 SHORT $LN12@AuthState_

; 2640 : 		{
; 2641 : 			delete[] m_pStream;

  00078	8b 45 cf	 mov	 eax, DWORD PTR _kPacket$[ebp+7]
  0007b	89 45 dc	 mov	 DWORD PTR $T4[ebp], eax
  0007e	ff 75 dc	 push	 DWORD PTR $T4[ebp]
  00081	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  00086	59		 pop	 ecx

; 2642 : 			m_pStream = NULL;

  00087	83 65 cf 00	 and	 DWORD PTR _kPacket$[ebp+7], 0
$LN12@AuthState_:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 401  : 		return false;

  0008b	8a 45 f3	 mov	 al, BYTE PTR $T8[ebp]
  0008e	eb 6d		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 402  : 
; 403  : 	if (!Recv(kPacket.iKeyStreamLen, kPacket.m_pStream))

  00090	ff 75 cf	 push	 DWORD PTR _kPacket$[ebp+7]
  00093	ff 75 cb	 push	 DWORD PTR _kPacket$[ebp+3]
  00096	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0009e	0f b6 c0	 movzx	 eax, al
  000a1	85 c0		 test	 eax, eax
  000a3	75 26		 jne	 SHORT $LN18@AuthState_

; 404  : 		return false;

  000a5	c6 45 f2 00	 mov	 BYTE PTR $T7[ebp], 0
  000a9	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h

; 2639 : 		if( m_pStream )

  000ad	83 7d cf 00	 cmp	 DWORD PTR _kPacket$[ebp+7], 0
  000b1	74 13		 je	 SHORT $LN16@AuthState_

; 2640 : 		{
; 2641 : 			delete[] m_pStream;

  000b3	8b 45 cf	 mov	 eax, DWORD PTR _kPacket$[ebp+7]
  000b6	89 45 d8	 mov	 DWORD PTR $T3[ebp], eax
  000b9	ff 75 d8	 push	 DWORD PTR $T3[ebp]
  000bc	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000c1	59		 pop	 ecx

; 2642 : 			m_pStream = NULL;

  000c2	83 65 cf 00	 and	 DWORD PTR _kPacket$[ebp+7], 0
$LN16@AuthState_:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 404  : 		return false;

  000c6	8a 45 f2	 mov	 al, BYTE PTR $T7[ebp]
  000c9	eb 32		 jmp	 SHORT $LN1@AuthState_
$LN18@AuthState_:

; 405  : 
; 406  : 	CEterPackManager::Instance().RetrieveHybridCryptPackKeys( kPacket.m_pStream ); 

  000cb	ff 75 cf	 push	 DWORD PTR _kPacket$[ebp+7]
  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  000d4	e8 00 00 00 00	 call	 ?RetrieveHybridCryptPackKeys@CEterPackManager@@QAEXPBE@Z ; CEterPackManager::RetrieveHybridCryptPackKeys

; 407  : 	return true;

  000d9	c6 45 f1 01	 mov	 BYTE PTR $T6[ebp], 1
  000dd	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\Packet.h

; 2639 : 		if( m_pStream )

  000e1	83 7d cf 00	 cmp	 DWORD PTR _kPacket$[ebp+7], 0
  000e5	74 13		 je	 SHORT $LN22@AuthState_

; 2640 : 		{
; 2641 : 			delete[] m_pStream;

  000e7	8b 45 cf	 mov	 eax, DWORD PTR _kPacket$[ebp+7]
  000ea	89 45 d4	 mov	 DWORD PTR $T2[ebp], eax
  000ed	ff 75 d4	 push	 DWORD PTR $T2[ebp]
  000f0	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  000f5	59		 pop	 ecx

; 2642 : 			m_pStream = NULL;

  000f6	83 65 cf 00	 and	 DWORD PTR _kPacket$[ebp+7], 0
$LN22@AuthState_:
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 407  : 	return true;

  000fa	8a 45 f1	 mov	 al, BYTE PTR $T6[ebp]
$LN1@AuthState_:

; 408  : }

  000fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00100	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00107	59		 pop	 ecx
  00108	c9		 leave
  00109	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _kPacket$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1SPacketGCHybridCryptKeys@@QAE@XZ ; SPacketGCHybridCryptKeys::~SPacketGCHybridCryptKeys
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z ENDP ; CAccountConnector::__AuthState_RecvHybridCryptKeys
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_packet$ = -8						; size = 4
_this$ = -4						; size = 4
?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted, COMDAT
; _this$ = ecx

; 614  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 615  : 	TPacketKeyAgreementCompleted packet;
; 616  : 	if (!Recv(sizeof(packet), &packet))

  00008	8d 45 f8	 lea	 eax, DWORD PTR _packet$[ebp]
  0000b	50		 push	 eax
  0000c	6a 04		 push	 4
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	75 04		 jne	 SHORT $LN2@AuthState_

; 617  : 	{
; 618  : 		return false;

  0001d	32 c0		 xor	 al, al
  0001f	eb 15		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 619  : 	}
; 620  : 
; 621  : 	Tracenf("KEY_AGREEMENT_COMPLETED RECV");

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@EDLJMNFO@KEY_AGREEMENT_COMPLETED?5RECV@
  00026	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0002b	59		 pop	 ecx

; 622  : 
; 623  : 	ActivateCipher();

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?ActivateCipher@CNetworkStream@@IAEXXZ ; CNetworkStream::ActivateCipher

; 624  : 
; 625  : 	return true;

  00034	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 626  : }

  00036	c9		 leave
  00037	c3		 ret	 0
?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_dataLength$ = -128					; size = 4
_agreedLength$ = -124					; size = 4
_this$ = -120						; size = 4
_packet$ = -116						; size = 261
_packetToSend$ = 148					; size = 261
__$ArrayPad$ = 412					; size = 4
?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvKeyAgreement, COMDAT
; _this$ = ecx

; 570  : {

  00000	55		 push	 ebp
  00001	8d ac 24 60 fe
	ff ff		 lea	 ebp, DWORD PTR [esp-416]
  00008	81 ec 20 02 00
	00		 sub	 esp, 544		; 00000220H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 9c 01 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 88	 mov	 DWORD PTR _this$[ebp], ecx

; 571  : 	TPacketKeyAgreement packet;
; 572  : 	if (!Recv(sizeof(packet), &packet))

  0001e	8d 45 8c	 lea	 eax, DWORD PTR _packet$[ebp]
  00021	50		 push	 eax
  00022	68 05 01 00 00	 push	 261			; 00000105H
  00027	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	75 07		 jne	 SHORT $LN2@AuthState_

; 573  : 	{
; 574  : 		return false;

  00036	32 c0		 xor	 al, al
  00038	e9 cb 00 00 00	 jmp	 $LN1@AuthState_
$LN2@AuthState_:

; 575  : 	}
; 576  : 
; 577  : 	Tracenf("KEY_AGREEMENT RECV %u", packet.wDataLength);

  0003d	0f b7 45 8f	 movzx	 eax, WORD PTR _packet$[ebp+3]
  00041	50		 push	 eax
  00042	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@BIKAAIDD@KEY_AGREEMENT?5RECV?5?$CFu@
  00047	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0004c	59		 pop	 ecx
  0004d	59		 pop	 ecx

; 578  : 
; 579  : 	TPacketKeyAgreement packetToSend;
; 580  : 	size_t dataLength = TPacketKeyAgreement::MAX_DATA_LEN;

  0004e	c7 45 80 00 01
	00 00		 mov	 DWORD PTR _dataLength$[ebp], 256 ; 00000100H

; 581  : 	size_t agreedLength = Prepare(packetToSend.data, &dataLength);

  00055	8d 45 80	 lea	 eax, DWORD PTR _dataLength$[ebp]
  00058	50		 push	 eax
  00059	8d 85 99 00 00
	00		 lea	 eax, DWORD PTR _packetToSend$[ebp+5]
  0005f	50		 push	 eax
  00060	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?Prepare@CNetworkStream@@IAEIPAXPAI@Z ; CNetworkStream::Prepare
  00068	89 45 84	 mov	 DWORD PTR _agreedLength$[ebp], eax

; 582  : 	if (agreedLength == 0)

  0006b	83 7d 84 00	 cmp	 DWORD PTR _agreedLength$[ebp], 0
  0006f	75 0f		 jne	 SHORT $LN3@AuthState_

; 583  : 	{
; 584  : 		//  
; 585  : 		Disconnect();

  00071	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?Disconnect@CAccountConnector@@QAEXXZ ; CAccountConnector::Disconnect

; 586  : 		return false;

  00079	32 c0		 xor	 al, al
  0007b	e9 88 00 00 00	 jmp	 $LN1@AuthState_
$LN3@AuthState_:

; 587  : 	}
; 588  : 	assert(dataLength <= TPacketKeyAgreement::MAX_DATA_LEN);
; 589  : 
; 590  : 	if (Activate(packet.wAgreedLength, packet.data, packet.wDataLength))

  00080	0f b7 45 8f	 movzx	 eax, WORD PTR _packet$[ebp+3]
  00084	50		 push	 eax
  00085	8d 45 91	 lea	 eax, DWORD PTR _packet$[ebp+5]
  00088	50		 push	 eax
  00089	0f b7 45 8d	 movzx	 eax, WORD PTR _packet$[ebp+1]
  0008d	50		 push	 eax
  0008e	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?Activate@CNetworkStream@@IAE_NIPBXI@Z ; CNetworkStream::Activate
  00096	0f b6 c0	 movzx	 eax, al
  00099	85 c0		 test	 eax, eax
  0009b	74 5d		 je	 SHORT $LN4@AuthState_

; 591  : 	{
; 592  : 		// Key agreement ,  
; 593  : 		packetToSend.bHeader = HEADER_CG_KEY_AGREEMENT;

  0009d	c6 85 94 00 00
	00 fb		 mov	 BYTE PTR _packetToSend$[ebp], 251 ; 000000fbH

; 594  : 		packetToSend.wAgreedLength = (WORD)agreedLength;

  000a4	66 8b 45 84	 mov	 ax, WORD PTR _agreedLength$[ebp]
  000a8	66 89 85 95 00
	00 00		 mov	 WORD PTR _packetToSend$[ebp+1], ax

; 595  : 		packetToSend.wDataLength = (WORD)dataLength;

  000af	66 8b 45 80	 mov	 ax, WORD PTR _dataLength$[ebp]
  000b3	66 89 85 97 00
	00 00		 mov	 WORD PTR _packetToSend$[ebp+3], ax

; 596  : 
; 597  : 		if (!Send(sizeof(packetToSend), &packetToSend))

  000ba	8d 85 94 00 00
	00		 lea	 eax, DWORD PTR _packetToSend$[ebp]
  000c0	50		 push	 eax
  000c1	68 05 01 00 00	 push	 261			; 00000105H
  000c6	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  000ce	0f b6 c0	 movzx	 eax, al
  000d1	85 c0		 test	 eax, eax
  000d3	75 0f		 jne	 SHORT $LN6@AuthState_

; 598  : 		{
; 599  : 			Tracen(" CAccountConnector::__AuthState_RecvKeyAgreement - SendKeyAgreement Error");

  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@DCNAEAA@?5CAccountConnector?3?3__AuthState@
  000da	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  000df	59		 pop	 ecx

; 600  : 			return false;

  000e0	32 c0		 xor	 al, al
  000e2	eb 24		 jmp	 SHORT $LN1@AuthState_
$LN6@AuthState_:

; 601  : 		}
; 602  : 		Tracenf("KEY_AGREEMENT SEND %u", packetToSend.wDataLength);

  000e4	0f b7 85 97 00
	00 00		 movzx	 eax, WORD PTR _packetToSend$[ebp+3]
  000eb	50		 push	 eax
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HCLENPJB@KEY_AGREEMENT?5SEND?5?$CFu@
  000f1	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  000f6	59		 pop	 ecx
  000f7	59		 pop	 ecx

; 603  : 	}

  000f8	eb 0c		 jmp	 SHORT $LN5@AuthState_
$LN4@AuthState_:

; 604  : 	else
; 605  : 	{
; 606  : 		//   
; 607  : 		Disconnect();

  000fa	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	e8 00 00 00 00	 call	 ?Disconnect@CAccountConnector@@QAEXXZ ; CAccountConnector::Disconnect

; 608  : 		return false;

  00102	32 c0		 xor	 al, al
  00104	eb 02		 jmp	 SHORT $LN1@AuthState_
$LN5@AuthState_:

; 609  : 	}
; 610  : 	return true;

  00106	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 611  : }

  00108	8b 8d 9c 01 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010e	33 cd		 xor	 ecx, ebp
  00110	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00115	81 c5 a0 01 00
	00		 add	 ebp, 416		; 000001a0H
  0011b	c9		 leave
  0011c	c3		 ret	 0
?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvKeyAgreement
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -128						; size = 4
_kPacket$ = -124					; size = 289
__$ArrayPad$ = 168					; size = 4
?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvPanamaPack, COMDAT
; _this$ = ecx

; 384  : {

  00000	55		 push	 ebp
  00001	8d ac 24 54 ff
	ff ff		 lea	 ebp, DWORD PTR [esp-172]
  00008	81 ec 2c 01 00
	00		 sub	 esp, 300		; 0000012cH
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 a8 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	89 4d 80	 mov	 DWORD PTR _this$[ebp], ecx

; 385  : 	TPacketGCPanamaPack kPacket;
; 386  : 
; 387  : 	if (!Recv(sizeof(TPacketGCPanamaPack), &kPacket))

  0001e	8d 45 84	 lea	 eax, DWORD PTR _kPacket$[ebp]
  00021	50		 push	 eax
  00022	68 21 01 00 00	 push	 289			; 00000121H
  00027	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	75 04		 jne	 SHORT $LN4@AuthState_

; 388  : 		return false;

  00036	32 c0		 xor	 al, al
  00038	eb 1d		 jmp	 SHORT $LN1@AuthState_
$LN4@AuthState_:

; 389  : 
; 390  : 	CEterPackManager::instance().RegisterPack(kPacket.szPackName, "*", kPacket.abIV);

  0003a	8d 85 85 00 00
	00		 lea	 eax, DWORD PTR _kPacket$[ebp+257]
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_01NBENCBCI@?$CK@
  00046	8d 45 85	 lea	 eax, DWORD PTR _kPacket$[ebp+1]
  00049	50		 push	 eax
  0004a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  00050	e8 00 00 00 00	 call	 ?RegisterPack@CEterPackManager@@QAE_NPBD0PBE@Z ; CEterPackManager::RegisterPack

; 391  : 	return true;

  00055	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 392  : }

  00057	8b 8d a8 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005d	33 cd		 xor	 ecx, ebp
  0005f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00064	81 c5 ac 00 00
	00		 add	 ebp, 172		; 000000acH
  0006a	c9		 leave
  0006b	c3		 ret	 0
?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvPanamaPack
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_kRequestPacket$ = -1					; size = 1
?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest, COMDAT
; _this$ = ecx

; 534  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 535  : 	TPacketGCNEWCIBNPasspodRequest kRequestPacket;
; 536  : 	if (!Recv(sizeof(kRequestPacket), &kRequestPacket))

  00008	8d 45 ff	 lea	 eax, DWORD PTR _kRequestPacket$[ebp]
  0000b	50		 push	 eax
  0000c	6a 01		 push	 1
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	75 04		 jne	 SHORT $LN2@AuthState_

; 537  : 		return false;

  0001d	32 c0		 xor	 al, al
  0001f	eb 25		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 538  : 
; 539  : 	PyCallClassMemberFunc(m_poHandler, "BINARY_OnNEWCIBNPasspodRequest", Py_BuildValue("()"));	

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002c	59		 pop	 ecx
  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@
  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	ff b0 d4 00 00
	00		 push	 DWORD PTR [eax+212]
  0003c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00041	83 c4 0c	 add	 esp, 12			; 0000000cH

; 540  : 	return true;

  00044	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 541  : }

  00046	c9		 leave
  00047	c3		 ret	 0
?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kMatrixQuizPacket$ = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvRunupMatrixQuiz, COMDAT
; _this$ = ecx

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 525  : 	TPacketGCRunupMatrixQuiz kMatrixQuizPacket;
; 526  : 	if (!Recv(sizeof(TPacketGCRunupMatrixQuiz), &kMatrixQuizPacket))

  00013	8d 45 f0	 lea	 eax, DWORD PTR _kMatrixQuizPacket$[ebp]
  00016	50		 push	 eax
  00017	6a 0a		 push	 10			; 0000000aH
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@AuthState_

; 527  : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	eb 2a		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 528  : 
; 529  : 	PyCallClassMemberFunc(m_poHandler, "BINARY_OnRunupMatrixQuiz", Py_BuildValue("(s)", kMatrixQuizPacket.szQuiz));	

  0002c	8d 45 f1	 lea	 eax, DWORD PTR _kMatrixQuizPacket$[ebp+1]
  0002f	50		 push	 eax
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@
  00043	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00046	ff b0 d4 00 00
	00		 push	 DWORD PTR [eax+212]
  0004c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00051	83 c4 0c	 add	 esp, 12			; 0000000cH

; 530  : 	return true;

  00054	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 531  : }

  00056	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00059	33 cd		 xor	 ecx, ebp
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	c9		 leave
  00061	c3		 ret	 0
?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvRunupMatrixQuiz
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_pyValue$1 = -24					; size = 4
_this$ = -20						; size = 4
_kMatrixCardPacket$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvChinaMatrixCard, COMDAT
; _this$ = ecx

; 547  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 548  : 	TPacketGCChinaMatrixCard kMatrixCardPacket;
; 549  : 	if (!Recv(sizeof(TPacketGCChinaMatrixCard), &kMatrixCardPacket))

  00013	8d 45 f0	 lea	 eax, DWORD PTR _kMatrixCardPacket$[ebp]
  00016	50		 push	 eax
  00017	6a 09		 push	 9
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 07		 jne	 SHORT $LN2@AuthState_

; 550  : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	e9 96 00 00 00	 jmp	 $LN1@AuthState_
$LN2@AuthState_:

; 551  : 
; 552  : 	if (m_poHandler)

  0002f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 b8 d4 00 00
	00 00		 cmp	 DWORD PTR [eax+212], 0
  00039	0f 84 84 00 00
	00		 je	 $LN3@AuthState_

; 553  : 	{
; 554  : 		PyObject * pyValue = Py_BuildValue("(iiiiiiii)",	ROW(kMatrixCardPacket.dwRows, 0),

  0003f	8b 45 f5	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+5]
  00042	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00047	50		 push	 eax
  00048	8b 45 f5	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+5]
  0004b	c1 e8 08	 shr	 eax, 8
  0004e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00053	50		 push	 eax
  00054	8b 45 f5	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+5]
  00057	c1 e8 10	 shr	 eax, 16			; 00000010H
  0005a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005f	50		 push	 eax
  00060	8b 45 f5	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+5]
  00063	c1 e8 18	 shr	 eax, 24			; 00000018H
  00066	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0006b	50		 push	 eax
  0006c	8b 45 f1	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+1]
  0006f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00074	50		 push	 eax
  00075	8b 45 f1	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+1]
  00078	c1 e8 08	 shr	 eax, 8
  0007b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00080	50		 push	 eax
  00081	8b 45 f1	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+1]
  00084	c1 e8 10	 shr	 eax, 16			; 00000010H
  00087	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0008c	50		 push	 eax
  0008d	8b 45 f1	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+1]
  00090	c1 e8 18	 shr	 eax, 24			; 00000018H
  00093	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00098	50		 push	 eax
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000a4	83 c4 24	 add	 esp, 36			; 00000024H
  000a7	89 45 e8	 mov	 DWORD PTR _pyValue$1[ebp], eax

; 555  : 															ROW(kMatrixCardPacket.dwRows, 1),
; 556  : 															ROW(kMatrixCardPacket.dwRows, 2),
; 557  : 															ROW(kMatrixCardPacket.dwRows, 3),
; 558  : 															COL(kMatrixCardPacket.dwCols, 0),
; 559  : 															COL(kMatrixCardPacket.dwCols, 1),
; 560  : 															COL(kMatrixCardPacket.dwCols, 2),
; 561  : 															COL(kMatrixCardPacket.dwCols, 3));
; 562  : 		PyCallClassMemberFunc(m_poHandler, "OnMatrixCard", pyValue);

  000aa	ff 75 e8	 push	 DWORD PTR _pyValue$1[ebp]
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PIKEFLJP@OnMatrixCard@
  000b2	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b5	ff b0 d4 00 00
	00		 push	 DWORD PTR [eax+212]
  000bb	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@AuthState_:

; 563  : 	}
; 564  : 
; 565  : 	return true;

  000c3	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 566  : }

  000c5	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c8	33 cd		 xor	 ecx, ebp
  000ca	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cf	c9		 leave
  000d0	c3		 ret	 0
?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvChinaMatrixCard
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_packet_failure$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvAuthFailure, COMDAT
; _this$ = ecx

; 510  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 511  : 	TPacketGCLoginFailure packet_failure;
; 512  : 	if (!Recv(sizeof(TPacketGCLoginFailure), &packet_failure))

  00013	8d 45 f0	 lea	 eax, DWORD PTR _packet_failure$[ebp]
  00016	50		 push	 eax
  00017	6a 0a		 push	 10			; 0000000aH
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@AuthState_

; 513  : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	eb 36		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 514  : 
; 515  : 	if (m_poHandler)

  0002c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 b8 d4 00 00
	00 00		 cmp	 DWORD PTR [eax+212], 0
  00036	74 28		 je	 SHORT $LN3@AuthState_

; 516  : 		PyCallClassMemberFunc(m_poHandler, "OnLoginFailure", Py_BuildValue("(s)", packet_failure.szStatus));

  00038	8d 45 f1	 lea	 eax, DWORD PTR _packet_failure$[ebp+1]
  0003b	50		 push	 eax
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ@
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00047	59		 pop	 ecx
  00048	59		 pop	 ecx
  00049	50		 push	 eax
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OOEAIINI@OnLoginFailure@
  0004f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00052	ff b0 d4 00 00
	00		 push	 DWORD PTR [eax+212]
  00058	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@AuthState_:

; 517  : 
; 518  : //	__OfflineState_Set();
; 519  : 
; 520  : 	return true;

  00060	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 521  : }

  00062	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00065	33 cd		 xor	 ecx, ebp
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	c9		 leave
  0006d	c3		 ret	 0
?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvAuthFailure
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_kAuthSuccessPacket$ = -24				; size = 6
$T1 = -16						; size = 4
_dwPanamaKey$2 = -12					; size = 4
_rkNet$3 = -8						; size = 4
_this$ = -4						; size = 4
?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvAuthSuccess, COMDAT
; _this$ = ecx

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 453  : 	TPacketGCAuthSuccess kAuthSuccessPacket;
; 454  : 	if (!Recv(sizeof(kAuthSuccessPacket), &kAuthSuccessPacket))

  00009	8d 45 e8	 lea	 eax, DWORD PTR _kAuthSuccessPacket$[ebp]
  0000c	50		 push	 eax
  0000d	6a 06		 push	 6
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 07		 jne	 SHORT $LN2@AuthState_

; 455  : 		return false;

  0001e	32 c0		 xor	 al, al
  00020	e9 ce 00 00 00	 jmp	 $LN1@AuthState_
$LN2@AuthState_:

; 456  : 
; 457  : 	if (!kAuthSuccessPacket.bResult)

  00025	0f b6 45 ed	 movzx	 eax, BYTE PTR _kAuthSuccessPacket$[ebp+5]
  00029	85 c0		 test	 eax, eax
  0002b	75 37		 jne	 SHORT $LN3@AuthState_

; 458  : 	{
; 459  : 		if (m_poHandler)

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 b8 d4 00 00
	00 00		 cmp	 DWORD PTR [eax+212], 0
  00037	74 29		 je	 SHORT $LN5@AuthState_

; 460  : 			PyCallClassMemberFunc(m_poHandler, "OnLoginFailure", Py_BuildValue("(s)", "BESAMEKEY"));

  00039	68 00 00 00 00	 push	 OFFSET ??_C@_09FJACDEDF@BESAMEKEY@
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ@
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00049	59		 pop	 ecx
  0004a	59		 pop	 ecx
  0004b	50		 push	 eax
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OOEAIINI@OnLoginFailure@
  00051	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00054	ff b0 d4 00 00
	00		 push	 DWORD PTR [eax+212]
  0005a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN5@AuthState_:

; 461  : 	}

  00062	eb 7d		 jmp	 SHORT $LN4@AuthState_
$LN3@AuthState_:

; 462  : 	else
; 463  : 	{
; 464  : 		DWORD dwPanamaKey = kAuthSuccessPacket.dwLoginKey ^ g_adwEncryptKey[0] ^ g_adwEncryptKey[1] ^ g_adwEncryptKey[2] ^ g_adwEncryptKey[3];

  00064	6a 04		 push	 4
  00066	58		 pop	 eax
  00067	6b c0 00	 imul	 eax, eax, 0
  0006a	8b 4d e9	 mov	 ecx, DWORD PTR _kAuthSuccessPacket$[ebp+1]
  0006d	33 88 00 00 00
	00		 xor	 ecx, DWORD PTR ?g_adwEncryptKey@@3PAKA[eax]
  00073	6a 04		 push	 4
  00075	58		 pop	 eax
  00076	c1 e0 00	 shl	 eax, 0
  00079	33 88 00 00 00
	00		 xor	 ecx, DWORD PTR ?g_adwEncryptKey@@3PAKA[eax]
  0007f	6a 04		 push	 4
  00081	58		 pop	 eax
  00082	d1 e0		 shl	 eax, 1
  00084	33 88 00 00 00
	00		 xor	 ecx, DWORD PTR ?g_adwEncryptKey@@3PAKA[eax]
  0008a	6a 04		 push	 4
  0008c	58		 pop	 eax
  0008d	6b c0 03	 imul	 eax, eax, 3
  00090	33 88 00 00 00
	00		 xor	 ecx, DWORD PTR ?g_adwEncryptKey@@3PAKA[eax]
  00096	89 4d f4	 mov	 DWORD PTR _dwPanamaKey$2[ebp], ecx

; 465  : 		CEterPackManager::instance().DecryptPackIV(dwPanamaKey);

  00099	ff 75 f4	 push	 DWORD PTR _dwPanamaKey$2[ebp]
  0009c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCEterPackManager@@@@0PAVCEterPackManager@@A ; CSingleton<CEterPackManager>::ms_singleton
  000a2	e8 00 00 00 00	 call	 ?DecryptPackIV@CEterPackManager@@QAE_NK@Z ; CEterPackManager::DecryptPackIV

; 466  : 
; 467  : 		CPythonNetworkStream & rkNet = CPythonNetworkStream::Instance();

  000a7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  000ac	89 45 f8	 mov	 DWORD PTR _rkNet$3[ebp], eax

; 468  : 		rkNet.SetLoginKey(kAuthSuccessPacket.dwLoginKey);

  000af	ff 75 e9	 push	 DWORD PTR _kAuthSuccessPacket$[ebp+1]
  000b2	8b 4d f8	 mov	 ecx, DWORD PTR _rkNet$3[ebp]
  000b5	e8 00 00 00 00	 call	 ?SetLoginKey@CPythonNetworkStream@@QAEXK@Z ; CPythonNetworkStream::SetLoginKey
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  000c3	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000c8	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 469  : 		rkNet.Connect(m_strAddr.c_str(), m_iPort);

  000cb	6a 03		 push	 3
  000cd	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	ff b0 cc 00 00
	00		 push	 DWORD PTR [eax+204]
  000d6	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  000d9	8b 4d f8	 mov	 ecx, DWORD PTR _rkNet$3[ebp]
  000dc	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NPBDHH@Z ; CNetworkStream::Connect
$LN4@AuthState_:

; 470  : 	}
; 471  : 
; 472  : 	Disconnect();

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?Disconnect@CAccountConnector@@QAEXXZ ; CAccountConnector::Disconnect

; 473  : 	__OfflineState_Set();

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 474  : 
; 475  : 	return true;

  000f1	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 476  : }

  000f3	c9		 leave
  000f4	c3		 ret	 0
?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvAuthSuccess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_SendPong@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_kPacketPong$ = -1					; size = 1
?__AuthState_SendPong@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_SendPong, COMDAT
; _this$ = ecx

; 439  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 440  : 	TPacketCGPong kPacketPong;
; 441  : 	kPacketPong.bHeader = HEADER_CG_PONG;

  00008	c6 45 ff fe	 mov	 BYTE PTR _kPacketPong$[ebp], 254 ; 000000feH

; 442  : 	if (!Send(sizeof(kPacketPong), &kPacketPong))

  0000c	8d 45 ff	 lea	 eax, DWORD PTR _kPacketPong$[ebp]
  0000f	50		 push	 eax
  00010	6a 01		 push	 1
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	75 04		 jne	 SHORT $LN2@AuthState_

; 443  : 		return false;

  00021	32 c0		 xor	 al, al
  00023	eb 1b		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 444  : 
; 445  : 	if (IsSecurityMode())

  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?IsSecurityMode@CNetworkStream@@QAE_NXZ ; CNetworkStream::IsSecurityMode
  0002d	0f b6 c0	 movzx	 eax, al
  00030	85 c0		 test	 eax, eax
  00032	74 0a		 je	 SHORT $LN3@AuthState_

; 446  : 		return SendSequence();

  00034	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0003c	eb 02		 jmp	 SHORT $LN1@AuthState_
$LN3@AuthState_:

; 447  : 
; 448  : 	return true;

  0003e	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 449  : }

  00040	c9		 leave
  00041	c3		 ret	 0
?__AuthState_SendPong@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_SendPong
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_kPacketPing$ = -1					; size = 1
?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_RecvPing, COMDAT
; _this$ = ecx

; 428  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 429  : 	TPacketGCPing kPacketPing;
; 430  : 	if (!Recv(sizeof(kPacketPing), &kPacketPing))

  00008	8d 45 ff	 lea	 eax, DWORD PTR _kPacketPing$[ebp]
  0000b	50		 push	 eax
  0000c	6a 01		 push	 1
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	75 04		 jne	 SHORT $LN2@AuthState_

; 431  : 		return false;

  0001d	32 c0		 xor	 al, al
  0001f	eb 0a		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 432  : 
; 433  : 	__AuthState_SendPong();

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?__AuthState_SendPong@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_SendPong

; 434  : 
; 435  : 	return true;

  00029	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 436  : }

  0002b	c9		 leave
  0002c	c3		 ret	 0
?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_RecvPing
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
_kPacketHandshake$ = -20				; size = 13
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__AuthState_RecvHandshake, COMDAT
; _this$ = ecx

; 354  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 355  : 	TPacketGCHandshake kPacketHandshake;
; 356  : 	if (!Recv(sizeof(kPacketHandshake), &kPacketHandshake))

  00013	8d 45 ec	 lea	 eax, DWORD PTR _kPacketHandshake$[ebp]
  00016	50		 push	 eax
  00017	6a 0d		 push	 13			; 0000000dH
  00019	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@AuthState_

; 357  : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	eb 65		 jmp	 SHORT $LN1@AuthState_
$LN2@AuthState_:

; 358  : 
; 359  : 	// HandShake
; 360  : 	{
; 361  : 		Tracenf("HANDSHAKE RECV %u %d", kPacketHandshake.dwTime, kPacketHandshake.lDelta);

  0002c	ff 75 f5	 push	 DWORD PTR _kPacketHandshake$[ebp+9]
  0002f	ff 75 f1	 push	 DWORD PTR _kPacketHandshake$[ebp+5]
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@MMAJMJLI@HANDSHAKE?5RECV?5?$CFu?5?$CFd@
  00037	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 362  : 
; 363  : 		ELTimer_SetServerMSec(kPacketHandshake.dwTime+ kPacketHandshake.lDelta);

  0003f	8b 45 f1	 mov	 eax, DWORD PTR _kPacketHandshake$[ebp+5]
  00042	03 45 f5	 add	 eax, DWORD PTR _kPacketHandshake$[ebp+9]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?ELTimer_SetServerMSec@@YAXK@Z ; ELTimer_SetServerMSec
  0004b	59		 pop	 ecx

; 364  : 
; 365  : 		//DWORD dwBaseServerTime = kPacketHandshake.dwTime+ kPacketHandshake.lDelta;
; 366  : 		//DWORD dwBaseClientTime = ELTimer_GetMSec();
; 367  : 
; 368  : 		kPacketHandshake.dwTime = kPacketHandshake.dwTime + kPacketHandshake.lDelta + kPacketHandshake.lDelta;

  0004c	8b 45 f1	 mov	 eax, DWORD PTR _kPacketHandshake$[ebp+5]
  0004f	03 45 f5	 add	 eax, DWORD PTR _kPacketHandshake$[ebp+9]
  00052	03 45 f5	 add	 eax, DWORD PTR _kPacketHandshake$[ebp+9]
  00055	89 45 f1	 mov	 DWORD PTR _kPacketHandshake$[ebp+5], eax

; 369  : 		kPacketHandshake.lDelta = 0;

  00058	83 65 f5 00	 and	 DWORD PTR _kPacketHandshake$[ebp+9], 0

; 370  : 
; 371  : 		Tracenf("HANDSHAKE SEND %u", kPacketHandshake.dwTime);

  0005c	ff 75 f1	 push	 DWORD PTR _kPacketHandshake$[ebp+5]
  0005f	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CAMNEEDN@HANDSHAKE?5SEND?5?$CFu@
  00064	e8 00 00 00 00	 call	 ?Tracenf@@YAXPBDZZ	; Tracenf
  00069	59		 pop	 ecx
  0006a	59		 pop	 ecx

; 372  : 
; 373  : 		if (!Send(sizeof(kPacketHandshake), &kPacketHandshake))

  0006b	8d 45 ec	 lea	 eax, DWORD PTR _kPacketHandshake$[ebp]
  0006e	50		 push	 eax
  0006f	6a 0d		 push	 13			; 0000000dH
  00071	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00079	0f b6 c0	 movzx	 eax, al
  0007c	85 c0		 test	 eax, eax
  0007e	75 0f		 jne	 SHORT $LN3@AuthState_

; 374  : 		{
; 375  : 			Tracen(" CAccountConnector::__AuthState_RecvHandshake - SendHandshake Error");

  00080	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@PGOEFGOD@?5CAccountConnector?3?3__AuthState@
  00085	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0008a	59		 pop	 ecx

; 376  : 			return false;

  0008b	32 c0		 xor	 al, al
  0008d	eb 02		 jmp	 SHORT $LN1@AuthState_
$LN3@AuthState_:

; 377  : 		}
; 378  : 	}
; 379  : 
; 380  : 	return true;

  0008f	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 381  : }

  00091	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00094	33 cd		 xor	 ecx, ebp
  00096	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009b	c9		 leave
  0009c	c3		 ret	 0
?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__AuthState_RecvHandshake
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
$T1 = -100						; size = 4
$T2 = -96						; size = 4
_rkNetStream$3 = -92					; size = 4
$T4 = -88						; size = 4
_i$5 = -84						; size = 4
_kPacketPhase$ = -80					; size = 2
_this$ = -76						; size = 4
_LoginPacket$6 = -72					; size = 65
__$ArrayPad$ = -4					; size = 4
?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_RecvPhase, COMDAT
; _this$ = ecx

; 232  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx

; 233  : 	TPacketGCPhase kPacketPhase;
; 234  : 	if (!Recv(sizeof(kPacketPhase), &kPacketPhase))

  00013	8d 45 b0	 lea	 eax, DWORD PTR _kPacketPhase$[ebp]
  00016	50		 push	 eax
  00017	6a 02		 push	 2
  00019	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 07		 jne	 SHORT $LN5@AuthState_

; 235  : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	e9 25 01 00 00	 jmp	 $LN1@AuthState_
$LN5@AuthState_:

; 236  : 
; 237  : 	if (kPacketPhase.phase == PHASE_HANDSHAKE)

  0002f	0f b6 45 b1	 movzx	 eax, BYTE PTR _kPacketPhase$[ebp+1]
  00033	83 f8 01	 cmp	 eax, 1
  00036	75 0d		 jne	 SHORT $LN6@AuthState_

; 238  : 	{
; 239  : 		__HandshakeState_Set();

  00038	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?__HandshakeState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__HandshakeState_Set

; 240  : 	}

  00040	e9 0d 01 00 00	 jmp	 $LN7@AuthState_
$LN6@AuthState_:

; 241  : 	else if (kPacketPhase.phase == PHASE_AUTH)

  00045	0f b6 45 b1	 movzx	 eax, BYTE PTR _kPacketPhase$[ebp+1]
  00049	83 f8 0a	 cmp	 eax, 10			; 0000000aH
  0004c	0f 85 00 01 00
	00		 jne	 $LN7@AuthState_

; 242  : 	{
; 243  : #ifndef _IMPROVED_PACKET_ENCRYPTION_
; 244  : 		const char* key = LocaleService_GetSecurityKey();
; 245  : 		SetSecurityMode(true, key);
; 246  : #endif
; 247  : 
; 248  : #ifdef USE_OPENID		
; 249  : 		if (!openid_test)
; 250  : 		{
; 251  : 			//2012.07.19 OpenID :  
; 252  : 			//Ongoing :   -> TPacketCGLogin5
; 253  : 			//     .
; 254  : 
; 255  : 			//const char* tempAuthKey = "d4025bc1f752b64fe5d51ae575ec4730"; //  32
; 256  : 			TPacketCGLogin5 LoginPacket;
; 257  : 			LoginPacket.header = HEADER_CG_LOGIN5_OPENID;
; 258  : 
; 259  : 			strncpy(LoginPacket.authKey, LocaleService_GetOpenIDAuthKey(), OPENID_AUTHKEY_LEN);
; 260  : 			LoginPacket.authKey[OPENID_AUTHKEY_LEN] = '\0';
; 261  : 			
; 262  : 			for (DWORD i = 0; i < 4; ++i)
; 263  : 				LoginPacket.adwClientKey[i] = g_adwEncryptKey[i];
; 264  : 
; 265  : 			if (!Send(sizeof(LoginPacket), &LoginPacket))
; 266  : 			{
; 267  : 				Tracen(" CAccountConnector::__AuthState_RecvPhase - SendLogin5 Error");
; 268  : 				return false;
; 269  : 			}
; 270  : 
; 271  : 			if (!SendSequence())
; 272  : 			{
; 273  : 				return false;
; 274  : 			}
; 275  : 		}
; 276  : 		else
; 277  : 		{
; 278  : 			TPacketCGLogin3 LoginPacket;
; 279  : 			LoginPacket.header = HEADER_CG_LOGIN3;
; 280  : 
; 281  : 			strncpy(LoginPacket.name, m_strID.c_str(), ID_MAX_NUM);
; 282  : 			strncpy(LoginPacket.pwd, m_strPassword.c_str(), PASS_MAX_NUM);
; 283  : 			LoginPacket.name[ID_MAX_NUM] = '\0';
; 284  : 			LoginPacket.pwd[PASS_MAX_NUM] = '\0';
; 285  : 
; 286  : 			//       ,     
; 287  : 			ClearLoginInfo();
; 288  : 			CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();
; 289  : 			rkNetStream.ClearLoginInfo();
; 290  : 
; 291  : 			m_strPassword = "";
; 292  : 
; 293  : 			for (DWORD i = 0; i < 4; ++i)
; 294  : 				LoginPacket.adwClientKey[i] = g_adwEncryptKey[i];
; 295  : 
; 296  : 			if (!Send(sizeof(LoginPacket), &LoginPacket))
; 297  : 			{
; 298  : 				Tracen(" CAccountConnector::__AuthState_RecvPhase - SendLogin3 Error");
; 299  : 				return false;
; 300  : 			}
; 301  : 
; 302  : 			if (!SendSequence())
; 303  : 			{
; 304  : 				return false;
; 305  : 			}
; 306  : 		}
; 307  : #else /* USE_OPENID */
; 308  : 
; 309  : #ifdef USE_AHNLAB_HACKSHIELD
; 310  : 		HackShield_SetUserInfo(m_strID.c_str());
; 311  : #endif
; 312  : #ifdef XTRAP_CLIENT_ENABLE
; 313  : 		XTrap_SetUserInfo(m_strID.c_str(), NULL, NULL, NULL, NULL);
; 314  : #endif
; 315  : 
; 316  : 
; 317  : 		TPacketCGLogin3 LoginPacket;
; 318  : 		LoginPacket.header = HEADER_CG_LOGIN3;

  00052	c6 45 b8 6f	 mov	 BYTE PTR _LoginPacket$6[ebp], 111 ; 0000006fH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3752 :         return _Mypair._Myval2._Myptr();

  00056	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0005f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00064	89 45 a8	 mov	 DWORD PTR $T4[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 320  : 		strncpy(LoginPacket.name, m_strID.c_str(), ID_MAX_NUM);

  00067	6a 1e		 push	 30			; 0000001eH
  00069	ff 75 a8	 push	 DWORD PTR $T4[ebp]
  0006c	8d 45 b9	 lea	 eax, DWORD PTR _LoginPacket$6[ebp+1]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 _strncpy
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 321  : 		strncpy(LoginPacket.pwd, m_strPassword.c_str(), PASS_MAX_NUM);

  00078	6a 10		 push	 16			; 00000010H
  0007a	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  00083	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00088	50		 push	 eax
  00089	8d 45 d8	 lea	 eax, DWORD PTR _LoginPacket$6[ebp+32]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 _strncpy
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH

; 322  : 		LoginPacket.name[ID_MAX_NUM] = '\0';

  00095	33 c0		 xor	 eax, eax
  00097	40		 inc	 eax
  00098	6b c0 1e	 imul	 eax, eax, 30
  0009b	c6 44 05 b9 00	 mov	 BYTE PTR _LoginPacket$6[ebp+eax+1], 0

; 323  : 		LoginPacket.pwd[PASS_MAX_NUM] = '\0';

  000a0	33 c0		 xor	 eax, eax
  000a2	40		 inc	 eax
  000a3	c1 e0 04	 shl	 eax, 4
  000a6	c6 44 05 d8 00	 mov	 BYTE PTR _LoginPacket$6[ebp+eax+32], 0

; 324  : 
; 325  : 		//       ,     
; 326  : 		ClearLoginInfo();

  000ab	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?ClearLoginInfo@CAccountConnector@@QAEXXZ ; CAccountConnector::ClearLoginInfo

; 327  : 		CPythonNetworkStream& rkNetStream=CPythonNetworkStream::Instance();

  000b3	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  000b8	89 45 a4	 mov	 DWORD PTR _rkNetStream$3[ebp], eax

; 328  : 		rkNetStream.ClearLoginInfo();

  000bb	8b 4d a4	 mov	 ecx, DWORD PTR _rkNetStream$3[ebp]
  000be	e8 00 00 00 00	 call	 ?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::ClearLoginInfo
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000c3	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000c8	e8 00 00 00 00	 call	 _strlen
  000cd	59		 pop	 ecx
  000ce	89 45 a0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000d1	8b 45 a0	 mov	 eax, DWORD PTR $T2[ebp]
  000d4	89 45 9c	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000d7	ff 75 9c	 push	 DWORD PTR $T1[ebp]
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 330  : 		m_strPassword = "";

  000df	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  000e2	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000e8	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 332  : 		for (DWORD i = 0; i < 4; ++i)

  000ed	83 65 ac 00	 and	 DWORD PTR _i$5[ebp], 0
  000f1	eb 07		 jmp	 SHORT $LN4@AuthState_
$LN2@AuthState_:
  000f3	8b 45 ac	 mov	 eax, DWORD PTR _i$5[ebp]
  000f6	40		 inc	 eax
  000f7	89 45 ac	 mov	 DWORD PTR _i$5[ebp], eax
$LN4@AuthState_:
  000fa	83 7d ac 04	 cmp	 DWORD PTR _i$5[ebp], 4
  000fe	73 13		 jae	 SHORT $LN3@AuthState_

; 333  : 			LoginPacket.adwClientKey[i] = g_adwEncryptKey[i];

  00100	8b 45 ac	 mov	 eax, DWORD PTR _i$5[ebp]
  00103	8b 4d ac	 mov	 ecx, DWORD PTR _i$5[ebp]
  00106	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_adwEncryptKey@@3PAKA[ecx*4]
  0010d	89 4c 85 e9	 mov	 DWORD PTR _LoginPacket$6[ebp+eax*4+49], ecx
  00111	eb e0		 jmp	 SHORT $LN2@AuthState_
$LN3@AuthState_:

; 334  : 
; 335  : 		if (!Send(sizeof(LoginPacket), &LoginPacket))

  00113	8d 45 b8	 lea	 eax, DWORD PTR _LoginPacket$6[ebp]
  00116	50		 push	 eax
  00117	6a 41		 push	 65			; 00000041H
  00119	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00121	0f b6 c0	 movzx	 eax, al
  00124	85 c0		 test	 eax, eax
  00126	75 0f		 jne	 SHORT $LN9@AuthState_

; 336  : 		{
; 337  : 			Tracen(" CAccountConnector::__AuthState_RecvPhase - SendLogin3 Error");

  00128	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@HEMMJEJK@?5CAccountConnector?3?3__AuthState@
  0012d	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00132	59		 pop	 ecx

; 338  : 			return false;

  00133	32 c0		 xor	 al, al
  00135	eb 1d		 jmp	 SHORT $LN1@AuthState_
$LN9@AuthState_:

; 339  : 		}
; 340  : 
; 341  : 		if (!SendSequence())

  00137	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0013a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  0013f	0f b6 c0	 movzx	 eax, al
  00142	85 c0		 test	 eax, eax
  00144	75 04		 jne	 SHORT $LN10@AuthState_

; 342  : 		{
; 343  : 			return false;

  00146	32 c0		 xor	 al, al
  00148	eb 0a		 jmp	 SHORT $LN1@AuthState_
$LN10@AuthState_:

; 344  : 		}
; 345  : #endif /* USE_OPENID */
; 346  : 
; 347  : 		__AuthState_Set();

  0014a	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0014d	e8 00 00 00 00	 call	 ?__AuthState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__AuthState_Set
$LN7@AuthState_:

; 348  : 	}
; 349  : 
; 350  : 	return true;

  00152	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 351  : }

  00154	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00157	33 cd		 xor	 ecx, ebp
  00159	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015e	c9		 leave
  0015f	c3		 ret	 0
?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_RecvPhase
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_byEmpty$ = -1						; size = 1
?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_RecvEmpty, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 	BYTE byEmpty;
; 227  : 	Recv(sizeof(BYTE), &byEmpty);

  00008	8d 45 ff	 lea	 eax, DWORD PTR _byEmpty$[ebp]
  0000b	50		 push	 eax
  0000c	6a 01		 push	 1
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv

; 228  : 	return true;

  00016	b0 01		 mov	 al, 1

; 229  : }

  00018	c9		 leave
  00019	c3		 ret	 0
?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_RecvEmpty
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_Process@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
$T1 = -116						; size = 8
$T2 = -108						; size = 8
$T3 = -100						; size = 8
$T4 = -92						; size = 8
$T5 = -84						; size = 8
$T6 = -76						; size = 8
$T7 = -68						; size = 8
$T8 = -60						; size = 8
$T9 = -52						; size = 8
$T10 = -44						; size = 8
$T11 = -36						; size = 8
$T12 = -28						; size = 8
$T13 = -20						; size = 8
$T14 = -12						; size = 8
_this$ = -4						; size = 4
?__AuthState_Process@CAccountConnector@@IAE_NXZ PROC	; CAccountConnector::__AuthState_Process, COMDAT
; _this$ = ecx

; 170  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  : 	if (!__AnalyzePacket(0, sizeof(BYTE), &CAccountConnector::__AuthState_RecvEmpty))

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T14[ebp], OFFSET ?__AuthState_RecvEmpty@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvEmpty
  00010	83 65 f8 00	 and	 DWORD PTR $T14[ebp+4], 0
  00014	ff 75 f8	 push	 DWORD PTR $T14[ebp+4]
  00017	ff 75 f4	 push	 DWORD PTR $T14[ebp]
  0001a	6a 01		 push	 1
  0001c	6a 00		 push	 0
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	75 07		 jne	 SHORT $LN2@AuthState_

; 172  : 		return true;

  0002d	b0 01		 mov	 al, 1
  0002f	e9 45 02 00 00	 jmp	 $LN1@AuthState_
$LN2@AuthState_:

; 173  : 
; 174  : 	if (!__AnalyzePacket(HEADER_GC_PHASE, sizeof(TPacketGCPhase), &CAccountConnector::__AuthState_RecvPhase))

  00034	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T13[ebp], OFFSET ?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPhase
  0003b	83 65 f0 00	 and	 DWORD PTR $T13[ebp+4], 0
  0003f	ff 75 f0	 push	 DWORD PTR $T13[ebp+4]
  00042	ff 75 ec	 push	 DWORD PTR $T13[ebp]
  00045	6a 02		 push	 2
  00047	68 fd 00 00 00	 push	 253			; 000000fdH
  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00054	0f b6 c0	 movzx	 eax, al
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN3@AuthState_

; 175  : 		return false;

  0005b	32 c0		 xor	 al, al
  0005d	e9 17 02 00 00	 jmp	 $LN1@AuthState_
$LN3@AuthState_:

; 176  : 
; 177  : 	if (!__AnalyzePacket(HEADER_GC_PING, sizeof(TPacketGCPing), &CAccountConnector::__AuthState_RecvPing))

  00062	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T12[ebp], OFFSET ?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPing
  00069	83 65 e8 00	 and	 DWORD PTR $T12[ebp+4], 0
  0006d	ff 75 e8	 push	 DWORD PTR $T12[ebp+4]
  00070	ff 75 e4	 push	 DWORD PTR $T12[ebp]
  00073	6a 01		 push	 1
  00075	6a 2c		 push	 44			; 0000002cH
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007a	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  0007f	0f b6 c0	 movzx	 eax, al
  00082	85 c0		 test	 eax, eax
  00084	75 07		 jne	 SHORT $LN4@AuthState_

; 178  : 		return false;

  00086	32 c0		 xor	 al, al
  00088	e9 ec 01 00 00	 jmp	 $LN1@AuthState_
$LN4@AuthState_:

; 179  : 
; 180  : 	if (!__AnalyzePacket(HEADER_GC_AUTH_SUCCESS, sizeof(TPacketGCAuthSuccess), &CAccountConnector::__AuthState_RecvAuthSuccess))

  0008d	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T11[ebp], OFFSET ?__AuthState_RecvAuthSuccess@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvAuthSuccess
  00094	83 65 e0 00	 and	 DWORD PTR $T11[ebp+4], 0
  00098	ff 75 e0	 push	 DWORD PTR $T11[ebp+4]
  0009b	ff 75 dc	 push	 DWORD PTR $T11[ebp]
  0009e	6a 06		 push	 6
  000a0	68 96 00 00 00	 push	 150			; 00000096H
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a8	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  000ad	0f b6 c0	 movzx	 eax, al
  000b0	85 c0		 test	 eax, eax
  000b2	75 07		 jne	 SHORT $LN5@AuthState_

; 181  : 		return true;

  000b4	b0 01		 mov	 al, 1
  000b6	e9 be 01 00 00	 jmp	 $LN1@AuthState_
$LN5@AuthState_:

; 182  : 
; 183  : #ifdef USE_OPENID
; 184  : 	if (!__AnalyzePacket(HEADER_GC_AUTH_SUCCESS_OPENID, sizeof(TPacketGCAuthSuccess), &CAccountConnector::__AuthState_RecvAuthSuccess_OpenID))
; 185  : 		return true;
; 186  : #endif /* USE_OPENID */
; 187  : 
; 188  : 	if (!__AnalyzePacket(HEADER_GC_LOGIN_FAILURE, sizeof(TPacketGCAuthSuccess), &CAccountConnector::__AuthState_RecvAuthFailure))

  000bb	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T10[ebp], OFFSET ?__AuthState_RecvAuthFailure@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvAuthFailure
  000c2	83 65 d8 00	 and	 DWORD PTR $T10[ebp+4], 0
  000c6	ff 75 d8	 push	 DWORD PTR $T10[ebp+4]
  000c9	ff 75 d4	 push	 DWORD PTR $T10[ebp]
  000cc	6a 06		 push	 6
  000ce	6a 07		 push	 7
  000d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d3	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  000d8	0f b6 c0	 movzx	 eax, al
  000db	85 c0		 test	 eax, eax
  000dd	75 07		 jne	 SHORT $LN6@AuthState_

; 189  : 		return true;

  000df	b0 01		 mov	 al, 1
  000e1	e9 93 01 00 00	 jmp	 $LN1@AuthState_
$LN6@AuthState_:

; 190  : 
; 191  : 	if (!__AnalyzePacket(HEADER_GC_CHINA_MATRIX_CARD, sizeof(TPacketGCChinaMatrixCard), &CAccountConnector::__AuthState_RecvChinaMatrixCard))

  000e6	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T9[ebp], OFFSET ?__AuthState_RecvChinaMatrixCard@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvChinaMatrixCard
  000ed	83 65 d0 00	 and	 DWORD PTR $T9[ebp+4], 0
  000f1	ff 75 d0	 push	 DWORD PTR $T9[ebp+4]
  000f4	ff 75 cc	 push	 DWORD PTR $T9[ebp]
  000f7	6a 09		 push	 9
  000f9	6a 74		 push	 116			; 00000074H
  000fb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00103	0f b6 c0	 movzx	 eax, al
  00106	85 c0		 test	 eax, eax
  00108	75 07		 jne	 SHORT $LN7@AuthState_

; 192  : 		return true;

  0010a	b0 01		 mov	 al, 1
  0010c	e9 68 01 00 00	 jmp	 $LN1@AuthState_
$LN7@AuthState_:

; 193  : 
; 194  : 	if (!__AnalyzePacket(HEADER_GC_RUNUP_MATRIX_QUIZ, sizeof(TPacketGCRunupMatrixQuiz), &CAccountConnector::__AuthState_RecvRunupMatrixQuiz))

  00111	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], OFFSET ?__AuthState_RecvRunupMatrixQuiz@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvRunupMatrixQuiz
  00118	83 65 c8 00	 and	 DWORD PTR $T8[ebp+4], 0
  0011c	ff 75 c8	 push	 DWORD PTR $T8[ebp+4]
  0011f	ff 75 c4	 push	 DWORD PTR $T8[ebp]
  00122	6a 0a		 push	 10			; 0000000aH
  00124	68 c9 00 00 00	 push	 201			; 000000c9H
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00131	0f b6 c0	 movzx	 eax, al
  00134	85 c0		 test	 eax, eax
  00136	75 07		 jne	 SHORT $LN8@AuthState_

; 195  : 		return true;

  00138	b0 01		 mov	 al, 1
  0013a	e9 3a 01 00 00	 jmp	 $LN1@AuthState_
$LN8@AuthState_:

; 196  : 
; 197  : 	if (!__AnalyzePacket(HEADER_GC_NEWCIBN_PASSPOD_REQUEST, sizeof(TPacketGCNEWCIBNPasspodRequest), &CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest))

  0013f	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], OFFSET ?__AuthState_RecvNEWCIBNPasspodRequest@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvNEWCIBNPasspodRequest
  00146	83 65 c0 00	 and	 DWORD PTR $T7[ebp+4], 0
  0014a	ff 75 c0	 push	 DWORD PTR $T7[ebp+4]
  0014d	ff 75 bc	 push	 DWORD PTR $T7[ebp]
  00150	6a 01		 push	 1
  00152	68 ca 00 00 00	 push	 202			; 000000caH
  00157	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015a	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  0015f	0f b6 c0	 movzx	 eax, al
  00162	85 c0		 test	 eax, eax
  00164	75 07		 jne	 SHORT $LN9@AuthState_

; 198  : 		return true;

  00166	b0 01		 mov	 al, 1
  00168	e9 0c 01 00 00	 jmp	 $LN1@AuthState_
$LN9@AuthState_:

; 199  : 
; 200  : 	if (!__AnalyzePacket(HEADER_GC_HANDSHAKE, sizeof(TPacketGCHandshake), &CAccountConnector::__AuthState_RecvHandshake))

  0016d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], OFFSET ?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvHandshake
  00174	83 65 b8 00	 and	 DWORD PTR $T6[ebp+4], 0
  00178	ff 75 b8	 push	 DWORD PTR $T6[ebp+4]
  0017b	ff 75 b4	 push	 DWORD PTR $T6[ebp]
  0017e	6a 0d		 push	 13			; 0000000dH
  00180	68 ff 00 00 00	 push	 255			; 000000ffH
  00185	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00188	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  0018d	0f b6 c0	 movzx	 eax, al
  00190	85 c0		 test	 eax, eax
  00192	75 07		 jne	 SHORT $LN10@AuthState_

; 201  : 		return false;

  00194	32 c0		 xor	 al, al
  00196	e9 de 00 00 00	 jmp	 $LN1@AuthState_
$LN10@AuthState_:

; 202  : 
; 203  : 	if (!__AnalyzePacket(HEADER_GC_PANAMA_PACK, sizeof(TPacketGCPanamaPack), &CAccountConnector::__AuthState_RecvPanamaPack))

  0019b	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], OFFSET ?__AuthState_RecvPanamaPack@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPanamaPack
  001a2	83 65 b0 00	 and	 DWORD PTR $T5[ebp+4], 0
  001a6	ff 75 b0	 push	 DWORD PTR $T5[ebp+4]
  001a9	ff 75 ac	 push	 DWORD PTR $T5[ebp]
  001ac	68 21 01 00 00	 push	 289			; 00000121H
  001b1	68 97 00 00 00	 push	 151			; 00000097H
  001b6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001b9	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  001be	0f b6 c0	 movzx	 eax, al
  001c1	85 c0		 test	 eax, eax
  001c3	75 07		 jne	 SHORT $LN11@AuthState_

; 204  : 		return false;

  001c5	32 c0		 xor	 al, al
  001c7	e9 ad 00 00 00	 jmp	 $LN1@AuthState_
$LN11@AuthState_:

; 205  : 
; 206  : #ifdef _IMPROVED_PACKET_ENCRYPTION_
; 207  : 	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT, sizeof(TPacketKeyAgreement), &CAccountConnector::__AuthState_RecvKeyAgreement))

  001cc	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreement
  001d3	83 65 a8 00	 and	 DWORD PTR $T4[ebp+4], 0
  001d7	ff 75 a8	 push	 DWORD PTR $T4[ebp+4]
  001da	ff 75 a4	 push	 DWORD PTR $T4[ebp]
  001dd	68 05 01 00 00	 push	 261			; 00000105H
  001e2	68 fb 00 00 00	 push	 251			; 000000fbH
  001e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ea	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  001ef	0f b6 c0	 movzx	 eax, al
  001f2	85 c0		 test	 eax, eax
  001f4	75 04		 jne	 SHORT $LN12@AuthState_

; 208  : 		return false;

  001f6	32 c0		 xor	 al, al
  001f8	eb 7f		 jmp	 SHORT $LN1@AuthState_
$LN12@AuthState_:

; 209  : 
; 210  : 	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT_COMPLETED, sizeof(TPacketKeyAgreementCompleted), &CAccountConnector::__AuthState_RecvKeyAgreementCompleted))

  001fa	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted
  00201	83 65 a0 00	 and	 DWORD PTR $T3[ebp+4], 0
  00205	ff 75 a0	 push	 DWORD PTR $T3[ebp+4]
  00208	ff 75 9c	 push	 DWORD PTR $T3[ebp]
  0020b	6a 04		 push	 4
  0020d	68 fa 00 00 00	 push	 250			; 000000faH
  00212	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00215	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  0021a	0f b6 c0	 movzx	 eax, al
  0021d	85 c0		 test	 eax, eax
  0021f	75 04		 jne	 SHORT $LN13@AuthState_

; 211  : 		return false;

  00221	32 c0		 xor	 al, al
  00223	eb 54		 jmp	 SHORT $LN1@AuthState_
$LN13@AuthState_:

; 212  : #endif
; 213  : 
; 214  : 	//  TODO :      data serialize & deserialize   .
; 215  : 	if (!__AnalyzeVarSizePacket(HEADER_GC_HYBRIDCRYPT_KEYS, &CAccountConnector::__AuthState_RecvHybridCryptKeys))

  00225	c7 45 94 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptKeys
  0022c	83 65 98 00	 and	 DWORD PTR $T2[ebp+4], 0
  00230	ff 75 98	 push	 DWORD PTR $T2[ebp+4]
  00233	ff 75 94	 push	 DWORD PTR $T2[ebp]
  00236	68 98 00 00 00	 push	 152			; 00000098H
  0023b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0023e	e8 00 00 00 00	 call	 ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
  00243	0f b6 c0	 movzx	 eax, al
  00246	85 c0		 test	 eax, eax
  00248	75 04		 jne	 SHORT $LN14@AuthState_

; 216  : 		return false;

  0024a	32 c0		 xor	 al, al
  0024c	eb 2b		 jmp	 SHORT $LN1@AuthState_
$LN14@AuthState_:

; 217  : 
; 218  : 	if (!__AnalyzeVarSizePacket(HEADER_GC_HYBRIDCRYPT_SDB, &CAccountConnector::__AuthState_RecvHybridCryptSDB))

  0024e	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptSDB
  00255	83 65 90 00	 and	 DWORD PTR $T1[ebp+4], 0
  00259	ff 75 90	 push	 DWORD PTR $T1[ebp+4]
  0025c	ff 75 8c	 push	 DWORD PTR $T1[ebp]
  0025f	68 99 00 00 00	 push	 153			; 00000099H
  00264	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00267	e8 00 00 00 00	 call	 ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
  0026c	0f b6 c0	 movzx	 eax, al
  0026f	85 c0		 test	 eax, eax
  00271	75 04		 jne	 SHORT $LN15@AuthState_

; 219  : 		return false;

  00273	32 c0		 xor	 al, al
  00275	eb 02		 jmp	 SHORT $LN1@AuthState_
$LN15@AuthState_:

; 220  : 
; 221  : 	return true;

  00277	b0 01		 mov	 al, 1
$LN1@AuthState_:

; 222  : }

  00279	c9		 leave
  0027a	c3		 ret	 0
?__AuthState_Process@CAccountConnector@@IAE_NXZ ENDP	; CAccountConnector::__AuthState_Process
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__HandshakeState_Process@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
$T1 = -60						; size = 8
$T2 = -52						; size = 8
$T3 = -44						; size = 8
$T4 = -36						; size = 8
$T5 = -28						; size = 8
$T6 = -20						; size = 8
$T7 = -12						; size = 8
_this$ = -4						; size = 4
?__HandshakeState_Process@CAccountConnector@@IAE_NXZ PROC ; CAccountConnector::__HandshakeState_Process, COMDAT
; _this$ = ecx

; 141  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 142  : 	if (!__AnalyzePacket(HEADER_GC_PHASE, sizeof(TPacketGCPhase), &CAccountConnector::__AuthState_RecvPhase))

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T7[ebp], OFFSET ?__AuthState_RecvPhase@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPhase
  00010	83 65 f8 00	 and	 DWORD PTR $T7[ebp+4], 0
  00014	ff 75 f8	 push	 DWORD PTR $T7[ebp+4]
  00017	ff 75 f4	 push	 DWORD PTR $T7[ebp]
  0001a	6a 02		 push	 2
  0001c	68 fd 00 00 00	 push	 253			; 000000fdH
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 07		 jne	 SHORT $LN2@HandshakeS

; 143  : 		return false;

  00030	32 c0		 xor	 al, al
  00032	e9 09 01 00 00	 jmp	 $LN1@HandshakeS
$LN2@HandshakeS:

; 144  : 
; 145  : 	if (!__AnalyzePacket(HEADER_GC_HANDSHAKE, sizeof(TPacketGCHandshake), &CAccountConnector::__AuthState_RecvHandshake))

  00037	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], OFFSET ?__AuthState_RecvHandshake@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvHandshake
  0003e	83 65 f0 00	 and	 DWORD PTR $T6[ebp+4], 0
  00042	ff 75 f0	 push	 DWORD PTR $T6[ebp+4]
  00045	ff 75 ec	 push	 DWORD PTR $T6[ebp]
  00048	6a 0d		 push	 13			; 0000000dH
  0004a	68 ff 00 00 00	 push	 255			; 000000ffH
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00057	0f b6 c0	 movzx	 eax, al
  0005a	85 c0		 test	 eax, eax
  0005c	75 07		 jne	 SHORT $LN3@HandshakeS

; 146  : 		return false;

  0005e	32 c0		 xor	 al, al
  00060	e9 db 00 00 00	 jmp	 $LN1@HandshakeS
$LN3@HandshakeS:

; 147  : 
; 148  : 	if (!__AnalyzePacket(HEADER_GC_PING, sizeof(TPacketGCPing), &CAccountConnector::__AuthState_RecvPing))

  00065	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], OFFSET ?__AuthState_RecvPing@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvPing
  0006c	83 65 e8 00	 and	 DWORD PTR $T5[ebp+4], 0
  00070	ff 75 e8	 push	 DWORD PTR $T5[ebp+4]
  00073	ff 75 e4	 push	 DWORD PTR $T5[ebp]
  00076	6a 01		 push	 1
  00078	6a 2c		 push	 44			; 0000002cH
  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00082	0f b6 c0	 movzx	 eax, al
  00085	85 c0		 test	 eax, eax
  00087	75 07		 jne	 SHORT $LN4@HandshakeS

; 149  : 		return false;

  00089	32 c0		 xor	 al, al
  0008b	e9 b0 00 00 00	 jmp	 $LN1@HandshakeS
$LN4@HandshakeS:

; 150  : 
; 151  : 	//  TODO :      data serialize & deserialize   .
; 152  : 	if (!__AnalyzeVarSizePacket(HEADER_GC_HYBRIDCRYPT_KEYS, &CAccountConnector::__AuthState_RecvHybridCryptKeys))

  00090	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], OFFSET ?__AuthState_RecvHybridCryptKeys@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptKeys
  00097	83 65 e0 00	 and	 DWORD PTR $T4[ebp+4], 0
  0009b	ff 75 e0	 push	 DWORD PTR $T4[ebp+4]
  0009e	ff 75 dc	 push	 DWORD PTR $T4[ebp]
  000a1	68 98 00 00 00	 push	 152			; 00000098H
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
  000ae	0f b6 c0	 movzx	 eax, al
  000b1	85 c0		 test	 eax, eax
  000b3	75 07		 jne	 SHORT $LN5@HandshakeS

; 153  : 		return false;

  000b5	32 c0		 xor	 al, al
  000b7	e9 84 00 00 00	 jmp	 $LN1@HandshakeS
$LN5@HandshakeS:

; 154  : 
; 155  : 	if (!__AnalyzeVarSizePacket(HEADER_GC_HYBRIDCRYPT_SDB, &CAccountConnector::__AuthState_RecvHybridCryptSDB))

  000bc	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], OFFSET ?__AuthState_RecvHybridCryptSDB@CAccountConnector@@IAE_NH@Z ; CAccountConnector::__AuthState_RecvHybridCryptSDB
  000c3	83 65 d8 00	 and	 DWORD PTR $T3[ebp+4], 0
  000c7	ff 75 d8	 push	 DWORD PTR $T3[ebp+4]
  000ca	ff 75 d4	 push	 DWORD PTR $T3[ebp]
  000cd	68 99 00 00 00	 push	 153			; 00000099H
  000d2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	e8 00 00 00 00	 call	 ?__AnalyzeVarSizePacket@CAccountConnector@@IAE_NIP81@AE_NH@Z@Z ; CAccountConnector::__AnalyzeVarSizePacket
  000da	0f b6 c0	 movzx	 eax, al
  000dd	85 c0		 test	 eax, eax
  000df	75 04		 jne	 SHORT $LN6@HandshakeS

; 156  : 		return false;

  000e1	32 c0		 xor	 al, al
  000e3	eb 5b		 jmp	 SHORT $LN1@HandshakeS
$LN6@HandshakeS:

; 157  : 
; 158  : #ifdef _IMPROVED_PACKET_ENCRYPTION_
; 159  : 	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT, sizeof(TPacketKeyAgreement), &CAccountConnector::__AuthState_RecvKeyAgreement))

  000e5	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ?__AuthState_RecvKeyAgreement@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreement
  000ec	83 65 d0 00	 and	 DWORD PTR $T2[ebp+4], 0
  000f0	ff 75 d0	 push	 DWORD PTR $T2[ebp+4]
  000f3	ff 75 cc	 push	 DWORD PTR $T2[ebp]
  000f6	68 05 01 00 00	 push	 261			; 00000105H
  000fb	68 fb 00 00 00	 push	 251			; 000000fbH
  00100	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00108	0f b6 c0	 movzx	 eax, al
  0010b	85 c0		 test	 eax, eax
  0010d	75 04		 jne	 SHORT $LN7@HandshakeS

; 160  : 		return false;

  0010f	32 c0		 xor	 al, al
  00111	eb 2d		 jmp	 SHORT $LN1@HandshakeS
$LN7@HandshakeS:

; 161  : 
; 162  : 	if (!__AnalyzePacket(HEADER_GC_KEY_AGREEMENT_COMPLETED, sizeof(TPacketKeyAgreementCompleted), &CAccountConnector::__AuthState_RecvKeyAgreementCompleted))

  00113	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ?__AuthState_RecvKeyAgreementCompleted@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_RecvKeyAgreementCompleted
  0011a	83 65 c8 00	 and	 DWORD PTR $T1[ebp+4], 0
  0011e	ff 75 c8	 push	 DWORD PTR $T1[ebp+4]
  00121	ff 75 c4	 push	 DWORD PTR $T1[ebp]
  00124	6a 04		 push	 4
  00126	68 fa 00 00 00	 push	 250			; 000000faH
  0012b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012e	e8 00 00 00 00	 call	 ?__AnalyzePacket@CAccountConnector@@IAE_NIIP81@AE_NXZ@Z ; CAccountConnector::__AnalyzePacket
  00133	0f b6 c0	 movzx	 eax, al
  00136	85 c0		 test	 eax, eax
  00138	75 04		 jne	 SHORT $LN8@HandshakeS

; 163  : 		return false;

  0013a	32 c0		 xor	 al, al
  0013c	eb 02		 jmp	 SHORT $LN1@HandshakeS
$LN8@HandshakeS:

; 164  : #endif
; 165  : 
; 166  : 	return true;

  0013e	b0 01		 mov	 al, 1
$LN1@HandshakeS:

; 167  : }

  00140	c9		 leave
  00141	c3		 ret	 0
?__HandshakeState_Process@CAccountConnector@@IAE_NXZ ENDP ; CAccountConnector::__HandshakeState_Process
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__AuthState_Set@CAccountConnector@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__AuthState_Set@CAccountConnector@@IAEXXZ PROC		; CAccountConnector::__AuthState_Set, COMDAT
; _this$ = ecx

; 676  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 677  : 	m_eState=STATE_AUTH;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 80 80 00 00
	00 02 00 00 00	 mov	 DWORD PTR [eax+128], 2

; 678  : }

  00014	c9		 leave
  00015	c3		 ret	 0
?__AuthState_Set@CAccountConnector@@IAEXXZ ENDP		; CAccountConnector::__AuthState_Set
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__HandshakeState_Set@CAccountConnector@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__HandshakeState_Set@CAccountConnector@@IAEXXZ PROC	; CAccountConnector::__HandshakeState_Set, COMDAT
; _this$ = ecx

; 671  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 672  : 	m_eState=STATE_HANDSHAKE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 80 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+128], 1

; 673  : }

  00014	c9		 leave
  00015	c3		 ret	 0
?__HandshakeState_Set@CAccountConnector@@IAEXXZ ENDP	; CAccountConnector::__HandshakeState_Set
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__OfflineState_Set@CAccountConnector@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__OfflineState_Set@CAccountConnector@@IAEXXZ PROC	; CAccountConnector::__OfflineState_Set, COMDAT
; _this$ = ecx

; 666  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 667  : 	__Inialize();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__Inialize@CAccountConnector@@IAEXXZ ; CAccountConnector::__Inialize

; 668  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?__OfflineState_Set@CAccountConnector@@IAEXXZ ENDP	; CAccountConnector::__OfflineState_Set
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__StateProcess@CAccountConnector@@IAE_NXZ
_TEXT	SEGMENT
tv65 = -8						; size = 4
_this$ = -4						; size = 4
?__StateProcess@CAccountConnector@@IAE_NXZ PROC		; CAccountConnector::__StateProcess, COMDAT
; _this$ = ecx

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 127  : 	switch (m_eState)

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [eax+128]
  00011	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  00014	83 7d f8 01	 cmp	 DWORD PTR tv65[ebp], 1
  00018	74 08		 je	 SHORT $LN4@StateProce
  0001a	83 7d f8 02	 cmp	 DWORD PTR tv65[ebp], 2
  0001e	74 0e		 je	 SHORT $LN5@StateProce
  00020	eb 16		 jmp	 SHORT $LN2@StateProce
$LN4@StateProce:

; 128  : 	{
; 129  : 		case STATE_HANDSHAKE:
; 130  : 			return __HandshakeState_Process();

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?__HandshakeState_Process@CAccountConnector@@IAE_NXZ ; CAccountConnector::__HandshakeState_Process
  0002a	eb 0e		 jmp	 SHORT $LN1@StateProce

; 131  : 			break;

  0002c	eb 0a		 jmp	 SHORT $LN2@StateProce
$LN5@StateProce:

; 132  : 		case STATE_AUTH:
; 133  : 			return __AuthState_Process();

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?__AuthState_Process@CAccountConnector@@IAE_NXZ ; CAccountConnector::__AuthState_Process
  00036	eb 02		 jmp	 SHORT $LN1@StateProce
$LN2@StateProce:

; 134  : 			break;
; 135  : 	}
; 136  : 
; 137  : 	return true;

  00038	b0 01		 mov	 al, 1
$LN1@StateProce:

; 138  : }

  0003a	c9		 leave
  0003b	c3		 ret	 0
?__StateProcess@CAccountConnector@@IAE_NXZ ENDP		; CAccountConnector::__StateProcess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?__Inialize@CAccountConnector@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__Inialize@CAccountConnector@@IAEXXZ PROC		; CAccountConnector::__Inialize, COMDAT
; _this$ = ecx

; 725  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 726  : 	m_eState=STATE_OFFLINE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 a0 80 00 00
	00 00		 and	 DWORD PTR [eax+128], 0

; 727  : 	m_isWaitKey = FALSE;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 a0 d0 00 00
	00 00		 and	 DWORD PTR [eax+208], 0

; 728  : }

  0001b	c9		 leave
  0001c	c3		 ret	 0
?__Inialize@CAccountConnector@@IAEXXZ ENDP		; CAccountConnector::__Inialize
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?OnDisconnect@CAccountConnector@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnDisconnect@CAccountConnector@@MAEXXZ PROC		; CAccountConnector::OnDisconnect, COMDAT
; _this$ = ecx

; 709  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 710  : 	__OfflineState_Set();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 711  : }

  0000f	c9		 leave
  00010	c3		 ret	 0
?OnDisconnect@CAccountConnector@@MAEXXZ ENDP		; CAccountConnector::OnDisconnect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?OnRemoteDisconnect@CAccountConnector@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnRemoteDisconnect@CAccountConnector@@MAEXXZ PROC	; CAccountConnector::OnRemoteDisconnect, COMDAT
; _this$ = ecx

; 694  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 695  : 	// Matrix Card Number    close    .
; 696  : 	if (m_isWaitKey)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 d0 00 00
	00 00		 cmp	 DWORD PTR [eax+208], 0
  00011	74 31		 je	 SHORT $LN2@OnRemoteDi

; 697  : 	{
; 698  : 		if (m_poHandler)

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 b8 d4 00 00
	00 00		 cmp	 DWORD PTR [eax+212], 0
  0001d	74 25		 je	 SHORT $LN2@OnRemoteDi

; 699  : 		{
; 700  : 			PyCallClassMemberFunc(m_poHandler, "OnExit", Py_BuildValue("()"));

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002a	59		 pop	 ecx
  0002b	50		 push	 eax
  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_06NAODFICM@OnExit@
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	ff b0 d4 00 00
	00		 push	 DWORD PTR [eax+212]
  0003a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 701  : 			return;

  00042	eb 08		 jmp	 SHORT $LN1@OnRemoteDi
$LN2@OnRemoteDi:

; 702  : 		}
; 703  : 	}
; 704  : 
; 705  : 	__OfflineState_Set();

  00044	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set
$LN1@OnRemoteDi:

; 706  : }

  0004c	c9		 leave
  0004d	c3		 ret	 0
?OnRemoteDisconnect@CAccountConnector@@MAEXXZ ENDP	; CAccountConnector::OnRemoteDisconnect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?OnConnectSuccess@CAccountConnector@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnConnectSuccess@CAccountConnector@@MAEXXZ PROC	; CAccountConnector::OnConnectSuccess, COMDAT
; _this$ = ecx

; 689  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 690  : 	m_eState = STATE_HANDSHAKE;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 80 80 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+128], 1

; 691  : }

  00014	c9		 leave
  00015	c3		 ret	 0
?OnConnectSuccess@CAccountConnector@@MAEXXZ ENDP	; CAccountConnector::OnConnectSuccess
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?OnConnectFailure@CAccountConnector@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnConnectFailure@CAccountConnector@@MAEXXZ PROC	; CAccountConnector::OnConnectFailure, COMDAT
; _this$ = ecx

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 682  : 	if (m_poHandler)

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 b8 d4 00 00
	00 00		 cmp	 DWORD PTR [eax+212], 0
  00011	74 23		 je	 SHORT $LN2@OnConnectF

; 683  : 		PyCallClassMemberFunc(m_poHandler, "OnConnectFailure", Py_BuildValue("()"));

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0001e	59		 pop	 ecx
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JEKGEMCL@OnConnectFailure@
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	ff b0 d4 00 00
	00		 push	 DWORD PTR [eax+212]
  0002e	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@OnConnectF:

; 684  : 
; 685  : 	__OfflineState_Set();

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 686  : }

  0003e	c9		 leave
  0003f	c3		 ret	 0
?OnConnectFailure@CAccountConnector@@MAEXXZ ENDP	; CAccountConnector::OnConnectFailure
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?Process@CAccountConnector@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Process@CAccountConnector@@QAEXXZ PROC			; CAccountConnector::Process, COMDAT
; _this$ = ecx

; 115  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 116  : 	CNetworkStream::Process();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Process@CNetworkStream@@QAEXXZ ; CNetworkStream::Process

; 117  : 
; 118  : 	if (!__StateProcess())

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?__StateProcess@CAccountConnector@@IAE_NXZ ; CAccountConnector::__StateProcess
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 10		 jne	 SHORT $LN1@Process

; 119  : 	{
; 120  : 		__OfflineState_Set();

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 121  : 		Disconnect();

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?Disconnect@CAccountConnector@@QAEXXZ ; CAccountConnector::Disconnect
$LN1@Process:

; 122  : 	}
; 123  : }

  0002e	c9		 leave
  0002f	c3		 ret	 0
?Process@CAccountConnector@@QAEXXZ ENDP			; CAccountConnector::Process
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?Disconnect@CAccountConnector@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?Disconnect@CAccountConnector@@QAEXXZ PROC		; CAccountConnector::Disconnect, COMDAT
; _this$ = ecx

; 62   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 63   : 	CNetworkStream::Disconnect();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?Disconnect@CNetworkStream@@QAEXXZ ; CNetworkStream::Disconnect

; 64   : 	__OfflineState_Set();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 65   : }

  00017	c9		 leave
  00018	c3		 ret	 0
?Disconnect@CAccountConnector@@QAEXXZ ENDP		; CAccountConnector::Disconnect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?Connect@CAccountConnector@@QAE_NPBDH0H@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
_c_szAddr$ = 8						; size = 4
_iPort$ = 12						; size = 4
_c_szAccountAddr$ = 16					; size = 4
_iAccountPort$ = 20					; size = 4
?Connect@CAccountConnector@@QAE_NPBDH0H@Z PROC		; CAccountConnector::Connect, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR _c_szAddr$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00015	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  00018	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001b	ff 75 f4	 push	 DWORD PTR $T1[ebp]
  0001e	ff 75 08	 push	 DWORD PTR _c_szAddr$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 43   : 	m_strAddr = c_szAddr;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 44   : 	m_iPort = iPort;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR _iPort$[ebp]
  00035	89 88 cc 00 00
	00		 mov	 DWORD PTR [eax+204], ecx

; 45   : 
; 46   : 	__OfflineState_Set();

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 47   : 
; 48   : 	// CHINA_CRYPT_KEY
; 49   : 	if (LocaleService_IsYMIR())

  00043	e8 00 00 00 00	 call	 ?LocaleService_IsYMIR@@YA_NXZ ; LocaleService_IsYMIR
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	74 02		 je	 SHORT $LN2@Connect

; 50   : 	{
; 51   : 	}	

  0004f	eb 08		 jmp	 SHORT $LN3@Connect
$LN2@Connect:

; 52   : 	else
; 53   : 	{
; 54   : 		__BuildClientKey_20050304Myevan();		

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?__BuildClientKey_20050304Myevan@CAccountConnector@@IAEXXZ ; CAccountConnector::__BuildClientKey_20050304Myevan
$LN3@Connect:

; 55   : 	}
; 56   : 	// END_OF_CHINA_CRYPT_KEY
; 57   : 
; 58   : 	return CNetworkStream::Connect(c_szAccountAddr, iAccountPort);

  00059	6a 03		 push	 3
  0005b	ff 75 14	 push	 DWORD PTR _iAccountPort$[ebp]
  0005e	ff 75 10	 push	 DWORD PTR _c_szAccountAddr$[ebp]
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?Connect@CNetworkStream@@QAE_NPBDHH@Z ; CNetworkStream::Connect

; 59   : }

  00069	c9		 leave
  0006a	c2 10 00	 ret	 16			; 00000010H
?Connect@CAccountConnector@@QAE_NPBDH0H@Z ENDP		; CAccountConnector::Connect
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?SendNEWCIBNPasspodAnswerPacket@CAccountConnector@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_answerPacket$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_answer$ = 8						; size = 4
?SendNEWCIBNPasspodAnswerPacket@CAccountConnector@@QAE_NPBD@Z PROC ; CAccountConnector::SendNEWCIBNPasspodAnswerPacket, COMDAT
; _this$ = ecx

; 68   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 69   : 	TPacketCGNEWCIBNPasspodAnswer answerPacket;
; 70   : 	answerPacket.bHeader = HEADER_CG_NEWCIBN_PASSPOD_ANSWER;

  00013	c6 45 f0 ca	 mov	 BYTE PTR _answerPacket$[ebp], 202 ; 000000caH

; 71   : 	strncpy(answerPacket.szAnswer, answer, NEWCIBN_PASSPOD_ANSWER_MAX_LEN);

  00017	6a 08		 push	 8
  00019	ff 75 08	 push	 DWORD PTR _answer$[ebp]
  0001c	8d 45 f1	 lea	 eax, DWORD PTR _answerPacket$[ebp+1]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _strncpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 72   : 	answerPacket.szAnswer[NEWCIBN_PASSPOD_ANSWER_MAX_LEN] = '\0';	

  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	c6 44 05 f1 00	 mov	 BYTE PTR _answerPacket$[ebp+eax+1], 0

; 73   : 	if (!Send(sizeof(answerPacket), &answerPacket))

  00033	8d 45 f0	 lea	 eax, DWORD PTR _answerPacket$[ebp]
  00036	50		 push	 eax
  00037	6a 0a		 push	 10			; 0000000aH
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	75 0f		 jne	 SHORT $LN2@SendNEWCIB

; 74   : 	{
; 75   : 		TraceError("SendNEWCIBNPasspodAnswerPacket");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@
  0004d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00052	59		 pop	 ecx

; 76   : 		return false;

  00053	32 c0		 xor	 al, al
  00055	eb 08		 jmp	 SHORT $LN1@SendNEWCIB
$LN2@SendNEWCIB:

; 77   : 	}
; 78   : 	return SendSequence();

  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
$LN1@SendNEWCIB:

; 79   : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
?SendNEWCIBNPasspodAnswerPacket@CAccountConnector@@QAE_NPBD@Z ENDP ; CAccountConnector::SendNEWCIBNPasspodAnswerPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?SendRunupMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_answerPacket$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_c_szMatrixCardString$ = 8				; size = 4
?SendRunupMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z PROC ; CAccountConnector::SendRunupMatrixCardPacket, COMDAT
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 83   : 	TPacketCGRunupMatrixAnswer answerPacket;
; 84   : 	answerPacket.bHeader = HEADER_CG_RUNUP_MATRIX_ANSWER;

  00013	c6 45 f4 c9	 mov	 BYTE PTR _answerPacket$[ebp], 201 ; 000000c9H

; 85   : 	strncpy(answerPacket.szAnswer, c_szMatrixCardString, RUNUP_MATRIX_ANSWER_MAX_LEN);

  00017	6a 04		 push	 4
  00019	ff 75 08	 push	 DWORD PTR _c_szMatrixCardString$[ebp]
  0001c	8d 45 f5	 lea	 eax, DWORD PTR _answerPacket$[ebp+1]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _strncpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 86   : 	answerPacket.szAnswer[RUNUP_MATRIX_ANSWER_MAX_LEN] = '\0';

  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	c6 44 05 f5 00	 mov	 BYTE PTR _answerPacket$[ebp+eax+1], 0

; 87   : 	if (!Send(sizeof(answerPacket), &answerPacket))

  00033	8d 45 f4	 lea	 eax, DWORD PTR _answerPacket$[ebp]
  00036	50		 push	 eax
  00037	6a 06		 push	 6
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	75 0f		 jne	 SHORT $LN2@SendRunupM

; 88   : 	{
; 89   : 		TraceError("SendRunupMatrixCardPacketError");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@
  0004d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00052	59		 pop	 ecx

; 90   : 		return false;

  00053	32 c0		 xor	 al, al
  00055	eb 08		 jmp	 SHORT $LN1@SendRunupM
$LN2@SendRunupM:

; 91   : 	}
; 92   : 	return SendSequence();

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
$LN1@SendRunupM:

; 93   : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
?SendRunupMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z ENDP ; CAccountConnector::SendRunupMatrixCardPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?SendChinaMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_MatrixCardPacket$ = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
_c_szMatrixCardString$ = 8				; size = 4
?SendChinaMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z PROC ; CAccountConnector::SendChinaMatrixCardPacket, COMDAT
; _this$ = ecx

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 97   : 	TPacketCGChinaMatrixCard MatrixCardPacket;
; 98   : 	MatrixCardPacket.bHeader = HEADER_CG_CHINA_MATRIX_CARD;

  00013	c6 45 f0 6c	 mov	 BYTE PTR _MatrixCardPacket$[ebp], 108 ; 0000006cH

; 99   : 	strncpy(MatrixCardPacket.szAnswer, c_szMatrixCardString, CHINA_MATRIX_ANSWER_MAX_LEN);

  00017	6a 08		 push	 8
  00019	ff 75 08	 push	 DWORD PTR _c_szMatrixCardString$[ebp]
  0001c	8d 45 f1	 lea	 eax, DWORD PTR _MatrixCardPacket$[ebp+1]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _strncpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  : 	MatrixCardPacket.szAnswer[CHINA_MATRIX_ANSWER_MAX_LEN] = '\0';

  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	c6 44 05 f1 00	 mov	 BYTE PTR _MatrixCardPacket$[ebp+eax+1], 0

; 101  : 
; 102  : 	if (!Send(sizeof(MatrixCardPacket), &MatrixCardPacket))

  00033	8d 45 f0	 lea	 eax, DWORD PTR _MatrixCardPacket$[ebp]
  00036	50		 push	 eax
  00037	6a 0a		 push	 10			; 0000000aH
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	75 0f		 jne	 SHORT $LN4@SendChinaM

; 103  : 	{
; 104  : 		Tracen("SendLogin Error");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
  0004d	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00052	59		 pop	 ecx

; 105  : 		return false;

  00053	32 c0		 xor	 al, al
  00055	eb 20		 jmp	 SHORT $LN1@SendChinaM
$LN4@SendChinaM:

; 106  : 	}
; 107  : 
; 108  : 	CPythonNetworkStream::Instance().SetWaitFlag();

  00057	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?ms_singleton@?$CSingleton@VCPythonNetworkStream@@@@0PAVCPythonNetworkStream@@A ; CSingleton<CPythonNetworkStream>::ms_singleton
  0005d	e8 00 00 00 00	 call	 ?SetWaitFlag@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::SetWaitFlag

; 109  : 	m_isWaitKey = TRUE;

  00062	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00065	c7 80 d0 00 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+208], 1

; 110  : 
; 111  : 	return SendSequence();

  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
$LN1@SendChinaM:

; 112  : }

  00077	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007a	33 cd		 xor	 ecx, ebp
  0007c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00081	c9		 leave
  00082	c2 04 00	 ret	 4
?SendChinaMatrixCardPacket@CAccountConnector@@QAE_NPBD@Z ENDP ; CAccountConnector::SendChinaMatrixCardPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?ClearLoginInfo@CAccountConnector@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
?ClearLoginInfo@CAccountConnector@@QAEXXZ PROC		; CAccountConnector::ClearLoginInfo, COMDAT
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  0000e	e8 00 00 00 00	 call	 _strlen
  00013	59		 pop	 ecx
  00014	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00017	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0001a	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001d	ff 75 f8	 push	 DWORD PTR $T1[ebp]
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 34   : 	m_strPassword = "";

  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 35   : }

  00033	c9		 leave
  00034	c3		 ret	 0
?ClearLoginInfo@CAccountConnector@@QAEXXZ ENDP		; CAccountConnector::ClearLoginInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
$T2 = -16						; size = 4
$T3 = -12						; size = 4
$T4 = -8						; size = 4
_this$ = -4						; size = 4
_c_szName$ = 8						; size = 4
_c_szPwd$ = 12						; size = 4
?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z PROC	; CAccountConnector::SetLoginInfo, COMDAT
; _this$ = ecx

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR _c_szName$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 f8	 mov	 DWORD PTR $T4[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  00015	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  00018	89 45 f4	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001b	ff 75 f4	 push	 DWORD PTR $T3[ebp]
  0001e	ff 75 08	 push	 DWORD PTR _c_szName$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 27   : 	m_strID = c_szName;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0002a	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0002f	ff 75 0c	 push	 DWORD PTR _c_szPwd$[ebp]
  00032	e8 00 00 00 00	 call	 _strlen
  00037	59		 pop	 ecx
  00038	89 45 f0	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T2[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00041	ff 75 ec	 push	 DWORD PTR $T1[ebp]
  00044	ff 75 0c	 push	 DWORD PTR _c_szPwd$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 28   : 	m_strPassword = c_szPwd;

  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00050	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 29   : }

  00055	c9		 leave
  00056	c2 08 00	 ret	 8
?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z ENDP	; CAccountConnector::SetLoginInfo
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ?SetHandler@CAccountConnector@@QAEXPAU_object@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_poHandler$ = 8						; size = 4
?SetHandler@CAccountConnector@@QAEXPAU_object@@@Z PROC	; CAccountConnector::SetHandler, COMDAT
; _this$ = ecx

; 21   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 22   : 	m_poHandler = poHandler;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR _poHandler$[ebp]
  0000d	89 88 d4 00 00
	00		 mov	 DWORD PTR [eax+212], ecx

; 23   : }

  00013	c9		 leave
  00014	c2 04 00	 ret	 4
?SetHandler@CAccountConnector@@QAEXPAU_object@@@Z ENDP	; CAccountConnector::SetHandler
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ??1CAccountConnector@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CAccountConnector@@UAE@XZ PROC			; CAccountConnector::~CAccountConnector, COMDAT
; _this$ = ecx

; 743  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1CAccountConnector@@UAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAccountConnector@@6BCNetworkStream@@@
  0002f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00032	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], OFFSET ??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@

; 744  : 	__OfflineState_Set();

  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?__OfflineState_Set@CAccountConnector@@IAEXXZ ; CAccountConnector::__OfflineState_Set

; 745  : }

  00041	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  0004a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 745  : }

  0004f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00058	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 745  : }

  0005d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2801 :         _Tidy_deallocate();

  00066	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 19   : 	{ 

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], OFFSET ??_7?$CSingleton@VCAccountConnector@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00075	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, 0 ; CSingleton<CAccountConnector>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 745  : }

  0007c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
  00084	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008e	59		 pop	 ecx
  0008f	c9		 leave
  00090	c3		 ret	 0
  00091	cc		 int	 3
  00092	cc		 int	 3
  00093	cc		 int	 3
  00094	cc		 int	 3
  00095	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1CAccountConnector@@UAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1CAccountConnector@@UAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1CAccountConnector@@UAE@XZ ENDP			; CAccountConnector::~CAccountConnector
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp
;	COMDAT ??0CAccountConnector@@QAE@XZ
_TEXT	SEGMENT
$T2 = -36						; size = 4
$T3 = -32						; size = 4
_offset$4 = -28						; size = 4
_this$ = -24						; size = 4
tv178 = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0CAccountConnector@@QAE@XZ PROC			; CAccountConnector::CAccountConnector, COMDAT
; _this$ = ecx

; 731  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0CAccountConnector@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0CNetworkStream@@QAE@XZ ; CNetworkStream::CNetworkStream
  00030	83 65 fc 00	 and	 DWORD PTR __$EHRec$[ebp+8], 0
  00034	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00037	83 c0 7c	 add	 eax, 124		; 0000007cH
  0003a	89 45 e8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h

; 12   : 	{ 

  0003d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCAccountConnector@@@@6B@

; 13   : 		assert(!ms_singleton);
; 14   : 		int offset = (int) (T*) 1 - (int) (CSingleton <T>*) (T*) 1; 

  00046	33 c0		 xor	 eax, eax
  00048	40		 inc	 eax
  00049	74 0a		 je	 SHORT $LN10@CAccountCo
  0004b	33 c0		 xor	 eax, eax
  0004d	83 c0 7d	 add	 eax, 125		; 0000007dH
  00050	89 45 ec	 mov	 DWORD PTR tv178[ebp], eax
  00053	eb 04		 jmp	 SHORT $LN11@CAccountCo
$LN10@CAccountCo:
  00055	83 65 ec 00	 and	 DWORD PTR tv178[ebp], 0
$LN11@CAccountCo:
  00059	33 c0		 xor	 eax, eax
  0005b	40		 inc	 eax
  0005c	2b 45 ec	 sub	 eax, DWORD PTR tv178[ebp]
  0005f	89 45 e4	 mov	 DWORD PTR _offset$4[ebp], eax

; 15   : 		ms_singleton = (T*) ((int) this + offset);

  00062	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	03 45 e4	 add	 eax, DWORD PTR _offset$4[ebp]
  00068	a3 00 00 00 00	 mov	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, eax ; CSingleton<CAccountConnector>::ms_singleton
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 731  : {

  0006d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00071	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7CAccountConnector@@6BCNetworkStream@@@
  0007a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0007d	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [eax+124], OFFSET ??_7CAccountConnector@@6B?$CSingleton@VCAccountConnector@@@@@
  00084	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0008d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00092	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  0009f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000a4	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000a8	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  000b1	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000b6	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4

; 732  : 	m_poHandler = NULL;

  000ba	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	83 a0 d4 00 00
	00 00		 and	 DWORD PTR [eax+212], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000c9	e8 00 00 00 00	 call	 _strlen
  000ce	59		 pop	 ecx
  000cf	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000d2	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  000d5	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000d8	ff 75 dc	 push	 DWORD PTR $T2[ebp]
  000db	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 733  : 	m_strAddr = "";

  000e0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000e9	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\AccountConnector.cpp

; 734  : 	m_iPort = 0;

  000ee	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	83 a0 cc 00 00
	00 00		 and	 DWORD PTR [eax+204], 0

; 735  : 
; 736  : 	SetLoginInfo("", "");

  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  000fd	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00102	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?SetLoginInfo@CAccountConnector@@QAEXPBD0@Z ; CAccountConnector::SetLoginInfo

; 737  : 	SetRecvBufferSize(1024 * 128);

  0010a	68 00 00 02 00	 push	 131072			; 00020000H
  0010f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	e8 00 00 00 00	 call	 ?SetRecvBufferSize@CNetworkStream@@QAEXH@Z ; CNetworkStream::SetRecvBufferSize

; 738  : 	SetSendBufferSize(2048);

  00117	68 00 08 00 00	 push	 2048			; 00000800H
  0011c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	e8 00 00 00 00	 call	 ?SetSendBufferSize@CNetworkStream@@QAEXH@Z ; CNetworkStream::SetSendBufferSize

; 739  : 	__Inialize();

  00124	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00127	e8 00 00 00 00	 call	 ?__Inialize@CAccountConnector@@IAEXXZ ; CAccountConnector::__Inialize

; 740  : }

  0012c	83 4d fc ff	 or	 DWORD PTR __$EHRec$[ebp+8], -1
  00130	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00133	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00136	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0013d	59		 pop	 ecx
  0013e	c9		 leave
  0013f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0CAccountConnector@@QAE@XZ$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CNetworkStream@@UAE@XZ ; CNetworkStream::~CNetworkStream
__unwindfunclet$??0CAccountConnector@@QAE@XZ$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 7c	 add	 ecx, 124		; 0000007cH
  0000e	e9 00 00 00 00	 jmp	 ??1?$CSingleton@VCAccountConnector@@@@UAE@XZ ; CSingleton<CAccountConnector>::~CSingleton<CAccountConnector>
__unwindfunclet$??0CAccountConnector@@QAE@XZ$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	81 c1 84 00 00
	00		 add	 ecx, 132		; 00000084H
  0001c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CAccountConnector@@QAE@XZ$3:
  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	81 c1 9c 00 00
	00		 add	 ecx, 156		; 0000009cH
  0002a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0CAccountConnector@@QAE@XZ$4:
  0002f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	81 c1 b4 00 00
	00		 add	 ecx, 180		; 000000b4H
  00038	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003d	cc		 int	 3
  0003e	cc		 int	 3
  0003f	cc		 int	 3
  00040	cc		 int	 3
  00041	cc		 int	 3
__ehhandler$??0CAccountConnector@@QAE@XZ:
  00042	90		 npad	 1
  00043	90		 npad	 1
  00044	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00048	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0004b	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0004e	33 c8		 xor	 ecx, eax
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0CAccountConnector@@QAE@XZ
  0005a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0CAccountConnector@@QAE@XZ ENDP			; CAccountConnector::CAccountConnector
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??_G?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z PROC	; CSingleton<CAccountConnector>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 19   : 	{ 

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCAccountConnector@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, 0 ; CSingleton<CAccountConnector>::ms_singleton
  00017	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	74 0c		 je	 SHORT $LN2@scalar
  0001f	6a 04		 push	 4
  00021	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx
$LN2@scalar:
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c2 04 00	 ret	 4
??_G?$CSingleton@VCAccountConnector@@@@UAEPAXI@Z ENDP	; CSingleton<CAccountConnector>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterBase\Singleton.h
;	COMDAT ??1?$CSingleton@VCAccountConnector@@@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$CSingleton@VCAccountConnector@@@@UAE@XZ PROC	; CSingleton<CAccountConnector>::~CSingleton<CAccountConnector>, COMDAT
; _this$ = ecx

; 19   : 	{ 

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$CSingleton@VCAccountConnector@@@@6B@

; 20   : 		assert(ms_singleton);
; 21   : 		ms_singleton = 0; 

  00010	83 25 00 00 00
	00 00		 and	 DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A, 0 ; CSingleton<CAccountConnector>::ms_singleton

; 22   : 	}

  00017	c9		 leave
  00018	c3		 ret	 0
??1?$CSingleton@VCAccountConnector@@@@UAE@XZ ENDP	; CSingleton<CAccountConnector>::~CSingleton<CAccountConnector>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 270  : /* _CONSTEXPR20_DYNALLOC */ void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 271  : #if _HAS_IF_CONSTEXPR
; 272  :     if constexpr (is_array_v<_Ty>) {
; 273  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 274  :     } else
; 275  : #endif // _HAS_IF_CONSTEXPR
; 276  :     {
; 277  :         _Obj.~_Ty();
; 278  :     }
; 279  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -28						; size = 4
__Ptr$2 = -24						; size = 4
__Count$ = -20						; size = 4
$T3 = -16						; size = 4
tv68 = -12						; size = 4
_this$ = -8						; size = 4
$T4 = -2						; size = 1
$T5 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4383 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2227 :         return _BUF_SIZE <= _Myres;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00010	72 09		 jb	 SHORT $LN9@Tidy_deall
  00012	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN10@Tidy_deall
$LN9@Tidy_deall:
  0001b	83 65 f4 00	 and	 DWORD PTR tv68[ebp], 0
$LN10@Tidy_deall:
  0001f	8a 45 f4	 mov	 al, BYTE PTR tv68[ebp]
  00022	88 45 ff	 mov	 BYTE PTR $T5[ebp], al

; 4384 :         _Mypair._Myval2._Orphan_all();
; 4385 :         if (_Mypair._Myval2._Large_string_engaged()) {

  00025	0f b6 45 ff	 movzx	 eax, BYTE PTR $T5[ebp]
  00029	85 c0		 test	 eax, eax
  0002b	74 34		 je	 SHORT $LN2@Tidy_deall

; 4386 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 00		 mov	 eax, DWORD PTR [eax]
  00032	89 45 e8	 mov	 DWORD PTR __Ptr$2[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00038	89 45 f0	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  0003b	8b 45 f0	 mov	 eax, DWORD PTR $T3[ebp]
  0003e	89 45 e4	 mov	 DWORD PTR __Al$1[ebp], eax

; 4387 :             auto& _Al          = _Getal();
; 4388 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  00041	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  00044	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00049	59		 pop	 ecx

; 4389 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0004a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004d	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00050	40		 inc	 eax
  00051	89 45 ec	 mov	 DWORD PTR __Count$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00054	ff 75 ec	 push	 DWORD PTR __Count$[ebp]
  00057	ff 75 e8	 push	 DWORD PTR __Ptr$2[ebp]
  0005a	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0005f	59		 pop	 ecx
  00060	59		 pop	 ecx
$LN2@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4392 :         _Mypair._Myval2._Mysize = 0;

  00061	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00064	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4393 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4394 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4395 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T4[ebp], 0
  00076	33 c0		 xor	 eax, eax
  00078	40		 inc	 eax
  00079	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  0007c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	8a 55 fe	 mov	 dl, BYTE PTR $T4[ebp]
  00082	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4396 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4376 :     void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4377 :         _Mypair._Myval2._Mysize = 0;

  00008	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 60 10 00	 and	 DWORD PTR [eax+16], 0

; 4378 :         _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 14 0f 00
	00 00		 mov	 DWORD PTR [eax+20], 15	; 0000000fH

; 4379 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4380 :         _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  00019	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0001d	33 c0		 xor	 eax, eax
  0001f	40		 inc	 eax
  00020	6b c0 00	 imul	 eax, eax, 0

; 428  :         _Left = _Right;

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8a 55 ff	 mov	 dl, BYTE PTR $T1[ebp]
  00029	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 4381 :     }

  0002c	c9		 leave
  0002d	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2800 :     ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2801 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 2802 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2803 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2804 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 2805 :         _Mypair._Myval2._Myproxy = nullptr;
; 2806 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 2807 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2808 :     }

  0000f	c9		 leave
  00010	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2365 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1339 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  0000f	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2198 :     _String_val() noexcept : _Bx(), _Mysize(0), _Myres(0) {}

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 60 10 00	 and	 DWORD PTR [eax+16], 0
  0001c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	83 60 14 00	 and	 DWORD PTR [eax+20], 0

; 2366 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2367 :         _Tidy_init();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2368 :     }

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c9		 leave
  0002f	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2217 :     const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2218 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2224 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
