; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29335.0 

	TITLE	D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?SetLoginPhase@CPythonNetworkStream@@QAEXXZ	; CPythonNetworkStream::SetLoginPhase
PUBLIC	?SendLoginPacket@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendLoginPacket
PUBLIC	?SendLoginPacketNew@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendLoginPacketNew
PUBLIC	?SendChinaMatrixCardPacket@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::SendChinaMatrixCardPacket
PUBLIC	?SendRunupMatrixAnswerPacket@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::SendRunupMatrixAnswerPacket
PUBLIC	?SendNEWCIBNPasspodAnswerPacket@CPythonNetworkStream@@QAE_NPBD@Z ; CPythonNetworkStream::SendNEWCIBNPasspodAnswerPacket
PUBLIC	?SendDirectEnterPacket@CPythonNetworkStream@@QAE_NPBD0I@Z ; CPythonNetworkStream::SendDirectEnterPacket
PUBLIC	?LoginPhase@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::LoginPhase
PUBLIC	?__RecvLoginSuccessPacket3@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvLoginSuccessPacket3
PUBLIC	?__RecvLoginSuccessPacket4@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvLoginSuccessPacket4
PUBLIC	?__RecvLoginFailurePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvLoginFailurePacket
PUBLIC	?__RecvEmpirePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvEmpirePacket
PUBLIC	?__RecvChinaMatrixCardPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvChinaMatrixCardPacket
PUBLIC	?__RecvRunupMatrixQuizPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvRunupMatrixQuizPacket
PUBLIC	?__RecvNEWCIBNPasspodRequestPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvNEWCIBNPasspodRequestPacket
PUBLIC	?__RecvNEWCIBNPasspodFailurePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvNEWCIBNPasspodFailurePacket
PUBLIC	?__RecvLoginKeyPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvLoginKeyPacket
PUBLIC	?OnConnectFailure@CPythonNetworkStream@@MAEXXZ	; CPythonNetworkStream::OnConnectFailure
PUBLIC	?__LeaveLoginPhase@CPythonNetworkStream@@IAEXXZ	; CPythonNetworkStream::__LeaveLoginPhase
PUBLIC	?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ ; CFuncObject<CPythonNetworkStream>::Run
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A ; CSingleton<CAccountConnector>::ms_singleton
PUBLIC	??_C@_05DHEMANOL@Login@				; `string'
PUBLIC	??_C@_0BM@GIOJNFMI@?$CD?$CD?5Network?5?9?5Login?5Phase?5?$CD?$CD@ ; `string'
PUBLIC	??_C@_02HCKGKOFO@?$CI?$CJ@			; `string'
PUBLIC	??_C@_0N@GCHAFKJJ@OnLoginStart@			; `string'
PUBLIC	??_C@_07POIENIBA@Refresh@			; `string'
PUBLIC	??_C@_0BB@JEKGEMCL@OnConnectFailure@		; `string'
PUBLIC	??_C@_03KJMMOONA@?$CIs?$CJ@			; `string'
PUBLIC	??_C@_0P@OOEAIINI@OnLoginFailure@		; `string'
PUBLIC	??_C@_0BA@HOEIMIKO@SendDirectEnter@		; `string'
PUBLIC	??_C@_0BA@HGDBLFFH@SendLogin?5Error@		; `string'
PUBLIC	??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@	; `string'
PUBLIC	??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@ ; `string'
PUBLIC	??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@ ; `string'
PUBLIC	??_C@_0BP@LPFBEHCD@BINARY_OnNEWCIBNPasspodFailure@ ; `string'
PUBLIC	??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@ ; `string'
PUBLIC	??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@		; `string'
PUBLIC	??_C@_0N@PIKEFLJP@OnMatrixCard@			; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_strlen:PROC
EXTRN	_strncpy:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?Tracen@@YAXPBD@Z:PROC				; Tracen
EXTRN	?TraceError@@YAXPBDZZ:PROC			; TraceError
EXTRN	__imp__Py_BuildValue:PROC
EXTRN	?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z:PROC ; PyCallClassMemberFunc
EXTRN	?ELTimer_GetMSec@@YAKXZ:PROC			; ELTimer_GetMSec
EXTRN	?LocaleService_GetSecurityKey@@YAPBDXZ:PROC	; LocaleService_GetSecurityKey
EXTRN	?Recv@CNetworkStream@@QAE_NHPAX@Z:PROC		; CNetworkStream::Recv
EXTRN	?Send@CNetworkStream@@QAE_NHPBX@Z:PROC		; CNetworkStream::Send
EXTRN	?SendSequence@CNetworkStream@@QAE_NXZ:PROC	; CNetworkStream::SendSequence
EXTRN	?__SendInternalBuffer@CNetworkStream@@IAE_NXZ:PROC ; CNetworkStream::__SendInternalBuffer
EXTRN	?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ:PROC ; CPythonNetworkStream::ClearLoginInfo
EXTRN	?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ:PROC ; CPythonNetworkStream::RecvHybridCryptKeyPacket
EXTRN	?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ:PROC ; CPythonNetworkStream::RecvHybridCryptSDBPacket
EXTRN	?ClosePhase@CPythonNetworkStream@@QAEXXZ:PROC	; CPythonNetworkStream::ClosePhase
EXTRN	?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z:PROC ; CPythonNetworkStream::RecvErrorPacket
EXTRN	?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ:PROC ; CPythonNetworkStream::RecvPingPacket
EXTRN	?RecvDefaultPacket@CPythonNetworkStream@@IAE_NH@Z:PROC ; CPythonNetworkStream::RecvDefaultPacket
EXTRN	?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ:PROC ; CPythonNetworkStream::RecvPhasePacket
EXTRN	?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z:PROC ; CPythonNetworkStream::CheckPacket
EXTRN	?__ClearSelectCharacterData@CPythonNetworkStream@@IAEXXZ:PROC ; CPythonNetworkStream::__ClearSelectCharacterData
EXTRN	?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ:PROC ; CPythonNetworkStream::__DirectEnterMode_IsSet
EXTRN	?ClearLoginInfo@CAccountConnector@@QAEXXZ:PROC	; CAccountConnector::ClearLoginInfo
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?g_adwEncryptKey@@3PAKA:BYTE			; g_adwEncryptKey
EXTRN	___security_cookie:DWORD
;	COMDAT ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A
_BSS	SEGMENT
?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A DD 01H DUP (?) ; CSingleton<CAccountConnector>::ms_singleton
_BSS	ENDS
;	COMDAT ??_C@_0N@PIKEFLJP@OnMatrixCard@
CONST	SEGMENT
??_C@_0N@PIKEFLJP@OnMatrixCard@ DB 'OnMatrixCard', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@
CONST	SEGMENT
??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@ DB '(iiiiiiii)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@
CONST	SEGMENT
??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@ DB 'SendNEWCIBNPasspod'
	DB	'AnswerPacket', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LPFBEHCD@BINARY_OnNEWCIBNPasspodFailure@
CONST	SEGMENT
??_C@_0BP@LPFBEHCD@BINARY_OnNEWCIBNPasspodFailure@ DB 'BINARY_OnNEWCIBNPa'
	DB	'sspodFailure', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@
CONST	SEGMENT
??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@ DB 'BINARY_OnNEWCIBNPa'
	DB	'sspodRequest', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@
CONST	SEGMENT
??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@ DB 'SendRunupMatrixCar'
	DB	'dPacketError', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@
CONST	SEGMENT
??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@ DB 'BINARY_OnRunupMatrixQuiz'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
CONST	SEGMENT
??_C@_0BA@HGDBLFFH@SendLogin?5Error@ DB 'SendLogin Error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HOEIMIKO@SendDirectEnter@
CONST	SEGMENT
??_C@_0BA@HOEIMIKO@SendDirectEnter@ DB 'SendDirectEnter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@OOEAIINI@OnLoginFailure@
CONST	SEGMENT
??_C@_0P@OOEAIINI@OnLoginFailure@ DB 'OnLoginFailure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03KJMMOONA@?$CIs?$CJ@
CONST	SEGMENT
??_C@_03KJMMOONA@?$CIs?$CJ@ DB '(s)', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JEKGEMCL@OnConnectFailure@
CONST	SEGMENT
??_C@_0BB@JEKGEMCL@OnConnectFailure@ DB 'OnConnectFailure', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07POIENIBA@Refresh@
CONST	SEGMENT
??_C@_07POIENIBA@Refresh@ DB 'Refresh', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GCHAFKJJ@OnLoginStart@
CONST	SEGMENT
??_C@_0N@GCHAFKJJ@OnLoginStart@ DB 'OnLoginStart', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02HCKGKOFO@?$CI?$CJ@
CONST	SEGMENT
??_C@_02HCKGKOFO@?$CI?$CJ@ DB '()', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GIOJNFMI@?$CD?$CD?5Network?5?9?5Login?5Phase?5?$CD?$CD@
CONST	SEGMENT
??_C@_0BM@GIOJNFMI@?$CD?$CD?5Network?5?9?5Login?5Phase?5?$CD?$CD@ DB '## '
	DB	'Network - Login Phase ##', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DHEMANOL@Login@
CONST	SEGMENT
??_C@_05DHEMANOL@Login@ DB 'Login', 00H			; `string'
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4559 : _NODISCARD bool operator==(_In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4560 :     return _Right._Equal(_Left);

  00003	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	e8 00 00 00 00	 call	 ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal

; 4561 : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 4575 : _NODISCARD bool operator!=(_In_z_ const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4576 :     return !(_Left == _Right);

  00004	ff 75 0c	 push	 DWORD PTR __Right$[ebp]
  00007	ff 75 08	 push	 DWORD PTR __Left$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
  0000f	59		 pop	 ecx
  00010	59		 pop	 ecx
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	75 09		 jne	 SHORT $LN3@operator
  00018	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00021	83 65 fc 00	 and	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00025	8a 45 fc	 mov	 al, BYTE PTR tv69[ebp]

; 4577 : }

  00028	c9		 leave
  00029	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\FuncObject.h
;	COMDAT ?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 8
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ PROC	; CFuncObject<CPythonNetworkStream>::Run, COMDAT
; _this$ = ecx

; 40   : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   : 			if (m_pSelfObject)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 4c		 je	 SHORT $LN1@Run

; 42   : 				if (m_pFuncObject)

  00012	83 65 f0 00	 and	 DWORD PTR $T1[ebp], 0
  00016	83 65 f4 00	 and	 DWORD PTR $T1[ebp+4], 0
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00020	3b 45 f0	 cmp	 eax, DWORD PTR $T1[ebp]
  00023	75 1a		 jne	 SHORT $LN6@Run
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0002c	74 0b		 je	 SHORT $LN5@Run
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00034	3b 45 f4	 cmp	 eax, DWORD PTR $T1[ebp+4]
  00037	75 06		 jne	 SHORT $LN6@Run
$LN5@Run:
  00039	83 65 f8 00	 and	 DWORD PTR tv75[ebp], 0
  0003d	eb 07		 jmp	 SHORT $LN7@Run
$LN6@Run:
  0003f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv75[ebp], 1
$LN7@Run:
  00046	83 7d f8 00	 cmp	 DWORD PTR tv75[ebp], 0
  0004a	74 12		 je	 SHORT $LN1@Run

; 43   : 					(m_pSelfObject->*m_pFuncObject)();

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00052	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00055	03 48 14	 add	 ecx, DWORD PTR [eax+20]
  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	ff 50 10	 call	 DWORD PTR [eax+16]
$LN1@Run:

; 44   : 		}

  0005e	c9		 leave
  0005f	c3		 ret	 0
?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ ENDP	; CFuncObject<CPythonNetworkStream>::Run
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStream.h
;	COMDAT ?__LeaveLoginPhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?__LeaveLoginPhase@CPythonNetworkStream@@IAEXXZ PROC	; CPythonNetworkStream::__LeaveLoginPhase, COMDAT
; _this$ = ecx

; 591  : 		void __LeaveLoginPhase() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	c9		 leave
  00008	c3		 ret	 0
?__LeaveLoginPhase@CPythonNetworkStream@@IAEXXZ ENDP	; CPythonNetworkStream::__LeaveLoginPhase
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?OnConnectFailure@CPythonNetworkStream@@MAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?OnConnectFailure@CPythonNetworkStream@@MAEXXZ PROC	; CPythonNetworkStream::OnConnectFailure, COMDAT
; _this$ = ecx

; 212  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 213  : 	if (__DirectEnterMode_IsSet())

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ ; CPythonNetworkStream::__DirectEnterMode_IsSet
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	74 0a		 je	 SHORT $LN2@OnConnectF

; 214  : 	{
; 215  : 		ClosePhase();

  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ?ClosePhase@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::ClosePhase

; 216  : 	}

  0001e	eb 2a		 jmp	 SHORT $LN1@OnConnectF
$LN2@OnConnectF:

; 217  : 	else
; 218  : 	{
; 219  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOGIN], "OnConnectFailure", Py_BuildValue("()"));	

  00020	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002b	59		 pop	 ecx
  0002c	50		 push	 eax
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@JEKGEMCL@OnConnectFailure@
  00032	6a 04		 push	 4
  00034	58		 pop	 eax
  00035	c1 e0 00	 shl	 eax, 0
  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  00042	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@OnConnectF:

; 220  : 	}
; 221  : }

  0004a	c9		 leave
  0004b	c3		 ret	 0
?OnConnectFailure@CPythonNetworkStream@@MAEXXZ ENDP	; CPythonNetworkStream::OnConnectFailure
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvLoginKeyPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_kLoginKeyPacket$ = -12					; size = 5
_this$ = -4						; size = 4
?__RecvLoginKeyPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::__RecvLoginKeyPacket, COMDAT
; _this$ = ecx

; 407  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 408  : 	TPacketGCLoginKey kLoginKeyPacket;
; 409  : 	if (!Recv(sizeof(TPacketGCLoginKey), &kLoginKeyPacket))

  00009	8d 45 f4	 lea	 eax, DWORD PTR _kLoginKeyPacket$[ebp]
  0000c	50		 push	 eax
  0000d	6a 05		 push	 5
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $LN2@RecvLoginK

; 410  : 		return false;

  0001e	32 c0		 xor	 al, al
  00020	eb 18		 jmp	 SHORT $LN1@RecvLoginK
$LN2@RecvLoginK:

; 411  : 
; 412  : 	m_dwLoginKey = kLoginKeyPacket.dwLoginKey;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d f5	 mov	 ecx, DWORD PTR _kLoginKeyPacket$[ebp+1]
  00028	89 88 24 01 00
	00		 mov	 DWORD PTR [eax+292], ecx

; 413  : 	m_isWaitLoginKey = FALSE;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 a0 28 01 00
	00 00		 and	 DWORD PTR [eax+296], 0

; 414  : 
; 415  : 	return true;

  00038	b0 01		 mov	 al, 1
$LN1@RecvLoginK:

; 416  : }

  0003a	c9		 leave
  0003b	c3		 ret	 0
?__RecvLoginKeyPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::__RecvLoginKeyPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvNEWCIBNPasspodFailurePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kFailurePacket$ = -16					; size = 130
__$ArrayPad$ = 116					; size = 4
?__RecvNEWCIBNPasspodFailurePacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::__RecvNEWCIBNPasspodFailurePacket, COMDAT
; _this$ = ecx

; 343  : {

  00000	55		 push	 ebp
  00001	8d 6c 24 88	 lea	 ebp, DWORD PTR [esp-120]
  00005	81 ec 8c 00 00
	00		 sub	 esp, 140		; 0000008cH
  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00010	33 c5		 xor	 eax, ebp
  00012	89 45 74	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00015	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 344  : 	TPacketGCNEWCIBNPasspodFailure kFailurePacket;
; 345  : 	if (!Recv(sizeof(kFailurePacket), &kFailurePacket))

  00018	8d 45 f0	 lea	 eax, DWORD PTR _kFailurePacket$[ebp]
  0001b	50		 push	 eax
  0001c	68 82 00 00 00	 push	 130			; 00000082H
  00021	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00029	0f b6 c0	 movzx	 eax, al
  0002c	85 c0		 test	 eax, eax
  0002e	75 04		 jne	 SHORT $LN2@RecvNEWCIB

; 346  : 		return false;

  00030	32 c0		 xor	 al, al
  00032	eb 2c		 jmp	 SHORT $LN1@RecvNEWCIB
$LN2@RecvNEWCIB:

; 347  : 
; 348  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOGIN], "BINARY_OnNEWCIBNPasspodFailure", Py_BuildValue("()"));	

  00034	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0003f	59		 pop	 ecx
  00040	50		 push	 eax
  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LPFBEHCD@BINARY_OnNEWCIBNPasspodFailure@
  00046	6a 04		 push	 4
  00048	58		 pop	 eax
  00049	c1 e0 00	 shl	 eax, 0
  0004c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  00056	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0005b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 349  : 	return true;

  0005e	b0 01		 mov	 al, 1
$LN1@RecvNEWCIB:

; 350  : }

  00060	8b 4d 74	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	83 c5 78	 add	 ebp, 120		; 00000078H
  0006d	c9		 leave
  0006e	c3		 ret	 0
?__RecvNEWCIBNPasspodFailurePacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::__RecvNEWCIBNPasspodFailurePacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvNEWCIBNPasspodRequestPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_kRequestPacket$ = -1					; size = 1
?__RecvNEWCIBNPasspodRequestPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::__RecvNEWCIBNPasspodRequestPacket, COMDAT
; _this$ = ecx

; 333  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 334  : 	TPacketGCNEWCIBNPasspodRequest kRequestPacket;
; 335  : 	if (!Recv(sizeof(kRequestPacket), &kRequestPacket))

  00008	8d 45 ff	 lea	 eax, DWORD PTR _kRequestPacket$[ebp]
  0000b	50		 push	 eax
  0000c	6a 01		 push	 1
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	75 04		 jne	 SHORT $LN2@RecvNEWCIB

; 336  : 		return false;

  0001d	32 c0		 xor	 al, al
  0001f	eb 2c		 jmp	 SHORT $LN1@RecvNEWCIB
$LN2@RecvNEWCIB:

; 337  : 
; 338  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOGIN], "BINARY_OnNEWCIBNPasspodRequest", Py_BuildValue("()"));	

  00021	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0002c	59		 pop	 ecx
  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DDJIDHFM@BINARY_OnNEWCIBNPasspodRequest@
  00033	6a 04		 push	 4
  00035	58		 pop	 eax
  00036	c1 e0 00	 shl	 eax, 0
  00039	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  00043	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  : 	return true;

  0004b	b0 01		 mov	 al, 1
$LN1@RecvNEWCIB:

; 340  : }

  0004d	c9		 leave
  0004e	c3		 ret	 0
?__RecvNEWCIBNPasspodRequestPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::__RecvNEWCIBNPasspodRequestPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvRunupMatrixQuizPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_kMatrixQuizPacket$ = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
?__RecvRunupMatrixQuizPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::__RecvRunupMatrixQuizPacket, COMDAT
; _this$ = ecx

; 309  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 310  : 	TPacketGCRunupMatrixQuiz kMatrixQuizPacket;
; 311  : 	if (!Recv(sizeof(TPacketGCRunupMatrixQuiz), &kMatrixQuizPacket))

  00013	8d 45 f0	 lea	 eax, DWORD PTR _kMatrixQuizPacket$[ebp]
  00016	50		 push	 eax
  00017	6a 0a		 push	 10			; 0000000aH
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@RecvRunupM

; 312  : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	eb 31		 jmp	 SHORT $LN1@RecvRunupM
$LN2@RecvRunupM:

; 313  : 
; 314  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOGIN], "BINARY_OnRunupMatrixQuiz", Py_BuildValue("(s)", kMatrixQuizPacket.szQuiz));	

  0002c	8d 45 f1	 lea	 eax, DWORD PTR _kMatrixQuizPacket$[ebp+1]
  0002f	50		 push	 eax
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@IENIHBKM@BINARY_OnRunupMatrixQuiz@
  00043	6a 04		 push	 4
  00045	58		 pop	 eax
  00046	c1 e0 00	 shl	 eax, 0
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  00053	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : 	return true;

  0005b	b0 01		 mov	 al, 1
$LN1@RecvRunupM:

; 316  : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	33 cd		 xor	 ecx, ebp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	c9		 leave
  00068	c3		 ret	 0
?__RecvRunupMatrixQuizPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::__RecvRunupMatrixQuizPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvChinaMatrixCardPacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_pyValue$ = -24						; size = 4
_this$ = -20						; size = 4
_kMatrixCardPacket$ = -16				; size = 9
__$ArrayPad$ = -4					; size = 4
?__RecvChinaMatrixCardPacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::__RecvChinaMatrixCardPacket, COMDAT
; _this$ = ecx

; 389  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 390  : 	TPacketGCChinaMatrixCard kMatrixCardPacket;
; 391  : 	if (!Recv(sizeof(TPacketGCChinaMatrixCard), &kMatrixCardPacket))

  00013	8d 45 f0	 lea	 eax, DWORD PTR _kMatrixCardPacket$[ebp]
  00016	50		 push	 eax
  00017	6a 09		 push	 9
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 07		 jne	 SHORT $LN2@RecvChinaM

; 392  : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	e9 8d 00 00 00	 jmp	 $LN1@RecvChinaM
$LN2@RecvChinaM:

; 393  : 
; 394  : 	PyObject * pyValue = Py_BuildValue("(iiiiiiii)",	ROW(kMatrixCardPacket.dwRows, 0),

  0002f	8b 45 f5	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+5]
  00032	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00037	50		 push	 eax
  00038	8b 45 f5	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+5]
  0003b	c1 e8 08	 shr	 eax, 8
  0003e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00043	50		 push	 eax
  00044	8b 45 f5	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+5]
  00047	c1 e8 10	 shr	 eax, 16			; 00000010H
  0004a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0004f	50		 push	 eax
  00050	8b 45 f5	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+5]
  00053	c1 e8 18	 shr	 eax, 24			; 00000018H
  00056	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0005b	50		 push	 eax
  0005c	8b 45 f1	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+1]
  0005f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00064	50		 push	 eax
  00065	8b 45 f1	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+1]
  00068	c1 e8 08	 shr	 eax, 8
  0006b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00070	50		 push	 eax
  00071	8b 45 f1	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+1]
  00074	c1 e8 10	 shr	 eax, 16			; 00000010H
  00077	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0007c	50		 push	 eax
  0007d	8b 45 f1	 mov	 eax, DWORD PTR _kMatrixCardPacket$[ebp+1]
  00080	c1 e8 18	 shr	 eax, 24			; 00000018H
  00083	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00088	50		 push	 eax
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_0L@FKCIBGAB@?$CIiiiiiiii?$CJ@
  0008e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  00094	83 c4 24	 add	 esp, 36			; 00000024H
  00097	89 45 e8	 mov	 DWORD PTR _pyValue$[ebp], eax

; 395  : 														ROW(kMatrixCardPacket.dwRows, 1),
; 396  : 														ROW(kMatrixCardPacket.dwRows, 2),
; 397  : 														ROW(kMatrixCardPacket.dwRows, 3),
; 398  : 														COL(kMatrixCardPacket.dwCols, 0),
; 399  : 														COL(kMatrixCardPacket.dwCols, 1),
; 400  : 														COL(kMatrixCardPacket.dwCols, 2),
; 401  : 														COL(kMatrixCardPacket.dwCols, 3));
; 402  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOGIN], "OnMatrixCard", pyValue);

  0009a	ff 75 e8	 push	 DWORD PTR _pyValue$[ebp]
  0009d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@PIKEFLJP@OnMatrixCard@
  000a2	6a 04		 push	 4
  000a4	58		 pop	 eax
  000a5	c1 e0 00	 shl	 eax, 0
  000a8	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ab	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  000b2	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  000b7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 403  : 	return true;

  000ba	b0 01		 mov	 al, 1
$LN1@RecvChinaM:

; 404  : }

  000bc	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000bf	33 cd		 xor	 ecx, ebp
  000c1	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c6	c9		 leave
  000c7	c3		 ret	 0
?__RecvChinaMatrixCardPacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::__RecvChinaMatrixCardPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvEmpirePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_kPacketEmpire$ = -4					; size = 2
?__RecvEmpirePacket@CPythonNetworkStream@@IAE_NXZ PROC	; CPythonNetworkStream::__RecvEmpirePacket, COMDAT
; _this$ = ecx

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 146  : 	TPacketGCEmpire kPacketEmpire;
; 147  : 	if (!Recv(sizeof(kPacketEmpire), &kPacketEmpire))

  00008	8d 45 fc	 lea	 eax, DWORD PTR _kPacketEmpire$[ebp]
  0000b	50		 push	 eax
  0000c	6a 02		 push	 2
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	75 04		 jne	 SHORT $LN2@RecvEmpire

; 148  : 		return false;

  0001d	32 c0		 xor	 al, al
  0001f	eb 0f		 jmp	 SHORT $LN1@RecvEmpire
$LN2@RecvEmpire:

; 149  : 
; 150  : 	m_dwEmpireID=kPacketEmpire.bEmpire;

  00021	0f b6 45 fd	 movzx	 eax, BYTE PTR _kPacketEmpire$[ebp+1]
  00025	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	89 81 b4 00 00
	00		 mov	 DWORD PTR [ecx+180], eax

; 151  : 	return true;

  0002e	b0 01		 mov	 al, 1
$LN1@RecvEmpire:

; 152  : }

  00030	c9		 leave
  00031	c3		 ret	 0
?__RecvEmpirePacket@CPythonNetworkStream@@IAE_NXZ ENDP	; CPythonNetworkStream::__RecvEmpirePacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvLoginFailurePacket@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_packet_failure$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
?__RecvLoginFailurePacket@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::__RecvLoginFailurePacket, COMDAT
; _this$ = ecx

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 226  : 	TPacketGCLoginFailure packet_failure;
; 227  : 	if (!Recv(sizeof(TPacketGCLoginFailure), &packet_failure))

  00013	8d 45 f0	 lea	 eax, DWORD PTR _packet_failure$[ebp]
  00016	50		 push	 eax
  00017	6a 0a		 push	 10			; 0000000aH
  00019	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 04		 jne	 SHORT $LN2@RecvLoginF

; 228  : 		return false;

  00028	32 c0		 xor	 al, al
  0002a	eb 31		 jmp	 SHORT $LN1@RecvLoginF
$LN2@RecvLoginF:

; 229  : 
; 230  : 	PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOGIN], "OnLoginFailure", Py_BuildValue("(s)", packet_failure.szStatus));

  0002c	8d 45 f1	 lea	 eax, DWORD PTR _packet_failure$[ebp+1]
  0002f	50		 push	 eax
  00030	68 00 00 00 00	 push	 OFFSET ??_C@_03KJMMOONA@?$CIs?$CJ@
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  0003b	59		 pop	 ecx
  0003c	59		 pop	 ecx
  0003d	50		 push	 eax
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0P@OOEAIINI@OnLoginFailure@
  00043	6a 04		 push	 4
  00045	58		 pop	 eax
  00046	c1 e0 00	 shl	 eax, 0
  00049	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004c	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  00053	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 231  : #ifdef _DEBUG
; 232  : 	Tracef(" RecvLoginFailurePacket : [%s]\n", packet_failure.szStatus);
; 233  : #endif
; 234  : 	return true;

  0005b	b0 01		 mov	 al, 1
$LN1@RecvLoginF:

; 235  : }

  0005d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00060	33 cd		 xor	 ecx, ebp
  00062	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00067	c9		 leave
  00068	c3		 ret	 0
?__RecvLoginFailurePacket@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::__RecvLoginFailurePacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvLoginSuccessPacket4@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
__Ptr$ = -120						; size = 4
_this$ = -116						; size = 4
_i$3 = -112						; size = 4
_kPacketLoginSuccess$ = -108				; size = 329
__$ArrayPad$ = 224					; size = 4
?__RecvLoginSuccessPacket4@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::__RecvLoginSuccessPacket4, COMDAT
; _this$ = ecx

; 183  : {

  00000	55		 push	 ebp
  00001	8d ac 24 1c ff
	ff ff		 lea	 ebp, DWORD PTR [esp-228]
  00008	81 ec 64 01 00
	00		 sub	 esp, 356		; 00000164H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 e0 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 4d 8c	 mov	 DWORD PTR _this$[ebp], ecx

; 184  : 	TPacketGCLoginSuccess4 kPacketLoginSuccess;
; 185  : 
; 186  : 	if (!Recv(sizeof(kPacketLoginSuccess), &kPacketLoginSuccess))

  00020	8d 45 94	 lea	 eax, DWORD PTR _kPacketLoginSuccess$[ebp]
  00023	50		 push	 eax
  00024	68 49 01 00 00	 push	 329			; 00000149H
  00029	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 07		 jne	 SHORT $LN5@RecvLoginS

; 187  : 		return false;	

  00038	32 c0		 xor	 al, al
  0003a	e9 dd 00 00 00	 jmp	 $LN1@RecvLoginS
$LN5@RecvLoginS:

; 188  : 	
; 189  : 	for (int i = 0; i<PLAYER_PER_ACCOUNT4; ++i)

  0003f	83 65 90 00	 and	 DWORD PTR _i$3[ebp], 0
  00043	eb 07		 jmp	 SHORT $LN4@RecvLoginS
$LN2@RecvLoginS:
  00045	8b 45 90	 mov	 eax, DWORD PTR _i$3[ebp]
  00048	40		 inc	 eax
  00049	89 45 90	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@RecvLoginS:
  0004c	83 7d 90 04	 cmp	 DWORD PTR _i$3[ebp], 4
  00050	7d 70		 jge	 SHORT $LN3@RecvLoginS

; 190  : 	{
; 191  : 		m_akSimplePlayerInfo[i]=kPacketLoginSuccess.akSimplePlayerInformation[i];

  00052	6b 45 90 3f	 imul	 eax, DWORD PTR _i$3[ebp], 63
  00056	8d 74 05 95	 lea	 esi, DWORD PTR _kPacketLoginSuccess$[ebp+eax+1]
  0005a	6b 45 90 3f	 imul	 eax, DWORD PTR _i$3[ebp], 63
  0005e	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8d bc 01 9c 01
	00 00		 lea	 edi, DWORD PTR [ecx+eax+412]
  00068	6a 0f		 push	 15			; 0000000fH
  0006a	59		 pop	 ecx
  0006b	f3 a5		 rep movsd
  0006d	66 a5		 movsw
  0006f	a4		 movsb

; 192  : 		m_adwGuildID[i]=kPacketLoginSuccess.guild_id[i];

  00070	8b 45 90	 mov	 eax, DWORD PTR _i$3[ebp]
  00073	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 55 90	 mov	 edx, DWORD PTR _i$3[ebp]
  00079	8b 94 95 91 00
	00 00		 mov	 edx, DWORD PTR _kPacketLoginSuccess$[ebp+edx*4+253]
  00080	89 94 81 98 02
	00 00		 mov	 DWORD PTR [ecx+eax*4+664], edx

; 193  : 		m_astrGuildName[i]=kPacketLoginSuccess.guild_name[i];

  00087	6b 45 90 0d	 imul	 eax, DWORD PTR _i$3[ebp], 13
  0008b	8d 84 05 a1 00
	00 00		 lea	 eax, DWORD PTR _kPacketLoginSuccess$[ebp+eax+269]
  00092	89 45 88	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00095	ff 75 88	 push	 DWORD PTR __Ptr$[ebp]
  00098	e8 00 00 00 00	 call	 _strlen
  0009d	59		 pop	 ecx
  0009e	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  000a1	8b 45 84	 mov	 eax, DWORD PTR $T2[ebp]
  000a4	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000a7	ff 75 80	 push	 DWORD PTR $T1[ebp]
  000aa	ff 75 88	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp

; 193  : 		m_astrGuildName[i]=kPacketLoginSuccess.guild_name[i];

  000ad	6b 45 90 18	 imul	 eax, DWORD PTR _i$3[ebp], 24
  000b1	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	8d 8c 01 a8 02
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+680]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000bb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp

; 194  : 	}

  000c0	eb 83		 jmp	 SHORT $LN2@RecvLoginS
$LN3@RecvLoginS:

; 195  : 
; 196  : 	m_kMarkAuth.m_dwHandle=kPacketLoginSuccess.handle;

  000c2	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  000c5	8b 8d d5 00 00
	00		 mov	 ecx, DWORD PTR _kPacketLoginSuccess$[ebp+321]
  000cb	89 88 08 79 00
	00		 mov	 DWORD PTR [eax+30984], ecx

; 197  : 	m_kMarkAuth.m_dwRandomKey=kPacketLoginSuccess.random_key;	

  000d1	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  000d4	8b 8d d9 00 00
	00		 mov	 ecx, DWORD PTR _kPacketLoginSuccess$[ebp+325]
  000da	89 88 0c 79 00
	00		 mov	 DWORD PTR [eax+30988], ecx

; 198  : 
; 199  : 	if (__DirectEnterMode_IsSet())

  000e0	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	e8 00 00 00 00	 call	 ?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ ; CPythonNetworkStream::__DirectEnterMode_IsSet
  000e8	0f b6 c0	 movzx	 eax, al
  000eb	85 c0		 test	 eax, eax
  000ed	74 02		 je	 SHORT $LN6@RecvLoginS

; 200  : 	{
; 201  : 	}

  000ef	eb 29		 jmp	 SHORT $LN7@RecvLoginS
$LN6@RecvLoginS:

; 202  : 	else
; 203  : 	{
; 204  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_SELECT], "Refresh", Py_BuildValue("()"));		

  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000fc	59		 pop	 ecx
  000fd	50		 push	 eax
  000fe	68 00 00 00 00	 push	 OFFSET ??_C@_07POIENIBA@Refresh@
  00103	6a 04		 push	 4
  00105	58		 pop	 eax
  00106	d1 e0		 shl	 eax, 1
  00108	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  0010b	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  00112	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00117	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@RecvLoginS:

; 205  : 	}
; 206  : 
; 207  : 	return true;

  0011a	b0 01		 mov	 al, 1
$LN1@RecvLoginS:

; 208  : }

  0011c	5f		 pop	 edi
  0011d	5e		 pop	 esi
  0011e	8b 8d e0 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00124	33 cd		 xor	 ecx, ebp
  00126	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0012b	81 c5 e4 00 00
	00		 add	 ebp, 228		; 000000e4H
  00131	c9		 leave
  00132	c3		 ret	 0
?__RecvLoginSuccessPacket4@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::__RecvLoginSuccessPacket4
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?__RecvLoginSuccessPacket3@CPythonNetworkStream@@IAE_NXZ
_TEXT	SEGMENT
$T1 = -128						; size = 4
$T2 = -124						; size = 4
__Ptr$ = -120						; size = 4
_this$ = -116						; size = 4
_i$3 = -112						; size = 4
_kPacketLoginSuccess$ = -108				; size = 249
__$ArrayPad$ = 144					; size = 4
?__RecvLoginSuccessPacket3@CPythonNetworkStream@@IAE_NXZ PROC ; CPythonNetworkStream::__RecvLoginSuccessPacket3, COMDAT
; _this$ = ecx

; 155  : {

  00000	55		 push	 ebp
  00001	8d ac 24 6c ff
	ff ff		 lea	 ebp, DWORD PTR [esp-148]
  00008	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  0000e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00013	33 c5		 xor	 eax, ebp
  00015	89 85 90 00 00
	00		 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001b	56		 push	 esi
  0001c	57		 push	 edi
  0001d	89 4d 8c	 mov	 DWORD PTR _this$[ebp], ecx

; 156  : 	TPacketGCLoginSuccess3 kPacketLoginSuccess;
; 157  : 
; 158  : 	if (!Recv(sizeof(kPacketLoginSuccess), &kPacketLoginSuccess))

  00020	8d 45 94	 lea	 eax, DWORD PTR _kPacketLoginSuccess$[ebp]
  00023	50		 push	 eax
  00024	68 f9 00 00 00	 push	 249			; 000000f9H
  00029	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?Recv@CNetworkStream@@QAE_NHPAX@Z ; CNetworkStream::Recv
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	75 07		 jne	 SHORT $LN5@RecvLoginS

; 159  : 		return false;	

  00038	32 c0		 xor	 al, al
  0003a	e9 d7 00 00 00	 jmp	 $LN1@RecvLoginS
$LN5@RecvLoginS:

; 160  : 	
; 161  : 	for (int i = 0; i<PLAYER_PER_ACCOUNT3; ++i)

  0003f	83 65 90 00	 and	 DWORD PTR _i$3[ebp], 0
  00043	eb 07		 jmp	 SHORT $LN4@RecvLoginS
$LN2@RecvLoginS:
  00045	8b 45 90	 mov	 eax, DWORD PTR _i$3[ebp]
  00048	40		 inc	 eax
  00049	89 45 90	 mov	 DWORD PTR _i$3[ebp], eax
$LN4@RecvLoginS:
  0004c	83 7d 90 03	 cmp	 DWORD PTR _i$3[ebp], 3
  00050	7d 6a		 jge	 SHORT $LN3@RecvLoginS

; 162  : 	{
; 163  : 		m_akSimplePlayerInfo[i]=kPacketLoginSuccess.akSimplePlayerInformation[i];

  00052	6b 45 90 3f	 imul	 eax, DWORD PTR _i$3[ebp], 63
  00056	8d 74 05 95	 lea	 esi, DWORD PTR _kPacketLoginSuccess$[ebp+eax+1]
  0005a	6b 45 90 3f	 imul	 eax, DWORD PTR _i$3[ebp], 63
  0005e	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8d bc 01 9c 01
	00 00		 lea	 edi, DWORD PTR [ecx+eax+412]
  00068	6a 0f		 push	 15			; 0000000fH
  0006a	59		 pop	 ecx
  0006b	f3 a5		 rep movsd
  0006d	66 a5		 movsw
  0006f	a4		 movsb

; 164  : 		m_adwGuildID[i]=kPacketLoginSuccess.guild_id[i];

  00070	8b 45 90	 mov	 eax, DWORD PTR _i$3[ebp]
  00073	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	8b 55 90	 mov	 edx, DWORD PTR _i$3[ebp]
  00079	8b 54 95 52	 mov	 edx, DWORD PTR _kPacketLoginSuccess$[ebp+edx*4+190]
  0007d	89 94 81 98 02
	00 00		 mov	 DWORD PTR [ecx+eax*4+664], edx

; 165  : 		m_astrGuildName[i]=kPacketLoginSuccess.guild_name[i];

  00084	6b 45 90 0d	 imul	 eax, DWORD PTR _i$3[ebp], 13
  00088	8d 44 05 5e	 lea	 eax, DWORD PTR _kPacketLoginSuccess$[ebp+eax+202]
  0008c	89 45 88	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0008f	ff 75 88	 push	 DWORD PTR __Ptr$[ebp]
  00092	e8 00 00 00 00	 call	 _strlen
  00097	59		 pop	 ecx
  00098	89 45 84	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0009b	8b 45 84	 mov	 eax, DWORD PTR $T2[ebp]
  0009e	89 45 80	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000a1	ff 75 80	 push	 DWORD PTR $T1[ebp]
  000a4	ff 75 88	 push	 DWORD PTR __Ptr$[ebp]
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp

; 165  : 		m_astrGuildName[i]=kPacketLoginSuccess.guild_name[i];

  000a7	6b 45 90 18	 imul	 eax, DWORD PTR _i$3[ebp], 24
  000ab	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	8d 8c 01 a8 02
	00 00		 lea	 ecx, DWORD PTR [ecx+eax+680]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  000b5	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp

; 166  : 	}

  000ba	eb 89		 jmp	 SHORT $LN2@RecvLoginS
$LN3@RecvLoginS:

; 167  : 
; 168  : 	m_kMarkAuth.m_dwHandle=kPacketLoginSuccess.handle;

  000bc	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b 8d 85 00 00
	00		 mov	 ecx, DWORD PTR _kPacketLoginSuccess$[ebp+241]
  000c5	89 88 08 79 00
	00		 mov	 DWORD PTR [eax+30984], ecx

; 169  : 	m_kMarkAuth.m_dwRandomKey=kPacketLoginSuccess.random_key;	

  000cb	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  000ce	8b 8d 89 00 00
	00		 mov	 ecx, DWORD PTR _kPacketLoginSuccess$[ebp+245]
  000d4	89 88 0c 79 00
	00		 mov	 DWORD PTR [eax+30988], ecx

; 170  : 
; 171  : 	if (__DirectEnterMode_IsSet())

  000da	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	e8 00 00 00 00	 call	 ?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ ; CPythonNetworkStream::__DirectEnterMode_IsSet
  000e2	0f b6 c0	 movzx	 eax, al
  000e5	85 c0		 test	 eax, eax
  000e7	74 02		 je	 SHORT $LN6@RecvLoginS

; 172  : 	{
; 173  : 	}

  000e9	eb 29		 jmp	 SHORT $LN7@RecvLoginS
$LN6@RecvLoginS:

; 174  : 	else
; 175  : 	{
; 176  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_SELECT], "Refresh", Py_BuildValue("()"));		

  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  000f6	59		 pop	 ecx
  000f7	50		 push	 eax
  000f8	68 00 00 00 00	 push	 OFFSET ??_C@_07POIENIBA@Refresh@
  000fd	6a 04		 push	 4
  000ff	58		 pop	 eax
  00100	d1 e0		 shl	 eax, 1
  00102	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  0010c	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN7@RecvLoginS:

; 177  : 	}
; 178  : 
; 179  : 	return true;

  00114	b0 01		 mov	 al, 1
$LN1@RecvLoginS:

; 180  : }

  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	8b 8d 90 00 00
	00		 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011e	33 cd		 xor	 ecx, ebp
  00120	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00125	81 c5 94 00 00
	00		 add	 ebp, 148		; 00000094H
  0012b	c9		 leave
  0012c	c3		 ret	 0
?__RecvLoginSuccessPacket3@CPythonNetworkStream@@IAE_NXZ ENDP ; CPythonNetworkStream::__RecvLoginSuccessPacket3
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?LoginPhase@CPythonNetworkStream@@IAEXXZ
_TEXT	SEGMENT
tv70 = -12						; size = 4
_this$ = -8						; size = 4
_header$ = -1						; size = 1
?LoginPhase@CPythonNetworkStream@@IAEXXZ PROC		; CPythonNetworkStream::LoginPhase, COMDAT
; _this$ = ecx

; 12   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 13   : 	TPacketHeader header;
; 14   : 	if (!CheckPacket(&header))

  00009	8d 45 ff	 lea	 eax, DWORD PTR _header$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?CheckPacket@CPythonNetworkStream@@IAE_NPAE@Z ; CPythonNetworkStream::CheckPacket
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	75 05		 jne	 SHORT $LN4@LoginPhase

; 15   : 		return;

  0001c	e9 da 01 00 00	 jmp	 $LN1@LoginPhase
$LN4@LoginPhase:

; 16   : 
; 17   : 	switch (header)

  00021	0f b6 45 ff	 movzx	 eax, BYTE PTR _header$[ebp]
  00025	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  00028	83 7d f4 76	 cmp	 DWORD PTR tv70[ebp], 118 ; 00000076H
  0002c	7f 4b		 jg	 SHORT $LN32@LoginPhase
  0002e	83 7d f4 76	 cmp	 DWORD PTR tv70[ebp], 118 ; 00000076H
  00032	0f 84 62 01 00
	00		 je	 $LN23@LoginPhase
  00038	83 7d f4 06	 cmp	 DWORD PTR tv70[ebp], 6
  0003c	0f 84 9f 00 00
	00		 je	 $LN7@LoginPhase
  00042	83 7d f4 07	 cmp	 DWORD PTR tv70[ebp], 7
  00046	0f 84 c7 00 00
	00		 je	 $LN11@LoginPhase
  0004c	83 7d f4 20	 cmp	 DWORD PTR tv70[ebp], 32	; 00000020H
  00050	0f 84 a4 00 00
	00		 je	 $LN9@LoginPhase
  00056	83 7d f4 2c	 cmp	 DWORD PTR tv70[ebp], 44	; 0000002cH
  0005a	0f 84 4d 01 00
	00		 je	 $LN25@LoginPhase
  00060	83 7d f4 5a	 cmp	 DWORD PTR tv70[ebp], 90	; 0000005aH
  00064	0f 84 c2 00 00
	00		 je	 $LN13@LoginPhase
  0006a	83 7d f4 74	 cmp	 DWORD PTR tv70[ebp], 116 ; 00000074H
  0006e	0f 84 d1 00 00
	00		 je	 $LN15@LoginPhase
  00074	e9 5f 01 00 00	 jmp	 $LN29@LoginPhase
$LN32@LoginPhase:
  00079	81 7d f4 98 00
	00 00		 cmp	 DWORD PTR tv70[ebp], 152 ; 00000098H
  00080	0f 84 3a 01 00
	00		 je	 $LN27@LoginPhase
  00086	81 7d f4 99 00
	00 00		 cmp	 DWORD PTR tv70[ebp], 153 ; 00000099H
  0008d	0f 84 39 01 00
	00		 je	 $LN28@LoginPhase
  00093	81 7d f4 c9 00
	00 00		 cmp	 DWORD PTR tv70[ebp], 201 ; 000000c9H
  0009a	0f 84 be 00 00
	00		 je	 $LN17@LoginPhase
  000a0	81 7d f4 ca 00
	00 00		 cmp	 DWORD PTR tv70[ebp], 202 ; 000000caH
  000a7	0f 84 c7 00 00
	00		 je	 $LN19@LoginPhase
  000ad	81 7d f4 cb 00
	00 00		 cmp	 DWORD PTR tv70[ebp], 203 ; 000000cbH
  000b4	0f 84 cd 00 00
	00		 je	 $LN21@LoginPhase
  000ba	81 7d f4 fd 00
	00 00		 cmp	 DWORD PTR tv70[ebp], 253 ; 000000fdH
  000c1	74 05		 je	 SHORT $LN5@LoginPhase
  000c3	e9 10 01 00 00	 jmp	 $LN29@LoginPhase
$LN5@LoginPhase:

; 18   : 	{
; 19   : 		case HEADER_GC_PHASE:
; 20   : 			if (RecvPhasePacket())

  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?RecvPhasePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPhasePacket
  000d0	0f b6 c0	 movzx	 eax, al
  000d3	85 c0		 test	 eax, eax
  000d5	74 05		 je	 SHORT $LN6@LoginPhase

; 21   : 				return;

  000d7	e9 1f 01 00 00	 jmp	 $LN1@LoginPhase
$LN6@LoginPhase:

; 22   : 			break;

  000dc	e9 0d 01 00 00	 jmp	 $LN2@LoginPhase
$LN7@LoginPhase:

; 23   : 
; 24   : 		case HEADER_GC_LOGIN_SUCCESS3:
; 25   : 			if (__RecvLoginSuccessPacket3())

  000e1	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000e4	e8 00 00 00 00	 call	 ?__RecvLoginSuccessPacket3@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvLoginSuccessPacket3
  000e9	0f b6 c0	 movzx	 eax, al
  000ec	85 c0		 test	 eax, eax
  000ee	74 05		 je	 SHORT $LN8@LoginPhase

; 26   : 				return;

  000f0	e9 06 01 00 00	 jmp	 $LN1@LoginPhase
$LN8@LoginPhase:

; 27   : 			break;

  000f5	e9 f4 00 00 00	 jmp	 $LN2@LoginPhase
$LN9@LoginPhase:

; 28   : 		case HEADER_GC_LOGIN_SUCCESS4:
; 29   : 			if (__RecvLoginSuccessPacket4())

  000fa	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fd	e8 00 00 00 00	 call	 ?__RecvLoginSuccessPacket4@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvLoginSuccessPacket4
  00102	0f b6 c0	 movzx	 eax, al
  00105	85 c0		 test	 eax, eax
  00107	74 05		 je	 SHORT $LN10@LoginPhase

; 30   : 				return;

  00109	e9 ed 00 00 00	 jmp	 $LN1@LoginPhase
$LN10@LoginPhase:

; 31   : 			break;

  0010e	e9 db 00 00 00	 jmp	 $LN2@LoginPhase
$LN11@LoginPhase:

; 32   : 
; 33   : 
; 34   : 		case HEADER_GC_LOGIN_FAILURE:
; 35   : 			if (__RecvLoginFailurePacket())

  00113	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00116	e8 00 00 00 00	 call	 ?__RecvLoginFailurePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvLoginFailurePacket
  0011b	0f b6 c0	 movzx	 eax, al
  0011e	85 c0		 test	 eax, eax
  00120	74 05		 je	 SHORT $LN12@LoginPhase

; 36   : 				return;		

  00122	e9 d4 00 00 00	 jmp	 $LN1@LoginPhase
$LN12@LoginPhase:

; 37   : 			break;

  00127	e9 c2 00 00 00	 jmp	 $LN2@LoginPhase
$LN13@LoginPhase:

; 38   : 
; 39   : 		case HEADER_GC_EMPIRE:
; 40   : 			if (__RecvEmpirePacket())

  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	e8 00 00 00 00	 call	 ?__RecvEmpirePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvEmpirePacket
  00134	0f b6 c0	 movzx	 eax, al
  00137	85 c0		 test	 eax, eax
  00139	74 05		 je	 SHORT $LN14@LoginPhase

; 41   : 				return;

  0013b	e9 bb 00 00 00	 jmp	 $LN1@LoginPhase
$LN14@LoginPhase:

; 42   : 			break;

  00140	e9 a9 00 00 00	 jmp	 $LN2@LoginPhase
$LN15@LoginPhase:

; 43   : 
; 44   : 		case HEADER_GC_CHINA_MATRIX_CARD:
; 45   : 			if (__RecvChinaMatrixCardPacket())

  00145	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	e8 00 00 00 00	 call	 ?__RecvChinaMatrixCardPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvChinaMatrixCardPacket
  0014d	0f b6 c0	 movzx	 eax, al
  00150	85 c0		 test	 eax, eax
  00152	74 05		 je	 SHORT $LN16@LoginPhase

; 46   : 				return;

  00154	e9 a2 00 00 00	 jmp	 $LN1@LoginPhase
$LN16@LoginPhase:

; 47   : 			break;

  00159	e9 90 00 00 00	 jmp	 $LN2@LoginPhase
$LN17@LoginPhase:

; 48   : 
; 49   : 		case HEADER_GC_RUNUP_MATRIX_QUIZ:
; 50   : 			if (__RecvRunupMatrixQuizPacket())

  0015e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00161	e8 00 00 00 00	 call	 ?__RecvRunupMatrixQuizPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvRunupMatrixQuizPacket
  00166	0f b6 c0	 movzx	 eax, al
  00169	85 c0		 test	 eax, eax
  0016b	74 05		 je	 SHORT $LN18@LoginPhase

; 51   : 				return;

  0016d	e9 89 00 00 00	 jmp	 $LN1@LoginPhase
$LN18@LoginPhase:

; 52   : 			break;

  00172	eb 7a		 jmp	 SHORT $LN2@LoginPhase
$LN19@LoginPhase:

; 53   : 
; 54   : 		case HEADER_GC_NEWCIBN_PASSPOD_REQUEST:
; 55   : 			if (__RecvNEWCIBNPasspodRequestPacket())

  00174	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00177	e8 00 00 00 00	 call	 ?__RecvNEWCIBNPasspodRequestPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvNEWCIBNPasspodRequestPacket
  0017c	0f b6 c0	 movzx	 eax, al
  0017f	85 c0		 test	 eax, eax
  00181	74 02		 je	 SHORT $LN20@LoginPhase

; 56   : 				return;

  00183	eb 76		 jmp	 SHORT $LN1@LoginPhase
$LN20@LoginPhase:

; 57   : 			break;

  00185	eb 67		 jmp	 SHORT $LN2@LoginPhase
$LN21@LoginPhase:

; 58   : 		case HEADER_GC_NEWCIBN_PASSPOD_FAILURE:
; 59   : 			if (__RecvNEWCIBNPasspodFailurePacket())

  00187	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018a	e8 00 00 00 00	 call	 ?__RecvNEWCIBNPasspodFailurePacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvNEWCIBNPasspodFailurePacket
  0018f	0f b6 c0	 movzx	 eax, al
  00192	85 c0		 test	 eax, eax
  00194	74 02		 je	 SHORT $LN22@LoginPhase

; 60   : 				return;

  00196	eb 63		 jmp	 SHORT $LN1@LoginPhase
$LN22@LoginPhase:

; 61   : 			break;

  00198	eb 54		 jmp	 SHORT $LN2@LoginPhase
$LN23@LoginPhase:

; 62   : 
; 63   : 
; 64   : 		case HEADER_GC_LOGIN_KEY:
; 65   : 			if (__RecvLoginKeyPacket())

  0019a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0019d	e8 00 00 00 00	 call	 ?__RecvLoginKeyPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::__RecvLoginKeyPacket
  001a2	0f b6 c0	 movzx	 eax, al
  001a5	85 c0		 test	 eax, eax
  001a7	74 02		 je	 SHORT $LN24@LoginPhase

; 66   : 				return;

  001a9	eb 50		 jmp	 SHORT $LN1@LoginPhase
$LN24@LoginPhase:

; 67   : 			break;

  001ab	eb 41		 jmp	 SHORT $LN2@LoginPhase
$LN25@LoginPhase:

; 68   : 
; 69   : 		case HEADER_GC_PING:
; 70   : 			if (RecvPingPacket())

  001ad	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001b0	e8 00 00 00 00	 call	 ?RecvPingPacket@CPythonNetworkStream@@IAE_NXZ ; CPythonNetworkStream::RecvPingPacket
  001b5	0f b6 c0	 movzx	 eax, al
  001b8	85 c0		 test	 eax, eax
  001ba	74 02		 je	 SHORT $LN26@LoginPhase

; 71   : 				return;

  001bc	eb 3d		 jmp	 SHORT $LN1@LoginPhase
$LN26@LoginPhase:

; 72   : 			break;

  001be	eb 2e		 jmp	 SHORT $LN2@LoginPhase
$LN27@LoginPhase:

; 73   : 
; 74   : 		case HEADER_GC_HYBRIDCRYPT_KEYS:
; 75   : 			RecvHybridCryptKeyPacket();

  001c0	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c3	e8 00 00 00 00	 call	 ?RecvHybridCryptKeyPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptKeyPacket

; 76   : 			return;

  001c8	eb 31		 jmp	 SHORT $LN1@LoginPhase

; 77   : 			break;

  001ca	eb 22		 jmp	 SHORT $LN2@LoginPhase
$LN28@LoginPhase:

; 78   : 
; 79   : 		case HEADER_GC_HYBRIDCRYPT_SDB:
; 80   : 			RecvHybridCryptSDBPacket();

  001cc	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001cf	e8 00 00 00 00	 call	 ?RecvHybridCryptSDBPacket@CPythonNetworkStream@@QAE_NXZ ; CPythonNetworkStream::RecvHybridCryptSDBPacket

; 81   : 			return;

  001d4	eb 25		 jmp	 SHORT $LN1@LoginPhase

; 82   : 			break;

  001d6	eb 16		 jmp	 SHORT $LN2@LoginPhase
$LN29@LoginPhase:

; 83   : 
; 84   : 		default:
; 85   : 			if (RecvDefaultPacket(header))

  001d8	0f b6 45 ff	 movzx	 eax, BYTE PTR _header$[ebp]
  001dc	50		 push	 eax
  001dd	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001e0	e8 00 00 00 00	 call	 ?RecvDefaultPacket@CPythonNetworkStream@@IAE_NH@Z ; CPythonNetworkStream::RecvDefaultPacket
  001e5	0f b6 c0	 movzx	 eax, al
  001e8	85 c0		 test	 eax, eax
  001ea	74 02		 je	 SHORT $LN2@LoginPhase

; 86   : 				return;

  001ec	eb 0d		 jmp	 SHORT $LN1@LoginPhase
$LN2@LoginPhase:

; 87   : 			break;
; 88   : 	}
; 89   : 
; 90   : 	RecvErrorPacket(header);

  001ee	0f b6 45 ff	 movzx	 eax, BYTE PTR _header$[ebp]
  001f2	50		 push	 eax
  001f3	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f6	e8 00 00 00 00	 call	 ?RecvErrorPacket@CPythonNetworkStream@@IAE_NH@Z ; CPythonNetworkStream::RecvErrorPacket
$LN1@LoginPhase:

; 91   : }

  001fb	c9		 leave
  001fc	c3		 ret	 0
?LoginPhase@CPythonNetworkStream@@IAEXXZ ENDP		; CPythonNetworkStream::LoginPhase
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?SendDirectEnterPacket@CPythonNetworkStream@@QAE_NPBD0I@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
_kPacketDirectEnter$ = -56				; size = 50
__$ArrayPad$ = -4					; size = 4
_c_szID$ = 8						; size = 4
_c_szPassword$ = 12					; size = 4
_uChrSlot$ = 16						; size = 4
?SendDirectEnterPacket@CPythonNetworkStream@@QAE_NPBD0I@Z PROC ; CPythonNetworkStream::SendDirectEnterPacket, COMDAT
; _this$ = ecx

; 238  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 239  : 	TPacketCGDirectEnter kPacketDirectEnter;
; 240  : 	kPacketDirectEnter.bHeader=HEADER_CG_DIRECT_ENTER;

  00013	c6 45 c8 09	 mov	 BYTE PTR _kPacketDirectEnter$[ebp], 9

; 241  : 	kPacketDirectEnter.index=uChrSlot;

  00017	8a 45 10	 mov	 al, BYTE PTR _uChrSlot$[ebp]
  0001a	88 45 f9	 mov	 BYTE PTR _kPacketDirectEnter$[ebp+49], al

; 242  : 	strncpy(kPacketDirectEnter.login, c_szID, ID_MAX_NUM);

  0001d	6a 1e		 push	 30			; 0000001eH
  0001f	ff 75 08	 push	 DWORD PTR _c_szID$[ebp]
  00022	8d 45 c9	 lea	 eax, DWORD PTR _kPacketDirectEnter$[ebp+1]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 _strncpy
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 243  : 	strncpy(kPacketDirectEnter.passwd, c_szPassword, PASS_MAX_NUM);

  0002e	6a 10		 push	 16			; 00000010H
  00030	ff 75 0c	 push	 DWORD PTR _c_szPassword$[ebp]
  00033	8d 45 e8	 lea	 eax, DWORD PTR _kPacketDirectEnter$[ebp+32]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 _strncpy
  0003c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 244  : 
; 245  : 	if (!Send(sizeof(kPacketDirectEnter), &kPacketDirectEnter))

  0003f	8d 45 c8	 lea	 eax, DWORD PTR _kPacketDirectEnter$[ebp]
  00042	50		 push	 eax
  00043	6a 32		 push	 50			; 00000032H
  00045	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0004d	0f b6 c0	 movzx	 eax, al
  00050	85 c0		 test	 eax, eax
  00052	75 0f		 jne	 SHORT $LN2@SendDirect

; 246  : 	{
; 247  : 		Tracen("SendDirectEnter");

  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HOEIMIKO@SendDirectEnter@
  00059	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0005e	59		 pop	 ecx

; 248  : 		return false;

  0005f	32 c0		 xor	 al, al
  00061	eb 08		 jmp	 SHORT $LN1@SendDirect
$LN2@SendDirect:

; 249  : 	}
; 250  : 
; 251  : 	return SendSequence();

  00063	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
$LN1@SendDirect:

; 252  : }

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006e	33 cd		 xor	 ecx, ebp
  00070	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00075	c9		 leave
  00076	c2 0c 00	 ret	 12			; 0000000cH
?SendDirectEnterPacket@CPythonNetworkStream@@QAE_NPBD0I@Z ENDP ; CPythonNetworkStream::SendDirectEnterPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?SendNEWCIBNPasspodAnswerPacket@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_answerPacket$ = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_answer$ = 8						; size = 4
?SendNEWCIBNPasspodAnswerPacket@CPythonNetworkStream@@QAE_NPBD@Z PROC ; CPythonNetworkStream::SendNEWCIBNPasspodAnswerPacket, COMDAT
; _this$ = ecx

; 354  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 355  : 	TPacketCGNEWCIBNPasspodAnswer answerPacket;
; 356  : 	answerPacket.bHeader = HEADER_CG_NEWCIBN_PASSPOD_ANSWER;

  00013	c6 45 f0 ca	 mov	 BYTE PTR _answerPacket$[ebp], 202 ; 000000caH

; 357  : 	strncpy(answerPacket.szAnswer, answer, NEWCIBN_PASSPOD_ANSWER_MAX_LEN);

  00017	6a 08		 push	 8
  00019	ff 75 08	 push	 DWORD PTR _answer$[ebp]
  0001c	8d 45 f1	 lea	 eax, DWORD PTR _answerPacket$[ebp+1]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _strncpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 358  : 	answerPacket.szAnswer[NEWCIBN_PASSPOD_ANSWER_MAX_LEN] = '\0';	

  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	c6 44 05 f1 00	 mov	 BYTE PTR _answerPacket$[ebp+eax+1], 0

; 359  : 	if (!Send(sizeof(answerPacket), &answerPacket))

  00033	8d 45 f0	 lea	 eax, DWORD PTR _answerPacket$[ebp]
  00036	50		 push	 eax
  00037	6a 0a		 push	 10			; 0000000aH
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	75 0f		 jne	 SHORT $LN2@SendNEWCIB

; 360  : 	{
; 361  : 		TraceError("SendNEWCIBNPasspodAnswerPacket");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@JFBAGMPA@SendNEWCIBNPasspodAnswerPacket@
  0004d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00052	59		 pop	 ecx

; 362  : 		return false;

  00053	32 c0		 xor	 al, al
  00055	eb 08		 jmp	 SHORT $LN1@SendNEWCIB
$LN2@SendNEWCIB:

; 363  : 	}
; 364  : 	return SendSequence();

  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
$LN1@SendNEWCIB:

; 365  : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
?SendNEWCIBNPasspodAnswerPacket@CPythonNetworkStream@@QAE_NPBD@Z ENDP ; CPythonNetworkStream::SendNEWCIBNPasspodAnswerPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?SendRunupMatrixAnswerPacket@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_answerPacket$ = -12					; size = 6
__$ArrayPad$ = -4					; size = 4
_c_szMatrixCardString$ = 8				; size = 4
?SendRunupMatrixAnswerPacket@CPythonNetworkStream@@QAE_NPBD@Z PROC ; CPythonNetworkStream::SendRunupMatrixAnswerPacket, COMDAT
; _this$ = ecx

; 319  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 320  : 	TPacketCGRunupMatrixAnswer answerPacket;
; 321  : 	answerPacket.bHeader = HEADER_CG_RUNUP_MATRIX_ANSWER;

  00013	c6 45 f4 c9	 mov	 BYTE PTR _answerPacket$[ebp], 201 ; 000000c9H

; 322  : 	strncpy(answerPacket.szAnswer, c_szMatrixCardString, RUNUP_MATRIX_ANSWER_MAX_LEN);

  00017	6a 04		 push	 4
  00019	ff 75 08	 push	 DWORD PTR _c_szMatrixCardString$[ebp]
  0001c	8d 45 f5	 lea	 eax, DWORD PTR _answerPacket$[ebp+1]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _strncpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 323  : 	answerPacket.szAnswer[RUNUP_MATRIX_ANSWER_MAX_LEN] = '\0';

  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
  0002b	c1 e0 02	 shl	 eax, 2
  0002e	c6 44 05 f5 00	 mov	 BYTE PTR _answerPacket$[ebp+eax+1], 0

; 324  : 	if (!Send(sizeof(answerPacket), &answerPacket))

  00033	8d 45 f4	 lea	 eax, DWORD PTR _answerPacket$[ebp]
  00036	50		 push	 eax
  00037	6a 06		 push	 6
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	75 0f		 jne	 SHORT $LN2@SendRunupM

; 325  : 	{
; 326  : 		TraceError("SendRunupMatrixCardPacketError");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@PNMANAPB@SendRunupMatrixCardPacketError@
  0004d	e8 00 00 00 00	 call	 ?TraceError@@YAXPBDZZ	; TraceError
  00052	59		 pop	 ecx

; 327  : 		return false;

  00053	32 c0		 xor	 al, al
  00055	eb 08		 jmp	 SHORT $LN1@SendRunupM
$LN2@SendRunupM:

; 328  : 	}
; 329  : 	return SendSequence();

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
$LN1@SendRunupM:

; 330  : }

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00062	33 cd		 xor	 ecx, ebp
  00064	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00069	c9		 leave
  0006a	c2 04 00	 ret	 4
?SendRunupMatrixAnswerPacket@CPythonNetworkStream@@QAE_NPBD@Z ENDP ; CPythonNetworkStream::SendRunupMatrixAnswerPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?SendChinaMatrixCardPacket@CPythonNetworkStream@@QAE_NPBD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_MatrixCardPacket$ = -16				; size = 10
__$ArrayPad$ = -4					; size = 4
_c_szMatrixCardString$ = 8				; size = 4
?SendChinaMatrixCardPacket@CPythonNetworkStream@@QAE_NPBD@Z PROC ; CPythonNetworkStream::SendChinaMatrixCardPacket, COMDAT
; _this$ = ecx

; 368  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 369  : 	TPacketCGChinaMatrixCard MatrixCardPacket;
; 370  : 	MatrixCardPacket.bHeader = HEADER_CG_CHINA_MATRIX_CARD;

  00013	c6 45 f0 6c	 mov	 BYTE PTR _MatrixCardPacket$[ebp], 108 ; 0000006cH

; 371  : 	strncpy(MatrixCardPacket.szAnswer, c_szMatrixCardString, CHINA_MATRIX_ANSWER_MAX_LEN);

  00017	6a 08		 push	 8
  00019	ff 75 08	 push	 DWORD PTR _c_szMatrixCardString$[ebp]
  0001c	8d 45 f1	 lea	 eax, DWORD PTR _MatrixCardPacket$[ebp+1]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _strncpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 372  : 	MatrixCardPacket.szAnswer[CHINA_MATRIX_ANSWER_MAX_LEN]='\0';

  00028	33 c0		 xor	 eax, eax
  0002a	40		 inc	 eax
  0002b	c1 e0 03	 shl	 eax, 3
  0002e	c6 44 05 f1 00	 mov	 BYTE PTR _MatrixCardPacket$[ebp+eax+1], 0

; 373  : 
; 374  : 	if (!Send(sizeof(MatrixCardPacket), &MatrixCardPacket))

  00033	8d 45 f0	 lea	 eax, DWORD PTR _MatrixCardPacket$[ebp]
  00036	50		 push	 eax
  00037	6a 0a		 push	 10			; 0000000aH
  00039	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	75 0f		 jne	 SHORT $LN2@SendChinaM

; 375  : 	{
; 376  : 		Tracen("SendLogin Error");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
  0004d	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00052	59		 pop	 ecx

; 377  : 		return false;

  00053	32 c0		 xor	 al, al
  00055	eb 15		 jmp	 SHORT $LN1@SendChinaM
$LN2@SendChinaM:

; 378  : 	}
; 379  : 
; 380  : 	m_isWaitLoginKey = TRUE;

  00057	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	c7 80 28 01 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+296], 1

; 381  : 
; 382  : 	return SendSequence();

  00064	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
$LN1@SendChinaM:

; 383  : }

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0006f	33 cd		 xor	 ecx, ebp
  00071	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00076	c9		 leave
  00077	c2 04 00	 ret	 4
?SendChinaMatrixCardPacket@CPythonNetworkStream@@QAE_NPBD@Z ENDP ; CPythonNetworkStream::SendChinaMatrixCardPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?SendLoginPacketNew@CPythonNetworkStream@@QAE_NPBD0@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
_i$1 = -60						; size = 4
_LoginPacket$ = -56					; size = 52
__$ArrayPad$ = -4					; size = 4
_c_szName$ = 8						; size = 4
_c_szPassword$ = 12					; size = 4
?SendLoginPacketNew@CPythonNetworkStream@@QAE_NPBD0@Z PROC ; CPythonNetworkStream::SendLoginPacketNew, COMDAT
; _this$ = ecx

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx

; 276  : 	TPacketCGLogin2 LoginPacket;
; 277  : 	LoginPacket.header = HEADER_CG_LOGIN2;

  00013	c6 45 c8 6d	 mov	 BYTE PTR _LoginPacket$[ebp], 109 ; 0000006dH

; 278  : 	LoginPacket.login_key = m_dwLoginKey;

  00017	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 80 24 01 00
	00		 mov	 eax, DWORD PTR [eax+292]
  00020	89 45 e8	 mov	 DWORD PTR _LoginPacket$[ebp+32], eax

; 279  : 
; 280  : 	strncpy(LoginPacket.name, c_szName, sizeof(LoginPacket.name)-1);

  00023	6a 1e		 push	 30			; 0000001eH
  00025	ff 75 08	 push	 DWORD PTR _c_szName$[ebp]
  00028	8d 45 c9	 lea	 eax, DWORD PTR _LoginPacket$[ebp+1]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 _strncpy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 281  : 	LoginPacket.name[ID_MAX_NUM]='\0';

  00034	33 c0		 xor	 eax, eax
  00036	40		 inc	 eax
  00037	6b c0 1e	 imul	 eax, eax, 30
  0003a	c6 44 05 c9 00	 mov	 BYTE PTR _LoginPacket$[ebp+eax+1], 0

; 282  : 
; 283  : 	extern DWORD g_adwEncryptKey[4];
; 284  : 	extern DWORD g_adwDecryptKey[4];
; 285  : 	for (DWORD i = 0; i < 4; ++i)

  0003f	83 65 c4 00	 and	 DWORD PTR _i$1[ebp], 0
  00043	eb 07		 jmp	 SHORT $LN4@SendLoginP
$LN2@SendLoginP:
  00045	8b 45 c4	 mov	 eax, DWORD PTR _i$1[ebp]
  00048	40		 inc	 eax
  00049	89 45 c4	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@SendLoginP:
  0004c	83 7d c4 04	 cmp	 DWORD PTR _i$1[ebp], 4
  00050	73 13		 jae	 SHORT $LN3@SendLoginP

; 286  : 		LoginPacket.adwClientKey[i] = g_adwEncryptKey[i];

  00052	8b 45 c4	 mov	 eax, DWORD PTR _i$1[ebp]
  00055	8b 4d c4	 mov	 ecx, DWORD PTR _i$1[ebp]
  00058	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?g_adwEncryptKey@@3PAKA[ecx*4]
  0005f	89 4c 85 ec	 mov	 DWORD PTR _LoginPacket$[ebp+eax*4+36], ecx
  00063	eb e0		 jmp	 SHORT $LN2@SendLoginP
$LN3@SendLoginP:

; 287  : 
; 288  : 	if (!Send(sizeof(LoginPacket), &LoginPacket))

  00065	8d 45 c8	 lea	 eax, DWORD PTR _LoginPacket$[ebp]
  00068	50		 push	 eax
  00069	6a 34		 push	 52			; 00000034H
  0006b	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  00073	0f b6 c0	 movzx	 eax, al
  00076	85 c0		 test	 eax, eax
  00078	75 0f		 jne	 SHORT $LN5@SendLoginP

; 289  : 	{
; 290  : 		Tracen("SendLogin Error");

  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
  0007f	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00084	59		 pop	 ecx

; 291  : 		return false;

  00085	32 c0		 xor	 al, al
  00087	eb 28		 jmp	 SHORT $LN1@SendLoginP
$LN5@SendLoginP:

; 292  : 	}
; 293  : 
; 294  : 	if (!SendSequence())

  00089	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008c	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
  00091	0f b6 c0	 movzx	 eax, al
  00094	85 c0		 test	 eax, eax
  00096	75 0f		 jne	 SHORT $LN6@SendLoginP

; 295  : 	{
; 296  : 		Tracen("SendLogin Error");

  00098	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
  0009d	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  000a2	59		 pop	 ecx

; 297  : 		return false;

  000a3	32 c0		 xor	 al, al
  000a5	eb 0a		 jmp	 SHORT $LN1@SendLoginP
$LN6@SendLoginP:

; 298  : 	}
; 299  : 
; 300  : 	__SendInternalBuffer();

  000a7	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  000aa	e8 00 00 00 00	 call	 ?__SendInternalBuffer@CNetworkStream@@IAE_NXZ ; CNetworkStream::__SendInternalBuffer

; 301  : 
; 302  : #ifndef _IMPROVED_PACKET_ENCRYPTION_
; 303  : 	SetSecurityMode(true, (const char *) g_adwEncryptKey, (const char *) g_adwDecryptKey);
; 304  : #endif
; 305  : 	return true;

  000af	b0 01		 mov	 al, 1
$LN1@SendLoginP:

; 306  : }

  000b1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000b4	33 cd		 xor	 ecx, ebp
  000b6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000bb	c9		 leave
  000bc	c2 08 00	 ret	 8
?SendLoginPacketNew@CPythonNetworkStream@@QAE_NPBD0@Z ENDP ; CPythonNetworkStream::SendLoginPacketNew
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?SendLoginPacket@CPythonNetworkStream@@QAE_NPBD0@Z
_TEXT	SEGMENT
_this$ = -60						; size = 4
_LoginPacket$ = -56					; size = 49
__$ArrayPad$ = -4					; size = 4
_c_szName$ = 8						; size = 4
_c_szPassword$ = 12					; size = 4
?SendLoginPacket@CPythonNetworkStream@@QAE_NPBD0@Z PROC	; CPythonNetworkStream::SendLoginPacket, COMDAT
; _this$ = ecx

; 255  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx

; 256  : 	TPacketCGLogin LoginPacket;
; 257  : 	LoginPacket.header = HEADER_CG_LOGIN;

  00013	c6 45 c8 01	 mov	 BYTE PTR _LoginPacket$[ebp], 1

; 258  : 
; 259  : 	strncpy(LoginPacket.name, c_szName, sizeof(LoginPacket.name)-1);

  00017	6a 1e		 push	 30			; 0000001eH
  00019	ff 75 08	 push	 DWORD PTR _c_szName$[ebp]
  0001c	8d 45 c9	 lea	 eax, DWORD PTR _LoginPacket$[ebp+1]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _strncpy
  00025	83 c4 0c	 add	 esp, 12			; 0000000cH

; 260  : 	strncpy(LoginPacket.pwd, c_szPassword, sizeof(LoginPacket.pwd)-1);

  00028	6a 10		 push	 16			; 00000010H
  0002a	ff 75 0c	 push	 DWORD PTR _c_szPassword$[ebp]
  0002d	8d 45 e8	 lea	 eax, DWORD PTR _LoginPacket$[ebp+32]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 _strncpy
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 261  : 
; 262  : 	LoginPacket.name[ID_MAX_NUM]='\0';

  00039	33 c0		 xor	 eax, eax
  0003b	40		 inc	 eax
  0003c	6b c0 1e	 imul	 eax, eax, 30
  0003f	c6 44 05 c9 00	 mov	 BYTE PTR _LoginPacket$[ebp+eax+1], 0

; 263  : 	LoginPacket.pwd[PASS_MAX_NUM]='\0';

  00044	33 c0		 xor	 eax, eax
  00046	40		 inc	 eax
  00047	c1 e0 04	 shl	 eax, 4
  0004a	c6 44 05 e8 00	 mov	 BYTE PTR _LoginPacket$[ebp+eax+32], 0

; 264  : 
; 265  : 	if (!Send(sizeof(LoginPacket), &LoginPacket))

  0004f	8d 45 c8	 lea	 eax, DWORD PTR _LoginPacket$[ebp]
  00052	50		 push	 eax
  00053	6a 31		 push	 49			; 00000031H
  00055	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ?Send@CNetworkStream@@QAE_NHPBX@Z ; CNetworkStream::Send
  0005d	0f b6 c0	 movzx	 eax, al
  00060	85 c0		 test	 eax, eax
  00062	75 0f		 jne	 SHORT $LN2@SendLoginP

; 266  : 	{
; 267  : 		Tracen("SendLogin Error");

  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@HGDBLFFH@SendLogin?5Error@
  00069	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0006e	59		 pop	 ecx

; 268  : 		return false;

  0006f	32 c0		 xor	 al, al
  00071	eb 08		 jmp	 SHORT $LN1@SendLoginP
$LN2@SendLoginP:

; 269  : 	}
; 270  : 
; 271  : 	return SendSequence();

  00073	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?SendSequence@CNetworkStream@@QAE_NXZ ; CNetworkStream::SendSequence
$LN1@SendLoginP:

; 272  : }

  0007b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007e	33 cd		 xor	 ecx, ebp
  00080	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00085	c9		 leave
  00086	c2 08 00	 ret	 8
?SendLoginPacket@CPythonNetworkStream@@QAE_NPBD0@Z ENDP	; CPythonNetworkStream::SendLoginPacket
_TEXT	ENDS
; Function compile flags: /Odspy
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\FuncObject.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\FuncObject.h
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp
;	COMDAT ?SetLoginPhase@CPythonNetworkStream@@QAEXXZ
_TEXT	SEGMENT
$T1 = -48						; size = 8
$T2 = -40						; size = 8
_key$ = -32						; size = 4
_rkAccountConnector$3 = -28				; size = 4
_rkAccountConnector$4 = -24				; size = 4
$T5 = -20						; size = 4
$T6 = -16						; size = 4
_this$ = -12						; size = 4
_this$ = -8						; size = 4
_this$ = -4						; size = 4
?SetLoginPhase@CPythonNetworkStream@@QAEXXZ PROC	; CPythonNetworkStream::SetLoginPhase, COMDAT
; _this$ = ecx

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   : 	const char* key = LocaleService_GetSecurityKey();

  00009	e8 00 00 00 00	 call	 ?LocaleService_GetSecurityKey@@YAPBDXZ ; LocaleService_GetSecurityKey
  0000e	89 45 e0	 mov	 DWORD PTR _key$[ebp], eax

; 96   : #ifndef _IMPROVED_PACKET_ENCRYPTION_
; 97   : 	SetSecurityMode(true, key);
; 98   : #endif
; 99   : 
; 100  : 	if ("Login" != m_strPhase)

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	05 0c 01 00 00	 add	 eax, 268		; 0000010cH
  00019	50		 push	 eax
  0001a	68 00 00 00 00	 push	 OFFSET ??_C@_05DHEMANOL@Login@
  0001f	e8 00 00 00 00	 call	 ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NQBDABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
  00024	59		 pop	 ecx
  00025	59		 pop	 ecx
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	74 0e		 je	 SHORT $LN2@SetLoginPh

; 101  : 		m_phaseLeaveFunc.Run();

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	81 c1 60 01 00
	00		 add	 ecx, 352		; 00000160H
  00036	e8 00 00 00 00	 call	 ?Run@?$CFuncObject@VCPythonNetworkStream@@@@QAEXXZ ; CFuncObject<CPythonNetworkStream>::Run
$LN2@SetLoginPh:

; 102  : 
; 103  : 	Tracen("");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00040	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00045	59		 pop	 ecx

; 104  : 	Tracen("## Network - Login Phase ##");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GIOJNFMI@?$CD?$CD?5Network?5?9?5Login?5Phase?5?$CD?$CD@
  0004b	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  00050	59		 pop	 ecx

; 105  : 	Tracen("");

  00051	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@@
  00056	e8 00 00 00 00	 call	 ?Tracen@@YAXPBD@Z	; Tracen
  0005b	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  0005c	68 00 00 00 00	 push	 OFFSET ??_C@_05DHEMANOL@Login@
  00061	e8 00 00 00 00	 call	 _strlen
  00066	59		 pop	 ecx
  00067	89 45 f0	 mov	 DWORD PTR $T6[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 997  :     return _Len;

  0006a	8b 45 f0	 mov	 eax, DWORD PTR $T6[ebp]
  0006d	89 45 ec	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00070	ff 75 ec	 push	 DWORD PTR $T5[ebp]
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_05DHEMANOL@Login@
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp

; 107  : 	m_strPhase = "Login";	

  00078	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3062 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00081	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp

; 109  : 	m_phaseProcessFunc.Set(this, &CPythonNetworkStream::LoginPhase);

  00086	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], OFFSET ?LoginPhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::LoginPhase
  0008d	83 65 dc 00	 and	 DWORD PTR $T2[ebp+4], 0
  00091	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00094	05 48 01 00 00	 add	 eax, 328		; 00000148H
  00099	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\FuncObject.h

; 24   : 			m_pSelfObject = pSelfObject;

  0009c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 25   : 			m_pFuncObject = pFuncObject;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b 4d d8	 mov	 ecx, DWORD PTR $T2[ebp]
  000ab	8b 55 dc	 mov	 edx, DWORD PTR $T2[ebp+4]
  000ae	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000b1	89 50 14	 mov	 DWORD PTR [eax+20], edx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp

; 110  : 	m_phaseLeaveFunc.Set(this, &CPythonNetworkStream::__LeaveLoginPhase);

  000b4	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], OFFSET ?__LeaveLoginPhase@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__LeaveLoginPhase
  000bb	83 65 d4 00	 and	 DWORD PTR $T1[ebp+4], 0
  000bf	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	05 60 01 00 00	 add	 eax, 352		; 00000160H
  000c7	89 45 f4	 mov	 DWORD PTR _this$[ebp], eax
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\eterLib\FuncObject.h

; 24   : 			m_pSelfObject = pSelfObject;

  000ca	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d0	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 25   : 			m_pFuncObject = pFuncObject;

  000d3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000d6	8b 4d d0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d9	8b 55 d4	 mov	 edx, DWORD PTR $T1[ebp+4]
  000dc	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  000df	89 50 14	 mov	 DWORD PTR [eax+20], edx
; File D:\Metin2 Server Files\mainline\SRC_2014\Metin2Client\UserInterface\PythonNetworkStreamPhaseLogin.cpp

; 112  : 	m_dwChangingPhaseTime = ELTimer_GetMSec();

  000e2	e8 00 00 00 00	 call	 ?ELTimer_GetMSec@@YAKXZ	; ELTimer_GetMSec
  000e7	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	89 81 90 00 00
	00		 mov	 DWORD PTR [ecx+144], eax

; 113  : 
; 114  : 	if (__DirectEnterMode_IsSet())

  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	e8 00 00 00 00	 call	 ?__DirectEnterMode_IsSet@CPythonNetworkStream@@AAE_NXZ ; CPythonNetworkStream::__DirectEnterMode_IsSet
  000f8	0f b6 c0	 movzx	 eax, al
  000fb	85 c0		 test	 eax, eax
  000fd	74 77		 je	 SHORT $LN3@SetLoginPh

; 115  : 	{
; 116  : 		if (0 != m_dwLoginKey)

  000ff	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00102	83 b8 24 01 00
	00 00		 cmp	 DWORD PTR [eax+292], 0
  00109	74 28		 je	 SHORT $LN5@SetLoginPh

; 117  : 			SendLoginPacketNew(m_stID.c_str(), m_stPassword.c_str());

  0010b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0010e	81 c1 dc 00 00
	00		 add	 ecx, 220		; 000000dcH
  00114	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00119	50		 push	 eax
  0011a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0011d	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  00123	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00128	50		 push	 eax
  00129	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0012c	e8 00 00 00 00	 call	 ?SendLoginPacketNew@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendLoginPacketNew
  00131	eb 26		 jmp	 SHORT $LN6@SetLoginPh
$LN5@SetLoginPh:

; 118  : 		else
; 119  : 			SendLoginPacket(m_stID.c_str(), m_stPassword.c_str());

  00133	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00136	81 c1 dc 00 00
	00		 add	 ecx, 220		; 000000dcH
  0013c	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00141	50		 push	 eax
  00142	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  0014b	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00150	50		 push	 eax
  00151	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	e8 00 00 00 00	 call	 ?SendLoginPacket@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendLoginPacket
$LN6@SetLoginPh:

; 120  : 
; 121  : 		//       ,     
; 122  : 		ClearLoginInfo();

  00159	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::ClearLoginInfo

; 123  : 		CAccountConnector & rkAccountConnector = CAccountConnector::Instance();

  00161	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A ; CSingleton<CAccountConnector>::ms_singleton
  00166	89 45 e8	 mov	 DWORD PTR _rkAccountConnector$4[ebp], eax

; 124  : 		rkAccountConnector.ClearLoginInfo();

  00169	8b 4d e8	 mov	 ecx, DWORD PTR _rkAccountConnector$4[ebp]
  0016c	e8 00 00 00 00	 call	 ?ClearLoginInfo@CAccountConnector@@QAEXXZ ; CAccountConnector::ClearLoginInfo

; 125  : 	}

  00171	e9 a4 00 00 00	 jmp	 $LN1@SetLoginPh
$LN3@SetLoginPh:

; 126  : 	else
; 127  : 	{
; 128  : 		if (0 != m_dwLoginKey)

  00176	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00179	83 b8 24 01 00
	00 00		 cmp	 DWORD PTR [eax+292], 0
  00180	74 28		 je	 SHORT $LN7@SetLoginPh

; 129  : 			SendLoginPacketNew(m_stID.c_str(), m_stPassword.c_str());

  00182	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00185	81 c1 dc 00 00
	00		 add	 ecx, 220		; 000000dcH
  0018b	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00190	50		 push	 eax
  00191	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  0019a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0019f	50		 push	 eax
  001a0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001a3	e8 00 00 00 00	 call	 ?SendLoginPacketNew@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendLoginPacketNew
  001a8	eb 26		 jmp	 SHORT $LN8@SetLoginPh
$LN7@SetLoginPh:

; 130  : 		else
; 131  : 			SendLoginPacket(m_stID.c_str(), m_stPassword.c_str());

  001aa	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001ad	81 c1 dc 00 00
	00		 add	 ecx, 220		; 000000dcH
  001b3	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  001b8	50		 push	 eax
  001b9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001bc	81 c1 c4 00 00
	00		 add	 ecx, 196		; 000000c4H
  001c2	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  001c7	50		 push	 eax
  001c8	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001cb	e8 00 00 00 00	 call	 ?SendLoginPacket@CPythonNetworkStream@@QAE_NPBD0@Z ; CPythonNetworkStream::SendLoginPacket
$LN8@SetLoginPh:

; 132  : 
; 133  : 		//       ,     
; 134  : 		ClearLoginInfo();

  001d0	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	e8 00 00 00 00	 call	 ?ClearLoginInfo@CPythonNetworkStream@@QAEXXZ ; CPythonNetworkStream::ClearLoginInfo

; 135  : 		CAccountConnector & rkAccountConnector = CAccountConnector::Instance();

  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR ?ms_singleton@?$CSingleton@VCAccountConnector@@@@0PAVCAccountConnector@@A ; CSingleton<CAccountConnector>::ms_singleton
  001dd	89 45 e4	 mov	 DWORD PTR _rkAccountConnector$3[ebp], eax

; 136  : 		rkAccountConnector.ClearLoginInfo();

  001e0	8b 4d e4	 mov	 ecx, DWORD PTR _rkAccountConnector$3[ebp]
  001e3	e8 00 00 00 00	 call	 ?ClearLoginInfo@CAccountConnector@@QAEXXZ ; CAccountConnector::ClearLoginInfo

; 137  : 
; 138  : 		PyCallClassMemberFunc(m_apoPhaseWnd[PHASE_WINDOW_LOGIN], "OnLoginStart", Py_BuildValue("()"));

  001e8	68 00 00 00 00	 push	 OFFSET ??_C@_02HCKGKOFO@?$CI?$CJ@
  001ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Py_BuildValue
  001f3	59		 pop	 ecx
  001f4	50		 push	 eax
  001f5	68 00 00 00 00	 push	 OFFSET ??_C@_0N@GCHAFKJJ@OnLoginStart@
  001fa	6a 04		 push	 4
  001fc	58		 pop	 eax
  001fd	c1 e0 00	 shl	 eax, 0
  00200	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00203	ff b4 01 7c 01
	00 00		 push	 DWORD PTR [ecx+eax+380]
  0020a	e8 00 00 00 00	 call	 ?PyCallClassMemberFunc@@YA_NPAU_object@@PBD0@Z ; PyCallClassMemberFunc
  0020f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 139  : 
; 140  : 		__ClearSelectCharacterData();

  00212	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00215	e8 00 00 00 00	 call	 ?__ClearSelectCharacterData@CPythonNetworkStream@@IAEXXZ ; CPythonNetworkStream::__ClearSelectCharacterData
$LN1@SetLoginPh:

; 141  : 	}
; 142  : }

  0021a	c9		 leave
  0021b	c3		 ret	 0
?SetLoginPhase@CPythonNetworkStream@@QAEXXZ ENDP	; CPythonNetworkStream::SetLoginPhase
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 113  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 114  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 115  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 116  :     if (_Block_size <= _Bytes) {

  0000f	8b 45 f8	 mov	 eax, DWORD PTR __Block_size$[ebp]
  00012	3b 45 08	 cmp	 eax, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN12@Allocate_m

; 117  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN12@Allocate_m:

; 77   :         return ::operator new(_Bytes);

  0001c	ff 75 f8	 push	 DWORD PTR __Block_size$[ebp]
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00024	59		 pop	 ecx

; 118  :     }
; 119  : 
; 120  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00025	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 121  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00028	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002c	74 02		 je	 SHORT $LN7@Allocate_m
  0002e	eb 09		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00030	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00035	33 c0		 xor	 eax, eax
  00037	75 f7		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00039	33 c0		 xor	 eax, eax
  0003b	75 eb		 jne	 SHORT $LN4@Allocate_m

; 122  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00040	83 c0 23	 add	 eax, 35			; 00000023H
  00043	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00046	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 123  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00049	6a 04		 push	 4
  0004b	58		 pop	 eax
  0004c	6b c0 ff	 imul	 eax, eax, -1
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00055	89 14 01	 mov	 DWORD PTR [ecx+eax], edx

; 124  : 
; 125  : #ifdef _DEBUG
; 126  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 127  : #endif // _DEBUG
; 128  :     return _Ptr;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 129  : }

  0005b	c9		 leave
  0005c	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 197  : __declspec(allocator) void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 198  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 199  : #if defined(_M_IX86) || defined(_M_X64)
; 200  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0b		 jb	 SHORT $LN2@Allocate

; 201  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  0000f	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00014	59		 pop	 ecx
  00015	eb 13		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 202  :     }
; 203  : #endif // defined(_M_IX86) || defined(_M_X64)
; 204  : 
; 205  :     if (_Bytes != 0) {

  00017	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001b	74 0b		 je	 SHORT $LN3@Allocate

; 77   :         return ::operator new(_Bytes);

  0001d	ff 75 08	 push	 DWORD PTR __Bytes$[ebp]
  00020	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00025	59		 pop	 ecx

; 206  :         return _Traits::_Allocate(_Bytes);

  00026	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 207  :     }
; 208  : 
; 209  :     return nullptr;

  00028	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 210  : }

  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 213  : void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 214  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 215  : #if defined(_M_IX86) || defined(_M_X64)
; 216  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 0f		 jb	 SHORT $LN2@Deallocate

; 217  :         _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	59		 pop	 ecx
  00039	59		 pop	 ecx
$LN2@Deallocate:

; 218  :     }
; 219  : #endif // defined(_M_IX86) || defined(_M_X64)
; 220  : 
; 221  :     ::operator delete(_Ptr, _Bytes);

  0003a	ff 75 0c	 push	 DWORD PTR __Bytes$[ebp]
  0003d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00040	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 222  : }

  00047	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00051	59		 pop	 ecx
  00052	c9		 leave
  00053	c3		 ret	 0
  00054	cc		 int	 3
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 228  : void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 275  :     return __builtin_addressof(_Val);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_new.h

; 169  :         return _Where;

  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T3[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\type_traits

; 1443 :     return static_cast<_Ty&&>(_Arg);

  00012	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00015	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 229  :     ::new (const_cast<void*>(static_cast<const volatile void*>(_STD addressof(_Obj))))

  00018	8b 45 f8	 mov	 eax, DWORD PTR $T2[ebp]
  0001b	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0001e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00020	89 08		 mov	 DWORD PTR [eax], ecx

; 230  :         _Ty(_STD forward<_Types>(_Args)...);
; 231  : }

  00022	c9		 leave
  00023	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z
_TEXT	SEGMENT
__Al$ = -40						; size = 4
__Ptr$ = -36						; size = 4
__Ptr$ = -32						; size = 4
$T1 = -28						; size = 4
__Old_capacity$ = -24					; size = 4
$T2 = -20						; size = 4
__New_capacity$ = -16					; size = 4
__New_ptr$ = -12					; size = 4
_this$ = -8						; size = 4
__Overflow_is_possible$3 = -2				; size = 1
$T4 = -1						; size = 1
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>, COMDAT
; _this$ = ecx

; 4302 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4303 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4304 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4305 :         if (_New_size > max_size()) {

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4306 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4307 :         }
; 4308 : 
; 4309 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00021	89 45 e8	 mov	 DWORD PTR __Old_capacity$[ebp], eax

; 4310 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00024	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00027	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4409 :         return _Mypair._Get_first();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1347 :         return *this;

  00035	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4409 :         return _Mypair._Get_first();

  00038	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
  0003b	89 45 d8	 mov	 DWORD PTR __Al$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 56   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0003e	c6 45 fe 00	 mov	 BYTE PTR __Overflow_is_possible$3[ebp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  00042	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00045	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 814  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0004c	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4312 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0004d	89 45 f4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4313 :         _Mypair._Myval2._Orphan_all();
; 4314 :         _Mypair._Myval2._Mysize = _New_size;

  00050	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00056	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4315 :         _Mypair._Myval2._Myres  = _New_capacity;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  0005f	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4316 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  00062	8b 45 f4	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00065	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0006b	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 62   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  0006e	ff 75 08	 push	 DWORD PTR __New_size$[ebp]
  00071	ff 75 10	 push	 DWORD PTR _<_Args_0>$[ebp]
  00074	ff 75 ec	 push	 DWORD PTR $T2[ebp]
  00077	e8 00 00 00 00	 call	 _memcpy
  0007c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0007f	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0

; 428  :         _Left = _Right;

  00083	8b 45 ec	 mov	 eax, DWORD PTR $T2[ebp]
  00086	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00089	8a 4d ff	 mov	 cl, BYTE PTR $T4[ebp]
  0008c	88 08		 mov	 BYTE PTR [eax], cl

; 4317 :         if (_BUF_SIZE <= _Old_capacity) {

  0008e	83 7d e8 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00092	72 21		 jb	 SHORT $LN3@Reallocate

; 4318 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 00		 mov	 eax, DWORD PTR [eax]
  00099	89 45 dc	 mov	 DWORD PTR __Ptr$[ebp], eax
  0009c	8b 45 e8	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  0009f	40		 inc	 eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 810  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000a0	50		 push	 eax
  000a1	ff 75 dc	 push	 DWORD PTR __Ptr$[ebp]
  000a4	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a9	59		 pop	 ecx
  000aa	59		 pop	 ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4319 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000ab	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b 4d f4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000b1	89 08		 mov	 DWORD PTR [eax], ecx

; 4320 :         } else {

  000b3	eb 0e		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4321 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000b5	8d 45 f4	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b8	50		 push	 eax
  000b9	ff 75 f8	 push	 DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000c1	59		 pop	 ecx
  000c2	59		 pop	 ecx
$LN4@Reallocate:

; 4322 :         }
; 4323 : 
; 4324 :         return *this;

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN5@Reallocate:

; 4325 :     }

  000c6	c9		 leave
  000c7	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
tv93 = -28						; size = 4
$T3 = -24						; size = 4
_this$ = -20						; size = 4
$T4 = -16						; size = 4
__Masked$5 = -12					; size = 4
__Old$ = -8						; size = 4
__Max$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4297 :     _NODISCARD size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 fc	 mov	 DWORD PTR __Max$[ebp], eax
  00014	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001a	89 45 f8	 mov	 DWORD PTR __Old$[ebp], eax

; 4285 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00020	83 c8 0f	 or	 eax, 15			; 0000000fH
  00023	89 45 f4	 mov	 DWORD PTR __Masked$5[ebp], eax

; 4286 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00026	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  00029	3b 45 fc	 cmp	 eax, DWORD PTR __Max$[ebp]
  0002c	76 08		 jbe	 SHORT $LN29@Calculate_

; 4287 :             return _Max;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  00034	eb 4c		 jmp	 SHORT $LN31@Calculate_
$LN29@Calculate_:

; 4288 :         }
; 4289 : 
; 4290 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00036	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00039	d1 e8		 shr	 eax, 1
  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Max$[ebp]
  0003e	2b c8		 sub	 ecx, eax
  00040	39 4d f8	 cmp	 DWORD PTR __Old$[ebp], ecx
  00043	76 08		 jbe	 SHORT $LN30@Calculate_

; 4291 :             return _Max;

  00045	8b 45 fc	 mov	 eax, DWORD PTR __Max$[ebp]
  00048	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
  0004b	eb 35		 jmp	 SHORT $LN31@Calculate_
$LN30@Calculate_:

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0004d	8b 45 f8	 mov	 eax, DWORD PTR __Old$[ebp]
  00050	d1 e8		 shr	 eax, 1
  00052	03 45 f8	 add	 eax, DWORD PTR __Old$[ebp]
  00055	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00058	8b 45 f4	 mov	 eax, DWORD PTR __Masked$5[ebp]
  0005b	3b 45 e8	 cmp	 eax, DWORD PTR $T3[ebp]
  0005e	73 08		 jae	 SHORT $LN35@Calculate_
  00060	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00063	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
  00066	eb 06		 jmp	 SHORT $LN36@Calculate_
$LN35@Calculate_:
  00068	8d 45 f4	 lea	 eax, DWORD PTR __Masked$5[ebp]
  0006b	89 45 e4	 mov	 DWORD PTR tv93[ebp], eax
$LN36@Calculate_:
  0006e	8b 45 e4	 mov	 eax, DWORD PTR tv93[ebp]
  00071	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00074	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]
  00077	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4294 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0007a	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  0007d	8b 00		 mov	 eax, DWORD PTR [eax]
  0007f	89 45 f0	 mov	 DWORD PTR $T4[ebp], eax
$LN31@Calculate_:

; 4298 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00082	8b 45 f0	 mov	 eax, DWORD PTR $T4[ebp]

; 4299 :     }

  00085	c9		 leave
  00086	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z
_TEXT	SEGMENT
$T1 = -44						; size = 4
$T2 = -40						; size = 4
$T3 = -36						; size = 4
__Ptr$ = -32						; size = 4
tv95 = -28						; size = 4
__Left_size$ = -24					; size = 4
_this$ = -20						; size = 4
__Result$4 = -16					; size = 4
tv91 = -12						; size = 4
_this$ = -8						; size = 4
$T5 = -2						; size = 1
$T6 = -1						; size = 1
__Ptr$ = 8						; size = 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT
; _this$ = ecx

; 4179 :     bool _Equal(_In_z_ const _Elem* const _Ptr) const noexcept { // compare [0, size()) with _Ptr for equality

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 389  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00009	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0000c	e8 00 00 00 00	 call	 _strlen
  00011	59		 pop	 ecx
  00012	89 45 dc	 mov	 DWORD PTR $T3[ebp], eax

; 4180 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00015	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00018	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	89 45 f0	 mov	 DWORD PTR __Result$4[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00021	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00028	72 09		 jb	 SHORT $LN12@Equal
  0002a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv91[ebp], 1
  00031	eb 04		 jmp	 SHORT $LN13@Equal
$LN12@Equal:
  00033	83 65 f4 00	 and	 DWORD PTR tv91[ebp], 0
$LN13@Equal:
  00037	8a 45 f4	 mov	 al, BYTE PTR tv91[ebp]
  0003a	88 45 ff	 mov	 BYTE PTR $T6[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  0003d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T6[ebp]
  00041	85 c0		 test	 eax, eax
  00043	74 0e		 je	 SHORT $LN7@Equal

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00045	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 00		 mov	 eax, DWORD PTR [eax]
  0004a	89 45 e0	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0004d	8b 45 e0	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	89 45 f0	 mov	 DWORD PTR __Result$4[ebp], eax
$LN7@Equal:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00053	8b 45 f0	 mov	 eax, DWORD PTR __Result$4[ebp]
  00056	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax

; 4180 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00059	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0005f	89 45 e8	 mov	 DWORD PTR __Left_size$[ebp], eax

; 561  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  00062	8b 45 e8	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00065	3b 45 dc	 cmp	 eax, DWORD PTR $T3[ebp]
  00068	75 23		 jne	 SHORT $LN20@Equal

; 369  :         return _CSTD memcmp(_First1, _First2, _Count);

  0006a	ff 75 e8	 push	 DWORD PTR __Left_size$[ebp]
  0006d	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00070	ff 75 d8	 push	 DWORD PTR $T2[ebp]
  00073	e8 00 00 00 00	 call	 _memcmp
  00078	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007b	89 45 d4	 mov	 DWORD PTR $T1[ebp], eax

; 561  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;

  0007e	83 7d d4 00	 cmp	 DWORD PTR $T1[ebp], 0
  00082	75 09		 jne	 SHORT $LN20@Equal
  00084	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv95[ebp], 1
  0008b	eb 04		 jmp	 SHORT $LN21@Equal
$LN20@Equal:
  0008d	83 65 e4 00	 and	 DWORD PTR tv95[ebp], 0
$LN21@Equal:
  00091	8a 45 e4	 mov	 al, BYTE PTR tv95[ebp]
  00094	88 45 fe	 mov	 BYTE PTR $T5[ebp], al

; 4180 :         return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));

  00097	8a 45 fe	 mov	 al, BYTE PTR $T5[ebp]

; 4181 :     }

  0009a	c9		 leave
  0009b	c2 04 00	 ret	 4
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NQBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -60						; size = 4
$T2 = -56						; size = 4
$T3 = -52						; size = 4
$T4 = -48						; size = 4
__Storage_max$ = -44					; size = 4
$T5 = -40						; size = 4
$T6 = -36						; size = 4
$T7 = -32						; size = 4
_this$ = -28						; size = 4
tv70 = -24						; size = 4
$T8 = -20						; size = 4
$T9 = -16						; size = 4
tv67 = -12						; size = 4
__Alloc_max$ = -8					; size = 4
$T10 = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3773 :     _NODISCARD size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 4413 :         return _Mypair._Get_first();

  00009	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 1351 :         return *this;

  0000c	89 45 e0	 mov	 DWORD PTR $T7[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 4413 :         return _Mypair._Get_first();

  0000f	8b 45 e0	 mov	 eax, DWORD PTR $T7[ebp]
  00012	89 45 c4	 mov	 DWORD PTR $T1[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory

; 710  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00015	83 4d f8 ff	 or	 DWORD PTR __Alloc_max$[ebp], -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00019	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR $T10[ebp], 16	; 00000010H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 44   :     return _Left < _Right ? _Right : _Left;

  00020	8b 45 f8	 mov	 eax, DWORD PTR __Alloc_max$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR $T10[ebp]
  00026	73 08		 jae	 SHORT $LN14@max_size
  00028	8d 45 fc	 lea	 eax, DWORD PTR $T10[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0002e	eb 06		 jmp	 SHORT $LN15@max_size
$LN14@max_size:
  00030	8d 45 f8	 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00033	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
$LN15@max_size:
  00036	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00039	89 45 dc	 mov	 DWORD PTR $T6[ebp], eax
  0003c	8b 45 dc	 mov	 eax, DWORD PTR $T6[ebp]
  0003f	89 45 d8	 mov	 DWORD PTR $T5[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3775 :         const size_type _Storage_max = // can always store small string

  00042	8b 45 d8	 mov	 eax, DWORD PTR $T5[ebp]
  00045	8b 00		 mov	 eax, DWORD PTR [eax]
  00047	89 45 d4	 mov	 DWORD PTR __Storage_max$[ebp], eax

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0004a	8b 45 d4	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0004d	48		 dec	 eax
  0004e	89 45 f0	 mov	 DWORD PTR $T9[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\limits

; 557  :         return INT_MAX;

  00051	c7 45 d0 ff ff
	ff 7f		 mov	 DWORD PTR $T4[ebp], 2147483647 ; 7fffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00058	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0005b	89 45 ec	 mov	 DWORD PTR $T8[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\utility

; 68   :     return _Right < _Left ? _Right : _Left;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR $T9[ebp]
  00061	3b 45 ec	 cmp	 eax, DWORD PTR $T8[ebp]
  00064	73 08		 jae	 SHORT $LN22@max_size
  00066	8d 45 f0	 lea	 eax, DWORD PTR $T9[ebp]
  00069	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  0006c	eb 06		 jmp	 SHORT $LN23@max_size
$LN22@max_size:
  0006e	8d 45 ec	 lea	 eax, DWORD PTR $T8[ebp]
  00071	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
$LN23@max_size:
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv70[ebp]
  00077	89 45 cc	 mov	 DWORD PTR $T3[ebp], eax
  0007a	8b 45 cc	 mov	 eax, DWORD PTR $T3[ebp]
  0007d	89 45 c8	 mov	 DWORD PTR $T2[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 3777 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00080	8b 45 c8	 mov	 eax, DWORD PTR $T2[ebp]
  00083	8b 00		 mov	 eax, DWORD PTR [eax]

; 3778 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3779 :         );
; 3780 :     }

  00085	c9		 leave
  00086	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__Result$2 = -16					; size = 4
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 3751 :     _NODISCARD _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 3752 :         return _Mypair._Myval2._Myptr();

  00009	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR _this$[ebp], eax

; 2218 :         const value_type* _Result = _Bx._Buf;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  00015	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00018	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  0001c	72 09		 jb	 SHORT $LN9@c_str
  0001e	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv80[ebp], 1
  00025	eb 04		 jmp	 SHORT $LN10@c_str
$LN9@c_str:
  00027	83 65 f4 00	 and	 DWORD PTR tv80[ebp], 0
$LN10@c_str:
  0002b	8a 45 f4	 mov	 al, BYTE PTR tv80[ebp]
  0002e	88 45 ff	 mov	 BYTE PTR $T3[ebp], al

; 2219 :         if (_Large_string_engaged()) {

  00031	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00035	85 c0		 test	 eax, eax
  00037	74 0e		 je	 SHORT $LN4@c_str

; 2220 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 00		 mov	 eax, DWORD PTR [eax]
  0003e	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  00041	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00044	89 45 f0	 mov	 DWORD PTR __Result$2[ebp], eax
$LN4@c_str:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2223 :         return _Result;

  00047	8b 45 f0	 mov	 eax, DWORD PTR __Result$2[ebp]
  0004a	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax

; 3752 :         return _Mypair._Myval2._Myptr();

  0004d	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 3753 :     }

  00050	c9		 leave
  00051	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -16						; size = 1
__Old_ptr$2 = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3042 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3043 :         // assign [_Ptr, _Ptr + _Count)
; 3044 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 39		 ja	 SHORT $LN2@assign

; 3045 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$2[ebp], eax

; 3046 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 119  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00028	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0002b	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  0002e	ff 75 f4	 push	 DWORD PTR __Old_ptr$2[ebp]
  00031	e8 00 00 00 00	 call	 _memmove
  00036	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3047 :             _Traits::move(_Old_ptr, _Ptr, _Count);
; 3048 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0

; 428  :         _Left = _Right;

  0003d	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$2[ebp]
  00040	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00043	8a 4d ff	 mov	 cl, BYTE PTR $T3[ebp]
  00046	88 08		 mov	 BYTE PTR [eax], cl

; 3049 :             return *this;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	eb 16		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3050 :         }
; 3051 : 
; 3052 :         return _Reallocate_for(

  0004d	33 c0		 xor	 eax, eax
  0004f	88 45 f0	 mov	 BYTE PTR $T1[ebp], al
  00052	ff 75 08	 push	 DWORD PTR __Ptr$[ebp]
  00055	ff 75 f0	 push	 DWORD PTR $T1[ebp]
  00058	ff 75 0c	 push	 DWORD PTR __Count$[ebp]
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_9366063389c5f42a00a5088cf24e69de>@@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_9366063389c5f42a00a5088cf24e69de>,char const *>
$LN1@assign:

; 3053 :             _Count,
; 3054 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3055 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3056 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3057 :             },
; 3058 :             _Ptr);
; 3059 :     }

  00063	c9		 leave
  00064	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Ptr$ = -20						; size = 4
__Result$ = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2208 :     value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2209 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         return _BUF_SIZE <= _Myres;

  0000f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00012	83 78 14 10	 cmp	 DWORD PTR [eax+20], 16	; 00000010H
  00016	72 09		 jb	 SHORT $LN6@Myptr
  00018	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv76[ebp], 1
  0001f	eb 04		 jmp	 SHORT $LN7@Myptr
$LN6@Myptr:
  00021	83 65 f4 00	 and	 DWORD PTR tv76[ebp], 0
$LN7@Myptr:
  00025	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00028	88 45 ff	 mov	 BYTE PTR $T1[ebp], al

; 2210 :         if (_Large_string_engaged()) {

  0002b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0002f	85 c0		 test	 eax, eax
  00031	74 0e		 je	 SHORT $LN2@Myptr

; 2211 :             _Result = _Unfancy(_Bx._Ptr);

  00033	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 00		 mov	 eax, DWORD PTR [eax]
  00038	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstddef

; 289  :     return _Ptr;

  0003b	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring

; 2214 :         return _Result;

  00041	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 2215 :     }

  00044	c9		 leave
  00045	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2274 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2275 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2276 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 132  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 133  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 134  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 00		 mov	 eax, DWORD PTR [eax]
  0000b	83 c0 23	 add	 eax, 35			; 00000023H
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00011	89 01		 mov	 DWORD PTR [ecx], eax

; 135  : 
; 136  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 00		 mov	 eax, DWORD PTR [eax]
  00018	89 45 f4	 mov	 DWORD PTR __Ptr_user$[ebp], eax

; 137  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	6a 04		 push	 4
  0001d	58		 pop	 eax
  0001e	6b c0 ff	 imul	 eax, eax, -1
  00021	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00024	8b 04 01	 mov	 eax, DWORD PTR [ecx+eax]
  00027	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax

; 138  : 
; 139  :     // If the following asserts, it likely means that we are performing
; 140  :     // an aligned delete on memory coming from an unaligned allocation.
; 141  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 142  : 
; 143  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 144  :     // in range [_Min_back_shift, _Non_user_size]
; 145  : #ifdef _DEBUG
; 146  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 147  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 148  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002a	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 149  : #endif // _DEBUG
; 150  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00034	8b 00		 mov	 eax, DWORD PTR [eax]
  00036	2b 45 f8	 sub	 eax, DWORD PTR __Ptr_container$[ebp]
  00039	89 45 fc	 mov	 DWORD PTR __Back_shift$[ebp], eax
$LN4@Adjust_man:

; 151  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003c	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00040	72 08		 jb	 SHORT $LN7@Adjust_man
  00042	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00046	77 02		 ja	 SHORT $LN7@Adjust_man
  00048	eb 09		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0004a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  0004f	33 c0		 xor	 eax, eax
  00051	75 f7		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  00053	33 c0		 xor	 eax, eax
  00055	75 e5		 jne	 SHORT $LN4@Adjust_man

; 152  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  0005d	89 08		 mov	 DWORD PTR [eax], ecx
$LN10@Adjust_man:

; 153  : }

  0005f	c9		 leave
  00060	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 321  :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0001c	c9		 leave
  0001d	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	c9		 leave
  00028	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	c9		 leave
  0001e	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 66   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@

; 130  :     {

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 141  :     {

  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	c9		 leave
  0003d	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	ff 75 08	 push	 DWORD PTR ___that$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c9		 leave
  0001f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 89   :     {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	83 c0 04	 add	 eax, 4
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	59		 pop	 ecx
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00020	83 e0 01	 and	 eax, 1
  00023	74 0c		 je	 SHORT $LN2@scalar
  00025	6a 0c		 push	 12			; 0000000cH
  00027	ff 75 fc	 push	 DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0002f	59		 pop	 ecx
  00030	59		 pop	 ecx
$LN2@scalar:
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c9		 leave
  00035	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000f	74 0b		 je	 SHORT $LN3@what
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00017	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0001a	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00023	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00026	c9		 leave
  00027	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odspy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29333\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c0		 xor	 eax, eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 04	 add	 ecx, 4
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00027	83 c0 04	 add	 eax, 4
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	59		 pop	 ecx
  00031	59		 pop	 ecx

; 74   :     }

  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	c9		 leave
  00036	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
tv66 = -4						; size = 4
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@vector:
  00004	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv66[ebp], eax
  0000a	8b 45 10	 mov	 eax, DWORD PTR ___n$[ebp]
  0000d	48		 dec	 eax
  0000e	89 45 10	 mov	 DWORD PTR ___n$[ebp], eax
  00011	83 7d fc 00	 cmp	 DWORD PTR tv66[ebp], 0
  00015	76 11		 jbe	 SHORT $LN1@vector
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___t$[ebp]
  0001a	ff 55 14	 call	 DWORD PTR ___f$[ebp]
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___t$[ebp]
  00020	03 45 0c	 add	 eax, DWORD PTR ___s$[ebp]
  00023	89 45 08	 mov	 DWORD PTR ___t$[ebp], eax
  00026	eb dc		 jmp	 SHORT $LN2@vector
$LN1@vector:
  00028	c9		 leave
  00029	c2 10 00	 ret	 16			; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
